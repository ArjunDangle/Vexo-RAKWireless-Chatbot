{"id": "16e9a33da9881cf909244b29f021350d", "product_family": "wisblock", "product_id": "kit6-light-and-color", "category": "Concept", "title": "WisBlock IoT Education Kit - Light & Color Quick Start Guide > WisBlock IoT Education Kit - Light & Color Quick Start Guide > Prerequisite > What Do You Need? > Introduction to WisBlock IoT Education Kit - Light & Color", "content": "The **WisBlock IoT Education Kit - Light & Color** comes with **RAK19007** and **RAK19001** **WisBlock Base boards**, two **RAK4631** **WisBlock Core modules**, and set of sensor modules to explore with. Before going through each and every step on using the **WisBlock IoT Education Kit - Light & Color**, make sure to prepare the necessary items listed below:", "keywords": ["WisBlock", "IoT Education Kit", "Light & Color", "RAK19007", "RAK19001", "RAK4631"], "source_file": "quickstart.md", "token_count": 75, "parent_content": "The **WisBlock IoT Education Kit - Light & Color** comes with **RAK19007** and **RAK19001** **WisBlock Base boards**, two **RAK4631** **WisBlock Core modules**, and set of sensor modules to explore with. Before going through each and every step on using the **WisBlock IoT Education Kit - Light & Color**, make sure to prepare the necessary items listed below:"}
{"id": "66587e826bbe5fdd587cb90c613a2953", "product_family": "wisblock", "product_id": "kit6-light-and-color", "category": "Reference", "title": "WisBlock IoT Education Kit - Light & Color Quick Start Guide > WisBlock IoT Education Kit - Light & Color Quick Start Guide > Prerequisite > What Do You Need? > Hardware > Components List for kit6-light-and-color", "content": "- [RAK4631 WisBlock Core](https://store.rakwireless.com/products/nordic-nrf52840-ble-core-module-for-lorawan-with-lora-sx1262-rak4631-rak4631-c?variant=42576992436422)\n- [RAK19007 WisBlock Base Board](https://store.rakwireless.com/products/rak19007-wisblock-base-board-2nd-gen)\n- [RAK19001 WisBlock Base Board](https://store.rakwireless.com/products/rak19001-wisblock-dual-io-base-board)\n- [RAK12019 UV Sensor](https://store.rakwireless.com/products/rak12019-wisblock-uv-sensor)", "keywords": ["RAK4631", "RAK19007", "RAK19001", "RAK12019", "RAK12010", "RAK12021", "RAK14001", "RAK14003", "USB C Cable", "RAK19005", "RAK19008", "Li-Ion/LiPo battery", "Solar charger"], "source_file": "quickstart.md", "token_count": 150, "parent_content": "- [RAK4631 WisBlock Core](https://store.rakwireless.com/products/nordic-nrf52840-ble-core-module-for-lorawan-with-lora-sx1262-rak4631-rak4631-c?variant=42576992436422)\n- [RAK19007 WisBlock Base Board](https://store.rakwireless.com/products/rak19007-wisblock-base-board-2nd-gen)\n- [RAK19001 WisBlock Base Board](https://store.rakwireless.com/products/rak19001-wisblock-dual-io-base-board)\n- [RAK12019 UV Sensor](https://store.rakwireless.com/products/rak12019-wisblock-uv-sensor)\n- [RAK12010 Ambient Light Sensor](https://store.rakwireless.com/products/wisblock-ambient-light-sensor-rak12010)\n- [RAK12021 RGB Light Sensor](https://store.rakwireless.com/products/rak12021-wisblock-rgb-sensor)\n- [RAK14001 RGB LED Module](https://store.rakwireless.com/products/rgb-led-module-rak14001)\n- [RAK14003 LED Bar Module](https://store.rakwireless.com/products/wisblock-led-bar-module-rak14003)\n- USB C Cable\n- [RAK19005 Sensor Extension Cable (optional)](https://store.rakwireless.com/products/fpc-extension-cable-for-slot-a-to-d-rak19005)\n- [RAK19008 IO Extension Cable (optional)](https://store.rakwireless.com/products/wisblock-io-extension-cable-rak19008)\n- [Li-Ion/LiPo battery (optional)](https://store.rakwireless.com/collections/wisblock-accessory/products/battery-connector-cable?utm_source=BatteryConnector&utm_medium=Document&utm_campaign=BuyFromStore)\n- [Solar charger (optional)](https://store.rakwireless.com/collections/wisblock-accessory/products/solar-panel-connector-cable?utm_source=SolarPanelConnector&utm_medium=Document&utm_campaign=BuyFromStore)"}
{"id": "2c2a5470f039de23170cb80d5212001b", "product_family": "wisblock", "product_id": "kit6-light-and-color", "category": "Reference", "title": "WisBlock IoT Education Kit - Light & Color Quick Start Guide > WisBlock IoT Education Kit - Light & Color Quick Start Guide > Prerequisite > What Do You Need? > Hardware > Components List for kit6-light-and-color", "content": "- [RAK12019 UV Sensor](https://store.rakwireless.com/products/rak12019-wisblock-uv-sensor)\n- [RAK12010 Ambient Light Sensor](https://store.rakwireless.com/products/wisblock-ambient-light-sensor-rak12010)\n- [RAK12021 RGB Light Sensor](https://store.rakwireless.com/products/rak12021-wisblock-rgb-sensor)\n- [RAK14001 RGB LED Module](https://store.rakwireless.com/products/rgb-led-module-rak14001)\n- [RAK14003 LED Bar Module](https://store.rakwireless.com/products/wisblock-led-bar-module-rak14003)", "keywords": ["RAK4631", "RAK19007", "RAK19001", "RAK12019", "RAK12010", "RAK12021", "RAK14001", "RAK14003", "USB C Cable", "RAK19005", "RAK19008", "Li-Ion/LiPo battery", "Solar charger"], "source_file": "quickstart.md", "token_count": 150, "parent_content": "- [RAK4631 WisBlock Core](https://store.rakwireless.com/products/nordic-nrf52840-ble-core-module-for-lorawan-with-lora-sx1262-rak4631-rak4631-c?variant=42576992436422)\n- [RAK19007 WisBlock Base Board](https://store.rakwireless.com/products/rak19007-wisblock-base-board-2nd-gen)\n- [RAK19001 WisBlock Base Board](https://store.rakwireless.com/products/rak19001-wisblock-dual-io-base-board)\n- [RAK12019 UV Sensor](https://store.rakwireless.com/products/rak12019-wisblock-uv-sensor)\n- [RAK12010 Ambient Light Sensor](https://store.rakwireless.com/products/wisblock-ambient-light-sensor-rak12010)\n- [RAK12021 RGB Light Sensor](https://store.rakwireless.com/products/rak12021-wisblock-rgb-sensor)\n- [RAK14001 RGB LED Module](https://store.rakwireless.com/products/rgb-led-module-rak14001)\n- [RAK14003 LED Bar Module](https://store.rakwireless.com/products/wisblock-led-bar-module-rak14003)\n- USB C Cable\n- [RAK19005 Sensor Extension Cable (optional)](https://store.rakwireless.com/products/fpc-extension-cable-for-slot-a-to-d-rak19005)\n- [RAK19008 IO Extension Cable (optional)](https://store.rakwireless.com/products/wisblock-io-extension-cable-rak19008)\n- [Li-Ion/LiPo battery (optional)](https://store.rakwireless.com/collections/wisblock-accessory/products/battery-connector-cable?utm_source=BatteryConnector&utm_medium=Document&utm_campaign=BuyFromStore)\n- [Solar charger (optional)](https://store.rakwireless.com/collections/wisblock-accessory/products/solar-panel-connector-cable?utm_source=SolarPanelConnector&utm_medium=Document&utm_campaign=BuyFromStore)"}
{"id": "abaaf2dac41d0f62bcd860fc2480d828", "product_family": "wisblock", "product_id": "kit6-light-and-color", "category": "Reference", "title": "WisBlock IoT Education Kit - Light & Color Quick Start Guide > WisBlock IoT Education Kit - Light & Color Quick Start Guide > Prerequisite > What Do You Need? > Hardware > Components List for kit6-light-and-color", "content": "- USB C Cable\n- [RAK19005 Sensor Extension Cable (optional)](https://store.rakwireless.com/products/fpc-extension-cable-for-slot-a-to-d-rak19005)\n- [RAK19008 IO Extension Cable (optional)](https://store.rakwireless.com/products/wisblock-io-extension-cable-rak19008)\n- [Li-Ion/LiPo battery (optional)](https://store.rakwireless.com/collections/wisblock-accessory/products/battery-connector-cable?utm_source=BatteryConnector&utm_medium=Document&utm_campaign=BuyFromStore)", "keywords": ["RAK4631", "RAK19007", "RAK19001", "RAK12019", "RAK12010", "RAK12021", "RAK14001", "RAK14003", "USB C Cable", "RAK19005", "RAK19008", "Li-Ion/LiPo battery", "Solar charger"], "source_file": "quickstart.md", "token_count": 150, "parent_content": "- [RAK4631 WisBlock Core](https://store.rakwireless.com/products/nordic-nrf52840-ble-core-module-for-lorawan-with-lora-sx1262-rak4631-rak4631-c?variant=42576992436422)\n- [RAK19007 WisBlock Base Board](https://store.rakwireless.com/products/rak19007-wisblock-base-board-2nd-gen)\n- [RAK19001 WisBlock Base Board](https://store.rakwireless.com/products/rak19001-wisblock-dual-io-base-board)\n- [RAK12019 UV Sensor](https://store.rakwireless.com/products/rak12019-wisblock-uv-sensor)\n- [RAK12010 Ambient Light Sensor](https://store.rakwireless.com/products/wisblock-ambient-light-sensor-rak12010)\n- [RAK12021 RGB Light Sensor](https://store.rakwireless.com/products/rak12021-wisblock-rgb-sensor)\n- [RAK14001 RGB LED Module](https://store.rakwireless.com/products/rgb-led-module-rak14001)\n- [RAK14003 LED Bar Module](https://store.rakwireless.com/products/wisblock-led-bar-module-rak14003)\n- USB C Cable\n- [RAK19005 Sensor Extension Cable (optional)](https://store.rakwireless.com/products/fpc-extension-cable-for-slot-a-to-d-rak19005)\n- [RAK19008 IO Extension Cable (optional)](https://store.rakwireless.com/products/wisblock-io-extension-cable-rak19008)\n- [Li-Ion/LiPo battery (optional)](https://store.rakwireless.com/collections/wisblock-accessory/products/battery-connector-cable?utm_source=BatteryConnector&utm_medium=Document&utm_campaign=BuyFromStore)\n- [Solar charger (optional)](https://store.rakwireless.com/collections/wisblock-accessory/products/solar-panel-connector-cable?utm_source=SolarPanelConnector&utm_medium=Document&utm_campaign=BuyFromStore)"}
{"id": "49f694cb23179fba2db653d6396d169c", "product_family": "wisblock", "product_id": "kit6-light-and-color", "category": "Reference", "title": "WisBlock IoT Education Kit - Light & Color Quick Start Guide > WisBlock IoT Education Kit - Light & Color Quick Start Guide > Prerequisite > What Do You Need? > Hardware > Components List for kit6-light-and-color", "content": "- [Solar charger (optional)](https://store.rakwireless.com/collections/wisblock-accessory/products/solar-panel-connector-cable?utm_source=SolarPanelConnector&utm_medium=Document&utm_campaign=BuyFromStore)", "keywords": ["RAK4631", "RAK19007", "RAK19001", "RAK12019", "RAK12010", "RAK12021", "RAK14001", "RAK14003", "USB C Cable", "RAK19005", "RAK19008", "Li-Ion/LiPo battery", "Solar charger"], "source_file": "quickstart.md", "token_count": 150, "parent_content": "- [RAK4631 WisBlock Core](https://store.rakwireless.com/products/nordic-nrf52840-ble-core-module-for-lorawan-with-lora-sx1262-rak4631-rak4631-c?variant=42576992436422)\n- [RAK19007 WisBlock Base Board](https://store.rakwireless.com/products/rak19007-wisblock-base-board-2nd-gen)\n- [RAK19001 WisBlock Base Board](https://store.rakwireless.com/products/rak19001-wisblock-dual-io-base-board)\n- [RAK12019 UV Sensor](https://store.rakwireless.com/products/rak12019-wisblock-uv-sensor)\n- [RAK12010 Ambient Light Sensor](https://store.rakwireless.com/products/wisblock-ambient-light-sensor-rak12010)\n- [RAK12021 RGB Light Sensor](https://store.rakwireless.com/products/rak12021-wisblock-rgb-sensor)\n- [RAK14001 RGB LED Module](https://store.rakwireless.com/products/rgb-led-module-rak14001)\n- [RAK14003 LED Bar Module](https://store.rakwireless.com/products/wisblock-led-bar-module-rak14003)\n- USB C Cable\n- [RAK19005 Sensor Extension Cable (optional)](https://store.rakwireless.com/products/fpc-extension-cable-for-slot-a-to-d-rak19005)\n- [RAK19008 IO Extension Cable (optional)](https://store.rakwireless.com/products/wisblock-io-extension-cable-rak19008)\n- [Li-Ion/LiPo battery (optional)](https://store.rakwireless.com/collections/wisblock-accessory/products/battery-connector-cable?utm_source=BatteryConnector&utm_medium=Document&utm_campaign=BuyFromStore)\n- [Solar charger (optional)](https://store.rakwireless.com/collections/wisblock-accessory/products/solar-panel-connector-cable?utm_source=SolarPanelConnector&utm_medium=Document&utm_campaign=BuyFromStore)"}
{"id": "1773aee30f895fbb13201f29d21f1aa1", "product_family": "wisblock", "product_id": "kit6-light-and-color", "category": "How-To", "title": "WisBlock IoT Education Kit - Light & Color Quick Start Guide > WisBlock IoT Education Kit - Light & Color Quick Start Guide > Prerequisite > What Do You Need? > Software > Arduino > Install Arduino IDE and RAKwireless BSP for kit6-light-and-color", "content": "- Download and install the [ArduinoIDE](https://www.arduino.cc/en/Main/Software).\n- To add the RAKwireless Core boards on your Arduino Boards Manager, install the [RAKwireless Arduino BSP](https://github.com/RAKWireless/RAKwireless-Arduino-BSP-Index).", "keywords": ["Arduino IDE", "RAKwireless BSP", "installation", "setup"], "source_file": "quickstart.md", "token_count": 40, "parent_content": "- Download and install the [ArduinoIDE](https://www.arduino.cc/en/Main/Software).\n- To add the RAKwireless Core boards on your Arduino Boards Manager, install the [RAKwireless Arduino BSP](https://github.com/RAKWireless/RAKwireless-Arduino-BSP-Index)."}
{"id": "63bdfec4be46bd9538a2c412c19e0a40", "product_family": "wisblock", "product_id": "kit6-light-and-color", "category": "Concept", "title": "WisBlock IoT Education Kit - Light & Color Quick Start Guide > WisBlock IoT Education Kit - Light & Color Quick Start Guide > Product Configuration > Hardware Setup & Sample Applications > WisBlock IoT Education Kit - Light & Color Overview", "content": "**WisBlock IoT Education Kit - Light & Color** comprises of UV and light sensors, and RGB LED modules that can be used with **RAK19007** and **RAK19001** **WisBlock Base boards** which you can choose from. This kit will help you learn how to measure light and colors and how to create different light sources. You can choose from these devices for your desired applications.  \n- **UV Index & UV Intensity Meter - RAK4631 + RAK12019 + RAK12010 + RAK14003**", "keywords": ["WisBlock", "IoT Education Kit", "Light & Color", "UV Sensor", "RGB LED", "RAK19007", "RAK19001", "RAK4631", "RAK12019", "RAK12010", "RAK14003", "RAK12021", "RAK14001"], "source_file": "quickstart.md", "token_count": 150, "parent_content": "**WisBlock IoT Education Kit - Light & Color** comprises of UV and light sensors, and RGB LED modules that can be used with **RAK19007** and **RAK19001** **WisBlock Base boards** which you can choose from. This kit will help you learn how to measure light and colors and how to create different light sources. You can choose from these devices for your desired applications.  \n- **UV Index & UV Intensity Meter - RAK4631 + RAK12019 + RAK12010 + RAK14003**  \n> **Image:** RAK4631 + RAK12019 + RAK12010 + RAK14003  \n- **RGB LED Color Changer - RAK4631 + RAK12021 + RAK14001**  \n> **Image:** RAK4631 + RAK12021 + RAK14001"}
{"id": "fab996db3bc32a591ccb1034529f4130", "product_family": "wisblock", "product_id": "kit6-light-and-color", "category": "Concept", "title": "WisBlock IoT Education Kit - Light & Color Quick Start Guide > WisBlock IoT Education Kit - Light & Color Quick Start Guide > Product Configuration > Hardware Setup & Sample Applications > WisBlock IoT Education Kit - Light & Color Overview", "content": "- **UV Index & UV Intensity Meter - RAK4631 + RAK12019 + RAK12010 + RAK14003**  \n> **Image:** RAK4631 + RAK12019 + RAK12010 + RAK14003  \n- **RGB LED Color Changer - RAK4631 + RAK12021 + RAK14001**  \n> **Image:** RAK4631 + RAK12021 + RAK14001", "keywords": ["WisBlock", "IoT Education Kit", "Light & Color", "UV Sensor", "RGB LED", "RAK19007", "RAK19001", "RAK4631", "RAK12019", "RAK12010", "RAK14003", "RAK12021", "RAK14001"], "source_file": "quickstart.md", "token_count": 150, "parent_content": "**WisBlock IoT Education Kit - Light & Color** comprises of UV and light sensors, and RGB LED modules that can be used with **RAK19007** and **RAK19001** **WisBlock Base boards** which you can choose from. This kit will help you learn how to measure light and colors and how to create different light sources. You can choose from these devices for your desired applications.  \n- **UV Index & UV Intensity Meter - RAK4631 + RAK12019 + RAK12010 + RAK14003**  \n> **Image:** RAK4631 + RAK12019 + RAK12010 + RAK14003  \n- **RGB LED Color Changer - RAK4631 + RAK12021 + RAK14001**  \n> **Image:** RAK4631 + RAK12021 + RAK14001"}
{"id": "4e1e35a693dd5c35720138b07b7a99a5", "product_family": "wisblock", "product_id": "kit6-light-and-color", "category": "Reference", "title": "WisBlock IoT Education Kit - Light & Color Quick Start Guide > WisBlock IoT Education Kit - Light & Color Quick Start Guide > Product Configuration > Hardware Setup & Sample Applications > Assembly and Functionality Tests of WisBlock Light and Color Modules > WisBlock Light and Color Modules Reference", "content": "The following WisBlock Light and Color modules listed below are used in this kit. To check for their asssemblies and functionalities, please refer to the links below for further information:  \n- [RAK12019 UV Sensor](https://docs.rakwireless.com/product-categories/wisblock/rak12019/quickstart/#prerequisite)\n- [RAK12010 Ambient Light Sensor](https://docs.rakwireless.com/product-categories/wisblock/rak12010/quickstart/#prerequisite)", "keywords": ["WisBlock", "Light and Color", "RAK12019", "RAK12010", "RAK12021", "RAK14001", "RAK14003"], "source_file": "quickstart.md", "token_count": 120, "parent_content": "The following WisBlock Light and Color modules listed below are used in this kit. To check for their asssemblies and functionalities, please refer to the links below for further information:  \n- [RAK12019 UV Sensor](https://docs.rakwireless.com/product-categories/wisblock/rak12019/quickstart/#prerequisite)\n- [RAK12010 Ambient Light Sensor](https://docs.rakwireless.com/product-categories/wisblock/rak12010/quickstart/#prerequisite)\n- [RAK12021 RGB Light Sensor](https://docs.rakwireless.com/product-categories/wisblock/rak12021/quickstart/#prerequisite)\n- [RAK14001 RGB LED Module](https://docs.rakwireless.com/product-categories/wisblock/rak14001/quickstart/#software-configuration-and-example)\n- [RAK14003 LED Bar Module](https://docs.rakwireless.com/product-categories/wisblock/rak14003/quickstart/#software-configuration-and-example)"}
{"id": "4af86490200c102050b8a72ddfd4bdb2", "product_family": "wisblock", "product_id": "kit6-light-and-color", "category": "Reference", "title": "WisBlock IoT Education Kit - Light & Color Quick Start Guide > WisBlock IoT Education Kit - Light & Color Quick Start Guide > Product Configuration > Hardware Setup & Sample Applications > Assembly and Functionality Tests of WisBlock Light and Color Modules > WisBlock Light and Color Modules Reference", "content": "- [RAK12021 RGB Light Sensor](https://docs.rakwireless.com/product-categories/wisblock/rak12021/quickstart/#prerequisite)\n- [RAK14001 RGB LED Module](https://docs.rakwireless.com/product-categories/wisblock/rak14001/quickstart/#software-configuration-and-example)\n- [RAK14003 LED Bar Module](https://docs.rakwireless.com/product-categories/wisblock/rak14003/quickstart/#software-configuration-and-example)", "keywords": ["WisBlock", "Light and Color", "RAK12019", "RAK12010", "RAK12021", "RAK14001", "RAK14003"], "source_file": "quickstart.md", "token_count": 120, "parent_content": "The following WisBlock Light and Color modules listed below are used in this kit. To check for their asssemblies and functionalities, please refer to the links below for further information:  \n- [RAK12019 UV Sensor](https://docs.rakwireless.com/product-categories/wisblock/rak12019/quickstart/#prerequisite)\n- [RAK12010 Ambient Light Sensor](https://docs.rakwireless.com/product-categories/wisblock/rak12010/quickstart/#prerequisite)\n- [RAK12021 RGB Light Sensor](https://docs.rakwireless.com/product-categories/wisblock/rak12021/quickstart/#prerequisite)\n- [RAK14001 RGB LED Module](https://docs.rakwireless.com/product-categories/wisblock/rak14001/quickstart/#software-configuration-and-example)\n- [RAK14003 LED Bar Module](https://docs.rakwireless.com/product-categories/wisblock/rak14003/quickstart/#software-configuration-and-example)"}
{"id": "1310d294b6d00ba31cf18d12a36a0392", "product_family": "wisblock", "product_id": "kit6-light-and-color", "category": "Concept", "title": "WisBlock IoT Education Kit - Light & Color Quick Start Guide > WisBlock IoT Education Kit - Light & Color Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock IoT Education Kit - Light & Color using TTN and Qubitro > UV Index & UV Intensity Monitoring LoRaWAN Application", "content": "- [UV Index & UV Intensity Monitoring LoRaWAN Application](#uv-index-uv-intensity-monitoring-lorawan-application)\n- [Light Color Recognizer LoRaWAN Application](#light-color-recognizer-lorawan-application)", "keywords": ["UV Index", "UV Intensity", "LoRaWAN", "Monitoring"], "source_file": "quickstart.md", "token_count": 15, "parent_content": "- [UV Index & UV Intensity Monitoring LoRaWAN Application](#uv-index-uv-intensity-monitoring-lorawan-application)\n- [Light Color Recognizer LoRaWAN Application](#light-color-recognizer-lorawan-application)"}
{"id": "9852cb45da6b70540a19e3c7ead5de7b", "product_family": "wisblock", "product_id": "kit6-light-and-color", "category": "Concept", "title": "WisBlock IoT Education Kit - Light & Color Quick Start Guide > WisBlock IoT Education Kit - Light & Color Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock IoT Education Kit - Light & Color using TTN and Qubitro > UV Index & UV Intensity Monitoring LoRaWAN Application > UV Index & UV Intensity Monitoring LoRaWAN Application Overview", "content": "The **UV Index & UV Intensity Monitoring LoRaWAN Application** is used to monitor the UV index, UV intensity and light intensity from the sun exposure. It uses **RAK12019** which is an ambient light sensor and a ultraviolet sensor which is based on **LTR-390UV-01** from Lite-On. Also, it uses **RAK12010** which is an ambient light sensor which is based from **VEML7700** chip from Vishay Semiconductors. And finally the **RAK14003** LED bar module which visualizes the UV Index level measured from", "keywords": ["UV Index", "UV Intensity", "LoRaWAN", "RAK12019", "RAK12010", "RAK14003", "LTR-390UV-01", "VEML7700"], "source_file": "quickstart.md", "token_count": 0, "parent_content": "The **UV Index & UV Intensity Monitoring LoRaWAN Application** is used to monitor the UV index, UV intensity and light intensity from the sun exposure. It uses **RAK12019** which is an ambient light sensor and a ultraviolet sensor which is based on **LTR-390UV-01** from Lite-On. Also, it uses **RAK12010** which is an ambient light sensor which is based from **VEML7700** chip from Vishay Semiconductors. And finally the **RAK14003** LED bar module which visualizes the UV Index level measured from the **RAK12019** module.  \n**UV Index** is the measure of the level of UV radiation from the sun exposure. It ranges from zero upward. The higher the UV Index level, the greater potential for damage to the skin and eye. The **UV Index & UV Intensity Monitoring** device will help alert people about the need to use sun protection when going outside. Below is the **UV Index Scale** which can help users monitor the level of the UV Index during daytime. For further details about UV index levels and their impacts, you can refer from this [link](https://www.epa.gov/sunsafety/uv-index-scale-0).  \n> **Image:** UV Index Scale  \n> **Image:** UV Index & UV Intensity Monitoring device"}
{"id": "8dea2b03ae0760d40fb8d5d77e63ae8a", "product_family": "wisblock", "product_id": "kit6-light-and-color", "category": "Concept", "title": "WisBlock IoT Education Kit - Light & Color Quick Start Guide > WisBlock IoT Education Kit - Light & Color Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock IoT Education Kit - Light & Color using TTN and Qubitro > UV Index & UV Intensity Monitoring LoRaWAN Application > UV Index & UV Intensity Monitoring LoRaWAN Application Overview", "content": "And finally the **RAK14003** LED bar module which visualizes the UV Index level measured from the **RAK12019** module.", "keywords": ["UV Index", "UV Intensity", "LoRaWAN", "RAK12019", "RAK12010", "RAK14003", "LTR-390UV-01", "VEML7700"], "source_file": "quickstart.md", "token_count": 0, "parent_content": "The **UV Index & UV Intensity Monitoring LoRaWAN Application** is used to monitor the UV index, UV intensity and light intensity from the sun exposure. It uses **RAK12019** which is an ambient light sensor and a ultraviolet sensor which is based on **LTR-390UV-01** from Lite-On. Also, it uses **RAK12010** which is an ambient light sensor which is based from **VEML7700** chip from Vishay Semiconductors. And finally the **RAK14003** LED bar module which visualizes the UV Index level measured from the **RAK12019** module.  \n**UV Index** is the measure of the level of UV radiation from the sun exposure. It ranges from zero upward. The higher the UV Index level, the greater potential for damage to the skin and eye. The **UV Index & UV Intensity Monitoring** device will help alert people about the need to use sun protection when going outside. Below is the **UV Index Scale** which can help users monitor the level of the UV Index during daytime. For further details about UV index levels and their impacts, you can refer from this [link](https://www.epa.gov/sunsafety/uv-index-scale-0).  \n> **Image:** UV Index Scale  \n> **Image:** UV Index & UV Intensity Monitoring device"}
{"id": "da60f147cc9dbf290d988f54bf9778fc", "product_family": "wisblock", "product_id": "kit6-light-and-color", "category": "Concept", "title": "WisBlock IoT Education Kit - Light & Color Quick Start Guide > WisBlock IoT Education Kit - Light & Color Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock IoT Education Kit - Light & Color using TTN and Qubitro > UV Index & UV Intensity Monitoring LoRaWAN Application > UV Index & UV Intensity Monitoring LoRaWAN Application Overview", "content": "**UV Index** is the measure of the level of UV radiation from the sun exposure. It ranges from zero upward. The higher the UV Index level, the greater potential for damage to the skin and eye. The **UV Index & UV Intensity Monitoring** device will help alert people about the need to use sun protection when going outside. Below is the **UV Index Scale** which can help users monitor the level of the UV Index during daytime. For further details about UV index levels and their impacts, you can", "keywords": ["UV Index", "UV Intensity", "LoRaWAN", "RAK12019", "RAK12010", "RAK14003", "LTR-390UV-01", "VEML7700"], "source_file": "quickstart.md", "token_count": 0, "parent_content": "The **UV Index & UV Intensity Monitoring LoRaWAN Application** is used to monitor the UV index, UV intensity and light intensity from the sun exposure. It uses **RAK12019** which is an ambient light sensor and a ultraviolet sensor which is based on **LTR-390UV-01** from Lite-On. Also, it uses **RAK12010** which is an ambient light sensor which is based from **VEML7700** chip from Vishay Semiconductors. And finally the **RAK14003** LED bar module which visualizes the UV Index level measured from the **RAK12019** module.  \n**UV Index** is the measure of the level of UV radiation from the sun exposure. It ranges from zero upward. The higher the UV Index level, the greater potential for damage to the skin and eye. The **UV Index & UV Intensity Monitoring** device will help alert people about the need to use sun protection when going outside. Below is the **UV Index Scale** which can help users monitor the level of the UV Index during daytime. For further details about UV index levels and their impacts, you can refer from this [link](https://www.epa.gov/sunsafety/uv-index-scale-0).  \n> **Image:** UV Index Scale  \n> **Image:** UV Index & UV Intensity Monitoring device"}
{"id": "fba5f264d61fc564c4a4e0ec40a81992", "product_family": "wisblock", "product_id": "kit6-light-and-color", "category": "Concept", "title": "WisBlock IoT Education Kit - Light & Color Quick Start Guide > WisBlock IoT Education Kit - Light & Color Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock IoT Education Kit - Light & Color using TTN and Qubitro > UV Index & UV Intensity Monitoring LoRaWAN Application > UV Index & UV Intensity Monitoring LoRaWAN Application Overview", "content": "the UV Index during daytime. For further details about UV index levels and their impacts, you can refer from this [link](https://www.epa.gov/sunsafety/uv-index-scale-0).", "keywords": ["UV Index", "UV Intensity", "LoRaWAN", "RAK12019", "RAK12010", "RAK14003", "LTR-390UV-01", "VEML7700"], "source_file": "quickstart.md", "token_count": 0, "parent_content": "The **UV Index & UV Intensity Monitoring LoRaWAN Application** is used to monitor the UV index, UV intensity and light intensity from the sun exposure. It uses **RAK12019** which is an ambient light sensor and a ultraviolet sensor which is based on **LTR-390UV-01** from Lite-On. Also, it uses **RAK12010** which is an ambient light sensor which is based from **VEML7700** chip from Vishay Semiconductors. And finally the **RAK14003** LED bar module which visualizes the UV Index level measured from the **RAK12019** module.  \n**UV Index** is the measure of the level of UV radiation from the sun exposure. It ranges from zero upward. The higher the UV Index level, the greater potential for damage to the skin and eye. The **UV Index & UV Intensity Monitoring** device will help alert people about the need to use sun protection when going outside. Below is the **UV Index Scale** which can help users monitor the level of the UV Index during daytime. For further details about UV index levels and their impacts, you can refer from this [link](https://www.epa.gov/sunsafety/uv-index-scale-0).  \n> **Image:** UV Index Scale  \n> **Image:** UV Index & UV Intensity Monitoring device"}
{"id": "6a7348283951451deb3879b3e8428da0", "product_family": "wisblock", "product_id": "kit6-light-and-color", "category": "Concept", "title": "WisBlock IoT Education Kit - Light & Color Quick Start Guide > WisBlock IoT Education Kit - Light & Color Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock IoT Education Kit - Light & Color using TTN and Qubitro > UV Index & UV Intensity Monitoring LoRaWAN Application > UV Index & UV Intensity Monitoring LoRaWAN Application Overview", "content": "> **Image:** UV Index Scale  \n> **Image:** UV Index & UV Intensity Monitoring device", "keywords": ["UV Index", "UV Intensity", "LoRaWAN", "RAK12019", "RAK12010", "RAK14003", "LTR-390UV-01", "VEML7700"], "source_file": "quickstart.md", "token_count": 0, "parent_content": "The **UV Index & UV Intensity Monitoring LoRaWAN Application** is used to monitor the UV index, UV intensity and light intensity from the sun exposure. It uses **RAK12019** which is an ambient light sensor and a ultraviolet sensor which is based on **LTR-390UV-01** from Lite-On. Also, it uses **RAK12010** which is an ambient light sensor which is based from **VEML7700** chip from Vishay Semiconductors. And finally the **RAK14003** LED bar module which visualizes the UV Index level measured from the **RAK12019** module.  \n**UV Index** is the measure of the level of UV radiation from the sun exposure. It ranges from zero upward. The higher the UV Index level, the greater potential for damage to the skin and eye. The **UV Index & UV Intensity Monitoring** device will help alert people about the need to use sun protection when going outside. Below is the **UV Index Scale** which can help users monitor the level of the UV Index during daytime. For further details about UV index levels and their impacts, you can refer from this [link](https://www.epa.gov/sunsafety/uv-index-scale-0).  \n> **Image:** UV Index Scale  \n> **Image:** UV Index & UV Intensity Monitoring device"}
{"id": "6e4f1d3e76b708bfc1d824507d069fc7", "product_family": "wisblock", "product_id": "kit6-light-and-color", "category": "How-To", "title": "WisBlock IoT Education Kit - Light & Color Quick Start Guide > WisBlock IoT Education Kit - Light & Color Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock IoT Education Kit - Light & Color using TTN and Qubitro > UV Index & UV Intensity Monitoring LoRaWAN Application > UV Index & UV Intensity Monitoring - TTN Registration Section and Device Registration > Steps for TTN Account Creation and Device Registration", "content": "1. If you already have an existing TTN account, you may proceed to the next steps. If you haven't created any TTN account, please refer to this [link](#ttn-account-creation) to create one.  \n2. Once done with the TTN account creation, you may now proceed with the device registration. Please refer to this [guide](#device-registration) for your reference. After creating the application and adding the device in TTN, you can proceed on the LoRaWAN Code uploading steps.", "keywords": ["TTN", "account creation", "device registration", "LoRaWAN"], "source_file": "quickstart.md", "token_count": 75, "parent_content": "1. If you already have an existing TTN account, you may proceed to the next steps. If you haven't created any TTN account, please refer to this [link](#ttn-account-creation) to create one.  \n2. Once done with the TTN account creation, you may now proceed with the device registration. Please refer to this [guide](#device-registration) for your reference. After creating the application and adding the device in TTN, you can proceed on the LoRaWAN Code uploading steps."}
{"id": "2c819e684ec0583ae59f60cb9458abf4", "product_family": "wisblock", "product_id": "kit6-light-and-color", "category": "How-To", "title": "WisBlock IoT Education Kit - Light & Color Quick Start Guide > WisBlock IoT Education Kit - Light & Color Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock IoT Education Kit - Light & Color using TTN and Qubitro > UV Index & UV Intensity Monitoring LoRaWAN Application > LoRaWAN Code for UV Index & UV Intensity Monitoring > Programming UV Index & UV Intensity Monitoring Device with Arduino IDE [CODE]", "content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.", "keywords": ["Arduino IDE", "RAK4631", "UV Index", "UV Intensity", "LoRaWAN", "SX126x-Arduino"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **UV Index & UV Intensity Monitoring** device. Just copy the code below for **UV Index & UV Intensity Monitoring LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the example </summary>  \n```c\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h>  //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n#include \"UVlight_LTR390.h\"                // http://librarymanager/All#RAK12019_LTR390\nUVlight_LTR390 ltr = UVlight_LTR390();\n\n#include \"Light_VEML7700.h\"                // http://librarymanager/All#Light_veml7700\nLight_VEML7700 VMEL = Light_VEML7700();\n\nuint16_t uvi;\nuint32_t uvs;\nuint32_t lux;\nuint32_t white;\nuint32_t raw_als;\n\n#include <Adafruit_MCP23X17.h>  //http://librarymanager/All#Adafruit_MCP23017\nAdafruit_MCP23X17 mcp;\n\n// Added definitions for the functionality of RAK14003\nconst uint8_t LED_0 = 0;      // PA0 (17) of MCP23017\nconst uint8_t LED_1 = 1;      // PA1 (18) of MCP23017\nconst uint8_t LED_2 = 2;      // PA2 (19) of MCP23017\nconst uint8_t LED_3 = 3;      // PA3 (20) of MCP23017\nconst uint8_t LED_4 = 4;      // PA4 (21) of MCP23017\nconst uint8_t LED_5 = 5;      // PA5 (22) of MCP23017\nconst uint8_t LED_6 = 6;      // PA6 (23) of MCP23017\nconst uint8_t LED_7 = 7;      // PA7 (24) of MCP23017\nconst uint8_t LED_8 = 8;      // PB0 (25) of MCP23017\nconst uint8_t LED_9 = 9;      // PB1 (26) of MCP23017\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define RAK4631_BOARD true\n#else\n#define RAK4631_BOARD false\n#endif\n\nbool doOTAA = true;                                               // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                                       /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                                     /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5                               /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                                        /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;                           /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;                 /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                              /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = { LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF };\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = { BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler };\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xE9, 0x0D, 0x28, 0x1D, 0x92, 0x3D, 0xE4, 0x9F, 0xD9, 0xF7, 0xE0, 0x5F, 0x39, 0x10, 0x55, 0x71 };\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };\nuint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                                            /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];               //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = { m_lora_app_data_buffer, 0, 0, 0, 0 };  //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {\n\n// Initialize Serial for debug output\npinMode(LED_BLUE, OUTPUT);\ndigitalWrite(LED_BLUE, HIGH);\n\n// Sensor Power Switch\npinMode(WB_IO2, OUTPUT);\ndigitalWrite(WB_IO2, HIGH);\n\n// Reset RAK14003 module\npinMode(WB_IO4, OUTPUT);\ndigitalWrite(WB_IO4, HIGH);\ndelay(10);\ndigitalWrite(WB_IO4, LOW);\ndelay(10);\ndigitalWrite(WB_IO4, HIGH);\ndelay(10);\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial) {\nif ((millis() - timeout) < 5000) {\ndelay(100);\n} else {\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA) {\nSerial.println(\"Type: OTAA\");\n} else {\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion) {\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA) {\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n} else {\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0) {\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"================================\");\nSerial.println(\"RAK12019 + RAK12010 LoRaWAN Code\");\nSerial.println(\"================================\");\n\nif (!VMEL.begin())\n{\nSerial.println(\"Sensor not found\");\nwhile (1);\n}\n\nVMEL.setGain(VEML7700_GAIN_1);\nVMEL.setIntegrationTime(VEML7700_IT_800MS);\n\nSerial.print(F(\"Gain: \"));\nswitch (VMEL.getGain())\n{\ncase VEML7700_GAIN_1: Serial.println(\"1\"); break;\ncase VEML7700_GAIN_2: Serial.println(\"2\"); break;\ncase VEML7700_GAIN_1_4: Serial.println(\"1/4\"); break;\ncase VEML7700_GAIN_1_8: Serial.println(\"1/8\"); break;\n}\n\nSerial.print(F(\"Integration Time (ms): \"));\nswitch (VMEL.getIntegrationTime())\n{\ncase VEML7700_IT_25MS: Serial.println(\"25\"); break;\ncase VEML7700_IT_50MS: Serial.println(\"50\"); break;\ncase VEML7700_IT_100MS: Serial.println(\"100\"); break;\ncase VEML7700_IT_200MS: Serial.println(\"200\"); break;\ncase VEML7700_IT_400MS: Serial.println(\"400\"); break;\ncase VEML7700_IT_800MS: Serial.println(\"800\"); break;\n}\n\nSerial.println(\"RAK12019 test\");\nWire.begin();\nif (!ltr.init())\n{\nSerial.println(\"Couldn't find LTR sensor!\");\nwhile (1)\ndelay(10);\n}\nSerial.println(\"Found LTR390 sensor!\");\n\n//set to LTR390_MODE_UVS,get ultraviolet light data.\nltr.setMode(LTR390_MODE_UVS);  // UVS Mode\n\nSerial.println(\"In UVS mode\");\n\nltr.setGain(LTR390_GAIN_3);\nSerial.print(\"Gain : \");\nswitch (ltr.getGain())\n{\ncase LTR390_GAIN_1:\nSerial.println(1);\nbreak;\ncase LTR390_GAIN_3:\nSerial.println(3);\nbreak;\ncase LTR390_GAIN_6:\nSerial.println(6);\nbreak;\ncase LTR390_GAIN_9:\nSerial.println(9);\nbreak;\ncase LTR390_GAIN_18:\nSerial.println(18);\nbreak;\ndefault:\nSerial.println(\"Failed to set gain\");\nbreak;\n}\nltr.setResolution(LTR390_RESOLUTION_16BIT);\nSerial.print(\"Integration Time (ms): \");\nswitch (ltr.getResolution())\n{\ncase LTR390_RESOLUTION_13BIT:\nSerial.println(13);\nbreak;\ncase LTR390_RESOLUTION_16BIT:\nSerial.println(16);\nbreak;\ncase LTR390_RESOLUTION_17BIT:\nSerial.println(17);\nbreak;\ncase LTR390_RESOLUTION_18BIT:\nSerial.println(18);\nbreak;\ncase LTR390_RESOLUTION_19BIT:\nSerial.println(19);\nbreak;\ncase LTR390_RESOLUTION_20BIT:\nSerial.println(20);\nbreak;\ndefault:\nSerial.println(\"Failed to set Integration Time\");\nbreak;\n}\n\nltr.setThresholds(100, 1000); //Set the interrupt output threshold range for lower and upper.\n\nltr.configInterrupt(true, LTR390_MODE_UVS);\n\n// For RAK14003\nmcp.begin_I2C(0x24);\n\n// Added for the functionality of RAK14003\n\nWire.begin();    // initialize I2C serial bus\n\n// Configuration of MCP23017 I/O ports\nmcp.pinMode(LED_0, OUTPUT);     // Red LED; Top most\nmcp.pinMode(LED_1, OUTPUT);     // Red LED\nmcp.pinMode(LED_2, OUTPUT);     // Orange LED\nmcp.pinMode(LED_3, OUTPUT);     // Orange LED\nmcp.pinMode(LED_4, OUTPUT);     // Orange LED\nmcp.pinMode(LED_5, OUTPUT);     // Green LED\nmcp.pinMode(LED_6, OUTPUT);     // Green LED\nmcp.pinMode(LED_7, OUTPUT);     // Green LED\nmcp.pinMode(LED_8, OUTPUT);     // Green LED\nmcp.pinMode(LED_9, OUTPUT);     // Green LED; Bottom\n\n// Initially Turn OFF all LEDs\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, HIGH);\n\n}\n\nvoid loop() {\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\n// Trial # 1\n// Data from RAK12019\nif (ltr.newDataAvailable())\n{\nuvi = ltr.getUVI();\nuvs = ltr.readUVS();\n}\n\n// Data from RAK12010\nlux = VMEL.readLux();\nwhite = VMEL.readWhite();\nraw_als = VMEL.readALS();\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\n\n// From RAK12019 module\nSerial.print(\"UVI: \");\nSerial.println(uvi);          // Uvi data from RAK12019\nSerial.print(\"UVS: \");\nSerial.println(uvs);            // Uvs data from RAK12019\n\n// From RAK12010\nSerial.print(\"Lux: \");\nSerial.print(lux);\nSerial.println(\" lx \");\nSerial.print(\"White: \");\nSerial.println(white);\nSerial.print(\"Raw ALS: \");\nSerial.println(raw_als);\n\n// Result of uvi to be displayed via RAK14003 module\nif (uvi <= 0.4)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, HIGH);\n}\n\nelse if (uvi > 0.5 && uvi <= 1)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 1.5 && uvi <= 2)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 2.5 && uvi <= 3)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 3.5 && uvi <= 4)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 4.5 && uvi <= 5)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 5.5 && uvi <= 6)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 6.5 && uvi <= 7)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 7.5 && uvi <= 8)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 8.5 && uvi <= 9.5)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, LOW);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi >= 10)\n{\nmcp.digitalWrite(LED_0, LOW);\nmcp.digitalWrite(LED_1, LOW);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\ndelay(10000);\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void) {\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void) {\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data) {\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class) {\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void) {\nif (lmh_join_status_get() != LMH_SET) {\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\ndata = \" Uvi Data: \" + String(uvi) + \" Uvs Data: \" + String(uvs) + \" Lux Data: \" + String(lux) + \" lx \" ;\n\nSerial.println(data);\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\nuint16_t uvi_data = uvi;            // Uvi data from RAK12019\nuint32_t uvs_data = uvs;            // Uvs data from RAK12019\nuint32_t lux_data = lux;            // Lux data from RAK12010\n\nm_lora_app_data.buffer[i++] = 0x01;  // byte[0]\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\n// Data from RAK12019 module\nm_lora_app_data.buffer[i++] = (uint8_t)((uvi_data & 0x0000FF00) >> 8);     // byte[1]\nm_lora_app_data.buffer[i++] = (uint8_t)(uvi_data & 0x000000FF);            // byte[2]\n\n// Data from RAK12019 module\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0xFF000000) >> 24);    // byte[3]\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0x00FF0000) >> 16);    // byte[4]\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0x0000FF00) >> 8);     // byte[5]\nm_lora_app_data.buffer[i++] = (uint8_t)(uvs_data & 0x000000FF);            // byte[6]\n\n// Data from RAK12010 module\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0xFF000000) >> 24);    // byte[7]\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0x00FF0000) >> 16);    // byte[8]\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0x0000FF00) >> 8);     // byte[9]\nm_lora_app_data.buffer[i++] = (uint8_t)(lux_data & 0x000000FF);            // byte[10]\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS) {\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n} else {\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xE9, 0x0D, 0x28, 0x1D, 0x92, 0x3D, 0xE4, 0x9F, 0xD9, 0xF7, 0xE0, 0x5F, 0x39, 0x10, 0x55, 0x71 };\n\n```  \n> **Image:** OTAA device successfully registered to TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "c8b8436fdb2e03b883be745cabe5936b", "product_family": "wisblock", "product_id": "kit6-light-and-color", "category": "How-To", "title": "WisBlock IoT Education Kit - Light & Color Quick Start Guide > WisBlock IoT Education Kit - Light & Color Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock IoT Education Kit - Light & Color using TTN and Qubitro > UV Index & UV Intensity Monitoring LoRaWAN Application > LoRaWAN Code for UV Index & UV Intensity Monitoring > Programming UV Index & UV Intensity Monitoring Device with Arduino IDE [CODE]", "content": "2. After the installation, you can now proceed programming your **UV Index & UV Intensity Monitoring** device. Just copy the code below for **UV Index & UV Intensity Monitoring LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the example </summary>  \n```c", "keywords": ["Arduino IDE", "RAK4631", "UV Index", "UV Intensity", "LoRaWAN", "SX126x-Arduino"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **UV Index & UV Intensity Monitoring** device. Just copy the code below for **UV Index & UV Intensity Monitoring LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the example </summary>  \n```c\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h>  //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n#include \"UVlight_LTR390.h\"                // http://librarymanager/All#RAK12019_LTR390\nUVlight_LTR390 ltr = UVlight_LTR390();\n\n#include \"Light_VEML7700.h\"                // http://librarymanager/All#Light_veml7700\nLight_VEML7700 VMEL = Light_VEML7700();\n\nuint16_t uvi;\nuint32_t uvs;\nuint32_t lux;\nuint32_t white;\nuint32_t raw_als;\n\n#include <Adafruit_MCP23X17.h>  //http://librarymanager/All#Adafruit_MCP23017\nAdafruit_MCP23X17 mcp;\n\n// Added definitions for the functionality of RAK14003\nconst uint8_t LED_0 = 0;      // PA0 (17) of MCP23017\nconst uint8_t LED_1 = 1;      // PA1 (18) of MCP23017\nconst uint8_t LED_2 = 2;      // PA2 (19) of MCP23017\nconst uint8_t LED_3 = 3;      // PA3 (20) of MCP23017\nconst uint8_t LED_4 = 4;      // PA4 (21) of MCP23017\nconst uint8_t LED_5 = 5;      // PA5 (22) of MCP23017\nconst uint8_t LED_6 = 6;      // PA6 (23) of MCP23017\nconst uint8_t LED_7 = 7;      // PA7 (24) of MCP23017\nconst uint8_t LED_8 = 8;      // PB0 (25) of MCP23017\nconst uint8_t LED_9 = 9;      // PB1 (26) of MCP23017\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define RAK4631_BOARD true\n#else\n#define RAK4631_BOARD false\n#endif\n\nbool doOTAA = true;                                               // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                                       /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                                     /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5                               /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                                        /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;                           /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;                 /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                              /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = { LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF };\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = { BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler };\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xE9, 0x0D, 0x28, 0x1D, 0x92, 0x3D, 0xE4, 0x9F, 0xD9, 0xF7, 0xE0, 0x5F, 0x39, 0x10, 0x55, 0x71 };\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };\nuint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                                            /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];               //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = { m_lora_app_data_buffer, 0, 0, 0, 0 };  //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {\n\n// Initialize Serial for debug output\npinMode(LED_BLUE, OUTPUT);\ndigitalWrite(LED_BLUE, HIGH);\n\n// Sensor Power Switch\npinMode(WB_IO2, OUTPUT);\ndigitalWrite(WB_IO2, HIGH);\n\n// Reset RAK14003 module\npinMode(WB_IO4, OUTPUT);\ndigitalWrite(WB_IO4, HIGH);\ndelay(10);\ndigitalWrite(WB_IO4, LOW);\ndelay(10);\ndigitalWrite(WB_IO4, HIGH);\ndelay(10);\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial) {\nif ((millis() - timeout) < 5000) {\ndelay(100);\n} else {\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA) {\nSerial.println(\"Type: OTAA\");\n} else {\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion) {\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA) {\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n} else {\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0) {\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"================================\");\nSerial.println(\"RAK12019 + RAK12010 LoRaWAN Code\");\nSerial.println(\"================================\");\n\nif (!VMEL.begin())\n{\nSerial.println(\"Sensor not found\");\nwhile (1);\n}\n\nVMEL.setGain(VEML7700_GAIN_1);\nVMEL.setIntegrationTime(VEML7700_IT_800MS);\n\nSerial.print(F(\"Gain: \"));\nswitch (VMEL.getGain())\n{\ncase VEML7700_GAIN_1: Serial.println(\"1\"); break;\ncase VEML7700_GAIN_2: Serial.println(\"2\"); break;\ncase VEML7700_GAIN_1_4: Serial.println(\"1/4\"); break;\ncase VEML7700_GAIN_1_8: Serial.println(\"1/8\"); break;\n}\n\nSerial.print(F(\"Integration Time (ms): \"));\nswitch (VMEL.getIntegrationTime())\n{\ncase VEML7700_IT_25MS: Serial.println(\"25\"); break;\ncase VEML7700_IT_50MS: Serial.println(\"50\"); break;\ncase VEML7700_IT_100MS: Serial.println(\"100\"); break;\ncase VEML7700_IT_200MS: Serial.println(\"200\"); break;\ncase VEML7700_IT_400MS: Serial.println(\"400\"); break;\ncase VEML7700_IT_800MS: Serial.println(\"800\"); break;\n}\n\nSerial.println(\"RAK12019 test\");\nWire.begin();\nif (!ltr.init())\n{\nSerial.println(\"Couldn't find LTR sensor!\");\nwhile (1)\ndelay(10);\n}\nSerial.println(\"Found LTR390 sensor!\");\n\n//set to LTR390_MODE_UVS,get ultraviolet light data.\nltr.setMode(LTR390_MODE_UVS);  // UVS Mode\n\nSerial.println(\"In UVS mode\");\n\nltr.setGain(LTR390_GAIN_3);\nSerial.print(\"Gain : \");\nswitch (ltr.getGain())\n{\ncase LTR390_GAIN_1:\nSerial.println(1);\nbreak;\ncase LTR390_GAIN_3:\nSerial.println(3);\nbreak;\ncase LTR390_GAIN_6:\nSerial.println(6);\nbreak;\ncase LTR390_GAIN_9:\nSerial.println(9);\nbreak;\ncase LTR390_GAIN_18:\nSerial.println(18);\nbreak;\ndefault:\nSerial.println(\"Failed to set gain\");\nbreak;\n}\nltr.setResolution(LTR390_RESOLUTION_16BIT);\nSerial.print(\"Integration Time (ms): \");\nswitch (ltr.getResolution())\n{\ncase LTR390_RESOLUTION_13BIT:\nSerial.println(13);\nbreak;\ncase LTR390_RESOLUTION_16BIT:\nSerial.println(16);\nbreak;\ncase LTR390_RESOLUTION_17BIT:\nSerial.println(17);\nbreak;\ncase LTR390_RESOLUTION_18BIT:\nSerial.println(18);\nbreak;\ncase LTR390_RESOLUTION_19BIT:\nSerial.println(19);\nbreak;\ncase LTR390_RESOLUTION_20BIT:\nSerial.println(20);\nbreak;\ndefault:\nSerial.println(\"Failed to set Integration Time\");\nbreak;\n}\n\nltr.setThresholds(100, 1000); //Set the interrupt output threshold range for lower and upper.\n\nltr.configInterrupt(true, LTR390_MODE_UVS);\n\n// For RAK14003\nmcp.begin_I2C(0x24);\n\n// Added for the functionality of RAK14003\n\nWire.begin();    // initialize I2C serial bus\n\n// Configuration of MCP23017 I/O ports\nmcp.pinMode(LED_0, OUTPUT);     // Red LED; Top most\nmcp.pinMode(LED_1, OUTPUT);     // Red LED\nmcp.pinMode(LED_2, OUTPUT);     // Orange LED\nmcp.pinMode(LED_3, OUTPUT);     // Orange LED\nmcp.pinMode(LED_4, OUTPUT);     // Orange LED\nmcp.pinMode(LED_5, OUTPUT);     // Green LED\nmcp.pinMode(LED_6, OUTPUT);     // Green LED\nmcp.pinMode(LED_7, OUTPUT);     // Green LED\nmcp.pinMode(LED_8, OUTPUT);     // Green LED\nmcp.pinMode(LED_9, OUTPUT);     // Green LED; Bottom\n\n// Initially Turn OFF all LEDs\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, HIGH);\n\n}\n\nvoid loop() {\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\n// Trial # 1\n// Data from RAK12019\nif (ltr.newDataAvailable())\n{\nuvi = ltr.getUVI();\nuvs = ltr.readUVS();\n}\n\n// Data from RAK12010\nlux = VMEL.readLux();\nwhite = VMEL.readWhite();\nraw_als = VMEL.readALS();\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\n\n// From RAK12019 module\nSerial.print(\"UVI: \");\nSerial.println(uvi);          // Uvi data from RAK12019\nSerial.print(\"UVS: \");\nSerial.println(uvs);            // Uvs data from RAK12019\n\n// From RAK12010\nSerial.print(\"Lux: \");\nSerial.print(lux);\nSerial.println(\" lx \");\nSerial.print(\"White: \");\nSerial.println(white);\nSerial.print(\"Raw ALS: \");\nSerial.println(raw_als);\n\n// Result of uvi to be displayed via RAK14003 module\nif (uvi <= 0.4)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, HIGH);\n}\n\nelse if (uvi > 0.5 && uvi <= 1)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 1.5 && uvi <= 2)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 2.5 && uvi <= 3)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 3.5 && uvi <= 4)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 4.5 && uvi <= 5)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 5.5 && uvi <= 6)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 6.5 && uvi <= 7)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 7.5 && uvi <= 8)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 8.5 && uvi <= 9.5)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, LOW);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi >= 10)\n{\nmcp.digitalWrite(LED_0, LOW);\nmcp.digitalWrite(LED_1, LOW);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\ndelay(10000);\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void) {\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void) {\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data) {\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class) {\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void) {\nif (lmh_join_status_get() != LMH_SET) {\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\ndata = \" Uvi Data: \" + String(uvi) + \" Uvs Data: \" + String(uvs) + \" Lux Data: \" + String(lux) + \" lx \" ;\n\nSerial.println(data);\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\nuint16_t uvi_data = uvi;            // Uvi data from RAK12019\nuint32_t uvs_data = uvs;            // Uvs data from RAK12019\nuint32_t lux_data = lux;            // Lux data from RAK12010\n\nm_lora_app_data.buffer[i++] = 0x01;  // byte[0]\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\n// Data from RAK12019 module\nm_lora_app_data.buffer[i++] = (uint8_t)((uvi_data & 0x0000FF00) >> 8);     // byte[1]\nm_lora_app_data.buffer[i++] = (uint8_t)(uvi_data & 0x000000FF);            // byte[2]\n\n// Data from RAK12019 module\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0xFF000000) >> 24);    // byte[3]\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0x00FF0000) >> 16);    // byte[4]\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0x0000FF00) >> 8);     // byte[5]\nm_lora_app_data.buffer[i++] = (uint8_t)(uvs_data & 0x000000FF);            // byte[6]\n\n// Data from RAK12010 module\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0xFF000000) >> 24);    // byte[7]\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0x00FF0000) >> 16);    // byte[8]\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0x0000FF00) >> 8);     // byte[9]\nm_lora_app_data.buffer[i++] = (uint8_t)(lux_data & 0x000000FF);            // byte[10]\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS) {\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n} else {\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xE9, 0x0D, 0x28, 0x1D, 0x92, 0x3D, 0xE4, 0x9F, 0xD9, 0xF7, 0xE0, 0x5F, 0x39, 0x10, 0x55, 0x71 };\n\n```  \n> **Image:** OTAA device successfully registered to TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "f61553e43e5035dca0712aebba3e3e95", "product_family": "wisblock", "product_id": "kit6-light-and-color", "category": "How-To", "title": "WisBlock IoT Education Kit - Light & Color Quick Start Guide > WisBlock IoT Education Kit - Light & Color Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock IoT Education Kit - Light & Color using TTN and Qubitro > UV Index & UV Intensity Monitoring LoRaWAN Application > LoRaWAN Code for UV Index & UV Intensity Monitoring > Programming UV Index & UV Intensity Monitoring Device with Arduino IDE [CODE]", "content": "<details>\n<summary> Click to view the example </summary>  \n```c\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h>  //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>", "keywords": ["Arduino IDE", "RAK4631", "UV Index", "UV Intensity", "LoRaWAN", "SX126x-Arduino"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **UV Index & UV Intensity Monitoring** device. Just copy the code below for **UV Index & UV Intensity Monitoring LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the example </summary>  \n```c\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h>  //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n#include \"UVlight_LTR390.h\"                // http://librarymanager/All#RAK12019_LTR390\nUVlight_LTR390 ltr = UVlight_LTR390();\n\n#include \"Light_VEML7700.h\"                // http://librarymanager/All#Light_veml7700\nLight_VEML7700 VMEL = Light_VEML7700();\n\nuint16_t uvi;\nuint32_t uvs;\nuint32_t lux;\nuint32_t white;\nuint32_t raw_als;\n\n#include <Adafruit_MCP23X17.h>  //http://librarymanager/All#Adafruit_MCP23017\nAdafruit_MCP23X17 mcp;\n\n// Added definitions for the functionality of RAK14003\nconst uint8_t LED_0 = 0;      // PA0 (17) of MCP23017\nconst uint8_t LED_1 = 1;      // PA1 (18) of MCP23017\nconst uint8_t LED_2 = 2;      // PA2 (19) of MCP23017\nconst uint8_t LED_3 = 3;      // PA3 (20) of MCP23017\nconst uint8_t LED_4 = 4;      // PA4 (21) of MCP23017\nconst uint8_t LED_5 = 5;      // PA5 (22) of MCP23017\nconst uint8_t LED_6 = 6;      // PA6 (23) of MCP23017\nconst uint8_t LED_7 = 7;      // PA7 (24) of MCP23017\nconst uint8_t LED_8 = 8;      // PB0 (25) of MCP23017\nconst uint8_t LED_9 = 9;      // PB1 (26) of MCP23017\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define RAK4631_BOARD true\n#else\n#define RAK4631_BOARD false\n#endif\n\nbool doOTAA = true;                                               // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                                       /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                                     /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5                               /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                                        /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;                           /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;                 /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                              /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = { LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF };\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = { BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler };\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xE9, 0x0D, 0x28, 0x1D, 0x92, 0x3D, 0xE4, 0x9F, 0xD9, 0xF7, 0xE0, 0x5F, 0x39, 0x10, 0x55, 0x71 };\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };\nuint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                                            /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];               //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = { m_lora_app_data_buffer, 0, 0, 0, 0 };  //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {\n\n// Initialize Serial for debug output\npinMode(LED_BLUE, OUTPUT);\ndigitalWrite(LED_BLUE, HIGH);\n\n// Sensor Power Switch\npinMode(WB_IO2, OUTPUT);\ndigitalWrite(WB_IO2, HIGH);\n\n// Reset RAK14003 module\npinMode(WB_IO4, OUTPUT);\ndigitalWrite(WB_IO4, HIGH);\ndelay(10);\ndigitalWrite(WB_IO4, LOW);\ndelay(10);\ndigitalWrite(WB_IO4, HIGH);\ndelay(10);\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial) {\nif ((millis() - timeout) < 5000) {\ndelay(100);\n} else {\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA) {\nSerial.println(\"Type: OTAA\");\n} else {\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion) {\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA) {\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n} else {\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0) {\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"================================\");\nSerial.println(\"RAK12019 + RAK12010 LoRaWAN Code\");\nSerial.println(\"================================\");\n\nif (!VMEL.begin())\n{\nSerial.println(\"Sensor not found\");\nwhile (1);\n}\n\nVMEL.setGain(VEML7700_GAIN_1);\nVMEL.setIntegrationTime(VEML7700_IT_800MS);\n\nSerial.print(F(\"Gain: \"));\nswitch (VMEL.getGain())\n{\ncase VEML7700_GAIN_1: Serial.println(\"1\"); break;\ncase VEML7700_GAIN_2: Serial.println(\"2\"); break;\ncase VEML7700_GAIN_1_4: Serial.println(\"1/4\"); break;\ncase VEML7700_GAIN_1_8: Serial.println(\"1/8\"); break;\n}\n\nSerial.print(F(\"Integration Time (ms): \"));\nswitch (VMEL.getIntegrationTime())\n{\ncase VEML7700_IT_25MS: Serial.println(\"25\"); break;\ncase VEML7700_IT_50MS: Serial.println(\"50\"); break;\ncase VEML7700_IT_100MS: Serial.println(\"100\"); break;\ncase VEML7700_IT_200MS: Serial.println(\"200\"); break;\ncase VEML7700_IT_400MS: Serial.println(\"400\"); break;\ncase VEML7700_IT_800MS: Serial.println(\"800\"); break;\n}\n\nSerial.println(\"RAK12019 test\");\nWire.begin();\nif (!ltr.init())\n{\nSerial.println(\"Couldn't find LTR sensor!\");\nwhile (1)\ndelay(10);\n}\nSerial.println(\"Found LTR390 sensor!\");\n\n//set to LTR390_MODE_UVS,get ultraviolet light data.\nltr.setMode(LTR390_MODE_UVS);  // UVS Mode\n\nSerial.println(\"In UVS mode\");\n\nltr.setGain(LTR390_GAIN_3);\nSerial.print(\"Gain : \");\nswitch (ltr.getGain())\n{\ncase LTR390_GAIN_1:\nSerial.println(1);\nbreak;\ncase LTR390_GAIN_3:\nSerial.println(3);\nbreak;\ncase LTR390_GAIN_6:\nSerial.println(6);\nbreak;\ncase LTR390_GAIN_9:\nSerial.println(9);\nbreak;\ncase LTR390_GAIN_18:\nSerial.println(18);\nbreak;\ndefault:\nSerial.println(\"Failed to set gain\");\nbreak;\n}\nltr.setResolution(LTR390_RESOLUTION_16BIT);\nSerial.print(\"Integration Time (ms): \");\nswitch (ltr.getResolution())\n{\ncase LTR390_RESOLUTION_13BIT:\nSerial.println(13);\nbreak;\ncase LTR390_RESOLUTION_16BIT:\nSerial.println(16);\nbreak;\ncase LTR390_RESOLUTION_17BIT:\nSerial.println(17);\nbreak;\ncase LTR390_RESOLUTION_18BIT:\nSerial.println(18);\nbreak;\ncase LTR390_RESOLUTION_19BIT:\nSerial.println(19);\nbreak;\ncase LTR390_RESOLUTION_20BIT:\nSerial.println(20);\nbreak;\ndefault:\nSerial.println(\"Failed to set Integration Time\");\nbreak;\n}\n\nltr.setThresholds(100, 1000); //Set the interrupt output threshold range for lower and upper.\n\nltr.configInterrupt(true, LTR390_MODE_UVS);\n\n// For RAK14003\nmcp.begin_I2C(0x24);\n\n// Added for the functionality of RAK14003\n\nWire.begin();    // initialize I2C serial bus\n\n// Configuration of MCP23017 I/O ports\nmcp.pinMode(LED_0, OUTPUT);     // Red LED; Top most\nmcp.pinMode(LED_1, OUTPUT);     // Red LED\nmcp.pinMode(LED_2, OUTPUT);     // Orange LED\nmcp.pinMode(LED_3, OUTPUT);     // Orange LED\nmcp.pinMode(LED_4, OUTPUT);     // Orange LED\nmcp.pinMode(LED_5, OUTPUT);     // Green LED\nmcp.pinMode(LED_6, OUTPUT);     // Green LED\nmcp.pinMode(LED_7, OUTPUT);     // Green LED\nmcp.pinMode(LED_8, OUTPUT);     // Green LED\nmcp.pinMode(LED_9, OUTPUT);     // Green LED; Bottom\n\n// Initially Turn OFF all LEDs\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, HIGH);\n\n}\n\nvoid loop() {\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\n// Trial # 1\n// Data from RAK12019\nif (ltr.newDataAvailable())\n{\nuvi = ltr.getUVI();\nuvs = ltr.readUVS();\n}\n\n// Data from RAK12010\nlux = VMEL.readLux();\nwhite = VMEL.readWhite();\nraw_als = VMEL.readALS();\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\n\n// From RAK12019 module\nSerial.print(\"UVI: \");\nSerial.println(uvi);          // Uvi data from RAK12019\nSerial.print(\"UVS: \");\nSerial.println(uvs);            // Uvs data from RAK12019\n\n// From RAK12010\nSerial.print(\"Lux: \");\nSerial.print(lux);\nSerial.println(\" lx \");\nSerial.print(\"White: \");\nSerial.println(white);\nSerial.print(\"Raw ALS: \");\nSerial.println(raw_als);\n\n// Result of uvi to be displayed via RAK14003 module\nif (uvi <= 0.4)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, HIGH);\n}\n\nelse if (uvi > 0.5 && uvi <= 1)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 1.5 && uvi <= 2)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 2.5 && uvi <= 3)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 3.5 && uvi <= 4)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 4.5 && uvi <= 5)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 5.5 && uvi <= 6)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 6.5 && uvi <= 7)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 7.5 && uvi <= 8)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 8.5 && uvi <= 9.5)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, LOW);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi >= 10)\n{\nmcp.digitalWrite(LED_0, LOW);\nmcp.digitalWrite(LED_1, LOW);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\ndelay(10000);\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void) {\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void) {\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data) {\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class) {\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void) {\nif (lmh_join_status_get() != LMH_SET) {\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\ndata = \" Uvi Data: \" + String(uvi) + \" Uvs Data: \" + String(uvs) + \" Lux Data: \" + String(lux) + \" lx \" ;\n\nSerial.println(data);\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\nuint16_t uvi_data = uvi;            // Uvi data from RAK12019\nuint32_t uvs_data = uvs;            // Uvs data from RAK12019\nuint32_t lux_data = lux;            // Lux data from RAK12010\n\nm_lora_app_data.buffer[i++] = 0x01;  // byte[0]\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\n// Data from RAK12019 module\nm_lora_app_data.buffer[i++] = (uint8_t)((uvi_data & 0x0000FF00) >> 8);     // byte[1]\nm_lora_app_data.buffer[i++] = (uint8_t)(uvi_data & 0x000000FF);            // byte[2]\n\n// Data from RAK12019 module\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0xFF000000) >> 24);    // byte[3]\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0x00FF0000) >> 16);    // byte[4]\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0x0000FF00) >> 8);     // byte[5]\nm_lora_app_data.buffer[i++] = (uint8_t)(uvs_data & 0x000000FF);            // byte[6]\n\n// Data from RAK12010 module\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0xFF000000) >> 24);    // byte[7]\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0x00FF0000) >> 16);    // byte[8]\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0x0000FF00) >> 8);     // byte[9]\nm_lora_app_data.buffer[i++] = (uint8_t)(lux_data & 0x000000FF);            // byte[10]\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS) {\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n} else {\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xE9, 0x0D, 0x28, 0x1D, 0x92, 0x3D, 0xE4, 0x9F, 0xD9, 0xF7, 0xE0, 0x5F, 0x39, 0x10, 0x55, 0x71 };\n\n```  \n> **Image:** OTAA device successfully registered to TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "655d442d36dac3b52b51914e32392357", "product_family": "wisblock", "product_id": "kit6-light-and-color", "category": "How-To", "title": "WisBlock IoT Education Kit - Light & Color Quick Start Guide > WisBlock IoT Education Kit - Light & Color Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock IoT Education Kit - Light & Color using TTN and Qubitro > UV Index & UV Intensity Monitoring LoRaWAN Application > LoRaWAN Code for UV Index & UV Intensity Monitoring > Programming UV Index & UV Intensity Monitoring Device with Arduino IDE [CODE]", "content": "#include \"UVlight_LTR390.h\"                // http://librarymanager/All#RAK12019_LTR390\nUVlight_LTR390 ltr = UVlight_LTR390();\n\n#include \"Light_VEML7700.h\"                // http://librarymanager/All#Light_veml7700\nLight_VEML7700 VMEL = Light_VEML7700();\n\nuint16_t uvi;\nuint32_t uvs;\nuint32_t lux;\nuint32_t white;\nuint32_t raw_als;\n\n#include <Adafruit_MCP23X17.h>  //http://librarymanager/All#Adafruit_MCP23017\nAdafruit_MCP23X17 mcp;", "keywords": ["Arduino IDE", "RAK4631", "UV Index", "UV Intensity", "LoRaWAN", "SX126x-Arduino"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **UV Index & UV Intensity Monitoring** device. Just copy the code below for **UV Index & UV Intensity Monitoring LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the example </summary>  \n```c\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h>  //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n#include \"UVlight_LTR390.h\"                // http://librarymanager/All#RAK12019_LTR390\nUVlight_LTR390 ltr = UVlight_LTR390();\n\n#include \"Light_VEML7700.h\"                // http://librarymanager/All#Light_veml7700\nLight_VEML7700 VMEL = Light_VEML7700();\n\nuint16_t uvi;\nuint32_t uvs;\nuint32_t lux;\nuint32_t white;\nuint32_t raw_als;\n\n#include <Adafruit_MCP23X17.h>  //http://librarymanager/All#Adafruit_MCP23017\nAdafruit_MCP23X17 mcp;\n\n// Added definitions for the functionality of RAK14003\nconst uint8_t LED_0 = 0;      // PA0 (17) of MCP23017\nconst uint8_t LED_1 = 1;      // PA1 (18) of MCP23017\nconst uint8_t LED_2 = 2;      // PA2 (19) of MCP23017\nconst uint8_t LED_3 = 3;      // PA3 (20) of MCP23017\nconst uint8_t LED_4 = 4;      // PA4 (21) of MCP23017\nconst uint8_t LED_5 = 5;      // PA5 (22) of MCP23017\nconst uint8_t LED_6 = 6;      // PA6 (23) of MCP23017\nconst uint8_t LED_7 = 7;      // PA7 (24) of MCP23017\nconst uint8_t LED_8 = 8;      // PB0 (25) of MCP23017\nconst uint8_t LED_9 = 9;      // PB1 (26) of MCP23017\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define RAK4631_BOARD true\n#else\n#define RAK4631_BOARD false\n#endif\n\nbool doOTAA = true;                                               // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                                       /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                                     /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5                               /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                                        /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;                           /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;                 /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                              /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = { LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF };\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = { BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler };\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xE9, 0x0D, 0x28, 0x1D, 0x92, 0x3D, 0xE4, 0x9F, 0xD9, 0xF7, 0xE0, 0x5F, 0x39, 0x10, 0x55, 0x71 };\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };\nuint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                                            /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];               //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = { m_lora_app_data_buffer, 0, 0, 0, 0 };  //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {\n\n// Initialize Serial for debug output\npinMode(LED_BLUE, OUTPUT);\ndigitalWrite(LED_BLUE, HIGH);\n\n// Sensor Power Switch\npinMode(WB_IO2, OUTPUT);\ndigitalWrite(WB_IO2, HIGH);\n\n// Reset RAK14003 module\npinMode(WB_IO4, OUTPUT);\ndigitalWrite(WB_IO4, HIGH);\ndelay(10);\ndigitalWrite(WB_IO4, LOW);\ndelay(10);\ndigitalWrite(WB_IO4, HIGH);\ndelay(10);\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial) {\nif ((millis() - timeout) < 5000) {\ndelay(100);\n} else {\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA) {\nSerial.println(\"Type: OTAA\");\n} else {\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion) {\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA) {\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n} else {\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0) {\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"================================\");\nSerial.println(\"RAK12019 + RAK12010 LoRaWAN Code\");\nSerial.println(\"================================\");\n\nif (!VMEL.begin())\n{\nSerial.println(\"Sensor not found\");\nwhile (1);\n}\n\nVMEL.setGain(VEML7700_GAIN_1);\nVMEL.setIntegrationTime(VEML7700_IT_800MS);\n\nSerial.print(F(\"Gain: \"));\nswitch (VMEL.getGain())\n{\ncase VEML7700_GAIN_1: Serial.println(\"1\"); break;\ncase VEML7700_GAIN_2: Serial.println(\"2\"); break;\ncase VEML7700_GAIN_1_4: Serial.println(\"1/4\"); break;\ncase VEML7700_GAIN_1_8: Serial.println(\"1/8\"); break;\n}\n\nSerial.print(F(\"Integration Time (ms): \"));\nswitch (VMEL.getIntegrationTime())\n{\ncase VEML7700_IT_25MS: Serial.println(\"25\"); break;\ncase VEML7700_IT_50MS: Serial.println(\"50\"); break;\ncase VEML7700_IT_100MS: Serial.println(\"100\"); break;\ncase VEML7700_IT_200MS: Serial.println(\"200\"); break;\ncase VEML7700_IT_400MS: Serial.println(\"400\"); break;\ncase VEML7700_IT_800MS: Serial.println(\"800\"); break;\n}\n\nSerial.println(\"RAK12019 test\");\nWire.begin();\nif (!ltr.init())\n{\nSerial.println(\"Couldn't find LTR sensor!\");\nwhile (1)\ndelay(10);\n}\nSerial.println(\"Found LTR390 sensor!\");\n\n//set to LTR390_MODE_UVS,get ultraviolet light data.\nltr.setMode(LTR390_MODE_UVS);  // UVS Mode\n\nSerial.println(\"In UVS mode\");\n\nltr.setGain(LTR390_GAIN_3);\nSerial.print(\"Gain : \");\nswitch (ltr.getGain())\n{\ncase LTR390_GAIN_1:\nSerial.println(1);\nbreak;\ncase LTR390_GAIN_3:\nSerial.println(3);\nbreak;\ncase LTR390_GAIN_6:\nSerial.println(6);\nbreak;\ncase LTR390_GAIN_9:\nSerial.println(9);\nbreak;\ncase LTR390_GAIN_18:\nSerial.println(18);\nbreak;\ndefault:\nSerial.println(\"Failed to set gain\");\nbreak;\n}\nltr.setResolution(LTR390_RESOLUTION_16BIT);\nSerial.print(\"Integration Time (ms): \");\nswitch (ltr.getResolution())\n{\ncase LTR390_RESOLUTION_13BIT:\nSerial.println(13);\nbreak;\ncase LTR390_RESOLUTION_16BIT:\nSerial.println(16);\nbreak;\ncase LTR390_RESOLUTION_17BIT:\nSerial.println(17);\nbreak;\ncase LTR390_RESOLUTION_18BIT:\nSerial.println(18);\nbreak;\ncase LTR390_RESOLUTION_19BIT:\nSerial.println(19);\nbreak;\ncase LTR390_RESOLUTION_20BIT:\nSerial.println(20);\nbreak;\ndefault:\nSerial.println(\"Failed to set Integration Time\");\nbreak;\n}\n\nltr.setThresholds(100, 1000); //Set the interrupt output threshold range for lower and upper.\n\nltr.configInterrupt(true, LTR390_MODE_UVS);\n\n// For RAK14003\nmcp.begin_I2C(0x24);\n\n// Added for the functionality of RAK14003\n\nWire.begin();    // initialize I2C serial bus\n\n// Configuration of MCP23017 I/O ports\nmcp.pinMode(LED_0, OUTPUT);     // Red LED; Top most\nmcp.pinMode(LED_1, OUTPUT);     // Red LED\nmcp.pinMode(LED_2, OUTPUT);     // Orange LED\nmcp.pinMode(LED_3, OUTPUT);     // Orange LED\nmcp.pinMode(LED_4, OUTPUT);     // Orange LED\nmcp.pinMode(LED_5, OUTPUT);     // Green LED\nmcp.pinMode(LED_6, OUTPUT);     // Green LED\nmcp.pinMode(LED_7, OUTPUT);     // Green LED\nmcp.pinMode(LED_8, OUTPUT);     // Green LED\nmcp.pinMode(LED_9, OUTPUT);     // Green LED; Bottom\n\n// Initially Turn OFF all LEDs\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, HIGH);\n\n}\n\nvoid loop() {\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\n// Trial # 1\n// Data from RAK12019\nif (ltr.newDataAvailable())\n{\nuvi = ltr.getUVI();\nuvs = ltr.readUVS();\n}\n\n// Data from RAK12010\nlux = VMEL.readLux();\nwhite = VMEL.readWhite();\nraw_als = VMEL.readALS();\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\n\n// From RAK12019 module\nSerial.print(\"UVI: \");\nSerial.println(uvi);          // Uvi data from RAK12019\nSerial.print(\"UVS: \");\nSerial.println(uvs);            // Uvs data from RAK12019\n\n// From RAK12010\nSerial.print(\"Lux: \");\nSerial.print(lux);\nSerial.println(\" lx \");\nSerial.print(\"White: \");\nSerial.println(white);\nSerial.print(\"Raw ALS: \");\nSerial.println(raw_als);\n\n// Result of uvi to be displayed via RAK14003 module\nif (uvi <= 0.4)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, HIGH);\n}\n\nelse if (uvi > 0.5 && uvi <= 1)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 1.5 && uvi <= 2)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 2.5 && uvi <= 3)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 3.5 && uvi <= 4)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 4.5 && uvi <= 5)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 5.5 && uvi <= 6)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 6.5 && uvi <= 7)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 7.5 && uvi <= 8)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 8.5 && uvi <= 9.5)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, LOW);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi >= 10)\n{\nmcp.digitalWrite(LED_0, LOW);\nmcp.digitalWrite(LED_1, LOW);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\ndelay(10000);\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void) {\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void) {\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data) {\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class) {\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void) {\nif (lmh_join_status_get() != LMH_SET) {\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\ndata = \" Uvi Data: \" + String(uvi) + \" Uvs Data: \" + String(uvs) + \" Lux Data: \" + String(lux) + \" lx \" ;\n\nSerial.println(data);\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\nuint16_t uvi_data = uvi;            // Uvi data from RAK12019\nuint32_t uvs_data = uvs;            // Uvs data from RAK12019\nuint32_t lux_data = lux;            // Lux data from RAK12010\n\nm_lora_app_data.buffer[i++] = 0x01;  // byte[0]\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\n// Data from RAK12019 module\nm_lora_app_data.buffer[i++] = (uint8_t)((uvi_data & 0x0000FF00) >> 8);     // byte[1]\nm_lora_app_data.buffer[i++] = (uint8_t)(uvi_data & 0x000000FF);            // byte[2]\n\n// Data from RAK12019 module\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0xFF000000) >> 24);    // byte[3]\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0x00FF0000) >> 16);    // byte[4]\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0x0000FF00) >> 8);     // byte[5]\nm_lora_app_data.buffer[i++] = (uint8_t)(uvs_data & 0x000000FF);            // byte[6]\n\n// Data from RAK12010 module\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0xFF000000) >> 24);    // byte[7]\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0x00FF0000) >> 16);    // byte[8]\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0x0000FF00) >> 8);     // byte[9]\nm_lora_app_data.buffer[i++] = (uint8_t)(lux_data & 0x000000FF);            // byte[10]\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS) {\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n} else {\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xE9, 0x0D, 0x28, 0x1D, 0x92, 0x3D, 0xE4, 0x9F, 0xD9, 0xF7, 0xE0, 0x5F, 0x39, 0x10, 0x55, 0x71 };\n\n```  \n> **Image:** OTAA device successfully registered to TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "c063efdddd74294a844bc4836f58ab18", "product_family": "wisblock", "product_id": "kit6-light-and-color", "category": "How-To", "title": "WisBlock IoT Education Kit - Light & Color Quick Start Guide > WisBlock IoT Education Kit - Light & Color Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock IoT Education Kit - Light & Color using TTN and Qubitro > UV Index & UV Intensity Monitoring LoRaWAN Application > LoRaWAN Code for UV Index & UV Intensity Monitoring > Programming UV Index & UV Intensity Monitoring Device with Arduino IDE [CODE]", "content": "// Added definitions for the functionality of RAK14003\nconst uint8_t LED_0 = 0;      // PA0 (17) of MCP23017\nconst uint8_t LED_1 = 1;      // PA1 (18) of MCP23017\nconst uint8_t LED_2 = 2;      // PA2 (19) of MCP23017\nconst uint8_t LED_3 = 3;      // PA3 (20) of MCP23017\nconst uint8_t LED_4 = 4;      // PA4 (21) of MCP23017\nconst uint8_t LED_5 = 5;      // PA5 (22) of MCP23017\nconst uint8_t LED_6 = 6;      // PA6 (23) of MCP23017\nconst uint8_t LED_7 = 7;      // PA7 (24) of MCP23017", "keywords": ["Arduino IDE", "RAK4631", "UV Index", "UV Intensity", "LoRaWAN", "SX126x-Arduino"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **UV Index & UV Intensity Monitoring** device. Just copy the code below for **UV Index & UV Intensity Monitoring LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the example </summary>  \n```c\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h>  //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n#include \"UVlight_LTR390.h\"                // http://librarymanager/All#RAK12019_LTR390\nUVlight_LTR390 ltr = UVlight_LTR390();\n\n#include \"Light_VEML7700.h\"                // http://librarymanager/All#Light_veml7700\nLight_VEML7700 VMEL = Light_VEML7700();\n\nuint16_t uvi;\nuint32_t uvs;\nuint32_t lux;\nuint32_t white;\nuint32_t raw_als;\n\n#include <Adafruit_MCP23X17.h>  //http://librarymanager/All#Adafruit_MCP23017\nAdafruit_MCP23X17 mcp;\n\n// Added definitions for the functionality of RAK14003\nconst uint8_t LED_0 = 0;      // PA0 (17) of MCP23017\nconst uint8_t LED_1 = 1;      // PA1 (18) of MCP23017\nconst uint8_t LED_2 = 2;      // PA2 (19) of MCP23017\nconst uint8_t LED_3 = 3;      // PA3 (20) of MCP23017\nconst uint8_t LED_4 = 4;      // PA4 (21) of MCP23017\nconst uint8_t LED_5 = 5;      // PA5 (22) of MCP23017\nconst uint8_t LED_6 = 6;      // PA6 (23) of MCP23017\nconst uint8_t LED_7 = 7;      // PA7 (24) of MCP23017\nconst uint8_t LED_8 = 8;      // PB0 (25) of MCP23017\nconst uint8_t LED_9 = 9;      // PB1 (26) of MCP23017\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define RAK4631_BOARD true\n#else\n#define RAK4631_BOARD false\n#endif\n\nbool doOTAA = true;                                               // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                                       /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                                     /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5                               /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                                        /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;                           /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;                 /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                              /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = { LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF };\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = { BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler };\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xE9, 0x0D, 0x28, 0x1D, 0x92, 0x3D, 0xE4, 0x9F, 0xD9, 0xF7, 0xE0, 0x5F, 0x39, 0x10, 0x55, 0x71 };\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };\nuint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                                            /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];               //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = { m_lora_app_data_buffer, 0, 0, 0, 0 };  //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {\n\n// Initialize Serial for debug output\npinMode(LED_BLUE, OUTPUT);\ndigitalWrite(LED_BLUE, HIGH);\n\n// Sensor Power Switch\npinMode(WB_IO2, OUTPUT);\ndigitalWrite(WB_IO2, HIGH);\n\n// Reset RAK14003 module\npinMode(WB_IO4, OUTPUT);\ndigitalWrite(WB_IO4, HIGH);\ndelay(10);\ndigitalWrite(WB_IO4, LOW);\ndelay(10);\ndigitalWrite(WB_IO4, HIGH);\ndelay(10);\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial) {\nif ((millis() - timeout) < 5000) {\ndelay(100);\n} else {\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA) {\nSerial.println(\"Type: OTAA\");\n} else {\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion) {\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA) {\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n} else {\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0) {\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"================================\");\nSerial.println(\"RAK12019 + RAK12010 LoRaWAN Code\");\nSerial.println(\"================================\");\n\nif (!VMEL.begin())\n{\nSerial.println(\"Sensor not found\");\nwhile (1);\n}\n\nVMEL.setGain(VEML7700_GAIN_1);\nVMEL.setIntegrationTime(VEML7700_IT_800MS);\n\nSerial.print(F(\"Gain: \"));\nswitch (VMEL.getGain())\n{\ncase VEML7700_GAIN_1: Serial.println(\"1\"); break;\ncase VEML7700_GAIN_2: Serial.println(\"2\"); break;\ncase VEML7700_GAIN_1_4: Serial.println(\"1/4\"); break;\ncase VEML7700_GAIN_1_8: Serial.println(\"1/8\"); break;\n}\n\nSerial.print(F(\"Integration Time (ms): \"));\nswitch (VMEL.getIntegrationTime())\n{\ncase VEML7700_IT_25MS: Serial.println(\"25\"); break;\ncase VEML7700_IT_50MS: Serial.println(\"50\"); break;\ncase VEML7700_IT_100MS: Serial.println(\"100\"); break;\ncase VEML7700_IT_200MS: Serial.println(\"200\"); break;\ncase VEML7700_IT_400MS: Serial.println(\"400\"); break;\ncase VEML7700_IT_800MS: Serial.println(\"800\"); break;\n}\n\nSerial.println(\"RAK12019 test\");\nWire.begin();\nif (!ltr.init())\n{\nSerial.println(\"Couldn't find LTR sensor!\");\nwhile (1)\ndelay(10);\n}\nSerial.println(\"Found LTR390 sensor!\");\n\n//set to LTR390_MODE_UVS,get ultraviolet light data.\nltr.setMode(LTR390_MODE_UVS);  // UVS Mode\n\nSerial.println(\"In UVS mode\");\n\nltr.setGain(LTR390_GAIN_3);\nSerial.print(\"Gain : \");\nswitch (ltr.getGain())\n{\ncase LTR390_GAIN_1:\nSerial.println(1);\nbreak;\ncase LTR390_GAIN_3:\nSerial.println(3);\nbreak;\ncase LTR390_GAIN_6:\nSerial.println(6);\nbreak;\ncase LTR390_GAIN_9:\nSerial.println(9);\nbreak;\ncase LTR390_GAIN_18:\nSerial.println(18);\nbreak;\ndefault:\nSerial.println(\"Failed to set gain\");\nbreak;\n}\nltr.setResolution(LTR390_RESOLUTION_16BIT);\nSerial.print(\"Integration Time (ms): \");\nswitch (ltr.getResolution())\n{\ncase LTR390_RESOLUTION_13BIT:\nSerial.println(13);\nbreak;\ncase LTR390_RESOLUTION_16BIT:\nSerial.println(16);\nbreak;\ncase LTR390_RESOLUTION_17BIT:\nSerial.println(17);\nbreak;\ncase LTR390_RESOLUTION_18BIT:\nSerial.println(18);\nbreak;\ncase LTR390_RESOLUTION_19BIT:\nSerial.println(19);\nbreak;\ncase LTR390_RESOLUTION_20BIT:\nSerial.println(20);\nbreak;\ndefault:\nSerial.println(\"Failed to set Integration Time\");\nbreak;\n}\n\nltr.setThresholds(100, 1000); //Set the interrupt output threshold range for lower and upper.\n\nltr.configInterrupt(true, LTR390_MODE_UVS);\n\n// For RAK14003\nmcp.begin_I2C(0x24);\n\n// Added for the functionality of RAK14003\n\nWire.begin();    // initialize I2C serial bus\n\n// Configuration of MCP23017 I/O ports\nmcp.pinMode(LED_0, OUTPUT);     // Red LED; Top most\nmcp.pinMode(LED_1, OUTPUT);     // Red LED\nmcp.pinMode(LED_2, OUTPUT);     // Orange LED\nmcp.pinMode(LED_3, OUTPUT);     // Orange LED\nmcp.pinMode(LED_4, OUTPUT);     // Orange LED\nmcp.pinMode(LED_5, OUTPUT);     // Green LED\nmcp.pinMode(LED_6, OUTPUT);     // Green LED\nmcp.pinMode(LED_7, OUTPUT);     // Green LED\nmcp.pinMode(LED_8, OUTPUT);     // Green LED\nmcp.pinMode(LED_9, OUTPUT);     // Green LED; Bottom\n\n// Initially Turn OFF all LEDs\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, HIGH);\n\n}\n\nvoid loop() {\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\n// Trial # 1\n// Data from RAK12019\nif (ltr.newDataAvailable())\n{\nuvi = ltr.getUVI();\nuvs = ltr.readUVS();\n}\n\n// Data from RAK12010\nlux = VMEL.readLux();\nwhite = VMEL.readWhite();\nraw_als = VMEL.readALS();\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\n\n// From RAK12019 module\nSerial.print(\"UVI: \");\nSerial.println(uvi);          // Uvi data from RAK12019\nSerial.print(\"UVS: \");\nSerial.println(uvs);            // Uvs data from RAK12019\n\n// From RAK12010\nSerial.print(\"Lux: \");\nSerial.print(lux);\nSerial.println(\" lx \");\nSerial.print(\"White: \");\nSerial.println(white);\nSerial.print(\"Raw ALS: \");\nSerial.println(raw_als);\n\n// Result of uvi to be displayed via RAK14003 module\nif (uvi <= 0.4)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, HIGH);\n}\n\nelse if (uvi > 0.5 && uvi <= 1)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 1.5 && uvi <= 2)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 2.5 && uvi <= 3)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 3.5 && uvi <= 4)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 4.5 && uvi <= 5)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 5.5 && uvi <= 6)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 6.5 && uvi <= 7)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 7.5 && uvi <= 8)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 8.5 && uvi <= 9.5)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, LOW);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi >= 10)\n{\nmcp.digitalWrite(LED_0, LOW);\nmcp.digitalWrite(LED_1, LOW);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\ndelay(10000);\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void) {\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void) {\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data) {\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class) {\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void) {\nif (lmh_join_status_get() != LMH_SET) {\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\ndata = \" Uvi Data: \" + String(uvi) + \" Uvs Data: \" + String(uvs) + \" Lux Data: \" + String(lux) + \" lx \" ;\n\nSerial.println(data);\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\nuint16_t uvi_data = uvi;            // Uvi data from RAK12019\nuint32_t uvs_data = uvs;            // Uvs data from RAK12019\nuint32_t lux_data = lux;            // Lux data from RAK12010\n\nm_lora_app_data.buffer[i++] = 0x01;  // byte[0]\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\n// Data from RAK12019 module\nm_lora_app_data.buffer[i++] = (uint8_t)((uvi_data & 0x0000FF00) >> 8);     // byte[1]\nm_lora_app_data.buffer[i++] = (uint8_t)(uvi_data & 0x000000FF);            // byte[2]\n\n// Data from RAK12019 module\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0xFF000000) >> 24);    // byte[3]\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0x00FF0000) >> 16);    // byte[4]\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0x0000FF00) >> 8);     // byte[5]\nm_lora_app_data.buffer[i++] = (uint8_t)(uvs_data & 0x000000FF);            // byte[6]\n\n// Data from RAK12010 module\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0xFF000000) >> 24);    // byte[7]\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0x00FF0000) >> 16);    // byte[8]\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0x0000FF00) >> 8);     // byte[9]\nm_lora_app_data.buffer[i++] = (uint8_t)(lux_data & 0x000000FF);            // byte[10]\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS) {\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n} else {\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xE9, 0x0D, 0x28, 0x1D, 0x92, 0x3D, 0xE4, 0x9F, 0xD9, 0xF7, 0xE0, 0x5F, 0x39, 0x10, 0x55, 0x71 };\n\n```  \n> **Image:** OTAA device successfully registered to TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "6120487b12183eb6a1922ee05ff32608", "product_family": "wisblock", "product_id": "kit6-light-and-color", "category": "How-To", "title": "WisBlock IoT Education Kit - Light & Color Quick Start Guide > WisBlock IoT Education Kit - Light & Color Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock IoT Education Kit - Light & Color using TTN and Qubitro > UV Index & UV Intensity Monitoring LoRaWAN Application > LoRaWAN Code for UV Index & UV Intensity Monitoring > Programming UV Index & UV Intensity Monitoring Device with Arduino IDE [CODE]", "content": "const uint8_t LED_7 = 7;      // PA7 (24) of MCP23017\nconst uint8_t LED_8 = 8;      // PB0 (25) of MCP23017\nconst uint8_t LED_9 = 9;      // PB1 (26) of MCP23017", "keywords": ["Arduino IDE", "RAK4631", "UV Index", "UV Intensity", "LoRaWAN", "SX126x-Arduino"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **UV Index & UV Intensity Monitoring** device. Just copy the code below for **UV Index & UV Intensity Monitoring LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the example </summary>  \n```c\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h>  //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n#include \"UVlight_LTR390.h\"                // http://librarymanager/All#RAK12019_LTR390\nUVlight_LTR390 ltr = UVlight_LTR390();\n\n#include \"Light_VEML7700.h\"                // http://librarymanager/All#Light_veml7700\nLight_VEML7700 VMEL = Light_VEML7700();\n\nuint16_t uvi;\nuint32_t uvs;\nuint32_t lux;\nuint32_t white;\nuint32_t raw_als;\n\n#include <Adafruit_MCP23X17.h>  //http://librarymanager/All#Adafruit_MCP23017\nAdafruit_MCP23X17 mcp;\n\n// Added definitions for the functionality of RAK14003\nconst uint8_t LED_0 = 0;      // PA0 (17) of MCP23017\nconst uint8_t LED_1 = 1;      // PA1 (18) of MCP23017\nconst uint8_t LED_2 = 2;      // PA2 (19) of MCP23017\nconst uint8_t LED_3 = 3;      // PA3 (20) of MCP23017\nconst uint8_t LED_4 = 4;      // PA4 (21) of MCP23017\nconst uint8_t LED_5 = 5;      // PA5 (22) of MCP23017\nconst uint8_t LED_6 = 6;      // PA6 (23) of MCP23017\nconst uint8_t LED_7 = 7;      // PA7 (24) of MCP23017\nconst uint8_t LED_8 = 8;      // PB0 (25) of MCP23017\nconst uint8_t LED_9 = 9;      // PB1 (26) of MCP23017\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define RAK4631_BOARD true\n#else\n#define RAK4631_BOARD false\n#endif\n\nbool doOTAA = true;                                               // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                                       /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                                     /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5                               /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                                        /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;                           /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;                 /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                              /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = { LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF };\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = { BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler };\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xE9, 0x0D, 0x28, 0x1D, 0x92, 0x3D, 0xE4, 0x9F, 0xD9, 0xF7, 0xE0, 0x5F, 0x39, 0x10, 0x55, 0x71 };\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };\nuint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                                            /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];               //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = { m_lora_app_data_buffer, 0, 0, 0, 0 };  //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {\n\n// Initialize Serial for debug output\npinMode(LED_BLUE, OUTPUT);\ndigitalWrite(LED_BLUE, HIGH);\n\n// Sensor Power Switch\npinMode(WB_IO2, OUTPUT);\ndigitalWrite(WB_IO2, HIGH);\n\n// Reset RAK14003 module\npinMode(WB_IO4, OUTPUT);\ndigitalWrite(WB_IO4, HIGH);\ndelay(10);\ndigitalWrite(WB_IO4, LOW);\ndelay(10);\ndigitalWrite(WB_IO4, HIGH);\ndelay(10);\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial) {\nif ((millis() - timeout) < 5000) {\ndelay(100);\n} else {\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA) {\nSerial.println(\"Type: OTAA\");\n} else {\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion) {\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA) {\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n} else {\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0) {\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"================================\");\nSerial.println(\"RAK12019 + RAK12010 LoRaWAN Code\");\nSerial.println(\"================================\");\n\nif (!VMEL.begin())\n{\nSerial.println(\"Sensor not found\");\nwhile (1);\n}\n\nVMEL.setGain(VEML7700_GAIN_1);\nVMEL.setIntegrationTime(VEML7700_IT_800MS);\n\nSerial.print(F(\"Gain: \"));\nswitch (VMEL.getGain())\n{\ncase VEML7700_GAIN_1: Serial.println(\"1\"); break;\ncase VEML7700_GAIN_2: Serial.println(\"2\"); break;\ncase VEML7700_GAIN_1_4: Serial.println(\"1/4\"); break;\ncase VEML7700_GAIN_1_8: Serial.println(\"1/8\"); break;\n}\n\nSerial.print(F(\"Integration Time (ms): \"));\nswitch (VMEL.getIntegrationTime())\n{\ncase VEML7700_IT_25MS: Serial.println(\"25\"); break;\ncase VEML7700_IT_50MS: Serial.println(\"50\"); break;\ncase VEML7700_IT_100MS: Serial.println(\"100\"); break;\ncase VEML7700_IT_200MS: Serial.println(\"200\"); break;\ncase VEML7700_IT_400MS: Serial.println(\"400\"); break;\ncase VEML7700_IT_800MS: Serial.println(\"800\"); break;\n}\n\nSerial.println(\"RAK12019 test\");\nWire.begin();\nif (!ltr.init())\n{\nSerial.println(\"Couldn't find LTR sensor!\");\nwhile (1)\ndelay(10);\n}\nSerial.println(\"Found LTR390 sensor!\");\n\n//set to LTR390_MODE_UVS,get ultraviolet light data.\nltr.setMode(LTR390_MODE_UVS);  // UVS Mode\n\nSerial.println(\"In UVS mode\");\n\nltr.setGain(LTR390_GAIN_3);\nSerial.print(\"Gain : \");\nswitch (ltr.getGain())\n{\ncase LTR390_GAIN_1:\nSerial.println(1);\nbreak;\ncase LTR390_GAIN_3:\nSerial.println(3);\nbreak;\ncase LTR390_GAIN_6:\nSerial.println(6);\nbreak;\ncase LTR390_GAIN_9:\nSerial.println(9);\nbreak;\ncase LTR390_GAIN_18:\nSerial.println(18);\nbreak;\ndefault:\nSerial.println(\"Failed to set gain\");\nbreak;\n}\nltr.setResolution(LTR390_RESOLUTION_16BIT);\nSerial.print(\"Integration Time (ms): \");\nswitch (ltr.getResolution())\n{\ncase LTR390_RESOLUTION_13BIT:\nSerial.println(13);\nbreak;\ncase LTR390_RESOLUTION_16BIT:\nSerial.println(16);\nbreak;\ncase LTR390_RESOLUTION_17BIT:\nSerial.println(17);\nbreak;\ncase LTR390_RESOLUTION_18BIT:\nSerial.println(18);\nbreak;\ncase LTR390_RESOLUTION_19BIT:\nSerial.println(19);\nbreak;\ncase LTR390_RESOLUTION_20BIT:\nSerial.println(20);\nbreak;\ndefault:\nSerial.println(\"Failed to set Integration Time\");\nbreak;\n}\n\nltr.setThresholds(100, 1000); //Set the interrupt output threshold range for lower and upper.\n\nltr.configInterrupt(true, LTR390_MODE_UVS);\n\n// For RAK14003\nmcp.begin_I2C(0x24);\n\n// Added for the functionality of RAK14003\n\nWire.begin();    // initialize I2C serial bus\n\n// Configuration of MCP23017 I/O ports\nmcp.pinMode(LED_0, OUTPUT);     // Red LED; Top most\nmcp.pinMode(LED_1, OUTPUT);     // Red LED\nmcp.pinMode(LED_2, OUTPUT);     // Orange LED\nmcp.pinMode(LED_3, OUTPUT);     // Orange LED\nmcp.pinMode(LED_4, OUTPUT);     // Orange LED\nmcp.pinMode(LED_5, OUTPUT);     // Green LED\nmcp.pinMode(LED_6, OUTPUT);     // Green LED\nmcp.pinMode(LED_7, OUTPUT);     // Green LED\nmcp.pinMode(LED_8, OUTPUT);     // Green LED\nmcp.pinMode(LED_9, OUTPUT);     // Green LED; Bottom\n\n// Initially Turn OFF all LEDs\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, HIGH);\n\n}\n\nvoid loop() {\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\n// Trial # 1\n// Data from RAK12019\nif (ltr.newDataAvailable())\n{\nuvi = ltr.getUVI();\nuvs = ltr.readUVS();\n}\n\n// Data from RAK12010\nlux = VMEL.readLux();\nwhite = VMEL.readWhite();\nraw_als = VMEL.readALS();\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\n\n// From RAK12019 module\nSerial.print(\"UVI: \");\nSerial.println(uvi);          // Uvi data from RAK12019\nSerial.print(\"UVS: \");\nSerial.println(uvs);            // Uvs data from RAK12019\n\n// From RAK12010\nSerial.print(\"Lux: \");\nSerial.print(lux);\nSerial.println(\" lx \");\nSerial.print(\"White: \");\nSerial.println(white);\nSerial.print(\"Raw ALS: \");\nSerial.println(raw_als);\n\n// Result of uvi to be displayed via RAK14003 module\nif (uvi <= 0.4)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, HIGH);\n}\n\nelse if (uvi > 0.5 && uvi <= 1)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 1.5 && uvi <= 2)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 2.5 && uvi <= 3)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 3.5 && uvi <= 4)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 4.5 && uvi <= 5)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 5.5 && uvi <= 6)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 6.5 && uvi <= 7)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 7.5 && uvi <= 8)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 8.5 && uvi <= 9.5)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, LOW);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi >= 10)\n{\nmcp.digitalWrite(LED_0, LOW);\nmcp.digitalWrite(LED_1, LOW);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\ndelay(10000);\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void) {\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void) {\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data) {\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class) {\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void) {\nif (lmh_join_status_get() != LMH_SET) {\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\ndata = \" Uvi Data: \" + String(uvi) + \" Uvs Data: \" + String(uvs) + \" Lux Data: \" + String(lux) + \" lx \" ;\n\nSerial.println(data);\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\nuint16_t uvi_data = uvi;            // Uvi data from RAK12019\nuint32_t uvs_data = uvs;            // Uvs data from RAK12019\nuint32_t lux_data = lux;            // Lux data from RAK12010\n\nm_lora_app_data.buffer[i++] = 0x01;  // byte[0]\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\n// Data from RAK12019 module\nm_lora_app_data.buffer[i++] = (uint8_t)((uvi_data & 0x0000FF00) >> 8);     // byte[1]\nm_lora_app_data.buffer[i++] = (uint8_t)(uvi_data & 0x000000FF);            // byte[2]\n\n// Data from RAK12019 module\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0xFF000000) >> 24);    // byte[3]\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0x00FF0000) >> 16);    // byte[4]\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0x0000FF00) >> 8);     // byte[5]\nm_lora_app_data.buffer[i++] = (uint8_t)(uvs_data & 0x000000FF);            // byte[6]\n\n// Data from RAK12010 module\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0xFF000000) >> 24);    // byte[7]\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0x00FF0000) >> 16);    // byte[8]\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0x0000FF00) >> 8);     // byte[9]\nm_lora_app_data.buffer[i++] = (uint8_t)(lux_data & 0x000000FF);            // byte[10]\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS) {\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n} else {\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xE9, 0x0D, 0x28, 0x1D, 0x92, 0x3D, 0xE4, 0x9F, 0xD9, 0xF7, 0xE0, 0x5F, 0x39, 0x10, 0x55, 0x71 };\n\n```  \n> **Image:** OTAA device successfully registered to TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "c1fb4d53154d489369d505b3559dbff7", "product_family": "wisblock", "product_id": "kit6-light-and-color", "category": "How-To", "title": "WisBlock IoT Education Kit - Light & Color Quick Start Guide > WisBlock IoT Education Kit - Light & Color Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock IoT Education Kit - Light & Color using TTN and Qubitro > UV Index & UV Intensity Monitoring LoRaWAN Application > LoRaWAN Code for UV Index & UV Intensity Monitoring > Programming UV Index & UV Intensity Monitoring Device with Arduino IDE [CODE]", "content": "#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define RAK4631_BOARD true\n#else\n#define RAK4631_BOARD false\n#endif", "keywords": ["Arduino IDE", "RAK4631", "UV Index", "UV Intensity", "LoRaWAN", "SX126x-Arduino"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **UV Index & UV Intensity Monitoring** device. Just copy the code below for **UV Index & UV Intensity Monitoring LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the example </summary>  \n```c\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h>  //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n#include \"UVlight_LTR390.h\"                // http://librarymanager/All#RAK12019_LTR390\nUVlight_LTR390 ltr = UVlight_LTR390();\n\n#include \"Light_VEML7700.h\"                // http://librarymanager/All#Light_veml7700\nLight_VEML7700 VMEL = Light_VEML7700();\n\nuint16_t uvi;\nuint32_t uvs;\nuint32_t lux;\nuint32_t white;\nuint32_t raw_als;\n\n#include <Adafruit_MCP23X17.h>  //http://librarymanager/All#Adafruit_MCP23017\nAdafruit_MCP23X17 mcp;\n\n// Added definitions for the functionality of RAK14003\nconst uint8_t LED_0 = 0;      // PA0 (17) of MCP23017\nconst uint8_t LED_1 = 1;      // PA1 (18) of MCP23017\nconst uint8_t LED_2 = 2;      // PA2 (19) of MCP23017\nconst uint8_t LED_3 = 3;      // PA3 (20) of MCP23017\nconst uint8_t LED_4 = 4;      // PA4 (21) of MCP23017\nconst uint8_t LED_5 = 5;      // PA5 (22) of MCP23017\nconst uint8_t LED_6 = 6;      // PA6 (23) of MCP23017\nconst uint8_t LED_7 = 7;      // PA7 (24) of MCP23017\nconst uint8_t LED_8 = 8;      // PB0 (25) of MCP23017\nconst uint8_t LED_9 = 9;      // PB1 (26) of MCP23017\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define RAK4631_BOARD true\n#else\n#define RAK4631_BOARD false\n#endif\n\nbool doOTAA = true;                                               // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                                       /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                                     /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5                               /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                                        /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;                           /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;                 /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                              /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = { LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF };\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = { BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler };\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xE9, 0x0D, 0x28, 0x1D, 0x92, 0x3D, 0xE4, 0x9F, 0xD9, 0xF7, 0xE0, 0x5F, 0x39, 0x10, 0x55, 0x71 };\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };\nuint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                                            /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];               //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = { m_lora_app_data_buffer, 0, 0, 0, 0 };  //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {\n\n// Initialize Serial for debug output\npinMode(LED_BLUE, OUTPUT);\ndigitalWrite(LED_BLUE, HIGH);\n\n// Sensor Power Switch\npinMode(WB_IO2, OUTPUT);\ndigitalWrite(WB_IO2, HIGH);\n\n// Reset RAK14003 module\npinMode(WB_IO4, OUTPUT);\ndigitalWrite(WB_IO4, HIGH);\ndelay(10);\ndigitalWrite(WB_IO4, LOW);\ndelay(10);\ndigitalWrite(WB_IO4, HIGH);\ndelay(10);\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial) {\nif ((millis() - timeout) < 5000) {\ndelay(100);\n} else {\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA) {\nSerial.println(\"Type: OTAA\");\n} else {\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion) {\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA) {\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n} else {\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0) {\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"================================\");\nSerial.println(\"RAK12019 + RAK12010 LoRaWAN Code\");\nSerial.println(\"================================\");\n\nif (!VMEL.begin())\n{\nSerial.println(\"Sensor not found\");\nwhile (1);\n}\n\nVMEL.setGain(VEML7700_GAIN_1);\nVMEL.setIntegrationTime(VEML7700_IT_800MS);\n\nSerial.print(F(\"Gain: \"));\nswitch (VMEL.getGain())\n{\ncase VEML7700_GAIN_1: Serial.println(\"1\"); break;\ncase VEML7700_GAIN_2: Serial.println(\"2\"); break;\ncase VEML7700_GAIN_1_4: Serial.println(\"1/4\"); break;\ncase VEML7700_GAIN_1_8: Serial.println(\"1/8\"); break;\n}\n\nSerial.print(F(\"Integration Time (ms): \"));\nswitch (VMEL.getIntegrationTime())\n{\ncase VEML7700_IT_25MS: Serial.println(\"25\"); break;\ncase VEML7700_IT_50MS: Serial.println(\"50\"); break;\ncase VEML7700_IT_100MS: Serial.println(\"100\"); break;\ncase VEML7700_IT_200MS: Serial.println(\"200\"); break;\ncase VEML7700_IT_400MS: Serial.println(\"400\"); break;\ncase VEML7700_IT_800MS: Serial.println(\"800\"); break;\n}\n\nSerial.println(\"RAK12019 test\");\nWire.begin();\nif (!ltr.init())\n{\nSerial.println(\"Couldn't find LTR sensor!\");\nwhile (1)\ndelay(10);\n}\nSerial.println(\"Found LTR390 sensor!\");\n\n//set to LTR390_MODE_UVS,get ultraviolet light data.\nltr.setMode(LTR390_MODE_UVS);  // UVS Mode\n\nSerial.println(\"In UVS mode\");\n\nltr.setGain(LTR390_GAIN_3);\nSerial.print(\"Gain : \");\nswitch (ltr.getGain())\n{\ncase LTR390_GAIN_1:\nSerial.println(1);\nbreak;\ncase LTR390_GAIN_3:\nSerial.println(3);\nbreak;\ncase LTR390_GAIN_6:\nSerial.println(6);\nbreak;\ncase LTR390_GAIN_9:\nSerial.println(9);\nbreak;\ncase LTR390_GAIN_18:\nSerial.println(18);\nbreak;\ndefault:\nSerial.println(\"Failed to set gain\");\nbreak;\n}\nltr.setResolution(LTR390_RESOLUTION_16BIT);\nSerial.print(\"Integration Time (ms): \");\nswitch (ltr.getResolution())\n{\ncase LTR390_RESOLUTION_13BIT:\nSerial.println(13);\nbreak;\ncase LTR390_RESOLUTION_16BIT:\nSerial.println(16);\nbreak;\ncase LTR390_RESOLUTION_17BIT:\nSerial.println(17);\nbreak;\ncase LTR390_RESOLUTION_18BIT:\nSerial.println(18);\nbreak;\ncase LTR390_RESOLUTION_19BIT:\nSerial.println(19);\nbreak;\ncase LTR390_RESOLUTION_20BIT:\nSerial.println(20);\nbreak;\ndefault:\nSerial.println(\"Failed to set Integration Time\");\nbreak;\n}\n\nltr.setThresholds(100, 1000); //Set the interrupt output threshold range for lower and upper.\n\nltr.configInterrupt(true, LTR390_MODE_UVS);\n\n// For RAK14003\nmcp.begin_I2C(0x24);\n\n// Added for the functionality of RAK14003\n\nWire.begin();    // initialize I2C serial bus\n\n// Configuration of MCP23017 I/O ports\nmcp.pinMode(LED_0, OUTPUT);     // Red LED; Top most\nmcp.pinMode(LED_1, OUTPUT);     // Red LED\nmcp.pinMode(LED_2, OUTPUT);     // Orange LED\nmcp.pinMode(LED_3, OUTPUT);     // Orange LED\nmcp.pinMode(LED_4, OUTPUT);     // Orange LED\nmcp.pinMode(LED_5, OUTPUT);     // Green LED\nmcp.pinMode(LED_6, OUTPUT);     // Green LED\nmcp.pinMode(LED_7, OUTPUT);     // Green LED\nmcp.pinMode(LED_8, OUTPUT);     // Green LED\nmcp.pinMode(LED_9, OUTPUT);     // Green LED; Bottom\n\n// Initially Turn OFF all LEDs\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, HIGH);\n\n}\n\nvoid loop() {\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\n// Trial # 1\n// Data from RAK12019\nif (ltr.newDataAvailable())\n{\nuvi = ltr.getUVI();\nuvs = ltr.readUVS();\n}\n\n// Data from RAK12010\nlux = VMEL.readLux();\nwhite = VMEL.readWhite();\nraw_als = VMEL.readALS();\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\n\n// From RAK12019 module\nSerial.print(\"UVI: \");\nSerial.println(uvi);          // Uvi data from RAK12019\nSerial.print(\"UVS: \");\nSerial.println(uvs);            // Uvs data from RAK12019\n\n// From RAK12010\nSerial.print(\"Lux: \");\nSerial.print(lux);\nSerial.println(\" lx \");\nSerial.print(\"White: \");\nSerial.println(white);\nSerial.print(\"Raw ALS: \");\nSerial.println(raw_als);\n\n// Result of uvi to be displayed via RAK14003 module\nif (uvi <= 0.4)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, HIGH);\n}\n\nelse if (uvi > 0.5 && uvi <= 1)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 1.5 && uvi <= 2)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 2.5 && uvi <= 3)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 3.5 && uvi <= 4)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 4.5 && uvi <= 5)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 5.5 && uvi <= 6)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 6.5 && uvi <= 7)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 7.5 && uvi <= 8)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 8.5 && uvi <= 9.5)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, LOW);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi >= 10)\n{\nmcp.digitalWrite(LED_0, LOW);\nmcp.digitalWrite(LED_1, LOW);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\ndelay(10000);\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void) {\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void) {\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data) {\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class) {\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void) {\nif (lmh_join_status_get() != LMH_SET) {\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\ndata = \" Uvi Data: \" + String(uvi) + \" Uvs Data: \" + String(uvs) + \" Lux Data: \" + String(lux) + \" lx \" ;\n\nSerial.println(data);\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\nuint16_t uvi_data = uvi;            // Uvi data from RAK12019\nuint32_t uvs_data = uvs;            // Uvs data from RAK12019\nuint32_t lux_data = lux;            // Lux data from RAK12010\n\nm_lora_app_data.buffer[i++] = 0x01;  // byte[0]\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\n// Data from RAK12019 module\nm_lora_app_data.buffer[i++] = (uint8_t)((uvi_data & 0x0000FF00) >> 8);     // byte[1]\nm_lora_app_data.buffer[i++] = (uint8_t)(uvi_data & 0x000000FF);            // byte[2]\n\n// Data from RAK12019 module\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0xFF000000) >> 24);    // byte[3]\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0x00FF0000) >> 16);    // byte[4]\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0x0000FF00) >> 8);     // byte[5]\nm_lora_app_data.buffer[i++] = (uint8_t)(uvs_data & 0x000000FF);            // byte[6]\n\n// Data from RAK12010 module\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0xFF000000) >> 24);    // byte[7]\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0x00FF0000) >> 16);    // byte[8]\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0x0000FF00) >> 8);     // byte[9]\nm_lora_app_data.buffer[i++] = (uint8_t)(lux_data & 0x000000FF);            // byte[10]\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS) {\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n} else {\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xE9, 0x0D, 0x28, 0x1D, 0x92, 0x3D, 0xE4, 0x9F, 0xD9, 0xF7, 0xE0, 0x5F, 0x39, 0x10, 0x55, 0x71 };\n\n```  \n> **Image:** OTAA device successfully registered to TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "698a96af3a065cfc61d833382de71ee6", "product_family": "wisblock", "product_id": "kit6-light-and-color", "category": "How-To", "title": "WisBlock IoT Education Kit - Light & Color Quick Start Guide > WisBlock IoT Education Kit - Light & Color Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock IoT Education Kit - Light & Color using TTN and Qubitro > UV Index & UV Intensity Monitoring LoRaWAN Application > LoRaWAN Code for UV Index & UV Intensity Monitoring > Programming UV Index & UV Intensity Monitoring Device with Arduino IDE [CODE]", "content": "bool doOTAA = true;                                               // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                                       /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                                     /*LoRaMac datarates definition, from DR_0 to DR_5*/", "keywords": ["Arduino IDE", "RAK4631", "UV Index", "UV Intensity", "LoRaWAN", "SX126x-Arduino"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **UV Index & UV Intensity Monitoring** device. Just copy the code below for **UV Index & UV Intensity Monitoring LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the example </summary>  \n```c\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h>  //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n#include \"UVlight_LTR390.h\"                // http://librarymanager/All#RAK12019_LTR390\nUVlight_LTR390 ltr = UVlight_LTR390();\n\n#include \"Light_VEML7700.h\"                // http://librarymanager/All#Light_veml7700\nLight_VEML7700 VMEL = Light_VEML7700();\n\nuint16_t uvi;\nuint32_t uvs;\nuint32_t lux;\nuint32_t white;\nuint32_t raw_als;\n\n#include <Adafruit_MCP23X17.h>  //http://librarymanager/All#Adafruit_MCP23017\nAdafruit_MCP23X17 mcp;\n\n// Added definitions for the functionality of RAK14003\nconst uint8_t LED_0 = 0;      // PA0 (17) of MCP23017\nconst uint8_t LED_1 = 1;      // PA1 (18) of MCP23017\nconst uint8_t LED_2 = 2;      // PA2 (19) of MCP23017\nconst uint8_t LED_3 = 3;      // PA3 (20) of MCP23017\nconst uint8_t LED_4 = 4;      // PA4 (21) of MCP23017\nconst uint8_t LED_5 = 5;      // PA5 (22) of MCP23017\nconst uint8_t LED_6 = 6;      // PA6 (23) of MCP23017\nconst uint8_t LED_7 = 7;      // PA7 (24) of MCP23017\nconst uint8_t LED_8 = 8;      // PB0 (25) of MCP23017\nconst uint8_t LED_9 = 9;      // PB1 (26) of MCP23017\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define RAK4631_BOARD true\n#else\n#define RAK4631_BOARD false\n#endif\n\nbool doOTAA = true;                                               // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                                       /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                                     /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5                               /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                                        /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;                           /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;                 /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                              /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = { LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF };\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = { BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler };\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xE9, 0x0D, 0x28, 0x1D, 0x92, 0x3D, 0xE4, 0x9F, 0xD9, 0xF7, 0xE0, 0x5F, 0x39, 0x10, 0x55, 0x71 };\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };\nuint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                                            /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];               //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = { m_lora_app_data_buffer, 0, 0, 0, 0 };  //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {\n\n// Initialize Serial for debug output\npinMode(LED_BLUE, OUTPUT);\ndigitalWrite(LED_BLUE, HIGH);\n\n// Sensor Power Switch\npinMode(WB_IO2, OUTPUT);\ndigitalWrite(WB_IO2, HIGH);\n\n// Reset RAK14003 module\npinMode(WB_IO4, OUTPUT);\ndigitalWrite(WB_IO4, HIGH);\ndelay(10);\ndigitalWrite(WB_IO4, LOW);\ndelay(10);\ndigitalWrite(WB_IO4, HIGH);\ndelay(10);\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial) {\nif ((millis() - timeout) < 5000) {\ndelay(100);\n} else {\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA) {\nSerial.println(\"Type: OTAA\");\n} else {\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion) {\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA) {\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n} else {\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0) {\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"================================\");\nSerial.println(\"RAK12019 + RAK12010 LoRaWAN Code\");\nSerial.println(\"================================\");\n\nif (!VMEL.begin())\n{\nSerial.println(\"Sensor not found\");\nwhile (1);\n}\n\nVMEL.setGain(VEML7700_GAIN_1);\nVMEL.setIntegrationTime(VEML7700_IT_800MS);\n\nSerial.print(F(\"Gain: \"));\nswitch (VMEL.getGain())\n{\ncase VEML7700_GAIN_1: Serial.println(\"1\"); break;\ncase VEML7700_GAIN_2: Serial.println(\"2\"); break;\ncase VEML7700_GAIN_1_4: Serial.println(\"1/4\"); break;\ncase VEML7700_GAIN_1_8: Serial.println(\"1/8\"); break;\n}\n\nSerial.print(F(\"Integration Time (ms): \"));\nswitch (VMEL.getIntegrationTime())\n{\ncase VEML7700_IT_25MS: Serial.println(\"25\"); break;\ncase VEML7700_IT_50MS: Serial.println(\"50\"); break;\ncase VEML7700_IT_100MS: Serial.println(\"100\"); break;\ncase VEML7700_IT_200MS: Serial.println(\"200\"); break;\ncase VEML7700_IT_400MS: Serial.println(\"400\"); break;\ncase VEML7700_IT_800MS: Serial.println(\"800\"); break;\n}\n\nSerial.println(\"RAK12019 test\");\nWire.begin();\nif (!ltr.init())\n{\nSerial.println(\"Couldn't find LTR sensor!\");\nwhile (1)\ndelay(10);\n}\nSerial.println(\"Found LTR390 sensor!\");\n\n//set to LTR390_MODE_UVS,get ultraviolet light data.\nltr.setMode(LTR390_MODE_UVS);  // UVS Mode\n\nSerial.println(\"In UVS mode\");\n\nltr.setGain(LTR390_GAIN_3);\nSerial.print(\"Gain : \");\nswitch (ltr.getGain())\n{\ncase LTR390_GAIN_1:\nSerial.println(1);\nbreak;\ncase LTR390_GAIN_3:\nSerial.println(3);\nbreak;\ncase LTR390_GAIN_6:\nSerial.println(6);\nbreak;\ncase LTR390_GAIN_9:\nSerial.println(9);\nbreak;\ncase LTR390_GAIN_18:\nSerial.println(18);\nbreak;\ndefault:\nSerial.println(\"Failed to set gain\");\nbreak;\n}\nltr.setResolution(LTR390_RESOLUTION_16BIT);\nSerial.print(\"Integration Time (ms): \");\nswitch (ltr.getResolution())\n{\ncase LTR390_RESOLUTION_13BIT:\nSerial.println(13);\nbreak;\ncase LTR390_RESOLUTION_16BIT:\nSerial.println(16);\nbreak;\ncase LTR390_RESOLUTION_17BIT:\nSerial.println(17);\nbreak;\ncase LTR390_RESOLUTION_18BIT:\nSerial.println(18);\nbreak;\ncase LTR390_RESOLUTION_19BIT:\nSerial.println(19);\nbreak;\ncase LTR390_RESOLUTION_20BIT:\nSerial.println(20);\nbreak;\ndefault:\nSerial.println(\"Failed to set Integration Time\");\nbreak;\n}\n\nltr.setThresholds(100, 1000); //Set the interrupt output threshold range for lower and upper.\n\nltr.configInterrupt(true, LTR390_MODE_UVS);\n\n// For RAK14003\nmcp.begin_I2C(0x24);\n\n// Added for the functionality of RAK14003\n\nWire.begin();    // initialize I2C serial bus\n\n// Configuration of MCP23017 I/O ports\nmcp.pinMode(LED_0, OUTPUT);     // Red LED; Top most\nmcp.pinMode(LED_1, OUTPUT);     // Red LED\nmcp.pinMode(LED_2, OUTPUT);     // Orange LED\nmcp.pinMode(LED_3, OUTPUT);     // Orange LED\nmcp.pinMode(LED_4, OUTPUT);     // Orange LED\nmcp.pinMode(LED_5, OUTPUT);     // Green LED\nmcp.pinMode(LED_6, OUTPUT);     // Green LED\nmcp.pinMode(LED_7, OUTPUT);     // Green LED\nmcp.pinMode(LED_8, OUTPUT);     // Green LED\nmcp.pinMode(LED_9, OUTPUT);     // Green LED; Bottom\n\n// Initially Turn OFF all LEDs\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, HIGH);\n\n}\n\nvoid loop() {\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\n// Trial # 1\n// Data from RAK12019\nif (ltr.newDataAvailable())\n{\nuvi = ltr.getUVI();\nuvs = ltr.readUVS();\n}\n\n// Data from RAK12010\nlux = VMEL.readLux();\nwhite = VMEL.readWhite();\nraw_als = VMEL.readALS();\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\n\n// From RAK12019 module\nSerial.print(\"UVI: \");\nSerial.println(uvi);          // Uvi data from RAK12019\nSerial.print(\"UVS: \");\nSerial.println(uvs);            // Uvs data from RAK12019\n\n// From RAK12010\nSerial.print(\"Lux: \");\nSerial.print(lux);\nSerial.println(\" lx \");\nSerial.print(\"White: \");\nSerial.println(white);\nSerial.print(\"Raw ALS: \");\nSerial.println(raw_als);\n\n// Result of uvi to be displayed via RAK14003 module\nif (uvi <= 0.4)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, HIGH);\n}\n\nelse if (uvi > 0.5 && uvi <= 1)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 1.5 && uvi <= 2)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 2.5 && uvi <= 3)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 3.5 && uvi <= 4)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 4.5 && uvi <= 5)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 5.5 && uvi <= 6)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 6.5 && uvi <= 7)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 7.5 && uvi <= 8)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 8.5 && uvi <= 9.5)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, LOW);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi >= 10)\n{\nmcp.digitalWrite(LED_0, LOW);\nmcp.digitalWrite(LED_1, LOW);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\ndelay(10000);\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void) {\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void) {\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data) {\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class) {\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void) {\nif (lmh_join_status_get() != LMH_SET) {\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\ndata = \" Uvi Data: \" + String(uvi) + \" Uvs Data: \" + String(uvs) + \" Lux Data: \" + String(lux) + \" lx \" ;\n\nSerial.println(data);\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\nuint16_t uvi_data = uvi;            // Uvi data from RAK12019\nuint32_t uvs_data = uvs;            // Uvs data from RAK12019\nuint32_t lux_data = lux;            // Lux data from RAK12010\n\nm_lora_app_data.buffer[i++] = 0x01;  // byte[0]\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\n// Data from RAK12019 module\nm_lora_app_data.buffer[i++] = (uint8_t)((uvi_data & 0x0000FF00) >> 8);     // byte[1]\nm_lora_app_data.buffer[i++] = (uint8_t)(uvi_data & 0x000000FF);            // byte[2]\n\n// Data from RAK12019 module\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0xFF000000) >> 24);    // byte[3]\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0x00FF0000) >> 16);    // byte[4]\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0x0000FF00) >> 8);     // byte[5]\nm_lora_app_data.buffer[i++] = (uint8_t)(uvs_data & 0x000000FF);            // byte[6]\n\n// Data from RAK12010 module\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0xFF000000) >> 24);    // byte[7]\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0x00FF0000) >> 16);    // byte[8]\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0x0000FF00) >> 8);     // byte[9]\nm_lora_app_data.buffer[i++] = (uint8_t)(lux_data & 0x000000FF);            // byte[10]\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS) {\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n} else {\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xE9, 0x0D, 0x28, 0x1D, 0x92, 0x3D, 0xE4, 0x9F, 0xD9, 0xF7, 0xE0, 0x5F, 0x39, 0x10, 0x55, 0x71 };\n\n```  \n> **Image:** OTAA device successfully registered to TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "799054c32337f6e37541362df0284577", "product_family": "wisblock", "product_id": "kit6-light-and-color", "category": "How-To", "title": "WisBlock IoT Education Kit - Light & Color Quick Start Guide > WisBlock IoT Education Kit - Light & Color Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock IoT Education Kit - Light & Color using TTN and Qubitro > UV Index & UV Intensity Monitoring LoRaWAN Application > LoRaWAN Code for UV Index & UV Intensity Monitoring > Programming UV Index & UV Intensity Monitoring Device with Arduino IDE [CODE]", "content": "#define LORAWAN_TX_POWER TX_POWER_5                               /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                                        /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;                           /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/", "keywords": ["Arduino IDE", "RAK4631", "UV Index", "UV Intensity", "LoRaWAN", "SX126x-Arduino"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **UV Index & UV Intensity Monitoring** device. Just copy the code below for **UV Index & UV Intensity Monitoring LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the example </summary>  \n```c\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h>  //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n#include \"UVlight_LTR390.h\"                // http://librarymanager/All#RAK12019_LTR390\nUVlight_LTR390 ltr = UVlight_LTR390();\n\n#include \"Light_VEML7700.h\"                // http://librarymanager/All#Light_veml7700\nLight_VEML7700 VMEL = Light_VEML7700();\n\nuint16_t uvi;\nuint32_t uvs;\nuint32_t lux;\nuint32_t white;\nuint32_t raw_als;\n\n#include <Adafruit_MCP23X17.h>  //http://librarymanager/All#Adafruit_MCP23017\nAdafruit_MCP23X17 mcp;\n\n// Added definitions for the functionality of RAK14003\nconst uint8_t LED_0 = 0;      // PA0 (17) of MCP23017\nconst uint8_t LED_1 = 1;      // PA1 (18) of MCP23017\nconst uint8_t LED_2 = 2;      // PA2 (19) of MCP23017\nconst uint8_t LED_3 = 3;      // PA3 (20) of MCP23017\nconst uint8_t LED_4 = 4;      // PA4 (21) of MCP23017\nconst uint8_t LED_5 = 5;      // PA5 (22) of MCP23017\nconst uint8_t LED_6 = 6;      // PA6 (23) of MCP23017\nconst uint8_t LED_7 = 7;      // PA7 (24) of MCP23017\nconst uint8_t LED_8 = 8;      // PB0 (25) of MCP23017\nconst uint8_t LED_9 = 9;      // PB1 (26) of MCP23017\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define RAK4631_BOARD true\n#else\n#define RAK4631_BOARD false\n#endif\n\nbool doOTAA = true;                                               // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                                       /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                                     /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5                               /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                                        /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;                           /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;                 /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                              /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = { LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF };\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = { BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler };\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xE9, 0x0D, 0x28, 0x1D, 0x92, 0x3D, 0xE4, 0x9F, 0xD9, 0xF7, 0xE0, 0x5F, 0x39, 0x10, 0x55, 0x71 };\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };\nuint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                                            /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];               //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = { m_lora_app_data_buffer, 0, 0, 0, 0 };  //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {\n\n// Initialize Serial for debug output\npinMode(LED_BLUE, OUTPUT);\ndigitalWrite(LED_BLUE, HIGH);\n\n// Sensor Power Switch\npinMode(WB_IO2, OUTPUT);\ndigitalWrite(WB_IO2, HIGH);\n\n// Reset RAK14003 module\npinMode(WB_IO4, OUTPUT);\ndigitalWrite(WB_IO4, HIGH);\ndelay(10);\ndigitalWrite(WB_IO4, LOW);\ndelay(10);\ndigitalWrite(WB_IO4, HIGH);\ndelay(10);\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial) {\nif ((millis() - timeout) < 5000) {\ndelay(100);\n} else {\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA) {\nSerial.println(\"Type: OTAA\");\n} else {\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion) {\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA) {\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n} else {\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0) {\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"================================\");\nSerial.println(\"RAK12019 + RAK12010 LoRaWAN Code\");\nSerial.println(\"================================\");\n\nif (!VMEL.begin())\n{\nSerial.println(\"Sensor not found\");\nwhile (1);\n}\n\nVMEL.setGain(VEML7700_GAIN_1);\nVMEL.setIntegrationTime(VEML7700_IT_800MS);\n\nSerial.print(F(\"Gain: \"));\nswitch (VMEL.getGain())\n{\ncase VEML7700_GAIN_1: Serial.println(\"1\"); break;\ncase VEML7700_GAIN_2: Serial.println(\"2\"); break;\ncase VEML7700_GAIN_1_4: Serial.println(\"1/4\"); break;\ncase VEML7700_GAIN_1_8: Serial.println(\"1/8\"); break;\n}\n\nSerial.print(F(\"Integration Time (ms): \"));\nswitch (VMEL.getIntegrationTime())\n{\ncase VEML7700_IT_25MS: Serial.println(\"25\"); break;\ncase VEML7700_IT_50MS: Serial.println(\"50\"); break;\ncase VEML7700_IT_100MS: Serial.println(\"100\"); break;\ncase VEML7700_IT_200MS: Serial.println(\"200\"); break;\ncase VEML7700_IT_400MS: Serial.println(\"400\"); break;\ncase VEML7700_IT_800MS: Serial.println(\"800\"); break;\n}\n\nSerial.println(\"RAK12019 test\");\nWire.begin();\nif (!ltr.init())\n{\nSerial.println(\"Couldn't find LTR sensor!\");\nwhile (1)\ndelay(10);\n}\nSerial.println(\"Found LTR390 sensor!\");\n\n//set to LTR390_MODE_UVS,get ultraviolet light data.\nltr.setMode(LTR390_MODE_UVS);  // UVS Mode\n\nSerial.println(\"In UVS mode\");\n\nltr.setGain(LTR390_GAIN_3);\nSerial.print(\"Gain : \");\nswitch (ltr.getGain())\n{\ncase LTR390_GAIN_1:\nSerial.println(1);\nbreak;\ncase LTR390_GAIN_3:\nSerial.println(3);\nbreak;\ncase LTR390_GAIN_6:\nSerial.println(6);\nbreak;\ncase LTR390_GAIN_9:\nSerial.println(9);\nbreak;\ncase LTR390_GAIN_18:\nSerial.println(18);\nbreak;\ndefault:\nSerial.println(\"Failed to set gain\");\nbreak;\n}\nltr.setResolution(LTR390_RESOLUTION_16BIT);\nSerial.print(\"Integration Time (ms): \");\nswitch (ltr.getResolution())\n{\ncase LTR390_RESOLUTION_13BIT:\nSerial.println(13);\nbreak;\ncase LTR390_RESOLUTION_16BIT:\nSerial.println(16);\nbreak;\ncase LTR390_RESOLUTION_17BIT:\nSerial.println(17);\nbreak;\ncase LTR390_RESOLUTION_18BIT:\nSerial.println(18);\nbreak;\ncase LTR390_RESOLUTION_19BIT:\nSerial.println(19);\nbreak;\ncase LTR390_RESOLUTION_20BIT:\nSerial.println(20);\nbreak;\ndefault:\nSerial.println(\"Failed to set Integration Time\");\nbreak;\n}\n\nltr.setThresholds(100, 1000); //Set the interrupt output threshold range for lower and upper.\n\nltr.configInterrupt(true, LTR390_MODE_UVS);\n\n// For RAK14003\nmcp.begin_I2C(0x24);\n\n// Added for the functionality of RAK14003\n\nWire.begin();    // initialize I2C serial bus\n\n// Configuration of MCP23017 I/O ports\nmcp.pinMode(LED_0, OUTPUT);     // Red LED; Top most\nmcp.pinMode(LED_1, OUTPUT);     // Red LED\nmcp.pinMode(LED_2, OUTPUT);     // Orange LED\nmcp.pinMode(LED_3, OUTPUT);     // Orange LED\nmcp.pinMode(LED_4, OUTPUT);     // Orange LED\nmcp.pinMode(LED_5, OUTPUT);     // Green LED\nmcp.pinMode(LED_6, OUTPUT);     // Green LED\nmcp.pinMode(LED_7, OUTPUT);     // Green LED\nmcp.pinMode(LED_8, OUTPUT);     // Green LED\nmcp.pinMode(LED_9, OUTPUT);     // Green LED; Bottom\n\n// Initially Turn OFF all LEDs\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, HIGH);\n\n}\n\nvoid loop() {\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\n// Trial # 1\n// Data from RAK12019\nif (ltr.newDataAvailable())\n{\nuvi = ltr.getUVI();\nuvs = ltr.readUVS();\n}\n\n// Data from RAK12010\nlux = VMEL.readLux();\nwhite = VMEL.readWhite();\nraw_als = VMEL.readALS();\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\n\n// From RAK12019 module\nSerial.print(\"UVI: \");\nSerial.println(uvi);          // Uvi data from RAK12019\nSerial.print(\"UVS: \");\nSerial.println(uvs);            // Uvs data from RAK12019\n\n// From RAK12010\nSerial.print(\"Lux: \");\nSerial.print(lux);\nSerial.println(\" lx \");\nSerial.print(\"White: \");\nSerial.println(white);\nSerial.print(\"Raw ALS: \");\nSerial.println(raw_als);\n\n// Result of uvi to be displayed via RAK14003 module\nif (uvi <= 0.4)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, HIGH);\n}\n\nelse if (uvi > 0.5 && uvi <= 1)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 1.5 && uvi <= 2)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 2.5 && uvi <= 3)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 3.5 && uvi <= 4)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 4.5 && uvi <= 5)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 5.5 && uvi <= 6)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 6.5 && uvi <= 7)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 7.5 && uvi <= 8)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 8.5 && uvi <= 9.5)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, LOW);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi >= 10)\n{\nmcp.digitalWrite(LED_0, LOW);\nmcp.digitalWrite(LED_1, LOW);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\ndelay(10000);\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void) {\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void) {\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data) {\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class) {\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void) {\nif (lmh_join_status_get() != LMH_SET) {\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\ndata = \" Uvi Data: \" + String(uvi) + \" Uvs Data: \" + String(uvs) + \" Lux Data: \" + String(lux) + \" lx \" ;\n\nSerial.println(data);\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\nuint16_t uvi_data = uvi;            // Uvi data from RAK12019\nuint32_t uvs_data = uvs;            // Uvs data from RAK12019\nuint32_t lux_data = lux;            // Lux data from RAK12010\n\nm_lora_app_data.buffer[i++] = 0x01;  // byte[0]\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\n// Data from RAK12019 module\nm_lora_app_data.buffer[i++] = (uint8_t)((uvi_data & 0x0000FF00) >> 8);     // byte[1]\nm_lora_app_data.buffer[i++] = (uint8_t)(uvi_data & 0x000000FF);            // byte[2]\n\n// Data from RAK12019 module\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0xFF000000) >> 24);    // byte[3]\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0x00FF0000) >> 16);    // byte[4]\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0x0000FF00) >> 8);     // byte[5]\nm_lora_app_data.buffer[i++] = (uint8_t)(uvs_data & 0x000000FF);            // byte[6]\n\n// Data from RAK12010 module\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0xFF000000) >> 24);    // byte[7]\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0x00FF0000) >> 16);    // byte[8]\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0x0000FF00) >> 8);     // byte[9]\nm_lora_app_data.buffer[i++] = (uint8_t)(lux_data & 0x000000FF);            // byte[10]\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS) {\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n} else {\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xE9, 0x0D, 0x28, 0x1D, 0x92, 0x3D, 0xE4, 0x9F, 0xD9, 0xF7, 0xE0, 0x5F, 0x39, 0x10, 0x55, 0x71 };\n\n```  \n> **Image:** OTAA device successfully registered to TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "928c4423e92ba93937743d0e7855f5cc", "product_family": "wisblock", "product_id": "kit6-light-and-color", "category": "How-To", "title": "WisBlock IoT Education Kit - Light & Color Quick Start Guide > WisBlock IoT Education Kit - Light & Color Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock IoT Education Kit - Light & Color using TTN and Qubitro > UV Index & UV Intensity Monitoring LoRaWAN Application > LoRaWAN Code for UV Index & UV Intensity Monitoring > Programming UV Index & UV Intensity Monitoring Device with Arduino IDE [CODE]", "content": "LoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;                 /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                              /* data port*/", "keywords": ["Arduino IDE", "RAK4631", "UV Index", "UV Intensity", "LoRaWAN", "SX126x-Arduino"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **UV Index & UV Intensity Monitoring** device. Just copy the code below for **UV Index & UV Intensity Monitoring LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the example </summary>  \n```c\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h>  //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n#include \"UVlight_LTR390.h\"                // http://librarymanager/All#RAK12019_LTR390\nUVlight_LTR390 ltr = UVlight_LTR390();\n\n#include \"Light_VEML7700.h\"                // http://librarymanager/All#Light_veml7700\nLight_VEML7700 VMEL = Light_VEML7700();\n\nuint16_t uvi;\nuint32_t uvs;\nuint32_t lux;\nuint32_t white;\nuint32_t raw_als;\n\n#include <Adafruit_MCP23X17.h>  //http://librarymanager/All#Adafruit_MCP23017\nAdafruit_MCP23X17 mcp;\n\n// Added definitions for the functionality of RAK14003\nconst uint8_t LED_0 = 0;      // PA0 (17) of MCP23017\nconst uint8_t LED_1 = 1;      // PA1 (18) of MCP23017\nconst uint8_t LED_2 = 2;      // PA2 (19) of MCP23017\nconst uint8_t LED_3 = 3;      // PA3 (20) of MCP23017\nconst uint8_t LED_4 = 4;      // PA4 (21) of MCP23017\nconst uint8_t LED_5 = 5;      // PA5 (22) of MCP23017\nconst uint8_t LED_6 = 6;      // PA6 (23) of MCP23017\nconst uint8_t LED_7 = 7;      // PA7 (24) of MCP23017\nconst uint8_t LED_8 = 8;      // PB0 (25) of MCP23017\nconst uint8_t LED_9 = 9;      // PB1 (26) of MCP23017\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define RAK4631_BOARD true\n#else\n#define RAK4631_BOARD false\n#endif\n\nbool doOTAA = true;                                               // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                                       /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                                     /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5                               /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                                        /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;                           /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;                 /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                              /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = { LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF };\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = { BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler };\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xE9, 0x0D, 0x28, 0x1D, 0x92, 0x3D, 0xE4, 0x9F, 0xD9, 0xF7, 0xE0, 0x5F, 0x39, 0x10, 0x55, 0x71 };\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };\nuint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                                            /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];               //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = { m_lora_app_data_buffer, 0, 0, 0, 0 };  //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {\n\n// Initialize Serial for debug output\npinMode(LED_BLUE, OUTPUT);\ndigitalWrite(LED_BLUE, HIGH);\n\n// Sensor Power Switch\npinMode(WB_IO2, OUTPUT);\ndigitalWrite(WB_IO2, HIGH);\n\n// Reset RAK14003 module\npinMode(WB_IO4, OUTPUT);\ndigitalWrite(WB_IO4, HIGH);\ndelay(10);\ndigitalWrite(WB_IO4, LOW);\ndelay(10);\ndigitalWrite(WB_IO4, HIGH);\ndelay(10);\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial) {\nif ((millis() - timeout) < 5000) {\ndelay(100);\n} else {\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA) {\nSerial.println(\"Type: OTAA\");\n} else {\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion) {\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA) {\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n} else {\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0) {\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"================================\");\nSerial.println(\"RAK12019 + RAK12010 LoRaWAN Code\");\nSerial.println(\"================================\");\n\nif (!VMEL.begin())\n{\nSerial.println(\"Sensor not found\");\nwhile (1);\n}\n\nVMEL.setGain(VEML7700_GAIN_1);\nVMEL.setIntegrationTime(VEML7700_IT_800MS);\n\nSerial.print(F(\"Gain: \"));\nswitch (VMEL.getGain())\n{\ncase VEML7700_GAIN_1: Serial.println(\"1\"); break;\ncase VEML7700_GAIN_2: Serial.println(\"2\"); break;\ncase VEML7700_GAIN_1_4: Serial.println(\"1/4\"); break;\ncase VEML7700_GAIN_1_8: Serial.println(\"1/8\"); break;\n}\n\nSerial.print(F(\"Integration Time (ms): \"));\nswitch (VMEL.getIntegrationTime())\n{\ncase VEML7700_IT_25MS: Serial.println(\"25\"); break;\ncase VEML7700_IT_50MS: Serial.println(\"50\"); break;\ncase VEML7700_IT_100MS: Serial.println(\"100\"); break;\ncase VEML7700_IT_200MS: Serial.println(\"200\"); break;\ncase VEML7700_IT_400MS: Serial.println(\"400\"); break;\ncase VEML7700_IT_800MS: Serial.println(\"800\"); break;\n}\n\nSerial.println(\"RAK12019 test\");\nWire.begin();\nif (!ltr.init())\n{\nSerial.println(\"Couldn't find LTR sensor!\");\nwhile (1)\ndelay(10);\n}\nSerial.println(\"Found LTR390 sensor!\");\n\n//set to LTR390_MODE_UVS,get ultraviolet light data.\nltr.setMode(LTR390_MODE_UVS);  // UVS Mode\n\nSerial.println(\"In UVS mode\");\n\nltr.setGain(LTR390_GAIN_3);\nSerial.print(\"Gain : \");\nswitch (ltr.getGain())\n{\ncase LTR390_GAIN_1:\nSerial.println(1);\nbreak;\ncase LTR390_GAIN_3:\nSerial.println(3);\nbreak;\ncase LTR390_GAIN_6:\nSerial.println(6);\nbreak;\ncase LTR390_GAIN_9:\nSerial.println(9);\nbreak;\ncase LTR390_GAIN_18:\nSerial.println(18);\nbreak;\ndefault:\nSerial.println(\"Failed to set gain\");\nbreak;\n}\nltr.setResolution(LTR390_RESOLUTION_16BIT);\nSerial.print(\"Integration Time (ms): \");\nswitch (ltr.getResolution())\n{\ncase LTR390_RESOLUTION_13BIT:\nSerial.println(13);\nbreak;\ncase LTR390_RESOLUTION_16BIT:\nSerial.println(16);\nbreak;\ncase LTR390_RESOLUTION_17BIT:\nSerial.println(17);\nbreak;\ncase LTR390_RESOLUTION_18BIT:\nSerial.println(18);\nbreak;\ncase LTR390_RESOLUTION_19BIT:\nSerial.println(19);\nbreak;\ncase LTR390_RESOLUTION_20BIT:\nSerial.println(20);\nbreak;\ndefault:\nSerial.println(\"Failed to set Integration Time\");\nbreak;\n}\n\nltr.setThresholds(100, 1000); //Set the interrupt output threshold range for lower and upper.\n\nltr.configInterrupt(true, LTR390_MODE_UVS);\n\n// For RAK14003\nmcp.begin_I2C(0x24);\n\n// Added for the functionality of RAK14003\n\nWire.begin();    // initialize I2C serial bus\n\n// Configuration of MCP23017 I/O ports\nmcp.pinMode(LED_0, OUTPUT);     // Red LED; Top most\nmcp.pinMode(LED_1, OUTPUT);     // Red LED\nmcp.pinMode(LED_2, OUTPUT);     // Orange LED\nmcp.pinMode(LED_3, OUTPUT);     // Orange LED\nmcp.pinMode(LED_4, OUTPUT);     // Orange LED\nmcp.pinMode(LED_5, OUTPUT);     // Green LED\nmcp.pinMode(LED_6, OUTPUT);     // Green LED\nmcp.pinMode(LED_7, OUTPUT);     // Green LED\nmcp.pinMode(LED_8, OUTPUT);     // Green LED\nmcp.pinMode(LED_9, OUTPUT);     // Green LED; Bottom\n\n// Initially Turn OFF all LEDs\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, HIGH);\n\n}\n\nvoid loop() {\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\n// Trial # 1\n// Data from RAK12019\nif (ltr.newDataAvailable())\n{\nuvi = ltr.getUVI();\nuvs = ltr.readUVS();\n}\n\n// Data from RAK12010\nlux = VMEL.readLux();\nwhite = VMEL.readWhite();\nraw_als = VMEL.readALS();\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\n\n// From RAK12019 module\nSerial.print(\"UVI: \");\nSerial.println(uvi);          // Uvi data from RAK12019\nSerial.print(\"UVS: \");\nSerial.println(uvs);            // Uvs data from RAK12019\n\n// From RAK12010\nSerial.print(\"Lux: \");\nSerial.print(lux);\nSerial.println(\" lx \");\nSerial.print(\"White: \");\nSerial.println(white);\nSerial.print(\"Raw ALS: \");\nSerial.println(raw_als);\n\n// Result of uvi to be displayed via RAK14003 module\nif (uvi <= 0.4)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, HIGH);\n}\n\nelse if (uvi > 0.5 && uvi <= 1)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 1.5 && uvi <= 2)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 2.5 && uvi <= 3)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 3.5 && uvi <= 4)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 4.5 && uvi <= 5)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 5.5 && uvi <= 6)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 6.5 && uvi <= 7)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 7.5 && uvi <= 8)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 8.5 && uvi <= 9.5)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, LOW);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi >= 10)\n{\nmcp.digitalWrite(LED_0, LOW);\nmcp.digitalWrite(LED_1, LOW);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\ndelay(10000);\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void) {\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void) {\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data) {\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class) {\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void) {\nif (lmh_join_status_get() != LMH_SET) {\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\ndata = \" Uvi Data: \" + String(uvi) + \" Uvs Data: \" + String(uvs) + \" Lux Data: \" + String(lux) + \" lx \" ;\n\nSerial.println(data);\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\nuint16_t uvi_data = uvi;            // Uvi data from RAK12019\nuint32_t uvs_data = uvs;            // Uvs data from RAK12019\nuint32_t lux_data = lux;            // Lux data from RAK12010\n\nm_lora_app_data.buffer[i++] = 0x01;  // byte[0]\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\n// Data from RAK12019 module\nm_lora_app_data.buffer[i++] = (uint8_t)((uvi_data & 0x0000FF00) >> 8);     // byte[1]\nm_lora_app_data.buffer[i++] = (uint8_t)(uvi_data & 0x000000FF);            // byte[2]\n\n// Data from RAK12019 module\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0xFF000000) >> 24);    // byte[3]\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0x00FF0000) >> 16);    // byte[4]\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0x0000FF00) >> 8);     // byte[5]\nm_lora_app_data.buffer[i++] = (uint8_t)(uvs_data & 0x000000FF);            // byte[6]\n\n// Data from RAK12010 module\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0xFF000000) >> 24);    // byte[7]\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0x00FF0000) >> 16);    // byte[8]\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0x0000FF00) >> 8);     // byte[9]\nm_lora_app_data.buffer[i++] = (uint8_t)(lux_data & 0x000000FF);            // byte[10]\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS) {\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n} else {\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xE9, 0x0D, 0x28, 0x1D, 0x92, 0x3D, 0xE4, 0x9F, 0xD9, 0xF7, 0xE0, 0x5F, 0x39, 0x10, 0x55, 0x71 };\n\n```  \n> **Image:** OTAA device successfully registered to TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "9baf7cde4f4998136519687a7beb983f", "product_family": "wisblock", "product_id": "kit6-light-and-color", "category": "How-To", "title": "WisBlock IoT Education Kit - Light & Color Quick Start Guide > WisBlock IoT Education Kit - Light & Color Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock IoT Education Kit - Light & Color using TTN and Qubitro > UV Index & UV Intensity Monitoring LoRaWAN Application > LoRaWAN Code for UV Index & UV Intensity Monitoring > Programming UV Index & UV Intensity Monitoring Device with Arduino IDE [CODE]", "content": "/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = { LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF };", "keywords": ["Arduino IDE", "RAK4631", "UV Index", "UV Intensity", "LoRaWAN", "SX126x-Arduino"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **UV Index & UV Intensity Monitoring** device. Just copy the code below for **UV Index & UV Intensity Monitoring LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the example </summary>  \n```c\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h>  //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n#include \"UVlight_LTR390.h\"                // http://librarymanager/All#RAK12019_LTR390\nUVlight_LTR390 ltr = UVlight_LTR390();\n\n#include \"Light_VEML7700.h\"                // http://librarymanager/All#Light_veml7700\nLight_VEML7700 VMEL = Light_VEML7700();\n\nuint16_t uvi;\nuint32_t uvs;\nuint32_t lux;\nuint32_t white;\nuint32_t raw_als;\n\n#include <Adafruit_MCP23X17.h>  //http://librarymanager/All#Adafruit_MCP23017\nAdafruit_MCP23X17 mcp;\n\n// Added definitions for the functionality of RAK14003\nconst uint8_t LED_0 = 0;      // PA0 (17) of MCP23017\nconst uint8_t LED_1 = 1;      // PA1 (18) of MCP23017\nconst uint8_t LED_2 = 2;      // PA2 (19) of MCP23017\nconst uint8_t LED_3 = 3;      // PA3 (20) of MCP23017\nconst uint8_t LED_4 = 4;      // PA4 (21) of MCP23017\nconst uint8_t LED_5 = 5;      // PA5 (22) of MCP23017\nconst uint8_t LED_6 = 6;      // PA6 (23) of MCP23017\nconst uint8_t LED_7 = 7;      // PA7 (24) of MCP23017\nconst uint8_t LED_8 = 8;      // PB0 (25) of MCP23017\nconst uint8_t LED_9 = 9;      // PB1 (26) of MCP23017\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define RAK4631_BOARD true\n#else\n#define RAK4631_BOARD false\n#endif\n\nbool doOTAA = true;                                               // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                                       /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                                     /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5                               /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                                        /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;                           /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;                 /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                              /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = { LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF };\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = { BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler };\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xE9, 0x0D, 0x28, 0x1D, 0x92, 0x3D, 0xE4, 0x9F, 0xD9, 0xF7, 0xE0, 0x5F, 0x39, 0x10, 0x55, 0x71 };\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };\nuint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                                            /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];               //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = { m_lora_app_data_buffer, 0, 0, 0, 0 };  //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {\n\n// Initialize Serial for debug output\npinMode(LED_BLUE, OUTPUT);\ndigitalWrite(LED_BLUE, HIGH);\n\n// Sensor Power Switch\npinMode(WB_IO2, OUTPUT);\ndigitalWrite(WB_IO2, HIGH);\n\n// Reset RAK14003 module\npinMode(WB_IO4, OUTPUT);\ndigitalWrite(WB_IO4, HIGH);\ndelay(10);\ndigitalWrite(WB_IO4, LOW);\ndelay(10);\ndigitalWrite(WB_IO4, HIGH);\ndelay(10);\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial) {\nif ((millis() - timeout) < 5000) {\ndelay(100);\n} else {\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA) {\nSerial.println(\"Type: OTAA\");\n} else {\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion) {\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA) {\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n} else {\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0) {\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"================================\");\nSerial.println(\"RAK12019 + RAK12010 LoRaWAN Code\");\nSerial.println(\"================================\");\n\nif (!VMEL.begin())\n{\nSerial.println(\"Sensor not found\");\nwhile (1);\n}\n\nVMEL.setGain(VEML7700_GAIN_1);\nVMEL.setIntegrationTime(VEML7700_IT_800MS);\n\nSerial.print(F(\"Gain: \"));\nswitch (VMEL.getGain())\n{\ncase VEML7700_GAIN_1: Serial.println(\"1\"); break;\ncase VEML7700_GAIN_2: Serial.println(\"2\"); break;\ncase VEML7700_GAIN_1_4: Serial.println(\"1/4\"); break;\ncase VEML7700_GAIN_1_8: Serial.println(\"1/8\"); break;\n}\n\nSerial.print(F(\"Integration Time (ms): \"));\nswitch (VMEL.getIntegrationTime())\n{\ncase VEML7700_IT_25MS: Serial.println(\"25\"); break;\ncase VEML7700_IT_50MS: Serial.println(\"50\"); break;\ncase VEML7700_IT_100MS: Serial.println(\"100\"); break;\ncase VEML7700_IT_200MS: Serial.println(\"200\"); break;\ncase VEML7700_IT_400MS: Serial.println(\"400\"); break;\ncase VEML7700_IT_800MS: Serial.println(\"800\"); break;\n}\n\nSerial.println(\"RAK12019 test\");\nWire.begin();\nif (!ltr.init())\n{\nSerial.println(\"Couldn't find LTR sensor!\");\nwhile (1)\ndelay(10);\n}\nSerial.println(\"Found LTR390 sensor!\");\n\n//set to LTR390_MODE_UVS,get ultraviolet light data.\nltr.setMode(LTR390_MODE_UVS);  // UVS Mode\n\nSerial.println(\"In UVS mode\");\n\nltr.setGain(LTR390_GAIN_3);\nSerial.print(\"Gain : \");\nswitch (ltr.getGain())\n{\ncase LTR390_GAIN_1:\nSerial.println(1);\nbreak;\ncase LTR390_GAIN_3:\nSerial.println(3);\nbreak;\ncase LTR390_GAIN_6:\nSerial.println(6);\nbreak;\ncase LTR390_GAIN_9:\nSerial.println(9);\nbreak;\ncase LTR390_GAIN_18:\nSerial.println(18);\nbreak;\ndefault:\nSerial.println(\"Failed to set gain\");\nbreak;\n}\nltr.setResolution(LTR390_RESOLUTION_16BIT);\nSerial.print(\"Integration Time (ms): \");\nswitch (ltr.getResolution())\n{\ncase LTR390_RESOLUTION_13BIT:\nSerial.println(13);\nbreak;\ncase LTR390_RESOLUTION_16BIT:\nSerial.println(16);\nbreak;\ncase LTR390_RESOLUTION_17BIT:\nSerial.println(17);\nbreak;\ncase LTR390_RESOLUTION_18BIT:\nSerial.println(18);\nbreak;\ncase LTR390_RESOLUTION_19BIT:\nSerial.println(19);\nbreak;\ncase LTR390_RESOLUTION_20BIT:\nSerial.println(20);\nbreak;\ndefault:\nSerial.println(\"Failed to set Integration Time\");\nbreak;\n}\n\nltr.setThresholds(100, 1000); //Set the interrupt output threshold range for lower and upper.\n\nltr.configInterrupt(true, LTR390_MODE_UVS);\n\n// For RAK14003\nmcp.begin_I2C(0x24);\n\n// Added for the functionality of RAK14003\n\nWire.begin();    // initialize I2C serial bus\n\n// Configuration of MCP23017 I/O ports\nmcp.pinMode(LED_0, OUTPUT);     // Red LED; Top most\nmcp.pinMode(LED_1, OUTPUT);     // Red LED\nmcp.pinMode(LED_2, OUTPUT);     // Orange LED\nmcp.pinMode(LED_3, OUTPUT);     // Orange LED\nmcp.pinMode(LED_4, OUTPUT);     // Orange LED\nmcp.pinMode(LED_5, OUTPUT);     // Green LED\nmcp.pinMode(LED_6, OUTPUT);     // Green LED\nmcp.pinMode(LED_7, OUTPUT);     // Green LED\nmcp.pinMode(LED_8, OUTPUT);     // Green LED\nmcp.pinMode(LED_9, OUTPUT);     // Green LED; Bottom\n\n// Initially Turn OFF all LEDs\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, HIGH);\n\n}\n\nvoid loop() {\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\n// Trial # 1\n// Data from RAK12019\nif (ltr.newDataAvailable())\n{\nuvi = ltr.getUVI();\nuvs = ltr.readUVS();\n}\n\n// Data from RAK12010\nlux = VMEL.readLux();\nwhite = VMEL.readWhite();\nraw_als = VMEL.readALS();\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\n\n// From RAK12019 module\nSerial.print(\"UVI: \");\nSerial.println(uvi);          // Uvi data from RAK12019\nSerial.print(\"UVS: \");\nSerial.println(uvs);            // Uvs data from RAK12019\n\n// From RAK12010\nSerial.print(\"Lux: \");\nSerial.print(lux);\nSerial.println(\" lx \");\nSerial.print(\"White: \");\nSerial.println(white);\nSerial.print(\"Raw ALS: \");\nSerial.println(raw_als);\n\n// Result of uvi to be displayed via RAK14003 module\nif (uvi <= 0.4)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, HIGH);\n}\n\nelse if (uvi > 0.5 && uvi <= 1)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 1.5 && uvi <= 2)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 2.5 && uvi <= 3)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 3.5 && uvi <= 4)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 4.5 && uvi <= 5)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 5.5 && uvi <= 6)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 6.5 && uvi <= 7)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 7.5 && uvi <= 8)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 8.5 && uvi <= 9.5)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, LOW);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi >= 10)\n{\nmcp.digitalWrite(LED_0, LOW);\nmcp.digitalWrite(LED_1, LOW);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\ndelay(10000);\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void) {\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void) {\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data) {\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class) {\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void) {\nif (lmh_join_status_get() != LMH_SET) {\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\ndata = \" Uvi Data: \" + String(uvi) + \" Uvs Data: \" + String(uvs) + \" Lux Data: \" + String(lux) + \" lx \" ;\n\nSerial.println(data);\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\nuint16_t uvi_data = uvi;            // Uvi data from RAK12019\nuint32_t uvs_data = uvs;            // Uvs data from RAK12019\nuint32_t lux_data = lux;            // Lux data from RAK12010\n\nm_lora_app_data.buffer[i++] = 0x01;  // byte[0]\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\n// Data from RAK12019 module\nm_lora_app_data.buffer[i++] = (uint8_t)((uvi_data & 0x0000FF00) >> 8);     // byte[1]\nm_lora_app_data.buffer[i++] = (uint8_t)(uvi_data & 0x000000FF);            // byte[2]\n\n// Data from RAK12019 module\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0xFF000000) >> 24);    // byte[3]\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0x00FF0000) >> 16);    // byte[4]\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0x0000FF00) >> 8);     // byte[5]\nm_lora_app_data.buffer[i++] = (uint8_t)(uvs_data & 0x000000FF);            // byte[6]\n\n// Data from RAK12010 module\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0xFF000000) >> 24);    // byte[7]\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0x00FF0000) >> 16);    // byte[8]\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0x0000FF00) >> 8);     // byte[9]\nm_lora_app_data.buffer[i++] = (uint8_t)(lux_data & 0x000000FF);            // byte[10]\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS) {\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n} else {\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xE9, 0x0D, 0x28, 0x1D, 0x92, 0x3D, 0xE4, 0x9F, 0xD9, 0xF7, 0xE0, 0x5F, 0x39, 0x10, 0x55, 0x71 };\n\n```  \n> **Image:** OTAA device successfully registered to TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "e26d6f7281edff6f982d722f28b7bedb", "product_family": "wisblock", "product_id": "kit6-light-and-color", "category": "How-To", "title": "WisBlock IoT Education Kit - Light & Color Quick Start Guide > WisBlock IoT Education Kit - Light & Color Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock IoT Education Kit - Light & Color using TTN and Qubitro > UV Index & UV Intensity Monitoring LoRaWAN Application > LoRaWAN Code for UV Index & UV Intensity Monitoring > Programming UV Index & UV Intensity Monitoring Device with Arduino IDE [CODE]", "content": "// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);", "keywords": ["Arduino IDE", "RAK4631", "UV Index", "UV Intensity", "LoRaWAN", "SX126x-Arduino"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **UV Index & UV Intensity Monitoring** device. Just copy the code below for **UV Index & UV Intensity Monitoring LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the example </summary>  \n```c\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h>  //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n#include \"UVlight_LTR390.h\"                // http://librarymanager/All#RAK12019_LTR390\nUVlight_LTR390 ltr = UVlight_LTR390();\n\n#include \"Light_VEML7700.h\"                // http://librarymanager/All#Light_veml7700\nLight_VEML7700 VMEL = Light_VEML7700();\n\nuint16_t uvi;\nuint32_t uvs;\nuint32_t lux;\nuint32_t white;\nuint32_t raw_als;\n\n#include <Adafruit_MCP23X17.h>  //http://librarymanager/All#Adafruit_MCP23017\nAdafruit_MCP23X17 mcp;\n\n// Added definitions for the functionality of RAK14003\nconst uint8_t LED_0 = 0;      // PA0 (17) of MCP23017\nconst uint8_t LED_1 = 1;      // PA1 (18) of MCP23017\nconst uint8_t LED_2 = 2;      // PA2 (19) of MCP23017\nconst uint8_t LED_3 = 3;      // PA3 (20) of MCP23017\nconst uint8_t LED_4 = 4;      // PA4 (21) of MCP23017\nconst uint8_t LED_5 = 5;      // PA5 (22) of MCP23017\nconst uint8_t LED_6 = 6;      // PA6 (23) of MCP23017\nconst uint8_t LED_7 = 7;      // PA7 (24) of MCP23017\nconst uint8_t LED_8 = 8;      // PB0 (25) of MCP23017\nconst uint8_t LED_9 = 9;      // PB1 (26) of MCP23017\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define RAK4631_BOARD true\n#else\n#define RAK4631_BOARD false\n#endif\n\nbool doOTAA = true;                                               // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                                       /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                                     /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5                               /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                                        /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;                           /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;                 /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                              /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = { LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF };\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = { BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler };\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xE9, 0x0D, 0x28, 0x1D, 0x92, 0x3D, 0xE4, 0x9F, 0xD9, 0xF7, 0xE0, 0x5F, 0x39, 0x10, 0x55, 0x71 };\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };\nuint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                                            /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];               //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = { m_lora_app_data_buffer, 0, 0, 0, 0 };  //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {\n\n// Initialize Serial for debug output\npinMode(LED_BLUE, OUTPUT);\ndigitalWrite(LED_BLUE, HIGH);\n\n// Sensor Power Switch\npinMode(WB_IO2, OUTPUT);\ndigitalWrite(WB_IO2, HIGH);\n\n// Reset RAK14003 module\npinMode(WB_IO4, OUTPUT);\ndigitalWrite(WB_IO4, HIGH);\ndelay(10);\ndigitalWrite(WB_IO4, LOW);\ndelay(10);\ndigitalWrite(WB_IO4, HIGH);\ndelay(10);\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial) {\nif ((millis() - timeout) < 5000) {\ndelay(100);\n} else {\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA) {\nSerial.println(\"Type: OTAA\");\n} else {\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion) {\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA) {\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n} else {\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0) {\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"================================\");\nSerial.println(\"RAK12019 + RAK12010 LoRaWAN Code\");\nSerial.println(\"================================\");\n\nif (!VMEL.begin())\n{\nSerial.println(\"Sensor not found\");\nwhile (1);\n}\n\nVMEL.setGain(VEML7700_GAIN_1);\nVMEL.setIntegrationTime(VEML7700_IT_800MS);\n\nSerial.print(F(\"Gain: \"));\nswitch (VMEL.getGain())\n{\ncase VEML7700_GAIN_1: Serial.println(\"1\"); break;\ncase VEML7700_GAIN_2: Serial.println(\"2\"); break;\ncase VEML7700_GAIN_1_4: Serial.println(\"1/4\"); break;\ncase VEML7700_GAIN_1_8: Serial.println(\"1/8\"); break;\n}\n\nSerial.print(F(\"Integration Time (ms): \"));\nswitch (VMEL.getIntegrationTime())\n{\ncase VEML7700_IT_25MS: Serial.println(\"25\"); break;\ncase VEML7700_IT_50MS: Serial.println(\"50\"); break;\ncase VEML7700_IT_100MS: Serial.println(\"100\"); break;\ncase VEML7700_IT_200MS: Serial.println(\"200\"); break;\ncase VEML7700_IT_400MS: Serial.println(\"400\"); break;\ncase VEML7700_IT_800MS: Serial.println(\"800\"); break;\n}\n\nSerial.println(\"RAK12019 test\");\nWire.begin();\nif (!ltr.init())\n{\nSerial.println(\"Couldn't find LTR sensor!\");\nwhile (1)\ndelay(10);\n}\nSerial.println(\"Found LTR390 sensor!\");\n\n//set to LTR390_MODE_UVS,get ultraviolet light data.\nltr.setMode(LTR390_MODE_UVS);  // UVS Mode\n\nSerial.println(\"In UVS mode\");\n\nltr.setGain(LTR390_GAIN_3);\nSerial.print(\"Gain : \");\nswitch (ltr.getGain())\n{\ncase LTR390_GAIN_1:\nSerial.println(1);\nbreak;\ncase LTR390_GAIN_3:\nSerial.println(3);\nbreak;\ncase LTR390_GAIN_6:\nSerial.println(6);\nbreak;\ncase LTR390_GAIN_9:\nSerial.println(9);\nbreak;\ncase LTR390_GAIN_18:\nSerial.println(18);\nbreak;\ndefault:\nSerial.println(\"Failed to set gain\");\nbreak;\n}\nltr.setResolution(LTR390_RESOLUTION_16BIT);\nSerial.print(\"Integration Time (ms): \");\nswitch (ltr.getResolution())\n{\ncase LTR390_RESOLUTION_13BIT:\nSerial.println(13);\nbreak;\ncase LTR390_RESOLUTION_16BIT:\nSerial.println(16);\nbreak;\ncase LTR390_RESOLUTION_17BIT:\nSerial.println(17);\nbreak;\ncase LTR390_RESOLUTION_18BIT:\nSerial.println(18);\nbreak;\ncase LTR390_RESOLUTION_19BIT:\nSerial.println(19);\nbreak;\ncase LTR390_RESOLUTION_20BIT:\nSerial.println(20);\nbreak;\ndefault:\nSerial.println(\"Failed to set Integration Time\");\nbreak;\n}\n\nltr.setThresholds(100, 1000); //Set the interrupt output threshold range for lower and upper.\n\nltr.configInterrupt(true, LTR390_MODE_UVS);\n\n// For RAK14003\nmcp.begin_I2C(0x24);\n\n// Added for the functionality of RAK14003\n\nWire.begin();    // initialize I2C serial bus\n\n// Configuration of MCP23017 I/O ports\nmcp.pinMode(LED_0, OUTPUT);     // Red LED; Top most\nmcp.pinMode(LED_1, OUTPUT);     // Red LED\nmcp.pinMode(LED_2, OUTPUT);     // Orange LED\nmcp.pinMode(LED_3, OUTPUT);     // Orange LED\nmcp.pinMode(LED_4, OUTPUT);     // Orange LED\nmcp.pinMode(LED_5, OUTPUT);     // Green LED\nmcp.pinMode(LED_6, OUTPUT);     // Green LED\nmcp.pinMode(LED_7, OUTPUT);     // Green LED\nmcp.pinMode(LED_8, OUTPUT);     // Green LED\nmcp.pinMode(LED_9, OUTPUT);     // Green LED; Bottom\n\n// Initially Turn OFF all LEDs\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, HIGH);\n\n}\n\nvoid loop() {\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\n// Trial # 1\n// Data from RAK12019\nif (ltr.newDataAvailable())\n{\nuvi = ltr.getUVI();\nuvs = ltr.readUVS();\n}\n\n// Data from RAK12010\nlux = VMEL.readLux();\nwhite = VMEL.readWhite();\nraw_als = VMEL.readALS();\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\n\n// From RAK12019 module\nSerial.print(\"UVI: \");\nSerial.println(uvi);          // Uvi data from RAK12019\nSerial.print(\"UVS: \");\nSerial.println(uvs);            // Uvs data from RAK12019\n\n// From RAK12010\nSerial.print(\"Lux: \");\nSerial.print(lux);\nSerial.println(\" lx \");\nSerial.print(\"White: \");\nSerial.println(white);\nSerial.print(\"Raw ALS: \");\nSerial.println(raw_als);\n\n// Result of uvi to be displayed via RAK14003 module\nif (uvi <= 0.4)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, HIGH);\n}\n\nelse if (uvi > 0.5 && uvi <= 1)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 1.5 && uvi <= 2)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 2.5 && uvi <= 3)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 3.5 && uvi <= 4)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 4.5 && uvi <= 5)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 5.5 && uvi <= 6)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 6.5 && uvi <= 7)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 7.5 && uvi <= 8)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 8.5 && uvi <= 9.5)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, LOW);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi >= 10)\n{\nmcp.digitalWrite(LED_0, LOW);\nmcp.digitalWrite(LED_1, LOW);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\ndelay(10000);\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void) {\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void) {\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data) {\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class) {\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void) {\nif (lmh_join_status_get() != LMH_SET) {\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\ndata = \" Uvi Data: \" + String(uvi) + \" Uvs Data: \" + String(uvs) + \" Lux Data: \" + String(lux) + \" lx \" ;\n\nSerial.println(data);\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\nuint16_t uvi_data = uvi;            // Uvi data from RAK12019\nuint32_t uvs_data = uvs;            // Uvs data from RAK12019\nuint32_t lux_data = lux;            // Lux data from RAK12010\n\nm_lora_app_data.buffer[i++] = 0x01;  // byte[0]\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\n// Data from RAK12019 module\nm_lora_app_data.buffer[i++] = (uint8_t)((uvi_data & 0x0000FF00) >> 8);     // byte[1]\nm_lora_app_data.buffer[i++] = (uint8_t)(uvi_data & 0x000000FF);            // byte[2]\n\n// Data from RAK12019 module\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0xFF000000) >> 24);    // byte[3]\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0x00FF0000) >> 16);    // byte[4]\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0x0000FF00) >> 8);     // byte[5]\nm_lora_app_data.buffer[i++] = (uint8_t)(uvs_data & 0x000000FF);            // byte[6]\n\n// Data from RAK12010 module\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0xFF000000) >> 24);    // byte[7]\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0x00FF0000) >> 16);    // byte[8]\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0x0000FF00) >> 8);     // byte[9]\nm_lora_app_data.buffer[i++] = (uint8_t)(lux_data & 0x000000FF);            // byte[10]\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS) {\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n} else {\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xE9, 0x0D, 0x28, 0x1D, 0x92, 0x3D, 0xE4, 0x9F, 0xD9, 0xF7, 0xE0, 0x5F, 0x39, 0x10, 0x55, 0x71 };\n\n```  \n> **Image:** OTAA device successfully registered to TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "fdb4a52a759cce10e2cabacdbcd81784", "product_family": "wisblock", "product_id": "kit6-light-and-color", "category": "How-To", "title": "WisBlock IoT Education Kit - Light & Color Quick Start Guide > WisBlock IoT Education Kit - Light & Color Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock IoT Education Kit - Light & Color using TTN and Qubitro > UV Index & UV Intensity Monitoring LoRaWAN Application > LoRaWAN Code for UV Index & UV Intensity Monitoring > Programming UV Index & UV Intensity Monitoring Device with Arduino IDE [CODE]", "content": "/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = { BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler };\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };", "keywords": ["Arduino IDE", "RAK4631", "UV Index", "UV Intensity", "LoRaWAN", "SX126x-Arduino"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **UV Index & UV Intensity Monitoring** device. Just copy the code below for **UV Index & UV Intensity Monitoring LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the example </summary>  \n```c\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h>  //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n#include \"UVlight_LTR390.h\"                // http://librarymanager/All#RAK12019_LTR390\nUVlight_LTR390 ltr = UVlight_LTR390();\n\n#include \"Light_VEML7700.h\"                // http://librarymanager/All#Light_veml7700\nLight_VEML7700 VMEL = Light_VEML7700();\n\nuint16_t uvi;\nuint32_t uvs;\nuint32_t lux;\nuint32_t white;\nuint32_t raw_als;\n\n#include <Adafruit_MCP23X17.h>  //http://librarymanager/All#Adafruit_MCP23017\nAdafruit_MCP23X17 mcp;\n\n// Added definitions for the functionality of RAK14003\nconst uint8_t LED_0 = 0;      // PA0 (17) of MCP23017\nconst uint8_t LED_1 = 1;      // PA1 (18) of MCP23017\nconst uint8_t LED_2 = 2;      // PA2 (19) of MCP23017\nconst uint8_t LED_3 = 3;      // PA3 (20) of MCP23017\nconst uint8_t LED_4 = 4;      // PA4 (21) of MCP23017\nconst uint8_t LED_5 = 5;      // PA5 (22) of MCP23017\nconst uint8_t LED_6 = 6;      // PA6 (23) of MCP23017\nconst uint8_t LED_7 = 7;      // PA7 (24) of MCP23017\nconst uint8_t LED_8 = 8;      // PB0 (25) of MCP23017\nconst uint8_t LED_9 = 9;      // PB1 (26) of MCP23017\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define RAK4631_BOARD true\n#else\n#define RAK4631_BOARD false\n#endif\n\nbool doOTAA = true;                                               // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                                       /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                                     /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5                               /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                                        /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;                           /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;                 /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                              /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = { LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF };\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = { BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler };\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xE9, 0x0D, 0x28, 0x1D, 0x92, 0x3D, 0xE4, 0x9F, 0xD9, 0xF7, 0xE0, 0x5F, 0x39, 0x10, 0x55, 0x71 };\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };\nuint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                                            /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];               //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = { m_lora_app_data_buffer, 0, 0, 0, 0 };  //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {\n\n// Initialize Serial for debug output\npinMode(LED_BLUE, OUTPUT);\ndigitalWrite(LED_BLUE, HIGH);\n\n// Sensor Power Switch\npinMode(WB_IO2, OUTPUT);\ndigitalWrite(WB_IO2, HIGH);\n\n// Reset RAK14003 module\npinMode(WB_IO4, OUTPUT);\ndigitalWrite(WB_IO4, HIGH);\ndelay(10);\ndigitalWrite(WB_IO4, LOW);\ndelay(10);\ndigitalWrite(WB_IO4, HIGH);\ndelay(10);\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial) {\nif ((millis() - timeout) < 5000) {\ndelay(100);\n} else {\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA) {\nSerial.println(\"Type: OTAA\");\n} else {\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion) {\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA) {\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n} else {\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0) {\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"================================\");\nSerial.println(\"RAK12019 + RAK12010 LoRaWAN Code\");\nSerial.println(\"================================\");\n\nif (!VMEL.begin())\n{\nSerial.println(\"Sensor not found\");\nwhile (1);\n}\n\nVMEL.setGain(VEML7700_GAIN_1);\nVMEL.setIntegrationTime(VEML7700_IT_800MS);\n\nSerial.print(F(\"Gain: \"));\nswitch (VMEL.getGain())\n{\ncase VEML7700_GAIN_1: Serial.println(\"1\"); break;\ncase VEML7700_GAIN_2: Serial.println(\"2\"); break;\ncase VEML7700_GAIN_1_4: Serial.println(\"1/4\"); break;\ncase VEML7700_GAIN_1_8: Serial.println(\"1/8\"); break;\n}\n\nSerial.print(F(\"Integration Time (ms): \"));\nswitch (VMEL.getIntegrationTime())\n{\ncase VEML7700_IT_25MS: Serial.println(\"25\"); break;\ncase VEML7700_IT_50MS: Serial.println(\"50\"); break;\ncase VEML7700_IT_100MS: Serial.println(\"100\"); break;\ncase VEML7700_IT_200MS: Serial.println(\"200\"); break;\ncase VEML7700_IT_400MS: Serial.println(\"400\"); break;\ncase VEML7700_IT_800MS: Serial.println(\"800\"); break;\n}\n\nSerial.println(\"RAK12019 test\");\nWire.begin();\nif (!ltr.init())\n{\nSerial.println(\"Couldn't find LTR sensor!\");\nwhile (1)\ndelay(10);\n}\nSerial.println(\"Found LTR390 sensor!\");\n\n//set to LTR390_MODE_UVS,get ultraviolet light data.\nltr.setMode(LTR390_MODE_UVS);  // UVS Mode\n\nSerial.println(\"In UVS mode\");\n\nltr.setGain(LTR390_GAIN_3);\nSerial.print(\"Gain : \");\nswitch (ltr.getGain())\n{\ncase LTR390_GAIN_1:\nSerial.println(1);\nbreak;\ncase LTR390_GAIN_3:\nSerial.println(3);\nbreak;\ncase LTR390_GAIN_6:\nSerial.println(6);\nbreak;\ncase LTR390_GAIN_9:\nSerial.println(9);\nbreak;\ncase LTR390_GAIN_18:\nSerial.println(18);\nbreak;\ndefault:\nSerial.println(\"Failed to set gain\");\nbreak;\n}\nltr.setResolution(LTR390_RESOLUTION_16BIT);\nSerial.print(\"Integration Time (ms): \");\nswitch (ltr.getResolution())\n{\ncase LTR390_RESOLUTION_13BIT:\nSerial.println(13);\nbreak;\ncase LTR390_RESOLUTION_16BIT:\nSerial.println(16);\nbreak;\ncase LTR390_RESOLUTION_17BIT:\nSerial.println(17);\nbreak;\ncase LTR390_RESOLUTION_18BIT:\nSerial.println(18);\nbreak;\ncase LTR390_RESOLUTION_19BIT:\nSerial.println(19);\nbreak;\ncase LTR390_RESOLUTION_20BIT:\nSerial.println(20);\nbreak;\ndefault:\nSerial.println(\"Failed to set Integration Time\");\nbreak;\n}\n\nltr.setThresholds(100, 1000); //Set the interrupt output threshold range for lower and upper.\n\nltr.configInterrupt(true, LTR390_MODE_UVS);\n\n// For RAK14003\nmcp.begin_I2C(0x24);\n\n// Added for the functionality of RAK14003\n\nWire.begin();    // initialize I2C serial bus\n\n// Configuration of MCP23017 I/O ports\nmcp.pinMode(LED_0, OUTPUT);     // Red LED; Top most\nmcp.pinMode(LED_1, OUTPUT);     // Red LED\nmcp.pinMode(LED_2, OUTPUT);     // Orange LED\nmcp.pinMode(LED_3, OUTPUT);     // Orange LED\nmcp.pinMode(LED_4, OUTPUT);     // Orange LED\nmcp.pinMode(LED_5, OUTPUT);     // Green LED\nmcp.pinMode(LED_6, OUTPUT);     // Green LED\nmcp.pinMode(LED_7, OUTPUT);     // Green LED\nmcp.pinMode(LED_8, OUTPUT);     // Green LED\nmcp.pinMode(LED_9, OUTPUT);     // Green LED; Bottom\n\n// Initially Turn OFF all LEDs\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, HIGH);\n\n}\n\nvoid loop() {\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\n// Trial # 1\n// Data from RAK12019\nif (ltr.newDataAvailable())\n{\nuvi = ltr.getUVI();\nuvs = ltr.readUVS();\n}\n\n// Data from RAK12010\nlux = VMEL.readLux();\nwhite = VMEL.readWhite();\nraw_als = VMEL.readALS();\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\n\n// From RAK12019 module\nSerial.print(\"UVI: \");\nSerial.println(uvi);          // Uvi data from RAK12019\nSerial.print(\"UVS: \");\nSerial.println(uvs);            // Uvs data from RAK12019\n\n// From RAK12010\nSerial.print(\"Lux: \");\nSerial.print(lux);\nSerial.println(\" lx \");\nSerial.print(\"White: \");\nSerial.println(white);\nSerial.print(\"Raw ALS: \");\nSerial.println(raw_als);\n\n// Result of uvi to be displayed via RAK14003 module\nif (uvi <= 0.4)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, HIGH);\n}\n\nelse if (uvi > 0.5 && uvi <= 1)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 1.5 && uvi <= 2)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 2.5 && uvi <= 3)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 3.5 && uvi <= 4)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 4.5 && uvi <= 5)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 5.5 && uvi <= 6)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 6.5 && uvi <= 7)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 7.5 && uvi <= 8)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 8.5 && uvi <= 9.5)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, LOW);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi >= 10)\n{\nmcp.digitalWrite(LED_0, LOW);\nmcp.digitalWrite(LED_1, LOW);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\ndelay(10000);\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void) {\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void) {\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data) {\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class) {\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void) {\nif (lmh_join_status_get() != LMH_SET) {\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\ndata = \" Uvi Data: \" + String(uvi) + \" Uvs Data: \" + String(uvs) + \" Lux Data: \" + String(lux) + \" lx \" ;\n\nSerial.println(data);\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\nuint16_t uvi_data = uvi;            // Uvi data from RAK12019\nuint32_t uvs_data = uvs;            // Uvs data from RAK12019\nuint32_t lux_data = lux;            // Lux data from RAK12010\n\nm_lora_app_data.buffer[i++] = 0x01;  // byte[0]\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\n// Data from RAK12019 module\nm_lora_app_data.buffer[i++] = (uint8_t)((uvi_data & 0x0000FF00) >> 8);     // byte[1]\nm_lora_app_data.buffer[i++] = (uint8_t)(uvi_data & 0x000000FF);            // byte[2]\n\n// Data from RAK12019 module\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0xFF000000) >> 24);    // byte[3]\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0x00FF0000) >> 16);    // byte[4]\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0x0000FF00) >> 8);     // byte[5]\nm_lora_app_data.buffer[i++] = (uint8_t)(uvs_data & 0x000000FF);            // byte[6]\n\n// Data from RAK12010 module\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0xFF000000) >> 24);    // byte[7]\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0x00FF0000) >> 16);    // byte[8]\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0x0000FF00) >> 8);     // byte[9]\nm_lora_app_data.buffer[i++] = (uint8_t)(lux_data & 0x000000FF);            // byte[10]\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS) {\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n} else {\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xE9, 0x0D, 0x28, 0x1D, 0x92, 0x3D, 0xE4, 0x9F, 0xD9, 0xF7, 0xE0, 0x5F, 0x39, 0x10, 0x55, 0x71 };\n\n```  \n> **Image:** OTAA device successfully registered to TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "82ad75c118acdb3b92184ace910d1075", "product_family": "wisblock", "product_id": "kit6-light-and-color", "category": "How-To", "title": "WisBlock IoT Education Kit - Light & Color Quick Start Guide > WisBlock IoT Education Kit - Light & Color Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock IoT Education Kit - Light & Color using TTN and Qubitro > UV Index & UV Intensity Monitoring LoRaWAN Application > LoRaWAN Code for UV Index & UV Intensity Monitoring > Programming UV Index & UV Intensity Monitoring Device with Arduino IDE [CODE]", "content": "uint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xE9, 0x0D, 0x28, 0x1D, 0x92, 0x3D, 0xE4, 0x9F, 0xD9, 0xF7, 0xE0, 0x5F, 0x39, 0x10, 0x55, 0x71 };", "keywords": ["Arduino IDE", "RAK4631", "UV Index", "UV Intensity", "LoRaWAN", "SX126x-Arduino"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **UV Index & UV Intensity Monitoring** device. Just copy the code below for **UV Index & UV Intensity Monitoring LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the example </summary>  \n```c\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h>  //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n#include \"UVlight_LTR390.h\"                // http://librarymanager/All#RAK12019_LTR390\nUVlight_LTR390 ltr = UVlight_LTR390();\n\n#include \"Light_VEML7700.h\"                // http://librarymanager/All#Light_veml7700\nLight_VEML7700 VMEL = Light_VEML7700();\n\nuint16_t uvi;\nuint32_t uvs;\nuint32_t lux;\nuint32_t white;\nuint32_t raw_als;\n\n#include <Adafruit_MCP23X17.h>  //http://librarymanager/All#Adafruit_MCP23017\nAdafruit_MCP23X17 mcp;\n\n// Added definitions for the functionality of RAK14003\nconst uint8_t LED_0 = 0;      // PA0 (17) of MCP23017\nconst uint8_t LED_1 = 1;      // PA1 (18) of MCP23017\nconst uint8_t LED_2 = 2;      // PA2 (19) of MCP23017\nconst uint8_t LED_3 = 3;      // PA3 (20) of MCP23017\nconst uint8_t LED_4 = 4;      // PA4 (21) of MCP23017\nconst uint8_t LED_5 = 5;      // PA5 (22) of MCP23017\nconst uint8_t LED_6 = 6;      // PA6 (23) of MCP23017\nconst uint8_t LED_7 = 7;      // PA7 (24) of MCP23017\nconst uint8_t LED_8 = 8;      // PB0 (25) of MCP23017\nconst uint8_t LED_9 = 9;      // PB1 (26) of MCP23017\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define RAK4631_BOARD true\n#else\n#define RAK4631_BOARD false\n#endif\n\nbool doOTAA = true;                                               // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                                       /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                                     /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5                               /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                                        /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;                           /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;                 /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                              /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = { LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF };\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = { BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler };\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xE9, 0x0D, 0x28, 0x1D, 0x92, 0x3D, 0xE4, 0x9F, 0xD9, 0xF7, 0xE0, 0x5F, 0x39, 0x10, 0x55, 0x71 };\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };\nuint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                                            /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];               //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = { m_lora_app_data_buffer, 0, 0, 0, 0 };  //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {\n\n// Initialize Serial for debug output\npinMode(LED_BLUE, OUTPUT);\ndigitalWrite(LED_BLUE, HIGH);\n\n// Sensor Power Switch\npinMode(WB_IO2, OUTPUT);\ndigitalWrite(WB_IO2, HIGH);\n\n// Reset RAK14003 module\npinMode(WB_IO4, OUTPUT);\ndigitalWrite(WB_IO4, HIGH);\ndelay(10);\ndigitalWrite(WB_IO4, LOW);\ndelay(10);\ndigitalWrite(WB_IO4, HIGH);\ndelay(10);\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial) {\nif ((millis() - timeout) < 5000) {\ndelay(100);\n} else {\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA) {\nSerial.println(\"Type: OTAA\");\n} else {\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion) {\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA) {\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n} else {\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0) {\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"================================\");\nSerial.println(\"RAK12019 + RAK12010 LoRaWAN Code\");\nSerial.println(\"================================\");\n\nif (!VMEL.begin())\n{\nSerial.println(\"Sensor not found\");\nwhile (1);\n}\n\nVMEL.setGain(VEML7700_GAIN_1);\nVMEL.setIntegrationTime(VEML7700_IT_800MS);\n\nSerial.print(F(\"Gain: \"));\nswitch (VMEL.getGain())\n{\ncase VEML7700_GAIN_1: Serial.println(\"1\"); break;\ncase VEML7700_GAIN_2: Serial.println(\"2\"); break;\ncase VEML7700_GAIN_1_4: Serial.println(\"1/4\"); break;\ncase VEML7700_GAIN_1_8: Serial.println(\"1/8\"); break;\n}\n\nSerial.print(F(\"Integration Time (ms): \"));\nswitch (VMEL.getIntegrationTime())\n{\ncase VEML7700_IT_25MS: Serial.println(\"25\"); break;\ncase VEML7700_IT_50MS: Serial.println(\"50\"); break;\ncase VEML7700_IT_100MS: Serial.println(\"100\"); break;\ncase VEML7700_IT_200MS: Serial.println(\"200\"); break;\ncase VEML7700_IT_400MS: Serial.println(\"400\"); break;\ncase VEML7700_IT_800MS: Serial.println(\"800\"); break;\n}\n\nSerial.println(\"RAK12019 test\");\nWire.begin();\nif (!ltr.init())\n{\nSerial.println(\"Couldn't find LTR sensor!\");\nwhile (1)\ndelay(10);\n}\nSerial.println(\"Found LTR390 sensor!\");\n\n//set to LTR390_MODE_UVS,get ultraviolet light data.\nltr.setMode(LTR390_MODE_UVS);  // UVS Mode\n\nSerial.println(\"In UVS mode\");\n\nltr.setGain(LTR390_GAIN_3);\nSerial.print(\"Gain : \");\nswitch (ltr.getGain())\n{\ncase LTR390_GAIN_1:\nSerial.println(1);\nbreak;\ncase LTR390_GAIN_3:\nSerial.println(3);\nbreak;\ncase LTR390_GAIN_6:\nSerial.println(6);\nbreak;\ncase LTR390_GAIN_9:\nSerial.println(9);\nbreak;\ncase LTR390_GAIN_18:\nSerial.println(18);\nbreak;\ndefault:\nSerial.println(\"Failed to set gain\");\nbreak;\n}\nltr.setResolution(LTR390_RESOLUTION_16BIT);\nSerial.print(\"Integration Time (ms): \");\nswitch (ltr.getResolution())\n{\ncase LTR390_RESOLUTION_13BIT:\nSerial.println(13);\nbreak;\ncase LTR390_RESOLUTION_16BIT:\nSerial.println(16);\nbreak;\ncase LTR390_RESOLUTION_17BIT:\nSerial.println(17);\nbreak;\ncase LTR390_RESOLUTION_18BIT:\nSerial.println(18);\nbreak;\ncase LTR390_RESOLUTION_19BIT:\nSerial.println(19);\nbreak;\ncase LTR390_RESOLUTION_20BIT:\nSerial.println(20);\nbreak;\ndefault:\nSerial.println(\"Failed to set Integration Time\");\nbreak;\n}\n\nltr.setThresholds(100, 1000); //Set the interrupt output threshold range for lower and upper.\n\nltr.configInterrupt(true, LTR390_MODE_UVS);\n\n// For RAK14003\nmcp.begin_I2C(0x24);\n\n// Added for the functionality of RAK14003\n\nWire.begin();    // initialize I2C serial bus\n\n// Configuration of MCP23017 I/O ports\nmcp.pinMode(LED_0, OUTPUT);     // Red LED; Top most\nmcp.pinMode(LED_1, OUTPUT);     // Red LED\nmcp.pinMode(LED_2, OUTPUT);     // Orange LED\nmcp.pinMode(LED_3, OUTPUT);     // Orange LED\nmcp.pinMode(LED_4, OUTPUT);     // Orange LED\nmcp.pinMode(LED_5, OUTPUT);     // Green LED\nmcp.pinMode(LED_6, OUTPUT);     // Green LED\nmcp.pinMode(LED_7, OUTPUT);     // Green LED\nmcp.pinMode(LED_8, OUTPUT);     // Green LED\nmcp.pinMode(LED_9, OUTPUT);     // Green LED; Bottom\n\n// Initially Turn OFF all LEDs\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, HIGH);\n\n}\n\nvoid loop() {\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\n// Trial # 1\n// Data from RAK12019\nif (ltr.newDataAvailable())\n{\nuvi = ltr.getUVI();\nuvs = ltr.readUVS();\n}\n\n// Data from RAK12010\nlux = VMEL.readLux();\nwhite = VMEL.readWhite();\nraw_als = VMEL.readALS();\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\n\n// From RAK12019 module\nSerial.print(\"UVI: \");\nSerial.println(uvi);          // Uvi data from RAK12019\nSerial.print(\"UVS: \");\nSerial.println(uvs);            // Uvs data from RAK12019\n\n// From RAK12010\nSerial.print(\"Lux: \");\nSerial.print(lux);\nSerial.println(\" lx \");\nSerial.print(\"White: \");\nSerial.println(white);\nSerial.print(\"Raw ALS: \");\nSerial.println(raw_als);\n\n// Result of uvi to be displayed via RAK14003 module\nif (uvi <= 0.4)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, HIGH);\n}\n\nelse if (uvi > 0.5 && uvi <= 1)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 1.5 && uvi <= 2)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 2.5 && uvi <= 3)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 3.5 && uvi <= 4)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 4.5 && uvi <= 5)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 5.5 && uvi <= 6)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 6.5 && uvi <= 7)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 7.5 && uvi <= 8)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 8.5 && uvi <= 9.5)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, LOW);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi >= 10)\n{\nmcp.digitalWrite(LED_0, LOW);\nmcp.digitalWrite(LED_1, LOW);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\ndelay(10000);\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void) {\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void) {\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data) {\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class) {\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void) {\nif (lmh_join_status_get() != LMH_SET) {\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\ndata = \" Uvi Data: \" + String(uvi) + \" Uvs Data: \" + String(uvs) + \" Lux Data: \" + String(lux) + \" lx \" ;\n\nSerial.println(data);\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\nuint16_t uvi_data = uvi;            // Uvi data from RAK12019\nuint32_t uvs_data = uvs;            // Uvs data from RAK12019\nuint32_t lux_data = lux;            // Lux data from RAK12010\n\nm_lora_app_data.buffer[i++] = 0x01;  // byte[0]\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\n// Data from RAK12019 module\nm_lora_app_data.buffer[i++] = (uint8_t)((uvi_data & 0x0000FF00) >> 8);     // byte[1]\nm_lora_app_data.buffer[i++] = (uint8_t)(uvi_data & 0x000000FF);            // byte[2]\n\n// Data from RAK12019 module\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0xFF000000) >> 24);    // byte[3]\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0x00FF0000) >> 16);    // byte[4]\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0x0000FF00) >> 8);     // byte[5]\nm_lora_app_data.buffer[i++] = (uint8_t)(uvs_data & 0x000000FF);            // byte[6]\n\n// Data from RAK12010 module\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0xFF000000) >> 24);    // byte[7]\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0x00FF0000) >> 16);    // byte[8]\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0x0000FF00) >> 8);     // byte[9]\nm_lora_app_data.buffer[i++] = (uint8_t)(lux_data & 0x000000FF);            // byte[10]\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS) {\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n} else {\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xE9, 0x0D, 0x28, 0x1D, 0x92, 0x3D, 0xE4, 0x9F, 0xD9, 0xF7, 0xE0, 0x5F, 0x39, 0x10, 0x55, 0x71 };\n\n```  \n> **Image:** OTAA device successfully registered to TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "bb1ae1fb81a51a3bb6ba823f6ab400ef", "product_family": "wisblock", "product_id": "kit6-light-and-color", "category": "How-To", "title": "WisBlock IoT Education Kit - Light & Color Quick Start Guide > WisBlock IoT Education Kit - Light & Color Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock IoT Education Kit - Light & Color using TTN and Qubitro > UV Index & UV Intensity Monitoring LoRaWAN Application > LoRaWAN Code for UV Index & UV Intensity Monitoring > Programming UV Index & UV Intensity Monitoring Device with Arduino IDE [CODE]", "content": "// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };\nuint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };", "keywords": ["Arduino IDE", "RAK4631", "UV Index", "UV Intensity", "LoRaWAN", "SX126x-Arduino"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **UV Index & UV Intensity Monitoring** device. Just copy the code below for **UV Index & UV Intensity Monitoring LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the example </summary>  \n```c\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h>  //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n#include \"UVlight_LTR390.h\"                // http://librarymanager/All#RAK12019_LTR390\nUVlight_LTR390 ltr = UVlight_LTR390();\n\n#include \"Light_VEML7700.h\"                // http://librarymanager/All#Light_veml7700\nLight_VEML7700 VMEL = Light_VEML7700();\n\nuint16_t uvi;\nuint32_t uvs;\nuint32_t lux;\nuint32_t white;\nuint32_t raw_als;\n\n#include <Adafruit_MCP23X17.h>  //http://librarymanager/All#Adafruit_MCP23017\nAdafruit_MCP23X17 mcp;\n\n// Added definitions for the functionality of RAK14003\nconst uint8_t LED_0 = 0;      // PA0 (17) of MCP23017\nconst uint8_t LED_1 = 1;      // PA1 (18) of MCP23017\nconst uint8_t LED_2 = 2;      // PA2 (19) of MCP23017\nconst uint8_t LED_3 = 3;      // PA3 (20) of MCP23017\nconst uint8_t LED_4 = 4;      // PA4 (21) of MCP23017\nconst uint8_t LED_5 = 5;      // PA5 (22) of MCP23017\nconst uint8_t LED_6 = 6;      // PA6 (23) of MCP23017\nconst uint8_t LED_7 = 7;      // PA7 (24) of MCP23017\nconst uint8_t LED_8 = 8;      // PB0 (25) of MCP23017\nconst uint8_t LED_9 = 9;      // PB1 (26) of MCP23017\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define RAK4631_BOARD true\n#else\n#define RAK4631_BOARD false\n#endif\n\nbool doOTAA = true;                                               // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                                       /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                                     /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5                               /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                                        /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;                           /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;                 /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                              /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = { LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF };\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = { BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler };\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xE9, 0x0D, 0x28, 0x1D, 0x92, 0x3D, 0xE4, 0x9F, 0xD9, 0xF7, 0xE0, 0x5F, 0x39, 0x10, 0x55, 0x71 };\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };\nuint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                                            /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];               //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = { m_lora_app_data_buffer, 0, 0, 0, 0 };  //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {\n\n// Initialize Serial for debug output\npinMode(LED_BLUE, OUTPUT);\ndigitalWrite(LED_BLUE, HIGH);\n\n// Sensor Power Switch\npinMode(WB_IO2, OUTPUT);\ndigitalWrite(WB_IO2, HIGH);\n\n// Reset RAK14003 module\npinMode(WB_IO4, OUTPUT);\ndigitalWrite(WB_IO4, HIGH);\ndelay(10);\ndigitalWrite(WB_IO4, LOW);\ndelay(10);\ndigitalWrite(WB_IO4, HIGH);\ndelay(10);\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial) {\nif ((millis() - timeout) < 5000) {\ndelay(100);\n} else {\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA) {\nSerial.println(\"Type: OTAA\");\n} else {\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion) {\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA) {\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n} else {\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0) {\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"================================\");\nSerial.println(\"RAK12019 + RAK12010 LoRaWAN Code\");\nSerial.println(\"================================\");\n\nif (!VMEL.begin())\n{\nSerial.println(\"Sensor not found\");\nwhile (1);\n}\n\nVMEL.setGain(VEML7700_GAIN_1);\nVMEL.setIntegrationTime(VEML7700_IT_800MS);\n\nSerial.print(F(\"Gain: \"));\nswitch (VMEL.getGain())\n{\ncase VEML7700_GAIN_1: Serial.println(\"1\"); break;\ncase VEML7700_GAIN_2: Serial.println(\"2\"); break;\ncase VEML7700_GAIN_1_4: Serial.println(\"1/4\"); break;\ncase VEML7700_GAIN_1_8: Serial.println(\"1/8\"); break;\n}\n\nSerial.print(F(\"Integration Time (ms): \"));\nswitch (VMEL.getIntegrationTime())\n{\ncase VEML7700_IT_25MS: Serial.println(\"25\"); break;\ncase VEML7700_IT_50MS: Serial.println(\"50\"); break;\ncase VEML7700_IT_100MS: Serial.println(\"100\"); break;\ncase VEML7700_IT_200MS: Serial.println(\"200\"); break;\ncase VEML7700_IT_400MS: Serial.println(\"400\"); break;\ncase VEML7700_IT_800MS: Serial.println(\"800\"); break;\n}\n\nSerial.println(\"RAK12019 test\");\nWire.begin();\nif (!ltr.init())\n{\nSerial.println(\"Couldn't find LTR sensor!\");\nwhile (1)\ndelay(10);\n}\nSerial.println(\"Found LTR390 sensor!\");\n\n//set to LTR390_MODE_UVS,get ultraviolet light data.\nltr.setMode(LTR390_MODE_UVS);  // UVS Mode\n\nSerial.println(\"In UVS mode\");\n\nltr.setGain(LTR390_GAIN_3);\nSerial.print(\"Gain : \");\nswitch (ltr.getGain())\n{\ncase LTR390_GAIN_1:\nSerial.println(1);\nbreak;\ncase LTR390_GAIN_3:\nSerial.println(3);\nbreak;\ncase LTR390_GAIN_6:\nSerial.println(6);\nbreak;\ncase LTR390_GAIN_9:\nSerial.println(9);\nbreak;\ncase LTR390_GAIN_18:\nSerial.println(18);\nbreak;\ndefault:\nSerial.println(\"Failed to set gain\");\nbreak;\n}\nltr.setResolution(LTR390_RESOLUTION_16BIT);\nSerial.print(\"Integration Time (ms): \");\nswitch (ltr.getResolution())\n{\ncase LTR390_RESOLUTION_13BIT:\nSerial.println(13);\nbreak;\ncase LTR390_RESOLUTION_16BIT:\nSerial.println(16);\nbreak;\ncase LTR390_RESOLUTION_17BIT:\nSerial.println(17);\nbreak;\ncase LTR390_RESOLUTION_18BIT:\nSerial.println(18);\nbreak;\ncase LTR390_RESOLUTION_19BIT:\nSerial.println(19);\nbreak;\ncase LTR390_RESOLUTION_20BIT:\nSerial.println(20);\nbreak;\ndefault:\nSerial.println(\"Failed to set Integration Time\");\nbreak;\n}\n\nltr.setThresholds(100, 1000); //Set the interrupt output threshold range for lower and upper.\n\nltr.configInterrupt(true, LTR390_MODE_UVS);\n\n// For RAK14003\nmcp.begin_I2C(0x24);\n\n// Added for the functionality of RAK14003\n\nWire.begin();    // initialize I2C serial bus\n\n// Configuration of MCP23017 I/O ports\nmcp.pinMode(LED_0, OUTPUT);     // Red LED; Top most\nmcp.pinMode(LED_1, OUTPUT);     // Red LED\nmcp.pinMode(LED_2, OUTPUT);     // Orange LED\nmcp.pinMode(LED_3, OUTPUT);     // Orange LED\nmcp.pinMode(LED_4, OUTPUT);     // Orange LED\nmcp.pinMode(LED_5, OUTPUT);     // Green LED\nmcp.pinMode(LED_6, OUTPUT);     // Green LED\nmcp.pinMode(LED_7, OUTPUT);     // Green LED\nmcp.pinMode(LED_8, OUTPUT);     // Green LED\nmcp.pinMode(LED_9, OUTPUT);     // Green LED; Bottom\n\n// Initially Turn OFF all LEDs\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, HIGH);\n\n}\n\nvoid loop() {\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\n// Trial # 1\n// Data from RAK12019\nif (ltr.newDataAvailable())\n{\nuvi = ltr.getUVI();\nuvs = ltr.readUVS();\n}\n\n// Data from RAK12010\nlux = VMEL.readLux();\nwhite = VMEL.readWhite();\nraw_als = VMEL.readALS();\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\n\n// From RAK12019 module\nSerial.print(\"UVI: \");\nSerial.println(uvi);          // Uvi data from RAK12019\nSerial.print(\"UVS: \");\nSerial.println(uvs);            // Uvs data from RAK12019\n\n// From RAK12010\nSerial.print(\"Lux: \");\nSerial.print(lux);\nSerial.println(\" lx \");\nSerial.print(\"White: \");\nSerial.println(white);\nSerial.print(\"Raw ALS: \");\nSerial.println(raw_als);\n\n// Result of uvi to be displayed via RAK14003 module\nif (uvi <= 0.4)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, HIGH);\n}\n\nelse if (uvi > 0.5 && uvi <= 1)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 1.5 && uvi <= 2)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 2.5 && uvi <= 3)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 3.5 && uvi <= 4)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 4.5 && uvi <= 5)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 5.5 && uvi <= 6)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 6.5 && uvi <= 7)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 7.5 && uvi <= 8)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 8.5 && uvi <= 9.5)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, LOW);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi >= 10)\n{\nmcp.digitalWrite(LED_0, LOW);\nmcp.digitalWrite(LED_1, LOW);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\ndelay(10000);\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void) {\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void) {\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data) {\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class) {\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void) {\nif (lmh_join_status_get() != LMH_SET) {\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\ndata = \" Uvi Data: \" + String(uvi) + \" Uvs Data: \" + String(uvs) + \" Lux Data: \" + String(lux) + \" lx \" ;\n\nSerial.println(data);\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\nuint16_t uvi_data = uvi;            // Uvi data from RAK12019\nuint32_t uvs_data = uvs;            // Uvs data from RAK12019\nuint32_t lux_data = lux;            // Lux data from RAK12010\n\nm_lora_app_data.buffer[i++] = 0x01;  // byte[0]\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\n// Data from RAK12019 module\nm_lora_app_data.buffer[i++] = (uint8_t)((uvi_data & 0x0000FF00) >> 8);     // byte[1]\nm_lora_app_data.buffer[i++] = (uint8_t)(uvi_data & 0x000000FF);            // byte[2]\n\n// Data from RAK12019 module\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0xFF000000) >> 24);    // byte[3]\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0x00FF0000) >> 16);    // byte[4]\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0x0000FF00) >> 8);     // byte[5]\nm_lora_app_data.buffer[i++] = (uint8_t)(uvs_data & 0x000000FF);            // byte[6]\n\n// Data from RAK12010 module\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0xFF000000) >> 24);    // byte[7]\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0x00FF0000) >> 16);    // byte[8]\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0x0000FF00) >> 8);     // byte[9]\nm_lora_app_data.buffer[i++] = (uint8_t)(lux_data & 0x000000FF);            // byte[10]\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS) {\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n} else {\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xE9, 0x0D, 0x28, 0x1D, 0x92, 0x3D, 0xE4, 0x9F, 0xD9, 0xF7, 0xE0, 0x5F, 0x39, 0x10, 0x55, 0x71 };\n\n```  \n> **Image:** OTAA device successfully registered to TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "ba341819b8ffb5de3bdd6f8fd2fe9964", "product_family": "wisblock", "product_id": "kit6-light-and-color", "category": "How-To", "title": "WisBlock IoT Education Kit - Light & Color Quick Start Guide > WisBlock IoT Education Kit - Light & Color Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock IoT Education Kit - Light & Color using TTN and Qubitro > UV Index & UV Intensity Monitoring LoRaWAN Application > LoRaWAN Code for UV Index & UV Intensity Monitoring > Programming UV Index & UV Intensity Monitoring Device with Arduino IDE [CODE]", "content": "// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                                            /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];               //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = { m_lora_app_data_buffer, 0, 0, 0, 0 };  //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {", "keywords": ["Arduino IDE", "RAK4631", "UV Index", "UV Intensity", "LoRaWAN", "SX126x-Arduino"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **UV Index & UV Intensity Monitoring** device. Just copy the code below for **UV Index & UV Intensity Monitoring LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the example </summary>  \n```c\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h>  //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n#include \"UVlight_LTR390.h\"                // http://librarymanager/All#RAK12019_LTR390\nUVlight_LTR390 ltr = UVlight_LTR390();\n\n#include \"Light_VEML7700.h\"                // http://librarymanager/All#Light_veml7700\nLight_VEML7700 VMEL = Light_VEML7700();\n\nuint16_t uvi;\nuint32_t uvs;\nuint32_t lux;\nuint32_t white;\nuint32_t raw_als;\n\n#include <Adafruit_MCP23X17.h>  //http://librarymanager/All#Adafruit_MCP23017\nAdafruit_MCP23X17 mcp;\n\n// Added definitions for the functionality of RAK14003\nconst uint8_t LED_0 = 0;      // PA0 (17) of MCP23017\nconst uint8_t LED_1 = 1;      // PA1 (18) of MCP23017\nconst uint8_t LED_2 = 2;      // PA2 (19) of MCP23017\nconst uint8_t LED_3 = 3;      // PA3 (20) of MCP23017\nconst uint8_t LED_4 = 4;      // PA4 (21) of MCP23017\nconst uint8_t LED_5 = 5;      // PA5 (22) of MCP23017\nconst uint8_t LED_6 = 6;      // PA6 (23) of MCP23017\nconst uint8_t LED_7 = 7;      // PA7 (24) of MCP23017\nconst uint8_t LED_8 = 8;      // PB0 (25) of MCP23017\nconst uint8_t LED_9 = 9;      // PB1 (26) of MCP23017\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define RAK4631_BOARD true\n#else\n#define RAK4631_BOARD false\n#endif\n\nbool doOTAA = true;                                               // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                                       /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                                     /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5                               /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                                        /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;                           /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;                 /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                              /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = { LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF };\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = { BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler };\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xE9, 0x0D, 0x28, 0x1D, 0x92, 0x3D, 0xE4, 0x9F, 0xD9, 0xF7, 0xE0, 0x5F, 0x39, 0x10, 0x55, 0x71 };\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };\nuint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                                            /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];               //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = { m_lora_app_data_buffer, 0, 0, 0, 0 };  //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {\n\n// Initialize Serial for debug output\npinMode(LED_BLUE, OUTPUT);\ndigitalWrite(LED_BLUE, HIGH);\n\n// Sensor Power Switch\npinMode(WB_IO2, OUTPUT);\ndigitalWrite(WB_IO2, HIGH);\n\n// Reset RAK14003 module\npinMode(WB_IO4, OUTPUT);\ndigitalWrite(WB_IO4, HIGH);\ndelay(10);\ndigitalWrite(WB_IO4, LOW);\ndelay(10);\ndigitalWrite(WB_IO4, HIGH);\ndelay(10);\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial) {\nif ((millis() - timeout) < 5000) {\ndelay(100);\n} else {\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA) {\nSerial.println(\"Type: OTAA\");\n} else {\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion) {\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA) {\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n} else {\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0) {\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"================================\");\nSerial.println(\"RAK12019 + RAK12010 LoRaWAN Code\");\nSerial.println(\"================================\");\n\nif (!VMEL.begin())\n{\nSerial.println(\"Sensor not found\");\nwhile (1);\n}\n\nVMEL.setGain(VEML7700_GAIN_1);\nVMEL.setIntegrationTime(VEML7700_IT_800MS);\n\nSerial.print(F(\"Gain: \"));\nswitch (VMEL.getGain())\n{\ncase VEML7700_GAIN_1: Serial.println(\"1\"); break;\ncase VEML7700_GAIN_2: Serial.println(\"2\"); break;\ncase VEML7700_GAIN_1_4: Serial.println(\"1/4\"); break;\ncase VEML7700_GAIN_1_8: Serial.println(\"1/8\"); break;\n}\n\nSerial.print(F(\"Integration Time (ms): \"));\nswitch (VMEL.getIntegrationTime())\n{\ncase VEML7700_IT_25MS: Serial.println(\"25\"); break;\ncase VEML7700_IT_50MS: Serial.println(\"50\"); break;\ncase VEML7700_IT_100MS: Serial.println(\"100\"); break;\ncase VEML7700_IT_200MS: Serial.println(\"200\"); break;\ncase VEML7700_IT_400MS: Serial.println(\"400\"); break;\ncase VEML7700_IT_800MS: Serial.println(\"800\"); break;\n}\n\nSerial.println(\"RAK12019 test\");\nWire.begin();\nif (!ltr.init())\n{\nSerial.println(\"Couldn't find LTR sensor!\");\nwhile (1)\ndelay(10);\n}\nSerial.println(\"Found LTR390 sensor!\");\n\n//set to LTR390_MODE_UVS,get ultraviolet light data.\nltr.setMode(LTR390_MODE_UVS);  // UVS Mode\n\nSerial.println(\"In UVS mode\");\n\nltr.setGain(LTR390_GAIN_3);\nSerial.print(\"Gain : \");\nswitch (ltr.getGain())\n{\ncase LTR390_GAIN_1:\nSerial.println(1);\nbreak;\ncase LTR390_GAIN_3:\nSerial.println(3);\nbreak;\ncase LTR390_GAIN_6:\nSerial.println(6);\nbreak;\ncase LTR390_GAIN_9:\nSerial.println(9);\nbreak;\ncase LTR390_GAIN_18:\nSerial.println(18);\nbreak;\ndefault:\nSerial.println(\"Failed to set gain\");\nbreak;\n}\nltr.setResolution(LTR390_RESOLUTION_16BIT);\nSerial.print(\"Integration Time (ms): \");\nswitch (ltr.getResolution())\n{\ncase LTR390_RESOLUTION_13BIT:\nSerial.println(13);\nbreak;\ncase LTR390_RESOLUTION_16BIT:\nSerial.println(16);\nbreak;\ncase LTR390_RESOLUTION_17BIT:\nSerial.println(17);\nbreak;\ncase LTR390_RESOLUTION_18BIT:\nSerial.println(18);\nbreak;\ncase LTR390_RESOLUTION_19BIT:\nSerial.println(19);\nbreak;\ncase LTR390_RESOLUTION_20BIT:\nSerial.println(20);\nbreak;\ndefault:\nSerial.println(\"Failed to set Integration Time\");\nbreak;\n}\n\nltr.setThresholds(100, 1000); //Set the interrupt output threshold range for lower and upper.\n\nltr.configInterrupt(true, LTR390_MODE_UVS);\n\n// For RAK14003\nmcp.begin_I2C(0x24);\n\n// Added for the functionality of RAK14003\n\nWire.begin();    // initialize I2C serial bus\n\n// Configuration of MCP23017 I/O ports\nmcp.pinMode(LED_0, OUTPUT);     // Red LED; Top most\nmcp.pinMode(LED_1, OUTPUT);     // Red LED\nmcp.pinMode(LED_2, OUTPUT);     // Orange LED\nmcp.pinMode(LED_3, OUTPUT);     // Orange LED\nmcp.pinMode(LED_4, OUTPUT);     // Orange LED\nmcp.pinMode(LED_5, OUTPUT);     // Green LED\nmcp.pinMode(LED_6, OUTPUT);     // Green LED\nmcp.pinMode(LED_7, OUTPUT);     // Green LED\nmcp.pinMode(LED_8, OUTPUT);     // Green LED\nmcp.pinMode(LED_9, OUTPUT);     // Green LED; Bottom\n\n// Initially Turn OFF all LEDs\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, HIGH);\n\n}\n\nvoid loop() {\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\n// Trial # 1\n// Data from RAK12019\nif (ltr.newDataAvailable())\n{\nuvi = ltr.getUVI();\nuvs = ltr.readUVS();\n}\n\n// Data from RAK12010\nlux = VMEL.readLux();\nwhite = VMEL.readWhite();\nraw_als = VMEL.readALS();\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\n\n// From RAK12019 module\nSerial.print(\"UVI: \");\nSerial.println(uvi);          // Uvi data from RAK12019\nSerial.print(\"UVS: \");\nSerial.println(uvs);            // Uvs data from RAK12019\n\n// From RAK12010\nSerial.print(\"Lux: \");\nSerial.print(lux);\nSerial.println(\" lx \");\nSerial.print(\"White: \");\nSerial.println(white);\nSerial.print(\"Raw ALS: \");\nSerial.println(raw_als);\n\n// Result of uvi to be displayed via RAK14003 module\nif (uvi <= 0.4)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, HIGH);\n}\n\nelse if (uvi > 0.5 && uvi <= 1)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 1.5 && uvi <= 2)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 2.5 && uvi <= 3)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 3.5 && uvi <= 4)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 4.5 && uvi <= 5)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 5.5 && uvi <= 6)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 6.5 && uvi <= 7)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 7.5 && uvi <= 8)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 8.5 && uvi <= 9.5)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, LOW);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi >= 10)\n{\nmcp.digitalWrite(LED_0, LOW);\nmcp.digitalWrite(LED_1, LOW);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\ndelay(10000);\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void) {\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void) {\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data) {\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class) {\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void) {\nif (lmh_join_status_get() != LMH_SET) {\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\ndata = \" Uvi Data: \" + String(uvi) + \" Uvs Data: \" + String(uvs) + \" Lux Data: \" + String(lux) + \" lx \" ;\n\nSerial.println(data);\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\nuint16_t uvi_data = uvi;            // Uvi data from RAK12019\nuint32_t uvs_data = uvs;            // Uvs data from RAK12019\nuint32_t lux_data = lux;            // Lux data from RAK12010\n\nm_lora_app_data.buffer[i++] = 0x01;  // byte[0]\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\n// Data from RAK12019 module\nm_lora_app_data.buffer[i++] = (uint8_t)((uvi_data & 0x0000FF00) >> 8);     // byte[1]\nm_lora_app_data.buffer[i++] = (uint8_t)(uvi_data & 0x000000FF);            // byte[2]\n\n// Data from RAK12019 module\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0xFF000000) >> 24);    // byte[3]\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0x00FF0000) >> 16);    // byte[4]\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0x0000FF00) >> 8);     // byte[5]\nm_lora_app_data.buffer[i++] = (uint8_t)(uvs_data & 0x000000FF);            // byte[6]\n\n// Data from RAK12010 module\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0xFF000000) >> 24);    // byte[7]\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0x00FF0000) >> 16);    // byte[8]\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0x0000FF00) >> 8);     // byte[9]\nm_lora_app_data.buffer[i++] = (uint8_t)(lux_data & 0x000000FF);            // byte[10]\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS) {\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n} else {\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xE9, 0x0D, 0x28, 0x1D, 0x92, 0x3D, 0xE4, 0x9F, 0xD9, 0xF7, 0xE0, 0x5F, 0x39, 0x10, 0x55, 0x71 };\n\n```  \n> **Image:** OTAA device successfully registered to TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "d80fe7fe8fca57258676e1d180841661", "product_family": "wisblock", "product_id": "kit6-light-and-color", "category": "How-To", "title": "WisBlock IoT Education Kit - Light & Color Quick Start Guide > WisBlock IoT Education Kit - Light & Color Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock IoT Education Kit - Light & Color using TTN and Qubitro > UV Index & UV Intensity Monitoring LoRaWAN Application > LoRaWAN Code for UV Index & UV Intensity Monitoring > Programming UV Index & UV Intensity Monitoring Device with Arduino IDE [CODE]", "content": "static uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {\n\n// Initialize Serial for debug output\npinMode(LED_BLUE, OUTPUT);\ndigitalWrite(LED_BLUE, HIGH);\n\n// Sensor Power Switch\npinMode(WB_IO2, OUTPUT);\ndigitalWrite(WB_IO2, HIGH);\n\n// Reset RAK14003 module\npinMode(WB_IO4, OUTPUT);\ndigitalWrite(WB_IO4, HIGH);\ndelay(10);\ndigitalWrite(WB_IO4, LOW);\ndelay(10);\ndigitalWrite(WB_IO4, HIGH);\ndelay(10);\n\n// Initialize LoRa chip.\nlora_rak4630_init();", "keywords": ["Arduino IDE", "RAK4631", "UV Index", "UV Intensity", "LoRaWAN", "SX126x-Arduino"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **UV Index & UV Intensity Monitoring** device. Just copy the code below for **UV Index & UV Intensity Monitoring LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the example </summary>  \n```c\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h>  //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n#include \"UVlight_LTR390.h\"                // http://librarymanager/All#RAK12019_LTR390\nUVlight_LTR390 ltr = UVlight_LTR390();\n\n#include \"Light_VEML7700.h\"                // http://librarymanager/All#Light_veml7700\nLight_VEML7700 VMEL = Light_VEML7700();\n\nuint16_t uvi;\nuint32_t uvs;\nuint32_t lux;\nuint32_t white;\nuint32_t raw_als;\n\n#include <Adafruit_MCP23X17.h>  //http://librarymanager/All#Adafruit_MCP23017\nAdafruit_MCP23X17 mcp;\n\n// Added definitions for the functionality of RAK14003\nconst uint8_t LED_0 = 0;      // PA0 (17) of MCP23017\nconst uint8_t LED_1 = 1;      // PA1 (18) of MCP23017\nconst uint8_t LED_2 = 2;      // PA2 (19) of MCP23017\nconst uint8_t LED_3 = 3;      // PA3 (20) of MCP23017\nconst uint8_t LED_4 = 4;      // PA4 (21) of MCP23017\nconst uint8_t LED_5 = 5;      // PA5 (22) of MCP23017\nconst uint8_t LED_6 = 6;      // PA6 (23) of MCP23017\nconst uint8_t LED_7 = 7;      // PA7 (24) of MCP23017\nconst uint8_t LED_8 = 8;      // PB0 (25) of MCP23017\nconst uint8_t LED_9 = 9;      // PB1 (26) of MCP23017\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define RAK4631_BOARD true\n#else\n#define RAK4631_BOARD false\n#endif\n\nbool doOTAA = true;                                               // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                                       /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                                     /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5                               /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                                        /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;                           /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;                 /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                              /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = { LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF };\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = { BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler };\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xE9, 0x0D, 0x28, 0x1D, 0x92, 0x3D, 0xE4, 0x9F, 0xD9, 0xF7, 0xE0, 0x5F, 0x39, 0x10, 0x55, 0x71 };\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };\nuint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                                            /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];               //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = { m_lora_app_data_buffer, 0, 0, 0, 0 };  //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {\n\n// Initialize Serial for debug output\npinMode(LED_BLUE, OUTPUT);\ndigitalWrite(LED_BLUE, HIGH);\n\n// Sensor Power Switch\npinMode(WB_IO2, OUTPUT);\ndigitalWrite(WB_IO2, HIGH);\n\n// Reset RAK14003 module\npinMode(WB_IO4, OUTPUT);\ndigitalWrite(WB_IO4, HIGH);\ndelay(10);\ndigitalWrite(WB_IO4, LOW);\ndelay(10);\ndigitalWrite(WB_IO4, HIGH);\ndelay(10);\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial) {\nif ((millis() - timeout) < 5000) {\ndelay(100);\n} else {\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA) {\nSerial.println(\"Type: OTAA\");\n} else {\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion) {\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA) {\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n} else {\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0) {\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"================================\");\nSerial.println(\"RAK12019 + RAK12010 LoRaWAN Code\");\nSerial.println(\"================================\");\n\nif (!VMEL.begin())\n{\nSerial.println(\"Sensor not found\");\nwhile (1);\n}\n\nVMEL.setGain(VEML7700_GAIN_1);\nVMEL.setIntegrationTime(VEML7700_IT_800MS);\n\nSerial.print(F(\"Gain: \"));\nswitch (VMEL.getGain())\n{\ncase VEML7700_GAIN_1: Serial.println(\"1\"); break;\ncase VEML7700_GAIN_2: Serial.println(\"2\"); break;\ncase VEML7700_GAIN_1_4: Serial.println(\"1/4\"); break;\ncase VEML7700_GAIN_1_8: Serial.println(\"1/8\"); break;\n}\n\nSerial.print(F(\"Integration Time (ms): \"));\nswitch (VMEL.getIntegrationTime())\n{\ncase VEML7700_IT_25MS: Serial.println(\"25\"); break;\ncase VEML7700_IT_50MS: Serial.println(\"50\"); break;\ncase VEML7700_IT_100MS: Serial.println(\"100\"); break;\ncase VEML7700_IT_200MS: Serial.println(\"200\"); break;\ncase VEML7700_IT_400MS: Serial.println(\"400\"); break;\ncase VEML7700_IT_800MS: Serial.println(\"800\"); break;\n}\n\nSerial.println(\"RAK12019 test\");\nWire.begin();\nif (!ltr.init())\n{\nSerial.println(\"Couldn't find LTR sensor!\");\nwhile (1)\ndelay(10);\n}\nSerial.println(\"Found LTR390 sensor!\");\n\n//set to LTR390_MODE_UVS,get ultraviolet light data.\nltr.setMode(LTR390_MODE_UVS);  // UVS Mode\n\nSerial.println(\"In UVS mode\");\n\nltr.setGain(LTR390_GAIN_3);\nSerial.print(\"Gain : \");\nswitch (ltr.getGain())\n{\ncase LTR390_GAIN_1:\nSerial.println(1);\nbreak;\ncase LTR390_GAIN_3:\nSerial.println(3);\nbreak;\ncase LTR390_GAIN_6:\nSerial.println(6);\nbreak;\ncase LTR390_GAIN_9:\nSerial.println(9);\nbreak;\ncase LTR390_GAIN_18:\nSerial.println(18);\nbreak;\ndefault:\nSerial.println(\"Failed to set gain\");\nbreak;\n}\nltr.setResolution(LTR390_RESOLUTION_16BIT);\nSerial.print(\"Integration Time (ms): \");\nswitch (ltr.getResolution())\n{\ncase LTR390_RESOLUTION_13BIT:\nSerial.println(13);\nbreak;\ncase LTR390_RESOLUTION_16BIT:\nSerial.println(16);\nbreak;\ncase LTR390_RESOLUTION_17BIT:\nSerial.println(17);\nbreak;\ncase LTR390_RESOLUTION_18BIT:\nSerial.println(18);\nbreak;\ncase LTR390_RESOLUTION_19BIT:\nSerial.println(19);\nbreak;\ncase LTR390_RESOLUTION_20BIT:\nSerial.println(20);\nbreak;\ndefault:\nSerial.println(\"Failed to set Integration Time\");\nbreak;\n}\n\nltr.setThresholds(100, 1000); //Set the interrupt output threshold range for lower and upper.\n\nltr.configInterrupt(true, LTR390_MODE_UVS);\n\n// For RAK14003\nmcp.begin_I2C(0x24);\n\n// Added for the functionality of RAK14003\n\nWire.begin();    // initialize I2C serial bus\n\n// Configuration of MCP23017 I/O ports\nmcp.pinMode(LED_0, OUTPUT);     // Red LED; Top most\nmcp.pinMode(LED_1, OUTPUT);     // Red LED\nmcp.pinMode(LED_2, OUTPUT);     // Orange LED\nmcp.pinMode(LED_3, OUTPUT);     // Orange LED\nmcp.pinMode(LED_4, OUTPUT);     // Orange LED\nmcp.pinMode(LED_5, OUTPUT);     // Green LED\nmcp.pinMode(LED_6, OUTPUT);     // Green LED\nmcp.pinMode(LED_7, OUTPUT);     // Green LED\nmcp.pinMode(LED_8, OUTPUT);     // Green LED\nmcp.pinMode(LED_9, OUTPUT);     // Green LED; Bottom\n\n// Initially Turn OFF all LEDs\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, HIGH);\n\n}\n\nvoid loop() {\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\n// Trial # 1\n// Data from RAK12019\nif (ltr.newDataAvailable())\n{\nuvi = ltr.getUVI();\nuvs = ltr.readUVS();\n}\n\n// Data from RAK12010\nlux = VMEL.readLux();\nwhite = VMEL.readWhite();\nraw_als = VMEL.readALS();\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\n\n// From RAK12019 module\nSerial.print(\"UVI: \");\nSerial.println(uvi);          // Uvi data from RAK12019\nSerial.print(\"UVS: \");\nSerial.println(uvs);            // Uvs data from RAK12019\n\n// From RAK12010\nSerial.print(\"Lux: \");\nSerial.print(lux);\nSerial.println(\" lx \");\nSerial.print(\"White: \");\nSerial.println(white);\nSerial.print(\"Raw ALS: \");\nSerial.println(raw_als);\n\n// Result of uvi to be displayed via RAK14003 module\nif (uvi <= 0.4)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, HIGH);\n}\n\nelse if (uvi > 0.5 && uvi <= 1)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 1.5 && uvi <= 2)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 2.5 && uvi <= 3)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 3.5 && uvi <= 4)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 4.5 && uvi <= 5)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 5.5 && uvi <= 6)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 6.5 && uvi <= 7)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 7.5 && uvi <= 8)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 8.5 && uvi <= 9.5)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, LOW);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi >= 10)\n{\nmcp.digitalWrite(LED_0, LOW);\nmcp.digitalWrite(LED_1, LOW);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\ndelay(10000);\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void) {\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void) {\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data) {\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class) {\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void) {\nif (lmh_join_status_get() != LMH_SET) {\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\ndata = \" Uvi Data: \" + String(uvi) + \" Uvs Data: \" + String(uvs) + \" Lux Data: \" + String(lux) + \" lx \" ;\n\nSerial.println(data);\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\nuint16_t uvi_data = uvi;            // Uvi data from RAK12019\nuint32_t uvs_data = uvs;            // Uvs data from RAK12019\nuint32_t lux_data = lux;            // Lux data from RAK12010\n\nm_lora_app_data.buffer[i++] = 0x01;  // byte[0]\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\n// Data from RAK12019 module\nm_lora_app_data.buffer[i++] = (uint8_t)((uvi_data & 0x0000FF00) >> 8);     // byte[1]\nm_lora_app_data.buffer[i++] = (uint8_t)(uvi_data & 0x000000FF);            // byte[2]\n\n// Data from RAK12019 module\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0xFF000000) >> 24);    // byte[3]\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0x00FF0000) >> 16);    // byte[4]\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0x0000FF00) >> 8);     // byte[5]\nm_lora_app_data.buffer[i++] = (uint8_t)(uvs_data & 0x000000FF);            // byte[6]\n\n// Data from RAK12010 module\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0xFF000000) >> 24);    // byte[7]\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0x00FF0000) >> 16);    // byte[8]\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0x0000FF00) >> 8);     // byte[9]\nm_lora_app_data.buffer[i++] = (uint8_t)(lux_data & 0x000000FF);            // byte[10]\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS) {\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n} else {\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xE9, 0x0D, 0x28, 0x1D, 0x92, 0x3D, 0xE4, 0x9F, 0xD9, 0xF7, 0xE0, 0x5F, 0x39, 0x10, 0x55, 0x71 };\n\n```  \n> **Image:** OTAA device successfully registered to TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "df3f551f53527b275822f00487dc92b4", "product_family": "wisblock", "product_id": "kit6-light-and-color", "category": "How-To", "title": "WisBlock IoT Education Kit - Light & Color Quick Start Guide > WisBlock IoT Education Kit - Light & Color Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock IoT Education Kit - Light & Color using TTN and Qubitro > UV Index & UV Intensity Monitoring LoRaWAN Application > LoRaWAN Code for UV Index & UV Intensity Monitoring > Programming UV Index & UV Intensity Monitoring Device with Arduino IDE [CODE]", "content": "// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial) {\nif ((millis() - timeout) < 5000) {\ndelay(100);\n} else {\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA) {\nSerial.println(\"Type: OTAA\");\n} else {\nSerial.println(\"Type: ABP\");\n}", "keywords": ["Arduino IDE", "RAK4631", "UV Index", "UV Intensity", "LoRaWAN", "SX126x-Arduino"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **UV Index & UV Intensity Monitoring** device. Just copy the code below for **UV Index & UV Intensity Monitoring LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the example </summary>  \n```c\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h>  //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n#include \"UVlight_LTR390.h\"                // http://librarymanager/All#RAK12019_LTR390\nUVlight_LTR390 ltr = UVlight_LTR390();\n\n#include \"Light_VEML7700.h\"                // http://librarymanager/All#Light_veml7700\nLight_VEML7700 VMEL = Light_VEML7700();\n\nuint16_t uvi;\nuint32_t uvs;\nuint32_t lux;\nuint32_t white;\nuint32_t raw_als;\n\n#include <Adafruit_MCP23X17.h>  //http://librarymanager/All#Adafruit_MCP23017\nAdafruit_MCP23X17 mcp;\n\n// Added definitions for the functionality of RAK14003\nconst uint8_t LED_0 = 0;      // PA0 (17) of MCP23017\nconst uint8_t LED_1 = 1;      // PA1 (18) of MCP23017\nconst uint8_t LED_2 = 2;      // PA2 (19) of MCP23017\nconst uint8_t LED_3 = 3;      // PA3 (20) of MCP23017\nconst uint8_t LED_4 = 4;      // PA4 (21) of MCP23017\nconst uint8_t LED_5 = 5;      // PA5 (22) of MCP23017\nconst uint8_t LED_6 = 6;      // PA6 (23) of MCP23017\nconst uint8_t LED_7 = 7;      // PA7 (24) of MCP23017\nconst uint8_t LED_8 = 8;      // PB0 (25) of MCP23017\nconst uint8_t LED_9 = 9;      // PB1 (26) of MCP23017\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define RAK4631_BOARD true\n#else\n#define RAK4631_BOARD false\n#endif\n\nbool doOTAA = true;                                               // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                                       /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                                     /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5                               /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                                        /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;                           /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;                 /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                              /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = { LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF };\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = { BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler };\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xE9, 0x0D, 0x28, 0x1D, 0x92, 0x3D, 0xE4, 0x9F, 0xD9, 0xF7, 0xE0, 0x5F, 0x39, 0x10, 0x55, 0x71 };\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };\nuint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                                            /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];               //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = { m_lora_app_data_buffer, 0, 0, 0, 0 };  //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {\n\n// Initialize Serial for debug output\npinMode(LED_BLUE, OUTPUT);\ndigitalWrite(LED_BLUE, HIGH);\n\n// Sensor Power Switch\npinMode(WB_IO2, OUTPUT);\ndigitalWrite(WB_IO2, HIGH);\n\n// Reset RAK14003 module\npinMode(WB_IO4, OUTPUT);\ndigitalWrite(WB_IO4, HIGH);\ndelay(10);\ndigitalWrite(WB_IO4, LOW);\ndelay(10);\ndigitalWrite(WB_IO4, HIGH);\ndelay(10);\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial) {\nif ((millis() - timeout) < 5000) {\ndelay(100);\n} else {\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA) {\nSerial.println(\"Type: OTAA\");\n} else {\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion) {\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA) {\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n} else {\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0) {\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"================================\");\nSerial.println(\"RAK12019 + RAK12010 LoRaWAN Code\");\nSerial.println(\"================================\");\n\nif (!VMEL.begin())\n{\nSerial.println(\"Sensor not found\");\nwhile (1);\n}\n\nVMEL.setGain(VEML7700_GAIN_1);\nVMEL.setIntegrationTime(VEML7700_IT_800MS);\n\nSerial.print(F(\"Gain: \"));\nswitch (VMEL.getGain())\n{\ncase VEML7700_GAIN_1: Serial.println(\"1\"); break;\ncase VEML7700_GAIN_2: Serial.println(\"2\"); break;\ncase VEML7700_GAIN_1_4: Serial.println(\"1/4\"); break;\ncase VEML7700_GAIN_1_8: Serial.println(\"1/8\"); break;\n}\n\nSerial.print(F(\"Integration Time (ms): \"));\nswitch (VMEL.getIntegrationTime())\n{\ncase VEML7700_IT_25MS: Serial.println(\"25\"); break;\ncase VEML7700_IT_50MS: Serial.println(\"50\"); break;\ncase VEML7700_IT_100MS: Serial.println(\"100\"); break;\ncase VEML7700_IT_200MS: Serial.println(\"200\"); break;\ncase VEML7700_IT_400MS: Serial.println(\"400\"); break;\ncase VEML7700_IT_800MS: Serial.println(\"800\"); break;\n}\n\nSerial.println(\"RAK12019 test\");\nWire.begin();\nif (!ltr.init())\n{\nSerial.println(\"Couldn't find LTR sensor!\");\nwhile (1)\ndelay(10);\n}\nSerial.println(\"Found LTR390 sensor!\");\n\n//set to LTR390_MODE_UVS,get ultraviolet light data.\nltr.setMode(LTR390_MODE_UVS);  // UVS Mode\n\nSerial.println(\"In UVS mode\");\n\nltr.setGain(LTR390_GAIN_3);\nSerial.print(\"Gain : \");\nswitch (ltr.getGain())\n{\ncase LTR390_GAIN_1:\nSerial.println(1);\nbreak;\ncase LTR390_GAIN_3:\nSerial.println(3);\nbreak;\ncase LTR390_GAIN_6:\nSerial.println(6);\nbreak;\ncase LTR390_GAIN_9:\nSerial.println(9);\nbreak;\ncase LTR390_GAIN_18:\nSerial.println(18);\nbreak;\ndefault:\nSerial.println(\"Failed to set gain\");\nbreak;\n}\nltr.setResolution(LTR390_RESOLUTION_16BIT);\nSerial.print(\"Integration Time (ms): \");\nswitch (ltr.getResolution())\n{\ncase LTR390_RESOLUTION_13BIT:\nSerial.println(13);\nbreak;\ncase LTR390_RESOLUTION_16BIT:\nSerial.println(16);\nbreak;\ncase LTR390_RESOLUTION_17BIT:\nSerial.println(17);\nbreak;\ncase LTR390_RESOLUTION_18BIT:\nSerial.println(18);\nbreak;\ncase LTR390_RESOLUTION_19BIT:\nSerial.println(19);\nbreak;\ncase LTR390_RESOLUTION_20BIT:\nSerial.println(20);\nbreak;\ndefault:\nSerial.println(\"Failed to set Integration Time\");\nbreak;\n}\n\nltr.setThresholds(100, 1000); //Set the interrupt output threshold range for lower and upper.\n\nltr.configInterrupt(true, LTR390_MODE_UVS);\n\n// For RAK14003\nmcp.begin_I2C(0x24);\n\n// Added for the functionality of RAK14003\n\nWire.begin();    // initialize I2C serial bus\n\n// Configuration of MCP23017 I/O ports\nmcp.pinMode(LED_0, OUTPUT);     // Red LED; Top most\nmcp.pinMode(LED_1, OUTPUT);     // Red LED\nmcp.pinMode(LED_2, OUTPUT);     // Orange LED\nmcp.pinMode(LED_3, OUTPUT);     // Orange LED\nmcp.pinMode(LED_4, OUTPUT);     // Orange LED\nmcp.pinMode(LED_5, OUTPUT);     // Green LED\nmcp.pinMode(LED_6, OUTPUT);     // Green LED\nmcp.pinMode(LED_7, OUTPUT);     // Green LED\nmcp.pinMode(LED_8, OUTPUT);     // Green LED\nmcp.pinMode(LED_9, OUTPUT);     // Green LED; Bottom\n\n// Initially Turn OFF all LEDs\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, HIGH);\n\n}\n\nvoid loop() {\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\n// Trial # 1\n// Data from RAK12019\nif (ltr.newDataAvailable())\n{\nuvi = ltr.getUVI();\nuvs = ltr.readUVS();\n}\n\n// Data from RAK12010\nlux = VMEL.readLux();\nwhite = VMEL.readWhite();\nraw_als = VMEL.readALS();\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\n\n// From RAK12019 module\nSerial.print(\"UVI: \");\nSerial.println(uvi);          // Uvi data from RAK12019\nSerial.print(\"UVS: \");\nSerial.println(uvs);            // Uvs data from RAK12019\n\n// From RAK12010\nSerial.print(\"Lux: \");\nSerial.print(lux);\nSerial.println(\" lx \");\nSerial.print(\"White: \");\nSerial.println(white);\nSerial.print(\"Raw ALS: \");\nSerial.println(raw_als);\n\n// Result of uvi to be displayed via RAK14003 module\nif (uvi <= 0.4)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, HIGH);\n}\n\nelse if (uvi > 0.5 && uvi <= 1)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 1.5 && uvi <= 2)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 2.5 && uvi <= 3)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 3.5 && uvi <= 4)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 4.5 && uvi <= 5)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 5.5 && uvi <= 6)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 6.5 && uvi <= 7)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 7.5 && uvi <= 8)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 8.5 && uvi <= 9.5)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, LOW);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi >= 10)\n{\nmcp.digitalWrite(LED_0, LOW);\nmcp.digitalWrite(LED_1, LOW);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\ndelay(10000);\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void) {\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void) {\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data) {\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class) {\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void) {\nif (lmh_join_status_get() != LMH_SET) {\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\ndata = \" Uvi Data: \" + String(uvi) + \" Uvs Data: \" + String(uvs) + \" Lux Data: \" + String(lux) + \" lx \" ;\n\nSerial.println(data);\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\nuint16_t uvi_data = uvi;            // Uvi data from RAK12019\nuint32_t uvs_data = uvs;            // Uvs data from RAK12019\nuint32_t lux_data = lux;            // Lux data from RAK12010\n\nm_lora_app_data.buffer[i++] = 0x01;  // byte[0]\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\n// Data from RAK12019 module\nm_lora_app_data.buffer[i++] = (uint8_t)((uvi_data & 0x0000FF00) >> 8);     // byte[1]\nm_lora_app_data.buffer[i++] = (uint8_t)(uvi_data & 0x000000FF);            // byte[2]\n\n// Data from RAK12019 module\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0xFF000000) >> 24);    // byte[3]\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0x00FF0000) >> 16);    // byte[4]\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0x0000FF00) >> 8);     // byte[5]\nm_lora_app_data.buffer[i++] = (uint8_t)(uvs_data & 0x000000FF);            // byte[6]\n\n// Data from RAK12010 module\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0xFF000000) >> 24);    // byte[7]\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0x00FF0000) >> 16);    // byte[8]\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0x0000FF00) >> 8);     // byte[9]\nm_lora_app_data.buffer[i++] = (uint8_t)(lux_data & 0x000000FF);            // byte[10]\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS) {\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n} else {\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xE9, 0x0D, 0x28, 0x1D, 0x92, 0x3D, 0xE4, 0x9F, 0xD9, 0xF7, 0xE0, 0x5F, 0x39, 0x10, 0x55, 0x71 };\n\n```  \n> **Image:** OTAA device successfully registered to TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "20ea3f283113945b677d8f453991c88c", "product_family": "wisblock", "product_id": "kit6-light-and-color", "category": "How-To", "title": "WisBlock IoT Education Kit - Light & Color Quick Start Guide > WisBlock IoT Education Kit - Light & Color Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock IoT Education Kit - Light & Color using TTN and Qubitro > UV Index & UV Intensity Monitoring LoRaWAN Application > LoRaWAN Code for UV Index & UV Intensity Monitoring > Programming UV Index & UV Intensity Monitoring Device with Arduino IDE [CODE]", "content": "switch (g_CurrentRegion) {\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;", "keywords": ["Arduino IDE", "RAK4631", "UV Index", "UV Intensity", "LoRaWAN", "SX126x-Arduino"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **UV Index & UV Intensity Monitoring** device. Just copy the code below for **UV Index & UV Intensity Monitoring LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the example </summary>  \n```c\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h>  //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n#include \"UVlight_LTR390.h\"                // http://librarymanager/All#RAK12019_LTR390\nUVlight_LTR390 ltr = UVlight_LTR390();\n\n#include \"Light_VEML7700.h\"                // http://librarymanager/All#Light_veml7700\nLight_VEML7700 VMEL = Light_VEML7700();\n\nuint16_t uvi;\nuint32_t uvs;\nuint32_t lux;\nuint32_t white;\nuint32_t raw_als;\n\n#include <Adafruit_MCP23X17.h>  //http://librarymanager/All#Adafruit_MCP23017\nAdafruit_MCP23X17 mcp;\n\n// Added definitions for the functionality of RAK14003\nconst uint8_t LED_0 = 0;      // PA0 (17) of MCP23017\nconst uint8_t LED_1 = 1;      // PA1 (18) of MCP23017\nconst uint8_t LED_2 = 2;      // PA2 (19) of MCP23017\nconst uint8_t LED_3 = 3;      // PA3 (20) of MCP23017\nconst uint8_t LED_4 = 4;      // PA4 (21) of MCP23017\nconst uint8_t LED_5 = 5;      // PA5 (22) of MCP23017\nconst uint8_t LED_6 = 6;      // PA6 (23) of MCP23017\nconst uint8_t LED_7 = 7;      // PA7 (24) of MCP23017\nconst uint8_t LED_8 = 8;      // PB0 (25) of MCP23017\nconst uint8_t LED_9 = 9;      // PB1 (26) of MCP23017\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define RAK4631_BOARD true\n#else\n#define RAK4631_BOARD false\n#endif\n\nbool doOTAA = true;                                               // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                                       /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                                     /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5                               /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                                        /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;                           /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;                 /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                              /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = { LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF };\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = { BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler };\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xE9, 0x0D, 0x28, 0x1D, 0x92, 0x3D, 0xE4, 0x9F, 0xD9, 0xF7, 0xE0, 0x5F, 0x39, 0x10, 0x55, 0x71 };\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };\nuint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                                            /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];               //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = { m_lora_app_data_buffer, 0, 0, 0, 0 };  //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {\n\n// Initialize Serial for debug output\npinMode(LED_BLUE, OUTPUT);\ndigitalWrite(LED_BLUE, HIGH);\n\n// Sensor Power Switch\npinMode(WB_IO2, OUTPUT);\ndigitalWrite(WB_IO2, HIGH);\n\n// Reset RAK14003 module\npinMode(WB_IO4, OUTPUT);\ndigitalWrite(WB_IO4, HIGH);\ndelay(10);\ndigitalWrite(WB_IO4, LOW);\ndelay(10);\ndigitalWrite(WB_IO4, HIGH);\ndelay(10);\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial) {\nif ((millis() - timeout) < 5000) {\ndelay(100);\n} else {\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA) {\nSerial.println(\"Type: OTAA\");\n} else {\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion) {\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA) {\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n} else {\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0) {\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"================================\");\nSerial.println(\"RAK12019 + RAK12010 LoRaWAN Code\");\nSerial.println(\"================================\");\n\nif (!VMEL.begin())\n{\nSerial.println(\"Sensor not found\");\nwhile (1);\n}\n\nVMEL.setGain(VEML7700_GAIN_1);\nVMEL.setIntegrationTime(VEML7700_IT_800MS);\n\nSerial.print(F(\"Gain: \"));\nswitch (VMEL.getGain())\n{\ncase VEML7700_GAIN_1: Serial.println(\"1\"); break;\ncase VEML7700_GAIN_2: Serial.println(\"2\"); break;\ncase VEML7700_GAIN_1_4: Serial.println(\"1/4\"); break;\ncase VEML7700_GAIN_1_8: Serial.println(\"1/8\"); break;\n}\n\nSerial.print(F(\"Integration Time (ms): \"));\nswitch (VMEL.getIntegrationTime())\n{\ncase VEML7700_IT_25MS: Serial.println(\"25\"); break;\ncase VEML7700_IT_50MS: Serial.println(\"50\"); break;\ncase VEML7700_IT_100MS: Serial.println(\"100\"); break;\ncase VEML7700_IT_200MS: Serial.println(\"200\"); break;\ncase VEML7700_IT_400MS: Serial.println(\"400\"); break;\ncase VEML7700_IT_800MS: Serial.println(\"800\"); break;\n}\n\nSerial.println(\"RAK12019 test\");\nWire.begin();\nif (!ltr.init())\n{\nSerial.println(\"Couldn't find LTR sensor!\");\nwhile (1)\ndelay(10);\n}\nSerial.println(\"Found LTR390 sensor!\");\n\n//set to LTR390_MODE_UVS,get ultraviolet light data.\nltr.setMode(LTR390_MODE_UVS);  // UVS Mode\n\nSerial.println(\"In UVS mode\");\n\nltr.setGain(LTR390_GAIN_3);\nSerial.print(\"Gain : \");\nswitch (ltr.getGain())\n{\ncase LTR390_GAIN_1:\nSerial.println(1);\nbreak;\ncase LTR390_GAIN_3:\nSerial.println(3);\nbreak;\ncase LTR390_GAIN_6:\nSerial.println(6);\nbreak;\ncase LTR390_GAIN_9:\nSerial.println(9);\nbreak;\ncase LTR390_GAIN_18:\nSerial.println(18);\nbreak;\ndefault:\nSerial.println(\"Failed to set gain\");\nbreak;\n}\nltr.setResolution(LTR390_RESOLUTION_16BIT);\nSerial.print(\"Integration Time (ms): \");\nswitch (ltr.getResolution())\n{\ncase LTR390_RESOLUTION_13BIT:\nSerial.println(13);\nbreak;\ncase LTR390_RESOLUTION_16BIT:\nSerial.println(16);\nbreak;\ncase LTR390_RESOLUTION_17BIT:\nSerial.println(17);\nbreak;\ncase LTR390_RESOLUTION_18BIT:\nSerial.println(18);\nbreak;\ncase LTR390_RESOLUTION_19BIT:\nSerial.println(19);\nbreak;\ncase LTR390_RESOLUTION_20BIT:\nSerial.println(20);\nbreak;\ndefault:\nSerial.println(\"Failed to set Integration Time\");\nbreak;\n}\n\nltr.setThresholds(100, 1000); //Set the interrupt output threshold range for lower and upper.\n\nltr.configInterrupt(true, LTR390_MODE_UVS);\n\n// For RAK14003\nmcp.begin_I2C(0x24);\n\n// Added for the functionality of RAK14003\n\nWire.begin();    // initialize I2C serial bus\n\n// Configuration of MCP23017 I/O ports\nmcp.pinMode(LED_0, OUTPUT);     // Red LED; Top most\nmcp.pinMode(LED_1, OUTPUT);     // Red LED\nmcp.pinMode(LED_2, OUTPUT);     // Orange LED\nmcp.pinMode(LED_3, OUTPUT);     // Orange LED\nmcp.pinMode(LED_4, OUTPUT);     // Orange LED\nmcp.pinMode(LED_5, OUTPUT);     // Green LED\nmcp.pinMode(LED_6, OUTPUT);     // Green LED\nmcp.pinMode(LED_7, OUTPUT);     // Green LED\nmcp.pinMode(LED_8, OUTPUT);     // Green LED\nmcp.pinMode(LED_9, OUTPUT);     // Green LED; Bottom\n\n// Initially Turn OFF all LEDs\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, HIGH);\n\n}\n\nvoid loop() {\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\n// Trial # 1\n// Data from RAK12019\nif (ltr.newDataAvailable())\n{\nuvi = ltr.getUVI();\nuvs = ltr.readUVS();\n}\n\n// Data from RAK12010\nlux = VMEL.readLux();\nwhite = VMEL.readWhite();\nraw_als = VMEL.readALS();\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\n\n// From RAK12019 module\nSerial.print(\"UVI: \");\nSerial.println(uvi);          // Uvi data from RAK12019\nSerial.print(\"UVS: \");\nSerial.println(uvs);            // Uvs data from RAK12019\n\n// From RAK12010\nSerial.print(\"Lux: \");\nSerial.print(lux);\nSerial.println(\" lx \");\nSerial.print(\"White: \");\nSerial.println(white);\nSerial.print(\"Raw ALS: \");\nSerial.println(raw_als);\n\n// Result of uvi to be displayed via RAK14003 module\nif (uvi <= 0.4)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, HIGH);\n}\n\nelse if (uvi > 0.5 && uvi <= 1)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 1.5 && uvi <= 2)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 2.5 && uvi <= 3)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 3.5 && uvi <= 4)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 4.5 && uvi <= 5)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 5.5 && uvi <= 6)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 6.5 && uvi <= 7)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 7.5 && uvi <= 8)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 8.5 && uvi <= 9.5)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, LOW);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi >= 10)\n{\nmcp.digitalWrite(LED_0, LOW);\nmcp.digitalWrite(LED_1, LOW);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\ndelay(10000);\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void) {\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void) {\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data) {\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class) {\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void) {\nif (lmh_join_status_get() != LMH_SET) {\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\ndata = \" Uvi Data: \" + String(uvi) + \" Uvs Data: \" + String(uvs) + \" Lux Data: \" + String(lux) + \" lx \" ;\n\nSerial.println(data);\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\nuint16_t uvi_data = uvi;            // Uvi data from RAK12019\nuint32_t uvs_data = uvs;            // Uvs data from RAK12019\nuint32_t lux_data = lux;            // Lux data from RAK12010\n\nm_lora_app_data.buffer[i++] = 0x01;  // byte[0]\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\n// Data from RAK12019 module\nm_lora_app_data.buffer[i++] = (uint8_t)((uvi_data & 0x0000FF00) >> 8);     // byte[1]\nm_lora_app_data.buffer[i++] = (uint8_t)(uvi_data & 0x000000FF);            // byte[2]\n\n// Data from RAK12019 module\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0xFF000000) >> 24);    // byte[3]\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0x00FF0000) >> 16);    // byte[4]\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0x0000FF00) >> 8);     // byte[5]\nm_lora_app_data.buffer[i++] = (uint8_t)(uvs_data & 0x000000FF);            // byte[6]\n\n// Data from RAK12010 module\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0xFF000000) >> 24);    // byte[7]\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0x00FF0000) >> 16);    // byte[8]\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0x0000FF00) >> 8);     // byte[9]\nm_lora_app_data.buffer[i++] = (uint8_t)(lux_data & 0x000000FF);            // byte[10]\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS) {\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n} else {\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xE9, 0x0D, 0x28, 0x1D, 0x92, 0x3D, 0xE4, 0x9F, 0xD9, 0xF7, 0xE0, 0x5F, 0x39, 0x10, 0x55, 0x71 };\n\n```  \n> **Image:** OTAA device successfully registered to TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "2767c635212a73671677c817ed799480", "product_family": "wisblock", "product_id": "kit6-light-and-color", "category": "How-To", "title": "WisBlock IoT Education Kit - Light & Color Quick Start Guide > WisBlock IoT Education Kit - Light & Color Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock IoT Education Kit - Light & Color using TTN and Qubitro > UV Index & UV Intensity Monitoring LoRaWAN Application > LoRaWAN Code for UV Index & UV Intensity Monitoring > Programming UV Index & UV Intensity Monitoring Device with Arduino IDE [CODE]", "content": "break;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");", "keywords": ["Arduino IDE", "RAK4631", "UV Index", "UV Intensity", "LoRaWAN", "SX126x-Arduino"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **UV Index & UV Intensity Monitoring** device. Just copy the code below for **UV Index & UV Intensity Monitoring LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the example </summary>  \n```c\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h>  //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n#include \"UVlight_LTR390.h\"                // http://librarymanager/All#RAK12019_LTR390\nUVlight_LTR390 ltr = UVlight_LTR390();\n\n#include \"Light_VEML7700.h\"                // http://librarymanager/All#Light_veml7700\nLight_VEML7700 VMEL = Light_VEML7700();\n\nuint16_t uvi;\nuint32_t uvs;\nuint32_t lux;\nuint32_t white;\nuint32_t raw_als;\n\n#include <Adafruit_MCP23X17.h>  //http://librarymanager/All#Adafruit_MCP23017\nAdafruit_MCP23X17 mcp;\n\n// Added definitions for the functionality of RAK14003\nconst uint8_t LED_0 = 0;      // PA0 (17) of MCP23017\nconst uint8_t LED_1 = 1;      // PA1 (18) of MCP23017\nconst uint8_t LED_2 = 2;      // PA2 (19) of MCP23017\nconst uint8_t LED_3 = 3;      // PA3 (20) of MCP23017\nconst uint8_t LED_4 = 4;      // PA4 (21) of MCP23017\nconst uint8_t LED_5 = 5;      // PA5 (22) of MCP23017\nconst uint8_t LED_6 = 6;      // PA6 (23) of MCP23017\nconst uint8_t LED_7 = 7;      // PA7 (24) of MCP23017\nconst uint8_t LED_8 = 8;      // PB0 (25) of MCP23017\nconst uint8_t LED_9 = 9;      // PB1 (26) of MCP23017\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define RAK4631_BOARD true\n#else\n#define RAK4631_BOARD false\n#endif\n\nbool doOTAA = true;                                               // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                                       /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                                     /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5                               /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                                        /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;                           /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;                 /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                              /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = { LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF };\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = { BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler };\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xE9, 0x0D, 0x28, 0x1D, 0x92, 0x3D, 0xE4, 0x9F, 0xD9, 0xF7, 0xE0, 0x5F, 0x39, 0x10, 0x55, 0x71 };\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };\nuint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                                            /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];               //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = { m_lora_app_data_buffer, 0, 0, 0, 0 };  //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {\n\n// Initialize Serial for debug output\npinMode(LED_BLUE, OUTPUT);\ndigitalWrite(LED_BLUE, HIGH);\n\n// Sensor Power Switch\npinMode(WB_IO2, OUTPUT);\ndigitalWrite(WB_IO2, HIGH);\n\n// Reset RAK14003 module\npinMode(WB_IO4, OUTPUT);\ndigitalWrite(WB_IO4, HIGH);\ndelay(10);\ndigitalWrite(WB_IO4, LOW);\ndelay(10);\ndigitalWrite(WB_IO4, HIGH);\ndelay(10);\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial) {\nif ((millis() - timeout) < 5000) {\ndelay(100);\n} else {\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA) {\nSerial.println(\"Type: OTAA\");\n} else {\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion) {\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA) {\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n} else {\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0) {\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"================================\");\nSerial.println(\"RAK12019 + RAK12010 LoRaWAN Code\");\nSerial.println(\"================================\");\n\nif (!VMEL.begin())\n{\nSerial.println(\"Sensor not found\");\nwhile (1);\n}\n\nVMEL.setGain(VEML7700_GAIN_1);\nVMEL.setIntegrationTime(VEML7700_IT_800MS);\n\nSerial.print(F(\"Gain: \"));\nswitch (VMEL.getGain())\n{\ncase VEML7700_GAIN_1: Serial.println(\"1\"); break;\ncase VEML7700_GAIN_2: Serial.println(\"2\"); break;\ncase VEML7700_GAIN_1_4: Serial.println(\"1/4\"); break;\ncase VEML7700_GAIN_1_8: Serial.println(\"1/8\"); break;\n}\n\nSerial.print(F(\"Integration Time (ms): \"));\nswitch (VMEL.getIntegrationTime())\n{\ncase VEML7700_IT_25MS: Serial.println(\"25\"); break;\ncase VEML7700_IT_50MS: Serial.println(\"50\"); break;\ncase VEML7700_IT_100MS: Serial.println(\"100\"); break;\ncase VEML7700_IT_200MS: Serial.println(\"200\"); break;\ncase VEML7700_IT_400MS: Serial.println(\"400\"); break;\ncase VEML7700_IT_800MS: Serial.println(\"800\"); break;\n}\n\nSerial.println(\"RAK12019 test\");\nWire.begin();\nif (!ltr.init())\n{\nSerial.println(\"Couldn't find LTR sensor!\");\nwhile (1)\ndelay(10);\n}\nSerial.println(\"Found LTR390 sensor!\");\n\n//set to LTR390_MODE_UVS,get ultraviolet light data.\nltr.setMode(LTR390_MODE_UVS);  // UVS Mode\n\nSerial.println(\"In UVS mode\");\n\nltr.setGain(LTR390_GAIN_3);\nSerial.print(\"Gain : \");\nswitch (ltr.getGain())\n{\ncase LTR390_GAIN_1:\nSerial.println(1);\nbreak;\ncase LTR390_GAIN_3:\nSerial.println(3);\nbreak;\ncase LTR390_GAIN_6:\nSerial.println(6);\nbreak;\ncase LTR390_GAIN_9:\nSerial.println(9);\nbreak;\ncase LTR390_GAIN_18:\nSerial.println(18);\nbreak;\ndefault:\nSerial.println(\"Failed to set gain\");\nbreak;\n}\nltr.setResolution(LTR390_RESOLUTION_16BIT);\nSerial.print(\"Integration Time (ms): \");\nswitch (ltr.getResolution())\n{\ncase LTR390_RESOLUTION_13BIT:\nSerial.println(13);\nbreak;\ncase LTR390_RESOLUTION_16BIT:\nSerial.println(16);\nbreak;\ncase LTR390_RESOLUTION_17BIT:\nSerial.println(17);\nbreak;\ncase LTR390_RESOLUTION_18BIT:\nSerial.println(18);\nbreak;\ncase LTR390_RESOLUTION_19BIT:\nSerial.println(19);\nbreak;\ncase LTR390_RESOLUTION_20BIT:\nSerial.println(20);\nbreak;\ndefault:\nSerial.println(\"Failed to set Integration Time\");\nbreak;\n}\n\nltr.setThresholds(100, 1000); //Set the interrupt output threshold range for lower and upper.\n\nltr.configInterrupt(true, LTR390_MODE_UVS);\n\n// For RAK14003\nmcp.begin_I2C(0x24);\n\n// Added for the functionality of RAK14003\n\nWire.begin();    // initialize I2C serial bus\n\n// Configuration of MCP23017 I/O ports\nmcp.pinMode(LED_0, OUTPUT);     // Red LED; Top most\nmcp.pinMode(LED_1, OUTPUT);     // Red LED\nmcp.pinMode(LED_2, OUTPUT);     // Orange LED\nmcp.pinMode(LED_3, OUTPUT);     // Orange LED\nmcp.pinMode(LED_4, OUTPUT);     // Orange LED\nmcp.pinMode(LED_5, OUTPUT);     // Green LED\nmcp.pinMode(LED_6, OUTPUT);     // Green LED\nmcp.pinMode(LED_7, OUTPUT);     // Green LED\nmcp.pinMode(LED_8, OUTPUT);     // Green LED\nmcp.pinMode(LED_9, OUTPUT);     // Green LED; Bottom\n\n// Initially Turn OFF all LEDs\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, HIGH);\n\n}\n\nvoid loop() {\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\n// Trial # 1\n// Data from RAK12019\nif (ltr.newDataAvailable())\n{\nuvi = ltr.getUVI();\nuvs = ltr.readUVS();\n}\n\n// Data from RAK12010\nlux = VMEL.readLux();\nwhite = VMEL.readWhite();\nraw_als = VMEL.readALS();\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\n\n// From RAK12019 module\nSerial.print(\"UVI: \");\nSerial.println(uvi);          // Uvi data from RAK12019\nSerial.print(\"UVS: \");\nSerial.println(uvs);            // Uvs data from RAK12019\n\n// From RAK12010\nSerial.print(\"Lux: \");\nSerial.print(lux);\nSerial.println(\" lx \");\nSerial.print(\"White: \");\nSerial.println(white);\nSerial.print(\"Raw ALS: \");\nSerial.println(raw_als);\n\n// Result of uvi to be displayed via RAK14003 module\nif (uvi <= 0.4)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, HIGH);\n}\n\nelse if (uvi > 0.5 && uvi <= 1)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 1.5 && uvi <= 2)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 2.5 && uvi <= 3)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 3.5 && uvi <= 4)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 4.5 && uvi <= 5)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 5.5 && uvi <= 6)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 6.5 && uvi <= 7)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 7.5 && uvi <= 8)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 8.5 && uvi <= 9.5)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, LOW);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi >= 10)\n{\nmcp.digitalWrite(LED_0, LOW);\nmcp.digitalWrite(LED_1, LOW);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\ndelay(10000);\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void) {\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void) {\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data) {\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class) {\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void) {\nif (lmh_join_status_get() != LMH_SET) {\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\ndata = \" Uvi Data: \" + String(uvi) + \" Uvs Data: \" + String(uvs) + \" Lux Data: \" + String(lux) + \" lx \" ;\n\nSerial.println(data);\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\nuint16_t uvi_data = uvi;            // Uvi data from RAK12019\nuint32_t uvs_data = uvs;            // Uvs data from RAK12019\nuint32_t lux_data = lux;            // Lux data from RAK12010\n\nm_lora_app_data.buffer[i++] = 0x01;  // byte[0]\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\n// Data from RAK12019 module\nm_lora_app_data.buffer[i++] = (uint8_t)((uvi_data & 0x0000FF00) >> 8);     // byte[1]\nm_lora_app_data.buffer[i++] = (uint8_t)(uvi_data & 0x000000FF);            // byte[2]\n\n// Data from RAK12019 module\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0xFF000000) >> 24);    // byte[3]\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0x00FF0000) >> 16);    // byte[4]\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0x0000FF00) >> 8);     // byte[5]\nm_lora_app_data.buffer[i++] = (uint8_t)(uvs_data & 0x000000FF);            // byte[6]\n\n// Data from RAK12010 module\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0xFF000000) >> 24);    // byte[7]\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0x00FF0000) >> 16);    // byte[8]\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0x0000FF00) >> 8);     // byte[9]\nm_lora_app_data.buffer[i++] = (uint8_t)(lux_data & 0x000000FF);            // byte[10]\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS) {\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n} else {\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xE9, 0x0D, 0x28, 0x1D, 0x92, 0x3D, 0xE4, 0x9F, 0xD9, 0xF7, 0xE0, 0x5F, 0x39, 0x10, 0x55, 0x71 };\n\n```  \n> **Image:** OTAA device successfully registered to TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "74804c5ac5fe7e4dcaea949a336bbf0d", "product_family": "wisblock", "product_id": "kit6-light-and-color", "category": "How-To", "title": "WisBlock IoT Education Kit - Light & Color Quick Start Guide > WisBlock IoT Education Kit - Light & Color Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock IoT Education Kit - Light & Color using TTN and Qubitro > UV Index & UV Intensity Monitoring LoRaWAN Application > LoRaWAN Code for UV Index & UV Intensity Monitoring > Programming UV Index & UV Intensity Monitoring Device with Arduino IDE [CODE]", "content": "// Setup the EUIs and Keys\nif (doOTAA) {\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n} else {\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0) {\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();", "keywords": ["Arduino IDE", "RAK4631", "UV Index", "UV Intensity", "LoRaWAN", "SX126x-Arduino"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **UV Index & UV Intensity Monitoring** device. Just copy the code below for **UV Index & UV Intensity Monitoring LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the example </summary>  \n```c\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h>  //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n#include \"UVlight_LTR390.h\"                // http://librarymanager/All#RAK12019_LTR390\nUVlight_LTR390 ltr = UVlight_LTR390();\n\n#include \"Light_VEML7700.h\"                // http://librarymanager/All#Light_veml7700\nLight_VEML7700 VMEL = Light_VEML7700();\n\nuint16_t uvi;\nuint32_t uvs;\nuint32_t lux;\nuint32_t white;\nuint32_t raw_als;\n\n#include <Adafruit_MCP23X17.h>  //http://librarymanager/All#Adafruit_MCP23017\nAdafruit_MCP23X17 mcp;\n\n// Added definitions for the functionality of RAK14003\nconst uint8_t LED_0 = 0;      // PA0 (17) of MCP23017\nconst uint8_t LED_1 = 1;      // PA1 (18) of MCP23017\nconst uint8_t LED_2 = 2;      // PA2 (19) of MCP23017\nconst uint8_t LED_3 = 3;      // PA3 (20) of MCP23017\nconst uint8_t LED_4 = 4;      // PA4 (21) of MCP23017\nconst uint8_t LED_5 = 5;      // PA5 (22) of MCP23017\nconst uint8_t LED_6 = 6;      // PA6 (23) of MCP23017\nconst uint8_t LED_7 = 7;      // PA7 (24) of MCP23017\nconst uint8_t LED_8 = 8;      // PB0 (25) of MCP23017\nconst uint8_t LED_9 = 9;      // PB1 (26) of MCP23017\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define RAK4631_BOARD true\n#else\n#define RAK4631_BOARD false\n#endif\n\nbool doOTAA = true;                                               // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                                       /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                                     /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5                               /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                                        /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;                           /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;                 /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                              /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = { LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF };\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = { BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler };\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xE9, 0x0D, 0x28, 0x1D, 0x92, 0x3D, 0xE4, 0x9F, 0xD9, 0xF7, 0xE0, 0x5F, 0x39, 0x10, 0x55, 0x71 };\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };\nuint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                                            /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];               //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = { m_lora_app_data_buffer, 0, 0, 0, 0 };  //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {\n\n// Initialize Serial for debug output\npinMode(LED_BLUE, OUTPUT);\ndigitalWrite(LED_BLUE, HIGH);\n\n// Sensor Power Switch\npinMode(WB_IO2, OUTPUT);\ndigitalWrite(WB_IO2, HIGH);\n\n// Reset RAK14003 module\npinMode(WB_IO4, OUTPUT);\ndigitalWrite(WB_IO4, HIGH);\ndelay(10);\ndigitalWrite(WB_IO4, LOW);\ndelay(10);\ndigitalWrite(WB_IO4, HIGH);\ndelay(10);\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial) {\nif ((millis() - timeout) < 5000) {\ndelay(100);\n} else {\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA) {\nSerial.println(\"Type: OTAA\");\n} else {\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion) {\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA) {\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n} else {\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0) {\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"================================\");\nSerial.println(\"RAK12019 + RAK12010 LoRaWAN Code\");\nSerial.println(\"================================\");\n\nif (!VMEL.begin())\n{\nSerial.println(\"Sensor not found\");\nwhile (1);\n}\n\nVMEL.setGain(VEML7700_GAIN_1);\nVMEL.setIntegrationTime(VEML7700_IT_800MS);\n\nSerial.print(F(\"Gain: \"));\nswitch (VMEL.getGain())\n{\ncase VEML7700_GAIN_1: Serial.println(\"1\"); break;\ncase VEML7700_GAIN_2: Serial.println(\"2\"); break;\ncase VEML7700_GAIN_1_4: Serial.println(\"1/4\"); break;\ncase VEML7700_GAIN_1_8: Serial.println(\"1/8\"); break;\n}\n\nSerial.print(F(\"Integration Time (ms): \"));\nswitch (VMEL.getIntegrationTime())\n{\ncase VEML7700_IT_25MS: Serial.println(\"25\"); break;\ncase VEML7700_IT_50MS: Serial.println(\"50\"); break;\ncase VEML7700_IT_100MS: Serial.println(\"100\"); break;\ncase VEML7700_IT_200MS: Serial.println(\"200\"); break;\ncase VEML7700_IT_400MS: Serial.println(\"400\"); break;\ncase VEML7700_IT_800MS: Serial.println(\"800\"); break;\n}\n\nSerial.println(\"RAK12019 test\");\nWire.begin();\nif (!ltr.init())\n{\nSerial.println(\"Couldn't find LTR sensor!\");\nwhile (1)\ndelay(10);\n}\nSerial.println(\"Found LTR390 sensor!\");\n\n//set to LTR390_MODE_UVS,get ultraviolet light data.\nltr.setMode(LTR390_MODE_UVS);  // UVS Mode\n\nSerial.println(\"In UVS mode\");\n\nltr.setGain(LTR390_GAIN_3);\nSerial.print(\"Gain : \");\nswitch (ltr.getGain())\n{\ncase LTR390_GAIN_1:\nSerial.println(1);\nbreak;\ncase LTR390_GAIN_3:\nSerial.println(3);\nbreak;\ncase LTR390_GAIN_6:\nSerial.println(6);\nbreak;\ncase LTR390_GAIN_9:\nSerial.println(9);\nbreak;\ncase LTR390_GAIN_18:\nSerial.println(18);\nbreak;\ndefault:\nSerial.println(\"Failed to set gain\");\nbreak;\n}\nltr.setResolution(LTR390_RESOLUTION_16BIT);\nSerial.print(\"Integration Time (ms): \");\nswitch (ltr.getResolution())\n{\ncase LTR390_RESOLUTION_13BIT:\nSerial.println(13);\nbreak;\ncase LTR390_RESOLUTION_16BIT:\nSerial.println(16);\nbreak;\ncase LTR390_RESOLUTION_17BIT:\nSerial.println(17);\nbreak;\ncase LTR390_RESOLUTION_18BIT:\nSerial.println(18);\nbreak;\ncase LTR390_RESOLUTION_19BIT:\nSerial.println(19);\nbreak;\ncase LTR390_RESOLUTION_20BIT:\nSerial.println(20);\nbreak;\ndefault:\nSerial.println(\"Failed to set Integration Time\");\nbreak;\n}\n\nltr.setThresholds(100, 1000); //Set the interrupt output threshold range for lower and upper.\n\nltr.configInterrupt(true, LTR390_MODE_UVS);\n\n// For RAK14003\nmcp.begin_I2C(0x24);\n\n// Added for the functionality of RAK14003\n\nWire.begin();    // initialize I2C serial bus\n\n// Configuration of MCP23017 I/O ports\nmcp.pinMode(LED_0, OUTPUT);     // Red LED; Top most\nmcp.pinMode(LED_1, OUTPUT);     // Red LED\nmcp.pinMode(LED_2, OUTPUT);     // Orange LED\nmcp.pinMode(LED_3, OUTPUT);     // Orange LED\nmcp.pinMode(LED_4, OUTPUT);     // Orange LED\nmcp.pinMode(LED_5, OUTPUT);     // Green LED\nmcp.pinMode(LED_6, OUTPUT);     // Green LED\nmcp.pinMode(LED_7, OUTPUT);     // Green LED\nmcp.pinMode(LED_8, OUTPUT);     // Green LED\nmcp.pinMode(LED_9, OUTPUT);     // Green LED; Bottom\n\n// Initially Turn OFF all LEDs\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, HIGH);\n\n}\n\nvoid loop() {\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\n// Trial # 1\n// Data from RAK12019\nif (ltr.newDataAvailable())\n{\nuvi = ltr.getUVI();\nuvs = ltr.readUVS();\n}\n\n// Data from RAK12010\nlux = VMEL.readLux();\nwhite = VMEL.readWhite();\nraw_als = VMEL.readALS();\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\n\n// From RAK12019 module\nSerial.print(\"UVI: \");\nSerial.println(uvi);          // Uvi data from RAK12019\nSerial.print(\"UVS: \");\nSerial.println(uvs);            // Uvs data from RAK12019\n\n// From RAK12010\nSerial.print(\"Lux: \");\nSerial.print(lux);\nSerial.println(\" lx \");\nSerial.print(\"White: \");\nSerial.println(white);\nSerial.print(\"Raw ALS: \");\nSerial.println(raw_als);\n\n// Result of uvi to be displayed via RAK14003 module\nif (uvi <= 0.4)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, HIGH);\n}\n\nelse if (uvi > 0.5 && uvi <= 1)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 1.5 && uvi <= 2)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 2.5 && uvi <= 3)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 3.5 && uvi <= 4)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 4.5 && uvi <= 5)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 5.5 && uvi <= 6)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 6.5 && uvi <= 7)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 7.5 && uvi <= 8)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 8.5 && uvi <= 9.5)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, LOW);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi >= 10)\n{\nmcp.digitalWrite(LED_0, LOW);\nmcp.digitalWrite(LED_1, LOW);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\ndelay(10000);\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void) {\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void) {\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data) {\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class) {\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void) {\nif (lmh_join_status_get() != LMH_SET) {\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\ndata = \" Uvi Data: \" + String(uvi) + \" Uvs Data: \" + String(uvs) + \" Lux Data: \" + String(lux) + \" lx \" ;\n\nSerial.println(data);\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\nuint16_t uvi_data = uvi;            // Uvi data from RAK12019\nuint32_t uvs_data = uvs;            // Uvs data from RAK12019\nuint32_t lux_data = lux;            // Lux data from RAK12010\n\nm_lora_app_data.buffer[i++] = 0x01;  // byte[0]\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\n// Data from RAK12019 module\nm_lora_app_data.buffer[i++] = (uint8_t)((uvi_data & 0x0000FF00) >> 8);     // byte[1]\nm_lora_app_data.buffer[i++] = (uint8_t)(uvi_data & 0x000000FF);            // byte[2]\n\n// Data from RAK12019 module\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0xFF000000) >> 24);    // byte[3]\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0x00FF0000) >> 16);    // byte[4]\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0x0000FF00) >> 8);     // byte[5]\nm_lora_app_data.buffer[i++] = (uint8_t)(uvs_data & 0x000000FF);            // byte[6]\n\n// Data from RAK12010 module\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0xFF000000) >> 24);    // byte[7]\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0x00FF0000) >> 16);    // byte[8]\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0x0000FF00) >> 8);     // byte[9]\nm_lora_app_data.buffer[i++] = (uint8_t)(lux_data & 0x000000FF);            // byte[10]\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS) {\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n} else {\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xE9, 0x0D, 0x28, 0x1D, 0x92, 0x3D, 0xE4, 0x9F, 0xD9, 0xF7, 0xE0, 0x5F, 0x39, 0x10, 0x55, 0x71 };\n\n```  \n> **Image:** OTAA device successfully registered to TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "b4858c9588df8ecc81e9896d3c9ec716", "product_family": "wisblock", "product_id": "kit6-light-and-color", "category": "How-To", "title": "WisBlock IoT Education Kit - Light & Color Quick Start Guide > WisBlock IoT Education Kit - Light & Color Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock IoT Education Kit - Light & Color using TTN and Qubitro > UV Index & UV Intensity Monitoring LoRaWAN Application > LoRaWAN Code for UV Index & UV Intensity Monitoring > Programming UV Index & UV Intensity Monitoring Device with Arduino IDE [CODE]", "content": "// Start Join procedure\nlmh_join();\n\nSerial.println(\"================================\");\nSerial.println(\"RAK12019 + RAK12010 LoRaWAN Code\");\nSerial.println(\"================================\");\n\nif (!VMEL.begin())\n{\nSerial.println(\"Sensor not found\");\nwhile (1);\n}\n\nVMEL.setGain(VEML7700_GAIN_1);\nVMEL.setIntegrationTime(VEML7700_IT_800MS);", "keywords": ["Arduino IDE", "RAK4631", "UV Index", "UV Intensity", "LoRaWAN", "SX126x-Arduino"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **UV Index & UV Intensity Monitoring** device. Just copy the code below for **UV Index & UV Intensity Monitoring LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the example </summary>  \n```c\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h>  //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n#include \"UVlight_LTR390.h\"                // http://librarymanager/All#RAK12019_LTR390\nUVlight_LTR390 ltr = UVlight_LTR390();\n\n#include \"Light_VEML7700.h\"                // http://librarymanager/All#Light_veml7700\nLight_VEML7700 VMEL = Light_VEML7700();\n\nuint16_t uvi;\nuint32_t uvs;\nuint32_t lux;\nuint32_t white;\nuint32_t raw_als;\n\n#include <Adafruit_MCP23X17.h>  //http://librarymanager/All#Adafruit_MCP23017\nAdafruit_MCP23X17 mcp;\n\n// Added definitions for the functionality of RAK14003\nconst uint8_t LED_0 = 0;      // PA0 (17) of MCP23017\nconst uint8_t LED_1 = 1;      // PA1 (18) of MCP23017\nconst uint8_t LED_2 = 2;      // PA2 (19) of MCP23017\nconst uint8_t LED_3 = 3;      // PA3 (20) of MCP23017\nconst uint8_t LED_4 = 4;      // PA4 (21) of MCP23017\nconst uint8_t LED_5 = 5;      // PA5 (22) of MCP23017\nconst uint8_t LED_6 = 6;      // PA6 (23) of MCP23017\nconst uint8_t LED_7 = 7;      // PA7 (24) of MCP23017\nconst uint8_t LED_8 = 8;      // PB0 (25) of MCP23017\nconst uint8_t LED_9 = 9;      // PB1 (26) of MCP23017\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define RAK4631_BOARD true\n#else\n#define RAK4631_BOARD false\n#endif\n\nbool doOTAA = true;                                               // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                                       /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                                     /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5                               /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                                        /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;                           /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;                 /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                              /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = { LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF };\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = { BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler };\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xE9, 0x0D, 0x28, 0x1D, 0x92, 0x3D, 0xE4, 0x9F, 0xD9, 0xF7, 0xE0, 0x5F, 0x39, 0x10, 0x55, 0x71 };\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };\nuint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                                            /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];               //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = { m_lora_app_data_buffer, 0, 0, 0, 0 };  //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {\n\n// Initialize Serial for debug output\npinMode(LED_BLUE, OUTPUT);\ndigitalWrite(LED_BLUE, HIGH);\n\n// Sensor Power Switch\npinMode(WB_IO2, OUTPUT);\ndigitalWrite(WB_IO2, HIGH);\n\n// Reset RAK14003 module\npinMode(WB_IO4, OUTPUT);\ndigitalWrite(WB_IO4, HIGH);\ndelay(10);\ndigitalWrite(WB_IO4, LOW);\ndelay(10);\ndigitalWrite(WB_IO4, HIGH);\ndelay(10);\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial) {\nif ((millis() - timeout) < 5000) {\ndelay(100);\n} else {\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA) {\nSerial.println(\"Type: OTAA\");\n} else {\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion) {\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA) {\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n} else {\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0) {\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"================================\");\nSerial.println(\"RAK12019 + RAK12010 LoRaWAN Code\");\nSerial.println(\"================================\");\n\nif (!VMEL.begin())\n{\nSerial.println(\"Sensor not found\");\nwhile (1);\n}\n\nVMEL.setGain(VEML7700_GAIN_1);\nVMEL.setIntegrationTime(VEML7700_IT_800MS);\n\nSerial.print(F(\"Gain: \"));\nswitch (VMEL.getGain())\n{\ncase VEML7700_GAIN_1: Serial.println(\"1\"); break;\ncase VEML7700_GAIN_2: Serial.println(\"2\"); break;\ncase VEML7700_GAIN_1_4: Serial.println(\"1/4\"); break;\ncase VEML7700_GAIN_1_8: Serial.println(\"1/8\"); break;\n}\n\nSerial.print(F(\"Integration Time (ms): \"));\nswitch (VMEL.getIntegrationTime())\n{\ncase VEML7700_IT_25MS: Serial.println(\"25\"); break;\ncase VEML7700_IT_50MS: Serial.println(\"50\"); break;\ncase VEML7700_IT_100MS: Serial.println(\"100\"); break;\ncase VEML7700_IT_200MS: Serial.println(\"200\"); break;\ncase VEML7700_IT_400MS: Serial.println(\"400\"); break;\ncase VEML7700_IT_800MS: Serial.println(\"800\"); break;\n}\n\nSerial.println(\"RAK12019 test\");\nWire.begin();\nif (!ltr.init())\n{\nSerial.println(\"Couldn't find LTR sensor!\");\nwhile (1)\ndelay(10);\n}\nSerial.println(\"Found LTR390 sensor!\");\n\n//set to LTR390_MODE_UVS,get ultraviolet light data.\nltr.setMode(LTR390_MODE_UVS);  // UVS Mode\n\nSerial.println(\"In UVS mode\");\n\nltr.setGain(LTR390_GAIN_3);\nSerial.print(\"Gain : \");\nswitch (ltr.getGain())\n{\ncase LTR390_GAIN_1:\nSerial.println(1);\nbreak;\ncase LTR390_GAIN_3:\nSerial.println(3);\nbreak;\ncase LTR390_GAIN_6:\nSerial.println(6);\nbreak;\ncase LTR390_GAIN_9:\nSerial.println(9);\nbreak;\ncase LTR390_GAIN_18:\nSerial.println(18);\nbreak;\ndefault:\nSerial.println(\"Failed to set gain\");\nbreak;\n}\nltr.setResolution(LTR390_RESOLUTION_16BIT);\nSerial.print(\"Integration Time (ms): \");\nswitch (ltr.getResolution())\n{\ncase LTR390_RESOLUTION_13BIT:\nSerial.println(13);\nbreak;\ncase LTR390_RESOLUTION_16BIT:\nSerial.println(16);\nbreak;\ncase LTR390_RESOLUTION_17BIT:\nSerial.println(17);\nbreak;\ncase LTR390_RESOLUTION_18BIT:\nSerial.println(18);\nbreak;\ncase LTR390_RESOLUTION_19BIT:\nSerial.println(19);\nbreak;\ncase LTR390_RESOLUTION_20BIT:\nSerial.println(20);\nbreak;\ndefault:\nSerial.println(\"Failed to set Integration Time\");\nbreak;\n}\n\nltr.setThresholds(100, 1000); //Set the interrupt output threshold range for lower and upper.\n\nltr.configInterrupt(true, LTR390_MODE_UVS);\n\n// For RAK14003\nmcp.begin_I2C(0x24);\n\n// Added for the functionality of RAK14003\n\nWire.begin();    // initialize I2C serial bus\n\n// Configuration of MCP23017 I/O ports\nmcp.pinMode(LED_0, OUTPUT);     // Red LED; Top most\nmcp.pinMode(LED_1, OUTPUT);     // Red LED\nmcp.pinMode(LED_2, OUTPUT);     // Orange LED\nmcp.pinMode(LED_3, OUTPUT);     // Orange LED\nmcp.pinMode(LED_4, OUTPUT);     // Orange LED\nmcp.pinMode(LED_5, OUTPUT);     // Green LED\nmcp.pinMode(LED_6, OUTPUT);     // Green LED\nmcp.pinMode(LED_7, OUTPUT);     // Green LED\nmcp.pinMode(LED_8, OUTPUT);     // Green LED\nmcp.pinMode(LED_9, OUTPUT);     // Green LED; Bottom\n\n// Initially Turn OFF all LEDs\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, HIGH);\n\n}\n\nvoid loop() {\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\n// Trial # 1\n// Data from RAK12019\nif (ltr.newDataAvailable())\n{\nuvi = ltr.getUVI();\nuvs = ltr.readUVS();\n}\n\n// Data from RAK12010\nlux = VMEL.readLux();\nwhite = VMEL.readWhite();\nraw_als = VMEL.readALS();\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\n\n// From RAK12019 module\nSerial.print(\"UVI: \");\nSerial.println(uvi);          // Uvi data from RAK12019\nSerial.print(\"UVS: \");\nSerial.println(uvs);            // Uvs data from RAK12019\n\n// From RAK12010\nSerial.print(\"Lux: \");\nSerial.print(lux);\nSerial.println(\" lx \");\nSerial.print(\"White: \");\nSerial.println(white);\nSerial.print(\"Raw ALS: \");\nSerial.println(raw_als);\n\n// Result of uvi to be displayed via RAK14003 module\nif (uvi <= 0.4)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, HIGH);\n}\n\nelse if (uvi > 0.5 && uvi <= 1)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 1.5 && uvi <= 2)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 2.5 && uvi <= 3)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 3.5 && uvi <= 4)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 4.5 && uvi <= 5)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 5.5 && uvi <= 6)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 6.5 && uvi <= 7)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 7.5 && uvi <= 8)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 8.5 && uvi <= 9.5)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, LOW);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi >= 10)\n{\nmcp.digitalWrite(LED_0, LOW);\nmcp.digitalWrite(LED_1, LOW);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\ndelay(10000);\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void) {\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void) {\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data) {\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class) {\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void) {\nif (lmh_join_status_get() != LMH_SET) {\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\ndata = \" Uvi Data: \" + String(uvi) + \" Uvs Data: \" + String(uvs) + \" Lux Data: \" + String(lux) + \" lx \" ;\n\nSerial.println(data);\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\nuint16_t uvi_data = uvi;            // Uvi data from RAK12019\nuint32_t uvs_data = uvs;            // Uvs data from RAK12019\nuint32_t lux_data = lux;            // Lux data from RAK12010\n\nm_lora_app_data.buffer[i++] = 0x01;  // byte[0]\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\n// Data from RAK12019 module\nm_lora_app_data.buffer[i++] = (uint8_t)((uvi_data & 0x0000FF00) >> 8);     // byte[1]\nm_lora_app_data.buffer[i++] = (uint8_t)(uvi_data & 0x000000FF);            // byte[2]\n\n// Data from RAK12019 module\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0xFF000000) >> 24);    // byte[3]\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0x00FF0000) >> 16);    // byte[4]\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0x0000FF00) >> 8);     // byte[5]\nm_lora_app_data.buffer[i++] = (uint8_t)(uvs_data & 0x000000FF);            // byte[6]\n\n// Data from RAK12010 module\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0xFF000000) >> 24);    // byte[7]\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0x00FF0000) >> 16);    // byte[8]\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0x0000FF00) >> 8);     // byte[9]\nm_lora_app_data.buffer[i++] = (uint8_t)(lux_data & 0x000000FF);            // byte[10]\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS) {\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n} else {\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xE9, 0x0D, 0x28, 0x1D, 0x92, 0x3D, 0xE4, 0x9F, 0xD9, 0xF7, 0xE0, 0x5F, 0x39, 0x10, 0x55, 0x71 };\n\n```  \n> **Image:** OTAA device successfully registered to TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "a5173a09bc58c115276a13d81b8e1b78", "product_family": "wisblock", "product_id": "kit6-light-and-color", "category": "How-To", "title": "WisBlock IoT Education Kit - Light & Color Quick Start Guide > WisBlock IoT Education Kit - Light & Color Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock IoT Education Kit - Light & Color using TTN and Qubitro > UV Index & UV Intensity Monitoring LoRaWAN Application > LoRaWAN Code for UV Index & UV Intensity Monitoring > Programming UV Index & UV Intensity Monitoring Device with Arduino IDE [CODE]", "content": "VMEL.setGain(VEML7700_GAIN_1);\nVMEL.setIntegrationTime(VEML7700_IT_800MS);\n\nSerial.print(F(\"Gain: \"));\nswitch (VMEL.getGain())\n{\ncase VEML7700_GAIN_1: Serial.println(\"1\"); break;\ncase VEML7700_GAIN_2: Serial.println(\"2\"); break;\ncase VEML7700_GAIN_1_4: Serial.println(\"1/4\"); break;\ncase VEML7700_GAIN_1_8: Serial.println(\"1/8\"); break;\n}", "keywords": ["Arduino IDE", "RAK4631", "UV Index", "UV Intensity", "LoRaWAN", "SX126x-Arduino"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **UV Index & UV Intensity Monitoring** device. Just copy the code below for **UV Index & UV Intensity Monitoring LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the example </summary>  \n```c\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h>  //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n#include \"UVlight_LTR390.h\"                // http://librarymanager/All#RAK12019_LTR390\nUVlight_LTR390 ltr = UVlight_LTR390();\n\n#include \"Light_VEML7700.h\"                // http://librarymanager/All#Light_veml7700\nLight_VEML7700 VMEL = Light_VEML7700();\n\nuint16_t uvi;\nuint32_t uvs;\nuint32_t lux;\nuint32_t white;\nuint32_t raw_als;\n\n#include <Adafruit_MCP23X17.h>  //http://librarymanager/All#Adafruit_MCP23017\nAdafruit_MCP23X17 mcp;\n\n// Added definitions for the functionality of RAK14003\nconst uint8_t LED_0 = 0;      // PA0 (17) of MCP23017\nconst uint8_t LED_1 = 1;      // PA1 (18) of MCP23017\nconst uint8_t LED_2 = 2;      // PA2 (19) of MCP23017\nconst uint8_t LED_3 = 3;      // PA3 (20) of MCP23017\nconst uint8_t LED_4 = 4;      // PA4 (21) of MCP23017\nconst uint8_t LED_5 = 5;      // PA5 (22) of MCP23017\nconst uint8_t LED_6 = 6;      // PA6 (23) of MCP23017\nconst uint8_t LED_7 = 7;      // PA7 (24) of MCP23017\nconst uint8_t LED_8 = 8;      // PB0 (25) of MCP23017\nconst uint8_t LED_9 = 9;      // PB1 (26) of MCP23017\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define RAK4631_BOARD true\n#else\n#define RAK4631_BOARD false\n#endif\n\nbool doOTAA = true;                                               // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                                       /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                                     /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5                               /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                                        /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;                           /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;                 /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                              /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = { LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF };\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = { BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler };\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xE9, 0x0D, 0x28, 0x1D, 0x92, 0x3D, 0xE4, 0x9F, 0xD9, 0xF7, 0xE0, 0x5F, 0x39, 0x10, 0x55, 0x71 };\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };\nuint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                                            /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];               //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = { m_lora_app_data_buffer, 0, 0, 0, 0 };  //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {\n\n// Initialize Serial for debug output\npinMode(LED_BLUE, OUTPUT);\ndigitalWrite(LED_BLUE, HIGH);\n\n// Sensor Power Switch\npinMode(WB_IO2, OUTPUT);\ndigitalWrite(WB_IO2, HIGH);\n\n// Reset RAK14003 module\npinMode(WB_IO4, OUTPUT);\ndigitalWrite(WB_IO4, HIGH);\ndelay(10);\ndigitalWrite(WB_IO4, LOW);\ndelay(10);\ndigitalWrite(WB_IO4, HIGH);\ndelay(10);\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial) {\nif ((millis() - timeout) < 5000) {\ndelay(100);\n} else {\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA) {\nSerial.println(\"Type: OTAA\");\n} else {\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion) {\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA) {\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n} else {\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0) {\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"================================\");\nSerial.println(\"RAK12019 + RAK12010 LoRaWAN Code\");\nSerial.println(\"================================\");\n\nif (!VMEL.begin())\n{\nSerial.println(\"Sensor not found\");\nwhile (1);\n}\n\nVMEL.setGain(VEML7700_GAIN_1);\nVMEL.setIntegrationTime(VEML7700_IT_800MS);\n\nSerial.print(F(\"Gain: \"));\nswitch (VMEL.getGain())\n{\ncase VEML7700_GAIN_1: Serial.println(\"1\"); break;\ncase VEML7700_GAIN_2: Serial.println(\"2\"); break;\ncase VEML7700_GAIN_1_4: Serial.println(\"1/4\"); break;\ncase VEML7700_GAIN_1_8: Serial.println(\"1/8\"); break;\n}\n\nSerial.print(F(\"Integration Time (ms): \"));\nswitch (VMEL.getIntegrationTime())\n{\ncase VEML7700_IT_25MS: Serial.println(\"25\"); break;\ncase VEML7700_IT_50MS: Serial.println(\"50\"); break;\ncase VEML7700_IT_100MS: Serial.println(\"100\"); break;\ncase VEML7700_IT_200MS: Serial.println(\"200\"); break;\ncase VEML7700_IT_400MS: Serial.println(\"400\"); break;\ncase VEML7700_IT_800MS: Serial.println(\"800\"); break;\n}\n\nSerial.println(\"RAK12019 test\");\nWire.begin();\nif (!ltr.init())\n{\nSerial.println(\"Couldn't find LTR sensor!\");\nwhile (1)\ndelay(10);\n}\nSerial.println(\"Found LTR390 sensor!\");\n\n//set to LTR390_MODE_UVS,get ultraviolet light data.\nltr.setMode(LTR390_MODE_UVS);  // UVS Mode\n\nSerial.println(\"In UVS mode\");\n\nltr.setGain(LTR390_GAIN_3);\nSerial.print(\"Gain : \");\nswitch (ltr.getGain())\n{\ncase LTR390_GAIN_1:\nSerial.println(1);\nbreak;\ncase LTR390_GAIN_3:\nSerial.println(3);\nbreak;\ncase LTR390_GAIN_6:\nSerial.println(6);\nbreak;\ncase LTR390_GAIN_9:\nSerial.println(9);\nbreak;\ncase LTR390_GAIN_18:\nSerial.println(18);\nbreak;\ndefault:\nSerial.println(\"Failed to set gain\");\nbreak;\n}\nltr.setResolution(LTR390_RESOLUTION_16BIT);\nSerial.print(\"Integration Time (ms): \");\nswitch (ltr.getResolution())\n{\ncase LTR390_RESOLUTION_13BIT:\nSerial.println(13);\nbreak;\ncase LTR390_RESOLUTION_16BIT:\nSerial.println(16);\nbreak;\ncase LTR390_RESOLUTION_17BIT:\nSerial.println(17);\nbreak;\ncase LTR390_RESOLUTION_18BIT:\nSerial.println(18);\nbreak;\ncase LTR390_RESOLUTION_19BIT:\nSerial.println(19);\nbreak;\ncase LTR390_RESOLUTION_20BIT:\nSerial.println(20);\nbreak;\ndefault:\nSerial.println(\"Failed to set Integration Time\");\nbreak;\n}\n\nltr.setThresholds(100, 1000); //Set the interrupt output threshold range for lower and upper.\n\nltr.configInterrupt(true, LTR390_MODE_UVS);\n\n// For RAK14003\nmcp.begin_I2C(0x24);\n\n// Added for the functionality of RAK14003\n\nWire.begin();    // initialize I2C serial bus\n\n// Configuration of MCP23017 I/O ports\nmcp.pinMode(LED_0, OUTPUT);     // Red LED; Top most\nmcp.pinMode(LED_1, OUTPUT);     // Red LED\nmcp.pinMode(LED_2, OUTPUT);     // Orange LED\nmcp.pinMode(LED_3, OUTPUT);     // Orange LED\nmcp.pinMode(LED_4, OUTPUT);     // Orange LED\nmcp.pinMode(LED_5, OUTPUT);     // Green LED\nmcp.pinMode(LED_6, OUTPUT);     // Green LED\nmcp.pinMode(LED_7, OUTPUT);     // Green LED\nmcp.pinMode(LED_8, OUTPUT);     // Green LED\nmcp.pinMode(LED_9, OUTPUT);     // Green LED; Bottom\n\n// Initially Turn OFF all LEDs\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, HIGH);\n\n}\n\nvoid loop() {\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\n// Trial # 1\n// Data from RAK12019\nif (ltr.newDataAvailable())\n{\nuvi = ltr.getUVI();\nuvs = ltr.readUVS();\n}\n\n// Data from RAK12010\nlux = VMEL.readLux();\nwhite = VMEL.readWhite();\nraw_als = VMEL.readALS();\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\n\n// From RAK12019 module\nSerial.print(\"UVI: \");\nSerial.println(uvi);          // Uvi data from RAK12019\nSerial.print(\"UVS: \");\nSerial.println(uvs);            // Uvs data from RAK12019\n\n// From RAK12010\nSerial.print(\"Lux: \");\nSerial.print(lux);\nSerial.println(\" lx \");\nSerial.print(\"White: \");\nSerial.println(white);\nSerial.print(\"Raw ALS: \");\nSerial.println(raw_als);\n\n// Result of uvi to be displayed via RAK14003 module\nif (uvi <= 0.4)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, HIGH);\n}\n\nelse if (uvi > 0.5 && uvi <= 1)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 1.5 && uvi <= 2)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 2.5 && uvi <= 3)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 3.5 && uvi <= 4)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 4.5 && uvi <= 5)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 5.5 && uvi <= 6)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 6.5 && uvi <= 7)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 7.5 && uvi <= 8)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 8.5 && uvi <= 9.5)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, LOW);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi >= 10)\n{\nmcp.digitalWrite(LED_0, LOW);\nmcp.digitalWrite(LED_1, LOW);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\ndelay(10000);\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void) {\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void) {\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data) {\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class) {\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void) {\nif (lmh_join_status_get() != LMH_SET) {\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\ndata = \" Uvi Data: \" + String(uvi) + \" Uvs Data: \" + String(uvs) + \" Lux Data: \" + String(lux) + \" lx \" ;\n\nSerial.println(data);\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\nuint16_t uvi_data = uvi;            // Uvi data from RAK12019\nuint32_t uvs_data = uvs;            // Uvs data from RAK12019\nuint32_t lux_data = lux;            // Lux data from RAK12010\n\nm_lora_app_data.buffer[i++] = 0x01;  // byte[0]\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\n// Data from RAK12019 module\nm_lora_app_data.buffer[i++] = (uint8_t)((uvi_data & 0x0000FF00) >> 8);     // byte[1]\nm_lora_app_data.buffer[i++] = (uint8_t)(uvi_data & 0x000000FF);            // byte[2]\n\n// Data from RAK12019 module\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0xFF000000) >> 24);    // byte[3]\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0x00FF0000) >> 16);    // byte[4]\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0x0000FF00) >> 8);     // byte[5]\nm_lora_app_data.buffer[i++] = (uint8_t)(uvs_data & 0x000000FF);            // byte[6]\n\n// Data from RAK12010 module\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0xFF000000) >> 24);    // byte[7]\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0x00FF0000) >> 16);    // byte[8]\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0x0000FF00) >> 8);     // byte[9]\nm_lora_app_data.buffer[i++] = (uint8_t)(lux_data & 0x000000FF);            // byte[10]\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS) {\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n} else {\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xE9, 0x0D, 0x28, 0x1D, 0x92, 0x3D, 0xE4, 0x9F, 0xD9, 0xF7, 0xE0, 0x5F, 0x39, 0x10, 0x55, 0x71 };\n\n```  \n> **Image:** OTAA device successfully registered to TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "13dd02fc0ea9a83602473c912239011a", "product_family": "wisblock", "product_id": "kit6-light-and-color", "category": "How-To", "title": "WisBlock IoT Education Kit - Light & Color Quick Start Guide > WisBlock IoT Education Kit - Light & Color Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock IoT Education Kit - Light & Color using TTN and Qubitro > UV Index & UV Intensity Monitoring LoRaWAN Application > LoRaWAN Code for UV Index & UV Intensity Monitoring > Programming UV Index & UV Intensity Monitoring Device with Arduino IDE [CODE]", "content": "Serial.print(F(\"Integration Time (ms): \"));\nswitch (VMEL.getIntegrationTime())\n{\ncase VEML7700_IT_25MS: Serial.println(\"25\"); break;\ncase VEML7700_IT_50MS: Serial.println(\"50\"); break;\ncase VEML7700_IT_100MS: Serial.println(\"100\"); break;\ncase VEML7700_IT_200MS: Serial.println(\"200\"); break;\ncase VEML7700_IT_400MS: Serial.println(\"400\"); break;\ncase VEML7700_IT_800MS: Serial.println(\"800\"); break;\n}", "keywords": ["Arduino IDE", "RAK4631", "UV Index", "UV Intensity", "LoRaWAN", "SX126x-Arduino"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **UV Index & UV Intensity Monitoring** device. Just copy the code below for **UV Index & UV Intensity Monitoring LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the example </summary>  \n```c\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h>  //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n#include \"UVlight_LTR390.h\"                // http://librarymanager/All#RAK12019_LTR390\nUVlight_LTR390 ltr = UVlight_LTR390();\n\n#include \"Light_VEML7700.h\"                // http://librarymanager/All#Light_veml7700\nLight_VEML7700 VMEL = Light_VEML7700();\n\nuint16_t uvi;\nuint32_t uvs;\nuint32_t lux;\nuint32_t white;\nuint32_t raw_als;\n\n#include <Adafruit_MCP23X17.h>  //http://librarymanager/All#Adafruit_MCP23017\nAdafruit_MCP23X17 mcp;\n\n// Added definitions for the functionality of RAK14003\nconst uint8_t LED_0 = 0;      // PA0 (17) of MCP23017\nconst uint8_t LED_1 = 1;      // PA1 (18) of MCP23017\nconst uint8_t LED_2 = 2;      // PA2 (19) of MCP23017\nconst uint8_t LED_3 = 3;      // PA3 (20) of MCP23017\nconst uint8_t LED_4 = 4;      // PA4 (21) of MCP23017\nconst uint8_t LED_5 = 5;      // PA5 (22) of MCP23017\nconst uint8_t LED_6 = 6;      // PA6 (23) of MCP23017\nconst uint8_t LED_7 = 7;      // PA7 (24) of MCP23017\nconst uint8_t LED_8 = 8;      // PB0 (25) of MCP23017\nconst uint8_t LED_9 = 9;      // PB1 (26) of MCP23017\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define RAK4631_BOARD true\n#else\n#define RAK4631_BOARD false\n#endif\n\nbool doOTAA = true;                                               // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                                       /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                                     /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5                               /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                                        /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;                           /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;                 /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                              /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = { LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF };\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = { BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler };\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xE9, 0x0D, 0x28, 0x1D, 0x92, 0x3D, 0xE4, 0x9F, 0xD9, 0xF7, 0xE0, 0x5F, 0x39, 0x10, 0x55, 0x71 };\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };\nuint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                                            /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];               //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = { m_lora_app_data_buffer, 0, 0, 0, 0 };  //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {\n\n// Initialize Serial for debug output\npinMode(LED_BLUE, OUTPUT);\ndigitalWrite(LED_BLUE, HIGH);\n\n// Sensor Power Switch\npinMode(WB_IO2, OUTPUT);\ndigitalWrite(WB_IO2, HIGH);\n\n// Reset RAK14003 module\npinMode(WB_IO4, OUTPUT);\ndigitalWrite(WB_IO4, HIGH);\ndelay(10);\ndigitalWrite(WB_IO4, LOW);\ndelay(10);\ndigitalWrite(WB_IO4, HIGH);\ndelay(10);\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial) {\nif ((millis() - timeout) < 5000) {\ndelay(100);\n} else {\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA) {\nSerial.println(\"Type: OTAA\");\n} else {\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion) {\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA) {\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n} else {\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0) {\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"================================\");\nSerial.println(\"RAK12019 + RAK12010 LoRaWAN Code\");\nSerial.println(\"================================\");\n\nif (!VMEL.begin())\n{\nSerial.println(\"Sensor not found\");\nwhile (1);\n}\n\nVMEL.setGain(VEML7700_GAIN_1);\nVMEL.setIntegrationTime(VEML7700_IT_800MS);\n\nSerial.print(F(\"Gain: \"));\nswitch (VMEL.getGain())\n{\ncase VEML7700_GAIN_1: Serial.println(\"1\"); break;\ncase VEML7700_GAIN_2: Serial.println(\"2\"); break;\ncase VEML7700_GAIN_1_4: Serial.println(\"1/4\"); break;\ncase VEML7700_GAIN_1_8: Serial.println(\"1/8\"); break;\n}\n\nSerial.print(F(\"Integration Time (ms): \"));\nswitch (VMEL.getIntegrationTime())\n{\ncase VEML7700_IT_25MS: Serial.println(\"25\"); break;\ncase VEML7700_IT_50MS: Serial.println(\"50\"); break;\ncase VEML7700_IT_100MS: Serial.println(\"100\"); break;\ncase VEML7700_IT_200MS: Serial.println(\"200\"); break;\ncase VEML7700_IT_400MS: Serial.println(\"400\"); break;\ncase VEML7700_IT_800MS: Serial.println(\"800\"); break;\n}\n\nSerial.println(\"RAK12019 test\");\nWire.begin();\nif (!ltr.init())\n{\nSerial.println(\"Couldn't find LTR sensor!\");\nwhile (1)\ndelay(10);\n}\nSerial.println(\"Found LTR390 sensor!\");\n\n//set to LTR390_MODE_UVS,get ultraviolet light data.\nltr.setMode(LTR390_MODE_UVS);  // UVS Mode\n\nSerial.println(\"In UVS mode\");\n\nltr.setGain(LTR390_GAIN_3);\nSerial.print(\"Gain : \");\nswitch (ltr.getGain())\n{\ncase LTR390_GAIN_1:\nSerial.println(1);\nbreak;\ncase LTR390_GAIN_3:\nSerial.println(3);\nbreak;\ncase LTR390_GAIN_6:\nSerial.println(6);\nbreak;\ncase LTR390_GAIN_9:\nSerial.println(9);\nbreak;\ncase LTR390_GAIN_18:\nSerial.println(18);\nbreak;\ndefault:\nSerial.println(\"Failed to set gain\");\nbreak;\n}\nltr.setResolution(LTR390_RESOLUTION_16BIT);\nSerial.print(\"Integration Time (ms): \");\nswitch (ltr.getResolution())\n{\ncase LTR390_RESOLUTION_13BIT:\nSerial.println(13);\nbreak;\ncase LTR390_RESOLUTION_16BIT:\nSerial.println(16);\nbreak;\ncase LTR390_RESOLUTION_17BIT:\nSerial.println(17);\nbreak;\ncase LTR390_RESOLUTION_18BIT:\nSerial.println(18);\nbreak;\ncase LTR390_RESOLUTION_19BIT:\nSerial.println(19);\nbreak;\ncase LTR390_RESOLUTION_20BIT:\nSerial.println(20);\nbreak;\ndefault:\nSerial.println(\"Failed to set Integration Time\");\nbreak;\n}\n\nltr.setThresholds(100, 1000); //Set the interrupt output threshold range for lower and upper.\n\nltr.configInterrupt(true, LTR390_MODE_UVS);\n\n// For RAK14003\nmcp.begin_I2C(0x24);\n\n// Added for the functionality of RAK14003\n\nWire.begin();    // initialize I2C serial bus\n\n// Configuration of MCP23017 I/O ports\nmcp.pinMode(LED_0, OUTPUT);     // Red LED; Top most\nmcp.pinMode(LED_1, OUTPUT);     // Red LED\nmcp.pinMode(LED_2, OUTPUT);     // Orange LED\nmcp.pinMode(LED_3, OUTPUT);     // Orange LED\nmcp.pinMode(LED_4, OUTPUT);     // Orange LED\nmcp.pinMode(LED_5, OUTPUT);     // Green LED\nmcp.pinMode(LED_6, OUTPUT);     // Green LED\nmcp.pinMode(LED_7, OUTPUT);     // Green LED\nmcp.pinMode(LED_8, OUTPUT);     // Green LED\nmcp.pinMode(LED_9, OUTPUT);     // Green LED; Bottom\n\n// Initially Turn OFF all LEDs\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, HIGH);\n\n}\n\nvoid loop() {\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\n// Trial # 1\n// Data from RAK12019\nif (ltr.newDataAvailable())\n{\nuvi = ltr.getUVI();\nuvs = ltr.readUVS();\n}\n\n// Data from RAK12010\nlux = VMEL.readLux();\nwhite = VMEL.readWhite();\nraw_als = VMEL.readALS();\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\n\n// From RAK12019 module\nSerial.print(\"UVI: \");\nSerial.println(uvi);          // Uvi data from RAK12019\nSerial.print(\"UVS: \");\nSerial.println(uvs);            // Uvs data from RAK12019\n\n// From RAK12010\nSerial.print(\"Lux: \");\nSerial.print(lux);\nSerial.println(\" lx \");\nSerial.print(\"White: \");\nSerial.println(white);\nSerial.print(\"Raw ALS: \");\nSerial.println(raw_als);\n\n// Result of uvi to be displayed via RAK14003 module\nif (uvi <= 0.4)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, HIGH);\n}\n\nelse if (uvi > 0.5 && uvi <= 1)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 1.5 && uvi <= 2)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 2.5 && uvi <= 3)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 3.5 && uvi <= 4)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 4.5 && uvi <= 5)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 5.5 && uvi <= 6)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 6.5 && uvi <= 7)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 7.5 && uvi <= 8)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 8.5 && uvi <= 9.5)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, LOW);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi >= 10)\n{\nmcp.digitalWrite(LED_0, LOW);\nmcp.digitalWrite(LED_1, LOW);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\ndelay(10000);\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void) {\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void) {\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data) {\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class) {\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void) {\nif (lmh_join_status_get() != LMH_SET) {\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\ndata = \" Uvi Data: \" + String(uvi) + \" Uvs Data: \" + String(uvs) + \" Lux Data: \" + String(lux) + \" lx \" ;\n\nSerial.println(data);\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\nuint16_t uvi_data = uvi;            // Uvi data from RAK12019\nuint32_t uvs_data = uvs;            // Uvs data from RAK12019\nuint32_t lux_data = lux;            // Lux data from RAK12010\n\nm_lora_app_data.buffer[i++] = 0x01;  // byte[0]\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\n// Data from RAK12019 module\nm_lora_app_data.buffer[i++] = (uint8_t)((uvi_data & 0x0000FF00) >> 8);     // byte[1]\nm_lora_app_data.buffer[i++] = (uint8_t)(uvi_data & 0x000000FF);            // byte[2]\n\n// Data from RAK12019 module\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0xFF000000) >> 24);    // byte[3]\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0x00FF0000) >> 16);    // byte[4]\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0x0000FF00) >> 8);     // byte[5]\nm_lora_app_data.buffer[i++] = (uint8_t)(uvs_data & 0x000000FF);            // byte[6]\n\n// Data from RAK12010 module\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0xFF000000) >> 24);    // byte[7]\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0x00FF0000) >> 16);    // byte[8]\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0x0000FF00) >> 8);     // byte[9]\nm_lora_app_data.buffer[i++] = (uint8_t)(lux_data & 0x000000FF);            // byte[10]\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS) {\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n} else {\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xE9, 0x0D, 0x28, 0x1D, 0x92, 0x3D, 0xE4, 0x9F, 0xD9, 0xF7, 0xE0, 0x5F, 0x39, 0x10, 0x55, 0x71 };\n\n```  \n> **Image:** OTAA device successfully registered to TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "46ab0fa67f97a58891890fc78a44edcd", "product_family": "wisblock", "product_id": "kit6-light-and-color", "category": "How-To", "title": "WisBlock IoT Education Kit - Light & Color Quick Start Guide > WisBlock IoT Education Kit - Light & Color Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock IoT Education Kit - Light & Color using TTN and Qubitro > UV Index & UV Intensity Monitoring LoRaWAN Application > LoRaWAN Code for UV Index & UV Intensity Monitoring > Programming UV Index & UV Intensity Monitoring Device with Arduino IDE [CODE]", "content": "Serial.println(\"RAK12019 test\");\nWire.begin();\nif (!ltr.init())\n{\nSerial.println(\"Couldn't find LTR sensor!\");\nwhile (1)\ndelay(10);\n}\nSerial.println(\"Found LTR390 sensor!\");\n\n//set to LTR390_MODE_UVS,get ultraviolet light data.\nltr.setMode(LTR390_MODE_UVS);  // UVS Mode\n\nSerial.println(\"In UVS mode\");", "keywords": ["Arduino IDE", "RAK4631", "UV Index", "UV Intensity", "LoRaWAN", "SX126x-Arduino"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **UV Index & UV Intensity Monitoring** device. Just copy the code below for **UV Index & UV Intensity Monitoring LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the example </summary>  \n```c\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h>  //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n#include \"UVlight_LTR390.h\"                // http://librarymanager/All#RAK12019_LTR390\nUVlight_LTR390 ltr = UVlight_LTR390();\n\n#include \"Light_VEML7700.h\"                // http://librarymanager/All#Light_veml7700\nLight_VEML7700 VMEL = Light_VEML7700();\n\nuint16_t uvi;\nuint32_t uvs;\nuint32_t lux;\nuint32_t white;\nuint32_t raw_als;\n\n#include <Adafruit_MCP23X17.h>  //http://librarymanager/All#Adafruit_MCP23017\nAdafruit_MCP23X17 mcp;\n\n// Added definitions for the functionality of RAK14003\nconst uint8_t LED_0 = 0;      // PA0 (17) of MCP23017\nconst uint8_t LED_1 = 1;      // PA1 (18) of MCP23017\nconst uint8_t LED_2 = 2;      // PA2 (19) of MCP23017\nconst uint8_t LED_3 = 3;      // PA3 (20) of MCP23017\nconst uint8_t LED_4 = 4;      // PA4 (21) of MCP23017\nconst uint8_t LED_5 = 5;      // PA5 (22) of MCP23017\nconst uint8_t LED_6 = 6;      // PA6 (23) of MCP23017\nconst uint8_t LED_7 = 7;      // PA7 (24) of MCP23017\nconst uint8_t LED_8 = 8;      // PB0 (25) of MCP23017\nconst uint8_t LED_9 = 9;      // PB1 (26) of MCP23017\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define RAK4631_BOARD true\n#else\n#define RAK4631_BOARD false\n#endif\n\nbool doOTAA = true;                                               // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                                       /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                                     /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5                               /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                                        /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;                           /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;                 /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                              /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = { LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF };\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = { BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler };\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xE9, 0x0D, 0x28, 0x1D, 0x92, 0x3D, 0xE4, 0x9F, 0xD9, 0xF7, 0xE0, 0x5F, 0x39, 0x10, 0x55, 0x71 };\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };\nuint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                                            /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];               //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = { m_lora_app_data_buffer, 0, 0, 0, 0 };  //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {\n\n// Initialize Serial for debug output\npinMode(LED_BLUE, OUTPUT);\ndigitalWrite(LED_BLUE, HIGH);\n\n// Sensor Power Switch\npinMode(WB_IO2, OUTPUT);\ndigitalWrite(WB_IO2, HIGH);\n\n// Reset RAK14003 module\npinMode(WB_IO4, OUTPUT);\ndigitalWrite(WB_IO4, HIGH);\ndelay(10);\ndigitalWrite(WB_IO4, LOW);\ndelay(10);\ndigitalWrite(WB_IO4, HIGH);\ndelay(10);\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial) {\nif ((millis() - timeout) < 5000) {\ndelay(100);\n} else {\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA) {\nSerial.println(\"Type: OTAA\");\n} else {\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion) {\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA) {\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n} else {\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0) {\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"================================\");\nSerial.println(\"RAK12019 + RAK12010 LoRaWAN Code\");\nSerial.println(\"================================\");\n\nif (!VMEL.begin())\n{\nSerial.println(\"Sensor not found\");\nwhile (1);\n}\n\nVMEL.setGain(VEML7700_GAIN_1);\nVMEL.setIntegrationTime(VEML7700_IT_800MS);\n\nSerial.print(F(\"Gain: \"));\nswitch (VMEL.getGain())\n{\ncase VEML7700_GAIN_1: Serial.println(\"1\"); break;\ncase VEML7700_GAIN_2: Serial.println(\"2\"); break;\ncase VEML7700_GAIN_1_4: Serial.println(\"1/4\"); break;\ncase VEML7700_GAIN_1_8: Serial.println(\"1/8\"); break;\n}\n\nSerial.print(F(\"Integration Time (ms): \"));\nswitch (VMEL.getIntegrationTime())\n{\ncase VEML7700_IT_25MS: Serial.println(\"25\"); break;\ncase VEML7700_IT_50MS: Serial.println(\"50\"); break;\ncase VEML7700_IT_100MS: Serial.println(\"100\"); break;\ncase VEML7700_IT_200MS: Serial.println(\"200\"); break;\ncase VEML7700_IT_400MS: Serial.println(\"400\"); break;\ncase VEML7700_IT_800MS: Serial.println(\"800\"); break;\n}\n\nSerial.println(\"RAK12019 test\");\nWire.begin();\nif (!ltr.init())\n{\nSerial.println(\"Couldn't find LTR sensor!\");\nwhile (1)\ndelay(10);\n}\nSerial.println(\"Found LTR390 sensor!\");\n\n//set to LTR390_MODE_UVS,get ultraviolet light data.\nltr.setMode(LTR390_MODE_UVS);  // UVS Mode\n\nSerial.println(\"In UVS mode\");\n\nltr.setGain(LTR390_GAIN_3);\nSerial.print(\"Gain : \");\nswitch (ltr.getGain())\n{\ncase LTR390_GAIN_1:\nSerial.println(1);\nbreak;\ncase LTR390_GAIN_3:\nSerial.println(3);\nbreak;\ncase LTR390_GAIN_6:\nSerial.println(6);\nbreak;\ncase LTR390_GAIN_9:\nSerial.println(9);\nbreak;\ncase LTR390_GAIN_18:\nSerial.println(18);\nbreak;\ndefault:\nSerial.println(\"Failed to set gain\");\nbreak;\n}\nltr.setResolution(LTR390_RESOLUTION_16BIT);\nSerial.print(\"Integration Time (ms): \");\nswitch (ltr.getResolution())\n{\ncase LTR390_RESOLUTION_13BIT:\nSerial.println(13);\nbreak;\ncase LTR390_RESOLUTION_16BIT:\nSerial.println(16);\nbreak;\ncase LTR390_RESOLUTION_17BIT:\nSerial.println(17);\nbreak;\ncase LTR390_RESOLUTION_18BIT:\nSerial.println(18);\nbreak;\ncase LTR390_RESOLUTION_19BIT:\nSerial.println(19);\nbreak;\ncase LTR390_RESOLUTION_20BIT:\nSerial.println(20);\nbreak;\ndefault:\nSerial.println(\"Failed to set Integration Time\");\nbreak;\n}\n\nltr.setThresholds(100, 1000); //Set the interrupt output threshold range for lower and upper.\n\nltr.configInterrupt(true, LTR390_MODE_UVS);\n\n// For RAK14003\nmcp.begin_I2C(0x24);\n\n// Added for the functionality of RAK14003\n\nWire.begin();    // initialize I2C serial bus\n\n// Configuration of MCP23017 I/O ports\nmcp.pinMode(LED_0, OUTPUT);     // Red LED; Top most\nmcp.pinMode(LED_1, OUTPUT);     // Red LED\nmcp.pinMode(LED_2, OUTPUT);     // Orange LED\nmcp.pinMode(LED_3, OUTPUT);     // Orange LED\nmcp.pinMode(LED_4, OUTPUT);     // Orange LED\nmcp.pinMode(LED_5, OUTPUT);     // Green LED\nmcp.pinMode(LED_6, OUTPUT);     // Green LED\nmcp.pinMode(LED_7, OUTPUT);     // Green LED\nmcp.pinMode(LED_8, OUTPUT);     // Green LED\nmcp.pinMode(LED_9, OUTPUT);     // Green LED; Bottom\n\n// Initially Turn OFF all LEDs\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, HIGH);\n\n}\n\nvoid loop() {\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\n// Trial # 1\n// Data from RAK12019\nif (ltr.newDataAvailable())\n{\nuvi = ltr.getUVI();\nuvs = ltr.readUVS();\n}\n\n// Data from RAK12010\nlux = VMEL.readLux();\nwhite = VMEL.readWhite();\nraw_als = VMEL.readALS();\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\n\n// From RAK12019 module\nSerial.print(\"UVI: \");\nSerial.println(uvi);          // Uvi data from RAK12019\nSerial.print(\"UVS: \");\nSerial.println(uvs);            // Uvs data from RAK12019\n\n// From RAK12010\nSerial.print(\"Lux: \");\nSerial.print(lux);\nSerial.println(\" lx \");\nSerial.print(\"White: \");\nSerial.println(white);\nSerial.print(\"Raw ALS: \");\nSerial.println(raw_als);\n\n// Result of uvi to be displayed via RAK14003 module\nif (uvi <= 0.4)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, HIGH);\n}\n\nelse if (uvi > 0.5 && uvi <= 1)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 1.5 && uvi <= 2)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 2.5 && uvi <= 3)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 3.5 && uvi <= 4)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 4.5 && uvi <= 5)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 5.5 && uvi <= 6)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 6.5 && uvi <= 7)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 7.5 && uvi <= 8)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 8.5 && uvi <= 9.5)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, LOW);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi >= 10)\n{\nmcp.digitalWrite(LED_0, LOW);\nmcp.digitalWrite(LED_1, LOW);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\ndelay(10000);\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void) {\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void) {\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data) {\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class) {\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void) {\nif (lmh_join_status_get() != LMH_SET) {\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\ndata = \" Uvi Data: \" + String(uvi) + \" Uvs Data: \" + String(uvs) + \" Lux Data: \" + String(lux) + \" lx \" ;\n\nSerial.println(data);\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\nuint16_t uvi_data = uvi;            // Uvi data from RAK12019\nuint32_t uvs_data = uvs;            // Uvs data from RAK12019\nuint32_t lux_data = lux;            // Lux data from RAK12010\n\nm_lora_app_data.buffer[i++] = 0x01;  // byte[0]\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\n// Data from RAK12019 module\nm_lora_app_data.buffer[i++] = (uint8_t)((uvi_data & 0x0000FF00) >> 8);     // byte[1]\nm_lora_app_data.buffer[i++] = (uint8_t)(uvi_data & 0x000000FF);            // byte[2]\n\n// Data from RAK12019 module\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0xFF000000) >> 24);    // byte[3]\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0x00FF0000) >> 16);    // byte[4]\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0x0000FF00) >> 8);     // byte[5]\nm_lora_app_data.buffer[i++] = (uint8_t)(uvs_data & 0x000000FF);            // byte[6]\n\n// Data from RAK12010 module\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0xFF000000) >> 24);    // byte[7]\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0x00FF0000) >> 16);    // byte[8]\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0x0000FF00) >> 8);     // byte[9]\nm_lora_app_data.buffer[i++] = (uint8_t)(lux_data & 0x000000FF);            // byte[10]\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS) {\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n} else {\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xE9, 0x0D, 0x28, 0x1D, 0x92, 0x3D, 0xE4, 0x9F, 0xD9, 0xF7, 0xE0, 0x5F, 0x39, 0x10, 0x55, 0x71 };\n\n```  \n> **Image:** OTAA device successfully registered to TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "5508bb04b5a54ad0ec0b21fcf55218b0", "product_family": "wisblock", "product_id": "kit6-light-and-color", "category": "How-To", "title": "WisBlock IoT Education Kit - Light & Color Quick Start Guide > WisBlock IoT Education Kit - Light & Color Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock IoT Education Kit - Light & Color using TTN and Qubitro > UV Index & UV Intensity Monitoring LoRaWAN Application > LoRaWAN Code for UV Index & UV Intensity Monitoring > Programming UV Index & UV Intensity Monitoring Device with Arduino IDE [CODE]", "content": "ltr.setGain(LTR390_GAIN_3);\nSerial.print(\"Gain : \");\nswitch (ltr.getGain())\n{\ncase LTR390_GAIN_1:\nSerial.println(1);\nbreak;\ncase LTR390_GAIN_3:\nSerial.println(3);\nbreak;\ncase LTR390_GAIN_6:\nSerial.println(6);\nbreak;\ncase LTR390_GAIN_9:\nSerial.println(9);\nbreak;\ncase LTR390_GAIN_18:\nSerial.println(18);\nbreak;\ndefault:\nSerial.println(\"Failed to set gain\");\nbreak;\n}\nltr.setResolution(LTR390_RESOLUTION_16BIT);\nSerial.print(\"Integration Time (ms): \");\nswitch (ltr.getResolution())\n{", "keywords": ["Arduino IDE", "RAK4631", "UV Index", "UV Intensity", "LoRaWAN", "SX126x-Arduino"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **UV Index & UV Intensity Monitoring** device. Just copy the code below for **UV Index & UV Intensity Monitoring LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the example </summary>  \n```c\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h>  //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n#include \"UVlight_LTR390.h\"                // http://librarymanager/All#RAK12019_LTR390\nUVlight_LTR390 ltr = UVlight_LTR390();\n\n#include \"Light_VEML7700.h\"                // http://librarymanager/All#Light_veml7700\nLight_VEML7700 VMEL = Light_VEML7700();\n\nuint16_t uvi;\nuint32_t uvs;\nuint32_t lux;\nuint32_t white;\nuint32_t raw_als;\n\n#include <Adafruit_MCP23X17.h>  //http://librarymanager/All#Adafruit_MCP23017\nAdafruit_MCP23X17 mcp;\n\n// Added definitions for the functionality of RAK14003\nconst uint8_t LED_0 = 0;      // PA0 (17) of MCP23017\nconst uint8_t LED_1 = 1;      // PA1 (18) of MCP23017\nconst uint8_t LED_2 = 2;      // PA2 (19) of MCP23017\nconst uint8_t LED_3 = 3;      // PA3 (20) of MCP23017\nconst uint8_t LED_4 = 4;      // PA4 (21) of MCP23017\nconst uint8_t LED_5 = 5;      // PA5 (22) of MCP23017\nconst uint8_t LED_6 = 6;      // PA6 (23) of MCP23017\nconst uint8_t LED_7 = 7;      // PA7 (24) of MCP23017\nconst uint8_t LED_8 = 8;      // PB0 (25) of MCP23017\nconst uint8_t LED_9 = 9;      // PB1 (26) of MCP23017\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define RAK4631_BOARD true\n#else\n#define RAK4631_BOARD false\n#endif\n\nbool doOTAA = true;                                               // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                                       /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                                     /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5                               /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                                        /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;                           /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;                 /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                              /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = { LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF };\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = { BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler };\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xE9, 0x0D, 0x28, 0x1D, 0x92, 0x3D, 0xE4, 0x9F, 0xD9, 0xF7, 0xE0, 0x5F, 0x39, 0x10, 0x55, 0x71 };\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };\nuint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                                            /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];               //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = { m_lora_app_data_buffer, 0, 0, 0, 0 };  //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {\n\n// Initialize Serial for debug output\npinMode(LED_BLUE, OUTPUT);\ndigitalWrite(LED_BLUE, HIGH);\n\n// Sensor Power Switch\npinMode(WB_IO2, OUTPUT);\ndigitalWrite(WB_IO2, HIGH);\n\n// Reset RAK14003 module\npinMode(WB_IO4, OUTPUT);\ndigitalWrite(WB_IO4, HIGH);\ndelay(10);\ndigitalWrite(WB_IO4, LOW);\ndelay(10);\ndigitalWrite(WB_IO4, HIGH);\ndelay(10);\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial) {\nif ((millis() - timeout) < 5000) {\ndelay(100);\n} else {\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA) {\nSerial.println(\"Type: OTAA\");\n} else {\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion) {\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA) {\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n} else {\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0) {\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"================================\");\nSerial.println(\"RAK12019 + RAK12010 LoRaWAN Code\");\nSerial.println(\"================================\");\n\nif (!VMEL.begin())\n{\nSerial.println(\"Sensor not found\");\nwhile (1);\n}\n\nVMEL.setGain(VEML7700_GAIN_1);\nVMEL.setIntegrationTime(VEML7700_IT_800MS);\n\nSerial.print(F(\"Gain: \"));\nswitch (VMEL.getGain())\n{\ncase VEML7700_GAIN_1: Serial.println(\"1\"); break;\ncase VEML7700_GAIN_2: Serial.println(\"2\"); break;\ncase VEML7700_GAIN_1_4: Serial.println(\"1/4\"); break;\ncase VEML7700_GAIN_1_8: Serial.println(\"1/8\"); break;\n}\n\nSerial.print(F(\"Integration Time (ms): \"));\nswitch (VMEL.getIntegrationTime())\n{\ncase VEML7700_IT_25MS: Serial.println(\"25\"); break;\ncase VEML7700_IT_50MS: Serial.println(\"50\"); break;\ncase VEML7700_IT_100MS: Serial.println(\"100\"); break;\ncase VEML7700_IT_200MS: Serial.println(\"200\"); break;\ncase VEML7700_IT_400MS: Serial.println(\"400\"); break;\ncase VEML7700_IT_800MS: Serial.println(\"800\"); break;\n}\n\nSerial.println(\"RAK12019 test\");\nWire.begin();\nif (!ltr.init())\n{\nSerial.println(\"Couldn't find LTR sensor!\");\nwhile (1)\ndelay(10);\n}\nSerial.println(\"Found LTR390 sensor!\");\n\n//set to LTR390_MODE_UVS,get ultraviolet light data.\nltr.setMode(LTR390_MODE_UVS);  // UVS Mode\n\nSerial.println(\"In UVS mode\");\n\nltr.setGain(LTR390_GAIN_3);\nSerial.print(\"Gain : \");\nswitch (ltr.getGain())\n{\ncase LTR390_GAIN_1:\nSerial.println(1);\nbreak;\ncase LTR390_GAIN_3:\nSerial.println(3);\nbreak;\ncase LTR390_GAIN_6:\nSerial.println(6);\nbreak;\ncase LTR390_GAIN_9:\nSerial.println(9);\nbreak;\ncase LTR390_GAIN_18:\nSerial.println(18);\nbreak;\ndefault:\nSerial.println(\"Failed to set gain\");\nbreak;\n}\nltr.setResolution(LTR390_RESOLUTION_16BIT);\nSerial.print(\"Integration Time (ms): \");\nswitch (ltr.getResolution())\n{\ncase LTR390_RESOLUTION_13BIT:\nSerial.println(13);\nbreak;\ncase LTR390_RESOLUTION_16BIT:\nSerial.println(16);\nbreak;\ncase LTR390_RESOLUTION_17BIT:\nSerial.println(17);\nbreak;\ncase LTR390_RESOLUTION_18BIT:\nSerial.println(18);\nbreak;\ncase LTR390_RESOLUTION_19BIT:\nSerial.println(19);\nbreak;\ncase LTR390_RESOLUTION_20BIT:\nSerial.println(20);\nbreak;\ndefault:\nSerial.println(\"Failed to set Integration Time\");\nbreak;\n}\n\nltr.setThresholds(100, 1000); //Set the interrupt output threshold range for lower and upper.\n\nltr.configInterrupt(true, LTR390_MODE_UVS);\n\n// For RAK14003\nmcp.begin_I2C(0x24);\n\n// Added for the functionality of RAK14003\n\nWire.begin();    // initialize I2C serial bus\n\n// Configuration of MCP23017 I/O ports\nmcp.pinMode(LED_0, OUTPUT);     // Red LED; Top most\nmcp.pinMode(LED_1, OUTPUT);     // Red LED\nmcp.pinMode(LED_2, OUTPUT);     // Orange LED\nmcp.pinMode(LED_3, OUTPUT);     // Orange LED\nmcp.pinMode(LED_4, OUTPUT);     // Orange LED\nmcp.pinMode(LED_5, OUTPUT);     // Green LED\nmcp.pinMode(LED_6, OUTPUT);     // Green LED\nmcp.pinMode(LED_7, OUTPUT);     // Green LED\nmcp.pinMode(LED_8, OUTPUT);     // Green LED\nmcp.pinMode(LED_9, OUTPUT);     // Green LED; Bottom\n\n// Initially Turn OFF all LEDs\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, HIGH);\n\n}\n\nvoid loop() {\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\n// Trial # 1\n// Data from RAK12019\nif (ltr.newDataAvailable())\n{\nuvi = ltr.getUVI();\nuvs = ltr.readUVS();\n}\n\n// Data from RAK12010\nlux = VMEL.readLux();\nwhite = VMEL.readWhite();\nraw_als = VMEL.readALS();\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\n\n// From RAK12019 module\nSerial.print(\"UVI: \");\nSerial.println(uvi);          // Uvi data from RAK12019\nSerial.print(\"UVS: \");\nSerial.println(uvs);            // Uvs data from RAK12019\n\n// From RAK12010\nSerial.print(\"Lux: \");\nSerial.print(lux);\nSerial.println(\" lx \");\nSerial.print(\"White: \");\nSerial.println(white);\nSerial.print(\"Raw ALS: \");\nSerial.println(raw_als);\n\n// Result of uvi to be displayed via RAK14003 module\nif (uvi <= 0.4)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, HIGH);\n}\n\nelse if (uvi > 0.5 && uvi <= 1)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 1.5 && uvi <= 2)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 2.5 && uvi <= 3)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 3.5 && uvi <= 4)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 4.5 && uvi <= 5)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 5.5 && uvi <= 6)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 6.5 && uvi <= 7)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 7.5 && uvi <= 8)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 8.5 && uvi <= 9.5)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, LOW);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi >= 10)\n{\nmcp.digitalWrite(LED_0, LOW);\nmcp.digitalWrite(LED_1, LOW);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\ndelay(10000);\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void) {\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void) {\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data) {\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class) {\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void) {\nif (lmh_join_status_get() != LMH_SET) {\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\ndata = \" Uvi Data: \" + String(uvi) + \" Uvs Data: \" + String(uvs) + \" Lux Data: \" + String(lux) + \" lx \" ;\n\nSerial.println(data);\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\nuint16_t uvi_data = uvi;            // Uvi data from RAK12019\nuint32_t uvs_data = uvs;            // Uvs data from RAK12019\nuint32_t lux_data = lux;            // Lux data from RAK12010\n\nm_lora_app_data.buffer[i++] = 0x01;  // byte[0]\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\n// Data from RAK12019 module\nm_lora_app_data.buffer[i++] = (uint8_t)((uvi_data & 0x0000FF00) >> 8);     // byte[1]\nm_lora_app_data.buffer[i++] = (uint8_t)(uvi_data & 0x000000FF);            // byte[2]\n\n// Data from RAK12019 module\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0xFF000000) >> 24);    // byte[3]\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0x00FF0000) >> 16);    // byte[4]\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0x0000FF00) >> 8);     // byte[5]\nm_lora_app_data.buffer[i++] = (uint8_t)(uvs_data & 0x000000FF);            // byte[6]\n\n// Data from RAK12010 module\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0xFF000000) >> 24);    // byte[7]\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0x00FF0000) >> 16);    // byte[8]\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0x0000FF00) >> 8);     // byte[9]\nm_lora_app_data.buffer[i++] = (uint8_t)(lux_data & 0x000000FF);            // byte[10]\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS) {\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n} else {\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xE9, 0x0D, 0x28, 0x1D, 0x92, 0x3D, 0xE4, 0x9F, 0xD9, 0xF7, 0xE0, 0x5F, 0x39, 0x10, 0x55, 0x71 };\n\n```  \n> **Image:** OTAA device successfully registered to TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "feb219e6e427fb0fbd58e93dd599c4c0", "product_family": "wisblock", "product_id": "kit6-light-and-color", "category": "How-To", "title": "WisBlock IoT Education Kit - Light & Color Quick Start Guide > WisBlock IoT Education Kit - Light & Color Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock IoT Education Kit - Light & Color using TTN and Qubitro > UV Index & UV Intensity Monitoring LoRaWAN Application > LoRaWAN Code for UV Index & UV Intensity Monitoring > Programming UV Index & UV Intensity Monitoring Device with Arduino IDE [CODE]", "content": "Serial.print(\"Integration Time (ms): \");\nswitch (ltr.getResolution())\n{\ncase LTR390_RESOLUTION_13BIT:\nSerial.println(13);\nbreak;\ncase LTR390_RESOLUTION_16BIT:\nSerial.println(16);\nbreak;\ncase LTR390_RESOLUTION_17BIT:\nSerial.println(17);\nbreak;\ncase LTR390_RESOLUTION_18BIT:\nSerial.println(18);\nbreak;\ncase LTR390_RESOLUTION_19BIT:\nSerial.println(19);\nbreak;\ncase LTR390_RESOLUTION_20BIT:\nSerial.println(20);\nbreak;\ndefault:\nSerial.println(\"Failed to set Integration Time\");\nbreak;\n}", "keywords": ["Arduino IDE", "RAK4631", "UV Index", "UV Intensity", "LoRaWAN", "SX126x-Arduino"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **UV Index & UV Intensity Monitoring** device. Just copy the code below for **UV Index & UV Intensity Monitoring LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the example </summary>  \n```c\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h>  //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n#include \"UVlight_LTR390.h\"                // http://librarymanager/All#RAK12019_LTR390\nUVlight_LTR390 ltr = UVlight_LTR390();\n\n#include \"Light_VEML7700.h\"                // http://librarymanager/All#Light_veml7700\nLight_VEML7700 VMEL = Light_VEML7700();\n\nuint16_t uvi;\nuint32_t uvs;\nuint32_t lux;\nuint32_t white;\nuint32_t raw_als;\n\n#include <Adafruit_MCP23X17.h>  //http://librarymanager/All#Adafruit_MCP23017\nAdafruit_MCP23X17 mcp;\n\n// Added definitions for the functionality of RAK14003\nconst uint8_t LED_0 = 0;      // PA0 (17) of MCP23017\nconst uint8_t LED_1 = 1;      // PA1 (18) of MCP23017\nconst uint8_t LED_2 = 2;      // PA2 (19) of MCP23017\nconst uint8_t LED_3 = 3;      // PA3 (20) of MCP23017\nconst uint8_t LED_4 = 4;      // PA4 (21) of MCP23017\nconst uint8_t LED_5 = 5;      // PA5 (22) of MCP23017\nconst uint8_t LED_6 = 6;      // PA6 (23) of MCP23017\nconst uint8_t LED_7 = 7;      // PA7 (24) of MCP23017\nconst uint8_t LED_8 = 8;      // PB0 (25) of MCP23017\nconst uint8_t LED_9 = 9;      // PB1 (26) of MCP23017\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define RAK4631_BOARD true\n#else\n#define RAK4631_BOARD false\n#endif\n\nbool doOTAA = true;                                               // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                                       /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                                     /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5                               /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                                        /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;                           /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;                 /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                              /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = { LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF };\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = { BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler };\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xE9, 0x0D, 0x28, 0x1D, 0x92, 0x3D, 0xE4, 0x9F, 0xD9, 0xF7, 0xE0, 0x5F, 0x39, 0x10, 0x55, 0x71 };\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };\nuint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                                            /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];               //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = { m_lora_app_data_buffer, 0, 0, 0, 0 };  //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {\n\n// Initialize Serial for debug output\npinMode(LED_BLUE, OUTPUT);\ndigitalWrite(LED_BLUE, HIGH);\n\n// Sensor Power Switch\npinMode(WB_IO2, OUTPUT);\ndigitalWrite(WB_IO2, HIGH);\n\n// Reset RAK14003 module\npinMode(WB_IO4, OUTPUT);\ndigitalWrite(WB_IO4, HIGH);\ndelay(10);\ndigitalWrite(WB_IO4, LOW);\ndelay(10);\ndigitalWrite(WB_IO4, HIGH);\ndelay(10);\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial) {\nif ((millis() - timeout) < 5000) {\ndelay(100);\n} else {\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA) {\nSerial.println(\"Type: OTAA\");\n} else {\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion) {\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA) {\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n} else {\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0) {\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"================================\");\nSerial.println(\"RAK12019 + RAK12010 LoRaWAN Code\");\nSerial.println(\"================================\");\n\nif (!VMEL.begin())\n{\nSerial.println(\"Sensor not found\");\nwhile (1);\n}\n\nVMEL.setGain(VEML7700_GAIN_1);\nVMEL.setIntegrationTime(VEML7700_IT_800MS);\n\nSerial.print(F(\"Gain: \"));\nswitch (VMEL.getGain())\n{\ncase VEML7700_GAIN_1: Serial.println(\"1\"); break;\ncase VEML7700_GAIN_2: Serial.println(\"2\"); break;\ncase VEML7700_GAIN_1_4: Serial.println(\"1/4\"); break;\ncase VEML7700_GAIN_1_8: Serial.println(\"1/8\"); break;\n}\n\nSerial.print(F(\"Integration Time (ms): \"));\nswitch (VMEL.getIntegrationTime())\n{\ncase VEML7700_IT_25MS: Serial.println(\"25\"); break;\ncase VEML7700_IT_50MS: Serial.println(\"50\"); break;\ncase VEML7700_IT_100MS: Serial.println(\"100\"); break;\ncase VEML7700_IT_200MS: Serial.println(\"200\"); break;\ncase VEML7700_IT_400MS: Serial.println(\"400\"); break;\ncase VEML7700_IT_800MS: Serial.println(\"800\"); break;\n}\n\nSerial.println(\"RAK12019 test\");\nWire.begin();\nif (!ltr.init())\n{\nSerial.println(\"Couldn't find LTR sensor!\");\nwhile (1)\ndelay(10);\n}\nSerial.println(\"Found LTR390 sensor!\");\n\n//set to LTR390_MODE_UVS,get ultraviolet light data.\nltr.setMode(LTR390_MODE_UVS);  // UVS Mode\n\nSerial.println(\"In UVS mode\");\n\nltr.setGain(LTR390_GAIN_3);\nSerial.print(\"Gain : \");\nswitch (ltr.getGain())\n{\ncase LTR390_GAIN_1:\nSerial.println(1);\nbreak;\ncase LTR390_GAIN_3:\nSerial.println(3);\nbreak;\ncase LTR390_GAIN_6:\nSerial.println(6);\nbreak;\ncase LTR390_GAIN_9:\nSerial.println(9);\nbreak;\ncase LTR390_GAIN_18:\nSerial.println(18);\nbreak;\ndefault:\nSerial.println(\"Failed to set gain\");\nbreak;\n}\nltr.setResolution(LTR390_RESOLUTION_16BIT);\nSerial.print(\"Integration Time (ms): \");\nswitch (ltr.getResolution())\n{\ncase LTR390_RESOLUTION_13BIT:\nSerial.println(13);\nbreak;\ncase LTR390_RESOLUTION_16BIT:\nSerial.println(16);\nbreak;\ncase LTR390_RESOLUTION_17BIT:\nSerial.println(17);\nbreak;\ncase LTR390_RESOLUTION_18BIT:\nSerial.println(18);\nbreak;\ncase LTR390_RESOLUTION_19BIT:\nSerial.println(19);\nbreak;\ncase LTR390_RESOLUTION_20BIT:\nSerial.println(20);\nbreak;\ndefault:\nSerial.println(\"Failed to set Integration Time\");\nbreak;\n}\n\nltr.setThresholds(100, 1000); //Set the interrupt output threshold range for lower and upper.\n\nltr.configInterrupt(true, LTR390_MODE_UVS);\n\n// For RAK14003\nmcp.begin_I2C(0x24);\n\n// Added for the functionality of RAK14003\n\nWire.begin();    // initialize I2C serial bus\n\n// Configuration of MCP23017 I/O ports\nmcp.pinMode(LED_0, OUTPUT);     // Red LED; Top most\nmcp.pinMode(LED_1, OUTPUT);     // Red LED\nmcp.pinMode(LED_2, OUTPUT);     // Orange LED\nmcp.pinMode(LED_3, OUTPUT);     // Orange LED\nmcp.pinMode(LED_4, OUTPUT);     // Orange LED\nmcp.pinMode(LED_5, OUTPUT);     // Green LED\nmcp.pinMode(LED_6, OUTPUT);     // Green LED\nmcp.pinMode(LED_7, OUTPUT);     // Green LED\nmcp.pinMode(LED_8, OUTPUT);     // Green LED\nmcp.pinMode(LED_9, OUTPUT);     // Green LED; Bottom\n\n// Initially Turn OFF all LEDs\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, HIGH);\n\n}\n\nvoid loop() {\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\n// Trial # 1\n// Data from RAK12019\nif (ltr.newDataAvailable())\n{\nuvi = ltr.getUVI();\nuvs = ltr.readUVS();\n}\n\n// Data from RAK12010\nlux = VMEL.readLux();\nwhite = VMEL.readWhite();\nraw_als = VMEL.readALS();\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\n\n// From RAK12019 module\nSerial.print(\"UVI: \");\nSerial.println(uvi);          // Uvi data from RAK12019\nSerial.print(\"UVS: \");\nSerial.println(uvs);            // Uvs data from RAK12019\n\n// From RAK12010\nSerial.print(\"Lux: \");\nSerial.print(lux);\nSerial.println(\" lx \");\nSerial.print(\"White: \");\nSerial.println(white);\nSerial.print(\"Raw ALS: \");\nSerial.println(raw_als);\n\n// Result of uvi to be displayed via RAK14003 module\nif (uvi <= 0.4)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, HIGH);\n}\n\nelse if (uvi > 0.5 && uvi <= 1)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 1.5 && uvi <= 2)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 2.5 && uvi <= 3)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 3.5 && uvi <= 4)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 4.5 && uvi <= 5)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 5.5 && uvi <= 6)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 6.5 && uvi <= 7)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 7.5 && uvi <= 8)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 8.5 && uvi <= 9.5)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, LOW);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi >= 10)\n{\nmcp.digitalWrite(LED_0, LOW);\nmcp.digitalWrite(LED_1, LOW);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\ndelay(10000);\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void) {\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void) {\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data) {\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class) {\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void) {\nif (lmh_join_status_get() != LMH_SET) {\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\ndata = \" Uvi Data: \" + String(uvi) + \" Uvs Data: \" + String(uvs) + \" Lux Data: \" + String(lux) + \" lx \" ;\n\nSerial.println(data);\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\nuint16_t uvi_data = uvi;            // Uvi data from RAK12019\nuint32_t uvs_data = uvs;            // Uvs data from RAK12019\nuint32_t lux_data = lux;            // Lux data from RAK12010\n\nm_lora_app_data.buffer[i++] = 0x01;  // byte[0]\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\n// Data from RAK12019 module\nm_lora_app_data.buffer[i++] = (uint8_t)((uvi_data & 0x0000FF00) >> 8);     // byte[1]\nm_lora_app_data.buffer[i++] = (uint8_t)(uvi_data & 0x000000FF);            // byte[2]\n\n// Data from RAK12019 module\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0xFF000000) >> 24);    // byte[3]\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0x00FF0000) >> 16);    // byte[4]\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0x0000FF00) >> 8);     // byte[5]\nm_lora_app_data.buffer[i++] = (uint8_t)(uvs_data & 0x000000FF);            // byte[6]\n\n// Data from RAK12010 module\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0xFF000000) >> 24);    // byte[7]\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0x00FF0000) >> 16);    // byte[8]\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0x0000FF00) >> 8);     // byte[9]\nm_lora_app_data.buffer[i++] = (uint8_t)(lux_data & 0x000000FF);            // byte[10]\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS) {\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n} else {\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xE9, 0x0D, 0x28, 0x1D, 0x92, 0x3D, 0xE4, 0x9F, 0xD9, 0xF7, 0xE0, 0x5F, 0x39, 0x10, 0x55, 0x71 };\n\n```  \n> **Image:** OTAA device successfully registered to TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "122b4ec6246f6c02bdeb130ba3e882d1", "product_family": "wisblock", "product_id": "kit6-light-and-color", "category": "How-To", "title": "WisBlock IoT Education Kit - Light & Color Quick Start Guide > WisBlock IoT Education Kit - Light & Color Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock IoT Education Kit - Light & Color using TTN and Qubitro > UV Index & UV Intensity Monitoring LoRaWAN Application > LoRaWAN Code for UV Index & UV Intensity Monitoring > Programming UV Index & UV Intensity Monitoring Device with Arduino IDE [CODE]", "content": "ltr.setThresholds(100, 1000); //Set the interrupt output threshold range for lower and upper.\n\nltr.configInterrupt(true, LTR390_MODE_UVS);\n\n// For RAK14003\nmcp.begin_I2C(0x24);\n\n// Added for the functionality of RAK14003\n\nWire.begin();    // initialize I2C serial bus", "keywords": ["Arduino IDE", "RAK4631", "UV Index", "UV Intensity", "LoRaWAN", "SX126x-Arduino"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **UV Index & UV Intensity Monitoring** device. Just copy the code below for **UV Index & UV Intensity Monitoring LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the example </summary>  \n```c\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h>  //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n#include \"UVlight_LTR390.h\"                // http://librarymanager/All#RAK12019_LTR390\nUVlight_LTR390 ltr = UVlight_LTR390();\n\n#include \"Light_VEML7700.h\"                // http://librarymanager/All#Light_veml7700\nLight_VEML7700 VMEL = Light_VEML7700();\n\nuint16_t uvi;\nuint32_t uvs;\nuint32_t lux;\nuint32_t white;\nuint32_t raw_als;\n\n#include <Adafruit_MCP23X17.h>  //http://librarymanager/All#Adafruit_MCP23017\nAdafruit_MCP23X17 mcp;\n\n// Added definitions for the functionality of RAK14003\nconst uint8_t LED_0 = 0;      // PA0 (17) of MCP23017\nconst uint8_t LED_1 = 1;      // PA1 (18) of MCP23017\nconst uint8_t LED_2 = 2;      // PA2 (19) of MCP23017\nconst uint8_t LED_3 = 3;      // PA3 (20) of MCP23017\nconst uint8_t LED_4 = 4;      // PA4 (21) of MCP23017\nconst uint8_t LED_5 = 5;      // PA5 (22) of MCP23017\nconst uint8_t LED_6 = 6;      // PA6 (23) of MCP23017\nconst uint8_t LED_7 = 7;      // PA7 (24) of MCP23017\nconst uint8_t LED_8 = 8;      // PB0 (25) of MCP23017\nconst uint8_t LED_9 = 9;      // PB1 (26) of MCP23017\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define RAK4631_BOARD true\n#else\n#define RAK4631_BOARD false\n#endif\n\nbool doOTAA = true;                                               // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                                       /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                                     /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5                               /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                                        /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;                           /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;                 /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                              /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = { LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF };\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = { BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler };\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xE9, 0x0D, 0x28, 0x1D, 0x92, 0x3D, 0xE4, 0x9F, 0xD9, 0xF7, 0xE0, 0x5F, 0x39, 0x10, 0x55, 0x71 };\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };\nuint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                                            /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];               //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = { m_lora_app_data_buffer, 0, 0, 0, 0 };  //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {\n\n// Initialize Serial for debug output\npinMode(LED_BLUE, OUTPUT);\ndigitalWrite(LED_BLUE, HIGH);\n\n// Sensor Power Switch\npinMode(WB_IO2, OUTPUT);\ndigitalWrite(WB_IO2, HIGH);\n\n// Reset RAK14003 module\npinMode(WB_IO4, OUTPUT);\ndigitalWrite(WB_IO4, HIGH);\ndelay(10);\ndigitalWrite(WB_IO4, LOW);\ndelay(10);\ndigitalWrite(WB_IO4, HIGH);\ndelay(10);\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial) {\nif ((millis() - timeout) < 5000) {\ndelay(100);\n} else {\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA) {\nSerial.println(\"Type: OTAA\");\n} else {\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion) {\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA) {\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n} else {\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0) {\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"================================\");\nSerial.println(\"RAK12019 + RAK12010 LoRaWAN Code\");\nSerial.println(\"================================\");\n\nif (!VMEL.begin())\n{\nSerial.println(\"Sensor not found\");\nwhile (1);\n}\n\nVMEL.setGain(VEML7700_GAIN_1);\nVMEL.setIntegrationTime(VEML7700_IT_800MS);\n\nSerial.print(F(\"Gain: \"));\nswitch (VMEL.getGain())\n{\ncase VEML7700_GAIN_1: Serial.println(\"1\"); break;\ncase VEML7700_GAIN_2: Serial.println(\"2\"); break;\ncase VEML7700_GAIN_1_4: Serial.println(\"1/4\"); break;\ncase VEML7700_GAIN_1_8: Serial.println(\"1/8\"); break;\n}\n\nSerial.print(F(\"Integration Time (ms): \"));\nswitch (VMEL.getIntegrationTime())\n{\ncase VEML7700_IT_25MS: Serial.println(\"25\"); break;\ncase VEML7700_IT_50MS: Serial.println(\"50\"); break;\ncase VEML7700_IT_100MS: Serial.println(\"100\"); break;\ncase VEML7700_IT_200MS: Serial.println(\"200\"); break;\ncase VEML7700_IT_400MS: Serial.println(\"400\"); break;\ncase VEML7700_IT_800MS: Serial.println(\"800\"); break;\n}\n\nSerial.println(\"RAK12019 test\");\nWire.begin();\nif (!ltr.init())\n{\nSerial.println(\"Couldn't find LTR sensor!\");\nwhile (1)\ndelay(10);\n}\nSerial.println(\"Found LTR390 sensor!\");\n\n//set to LTR390_MODE_UVS,get ultraviolet light data.\nltr.setMode(LTR390_MODE_UVS);  // UVS Mode\n\nSerial.println(\"In UVS mode\");\n\nltr.setGain(LTR390_GAIN_3);\nSerial.print(\"Gain : \");\nswitch (ltr.getGain())\n{\ncase LTR390_GAIN_1:\nSerial.println(1);\nbreak;\ncase LTR390_GAIN_3:\nSerial.println(3);\nbreak;\ncase LTR390_GAIN_6:\nSerial.println(6);\nbreak;\ncase LTR390_GAIN_9:\nSerial.println(9);\nbreak;\ncase LTR390_GAIN_18:\nSerial.println(18);\nbreak;\ndefault:\nSerial.println(\"Failed to set gain\");\nbreak;\n}\nltr.setResolution(LTR390_RESOLUTION_16BIT);\nSerial.print(\"Integration Time (ms): \");\nswitch (ltr.getResolution())\n{\ncase LTR390_RESOLUTION_13BIT:\nSerial.println(13);\nbreak;\ncase LTR390_RESOLUTION_16BIT:\nSerial.println(16);\nbreak;\ncase LTR390_RESOLUTION_17BIT:\nSerial.println(17);\nbreak;\ncase LTR390_RESOLUTION_18BIT:\nSerial.println(18);\nbreak;\ncase LTR390_RESOLUTION_19BIT:\nSerial.println(19);\nbreak;\ncase LTR390_RESOLUTION_20BIT:\nSerial.println(20);\nbreak;\ndefault:\nSerial.println(\"Failed to set Integration Time\");\nbreak;\n}\n\nltr.setThresholds(100, 1000); //Set the interrupt output threshold range for lower and upper.\n\nltr.configInterrupt(true, LTR390_MODE_UVS);\n\n// For RAK14003\nmcp.begin_I2C(0x24);\n\n// Added for the functionality of RAK14003\n\nWire.begin();    // initialize I2C serial bus\n\n// Configuration of MCP23017 I/O ports\nmcp.pinMode(LED_0, OUTPUT);     // Red LED; Top most\nmcp.pinMode(LED_1, OUTPUT);     // Red LED\nmcp.pinMode(LED_2, OUTPUT);     // Orange LED\nmcp.pinMode(LED_3, OUTPUT);     // Orange LED\nmcp.pinMode(LED_4, OUTPUT);     // Orange LED\nmcp.pinMode(LED_5, OUTPUT);     // Green LED\nmcp.pinMode(LED_6, OUTPUT);     // Green LED\nmcp.pinMode(LED_7, OUTPUT);     // Green LED\nmcp.pinMode(LED_8, OUTPUT);     // Green LED\nmcp.pinMode(LED_9, OUTPUT);     // Green LED; Bottom\n\n// Initially Turn OFF all LEDs\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, HIGH);\n\n}\n\nvoid loop() {\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\n// Trial # 1\n// Data from RAK12019\nif (ltr.newDataAvailable())\n{\nuvi = ltr.getUVI();\nuvs = ltr.readUVS();\n}\n\n// Data from RAK12010\nlux = VMEL.readLux();\nwhite = VMEL.readWhite();\nraw_als = VMEL.readALS();\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\n\n// From RAK12019 module\nSerial.print(\"UVI: \");\nSerial.println(uvi);          // Uvi data from RAK12019\nSerial.print(\"UVS: \");\nSerial.println(uvs);            // Uvs data from RAK12019\n\n// From RAK12010\nSerial.print(\"Lux: \");\nSerial.print(lux);\nSerial.println(\" lx \");\nSerial.print(\"White: \");\nSerial.println(white);\nSerial.print(\"Raw ALS: \");\nSerial.println(raw_als);\n\n// Result of uvi to be displayed via RAK14003 module\nif (uvi <= 0.4)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, HIGH);\n}\n\nelse if (uvi > 0.5 && uvi <= 1)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 1.5 && uvi <= 2)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 2.5 && uvi <= 3)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 3.5 && uvi <= 4)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 4.5 && uvi <= 5)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 5.5 && uvi <= 6)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 6.5 && uvi <= 7)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 7.5 && uvi <= 8)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 8.5 && uvi <= 9.5)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, LOW);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi >= 10)\n{\nmcp.digitalWrite(LED_0, LOW);\nmcp.digitalWrite(LED_1, LOW);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\ndelay(10000);\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void) {\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void) {\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data) {\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class) {\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void) {\nif (lmh_join_status_get() != LMH_SET) {\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\ndata = \" Uvi Data: \" + String(uvi) + \" Uvs Data: \" + String(uvs) + \" Lux Data: \" + String(lux) + \" lx \" ;\n\nSerial.println(data);\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\nuint16_t uvi_data = uvi;            // Uvi data from RAK12019\nuint32_t uvs_data = uvs;            // Uvs data from RAK12019\nuint32_t lux_data = lux;            // Lux data from RAK12010\n\nm_lora_app_data.buffer[i++] = 0x01;  // byte[0]\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\n// Data from RAK12019 module\nm_lora_app_data.buffer[i++] = (uint8_t)((uvi_data & 0x0000FF00) >> 8);     // byte[1]\nm_lora_app_data.buffer[i++] = (uint8_t)(uvi_data & 0x000000FF);            // byte[2]\n\n// Data from RAK12019 module\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0xFF000000) >> 24);    // byte[3]\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0x00FF0000) >> 16);    // byte[4]\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0x0000FF00) >> 8);     // byte[5]\nm_lora_app_data.buffer[i++] = (uint8_t)(uvs_data & 0x000000FF);            // byte[6]\n\n// Data from RAK12010 module\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0xFF000000) >> 24);    // byte[7]\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0x00FF0000) >> 16);    // byte[8]\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0x0000FF00) >> 8);     // byte[9]\nm_lora_app_data.buffer[i++] = (uint8_t)(lux_data & 0x000000FF);            // byte[10]\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS) {\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n} else {\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xE9, 0x0D, 0x28, 0x1D, 0x92, 0x3D, 0xE4, 0x9F, 0xD9, 0xF7, 0xE0, 0x5F, 0x39, 0x10, 0x55, 0x71 };\n\n```  \n> **Image:** OTAA device successfully registered to TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "4f70201e351c8312c9d3c1fde7f43a45", "product_family": "wisblock", "product_id": "kit6-light-and-color", "category": "How-To", "title": "WisBlock IoT Education Kit - Light & Color Quick Start Guide > WisBlock IoT Education Kit - Light & Color Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock IoT Education Kit - Light & Color using TTN and Qubitro > UV Index & UV Intensity Monitoring LoRaWAN Application > LoRaWAN Code for UV Index & UV Intensity Monitoring > Programming UV Index & UV Intensity Monitoring Device with Arduino IDE [CODE]", "content": "// Configuration of MCP23017 I/O ports\nmcp.pinMode(LED_0, OUTPUT);     // Red LED; Top most\nmcp.pinMode(LED_1, OUTPUT);     // Red LED\nmcp.pinMode(LED_2, OUTPUT);     // Orange LED\nmcp.pinMode(LED_3, OUTPUT);     // Orange LED\nmcp.pinMode(LED_4, OUTPUT);     // Orange LED\nmcp.pinMode(LED_5, OUTPUT);     // Green LED\nmcp.pinMode(LED_6, OUTPUT);     // Green LED\nmcp.pinMode(LED_7, OUTPUT);     // Green LED\nmcp.pinMode(LED_8, OUTPUT);     // Green LED", "keywords": ["Arduino IDE", "RAK4631", "UV Index", "UV Intensity", "LoRaWAN", "SX126x-Arduino"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **UV Index & UV Intensity Monitoring** device. Just copy the code below for **UV Index & UV Intensity Monitoring LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the example </summary>  \n```c\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h>  //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n#include \"UVlight_LTR390.h\"                // http://librarymanager/All#RAK12019_LTR390\nUVlight_LTR390 ltr = UVlight_LTR390();\n\n#include \"Light_VEML7700.h\"                // http://librarymanager/All#Light_veml7700\nLight_VEML7700 VMEL = Light_VEML7700();\n\nuint16_t uvi;\nuint32_t uvs;\nuint32_t lux;\nuint32_t white;\nuint32_t raw_als;\n\n#include <Adafruit_MCP23X17.h>  //http://librarymanager/All#Adafruit_MCP23017\nAdafruit_MCP23X17 mcp;\n\n// Added definitions for the functionality of RAK14003\nconst uint8_t LED_0 = 0;      // PA0 (17) of MCP23017\nconst uint8_t LED_1 = 1;      // PA1 (18) of MCP23017\nconst uint8_t LED_2 = 2;      // PA2 (19) of MCP23017\nconst uint8_t LED_3 = 3;      // PA3 (20) of MCP23017\nconst uint8_t LED_4 = 4;      // PA4 (21) of MCP23017\nconst uint8_t LED_5 = 5;      // PA5 (22) of MCP23017\nconst uint8_t LED_6 = 6;      // PA6 (23) of MCP23017\nconst uint8_t LED_7 = 7;      // PA7 (24) of MCP23017\nconst uint8_t LED_8 = 8;      // PB0 (25) of MCP23017\nconst uint8_t LED_9 = 9;      // PB1 (26) of MCP23017\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define RAK4631_BOARD true\n#else\n#define RAK4631_BOARD false\n#endif\n\nbool doOTAA = true;                                               // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                                       /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                                     /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5                               /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                                        /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;                           /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;                 /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                              /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = { LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF };\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = { BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler };\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xE9, 0x0D, 0x28, 0x1D, 0x92, 0x3D, 0xE4, 0x9F, 0xD9, 0xF7, 0xE0, 0x5F, 0x39, 0x10, 0x55, 0x71 };\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };\nuint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                                            /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];               //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = { m_lora_app_data_buffer, 0, 0, 0, 0 };  //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {\n\n// Initialize Serial for debug output\npinMode(LED_BLUE, OUTPUT);\ndigitalWrite(LED_BLUE, HIGH);\n\n// Sensor Power Switch\npinMode(WB_IO2, OUTPUT);\ndigitalWrite(WB_IO2, HIGH);\n\n// Reset RAK14003 module\npinMode(WB_IO4, OUTPUT);\ndigitalWrite(WB_IO4, HIGH);\ndelay(10);\ndigitalWrite(WB_IO4, LOW);\ndelay(10);\ndigitalWrite(WB_IO4, HIGH);\ndelay(10);\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial) {\nif ((millis() - timeout) < 5000) {\ndelay(100);\n} else {\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA) {\nSerial.println(\"Type: OTAA\");\n} else {\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion) {\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA) {\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n} else {\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0) {\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"================================\");\nSerial.println(\"RAK12019 + RAK12010 LoRaWAN Code\");\nSerial.println(\"================================\");\n\nif (!VMEL.begin())\n{\nSerial.println(\"Sensor not found\");\nwhile (1);\n}\n\nVMEL.setGain(VEML7700_GAIN_1);\nVMEL.setIntegrationTime(VEML7700_IT_800MS);\n\nSerial.print(F(\"Gain: \"));\nswitch (VMEL.getGain())\n{\ncase VEML7700_GAIN_1: Serial.println(\"1\"); break;\ncase VEML7700_GAIN_2: Serial.println(\"2\"); break;\ncase VEML7700_GAIN_1_4: Serial.println(\"1/4\"); break;\ncase VEML7700_GAIN_1_8: Serial.println(\"1/8\"); break;\n}\n\nSerial.print(F(\"Integration Time (ms): \"));\nswitch (VMEL.getIntegrationTime())\n{\ncase VEML7700_IT_25MS: Serial.println(\"25\"); break;\ncase VEML7700_IT_50MS: Serial.println(\"50\"); break;\ncase VEML7700_IT_100MS: Serial.println(\"100\"); break;\ncase VEML7700_IT_200MS: Serial.println(\"200\"); break;\ncase VEML7700_IT_400MS: Serial.println(\"400\"); break;\ncase VEML7700_IT_800MS: Serial.println(\"800\"); break;\n}\n\nSerial.println(\"RAK12019 test\");\nWire.begin();\nif (!ltr.init())\n{\nSerial.println(\"Couldn't find LTR sensor!\");\nwhile (1)\ndelay(10);\n}\nSerial.println(\"Found LTR390 sensor!\");\n\n//set to LTR390_MODE_UVS,get ultraviolet light data.\nltr.setMode(LTR390_MODE_UVS);  // UVS Mode\n\nSerial.println(\"In UVS mode\");\n\nltr.setGain(LTR390_GAIN_3);\nSerial.print(\"Gain : \");\nswitch (ltr.getGain())\n{\ncase LTR390_GAIN_1:\nSerial.println(1);\nbreak;\ncase LTR390_GAIN_3:\nSerial.println(3);\nbreak;\ncase LTR390_GAIN_6:\nSerial.println(6);\nbreak;\ncase LTR390_GAIN_9:\nSerial.println(9);\nbreak;\ncase LTR390_GAIN_18:\nSerial.println(18);\nbreak;\ndefault:\nSerial.println(\"Failed to set gain\");\nbreak;\n}\nltr.setResolution(LTR390_RESOLUTION_16BIT);\nSerial.print(\"Integration Time (ms): \");\nswitch (ltr.getResolution())\n{\ncase LTR390_RESOLUTION_13BIT:\nSerial.println(13);\nbreak;\ncase LTR390_RESOLUTION_16BIT:\nSerial.println(16);\nbreak;\ncase LTR390_RESOLUTION_17BIT:\nSerial.println(17);\nbreak;\ncase LTR390_RESOLUTION_18BIT:\nSerial.println(18);\nbreak;\ncase LTR390_RESOLUTION_19BIT:\nSerial.println(19);\nbreak;\ncase LTR390_RESOLUTION_20BIT:\nSerial.println(20);\nbreak;\ndefault:\nSerial.println(\"Failed to set Integration Time\");\nbreak;\n}\n\nltr.setThresholds(100, 1000); //Set the interrupt output threshold range for lower and upper.\n\nltr.configInterrupt(true, LTR390_MODE_UVS);\n\n// For RAK14003\nmcp.begin_I2C(0x24);\n\n// Added for the functionality of RAK14003\n\nWire.begin();    // initialize I2C serial bus\n\n// Configuration of MCP23017 I/O ports\nmcp.pinMode(LED_0, OUTPUT);     // Red LED; Top most\nmcp.pinMode(LED_1, OUTPUT);     // Red LED\nmcp.pinMode(LED_2, OUTPUT);     // Orange LED\nmcp.pinMode(LED_3, OUTPUT);     // Orange LED\nmcp.pinMode(LED_4, OUTPUT);     // Orange LED\nmcp.pinMode(LED_5, OUTPUT);     // Green LED\nmcp.pinMode(LED_6, OUTPUT);     // Green LED\nmcp.pinMode(LED_7, OUTPUT);     // Green LED\nmcp.pinMode(LED_8, OUTPUT);     // Green LED\nmcp.pinMode(LED_9, OUTPUT);     // Green LED; Bottom\n\n// Initially Turn OFF all LEDs\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, HIGH);\n\n}\n\nvoid loop() {\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\n// Trial # 1\n// Data from RAK12019\nif (ltr.newDataAvailable())\n{\nuvi = ltr.getUVI();\nuvs = ltr.readUVS();\n}\n\n// Data from RAK12010\nlux = VMEL.readLux();\nwhite = VMEL.readWhite();\nraw_als = VMEL.readALS();\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\n\n// From RAK12019 module\nSerial.print(\"UVI: \");\nSerial.println(uvi);          // Uvi data from RAK12019\nSerial.print(\"UVS: \");\nSerial.println(uvs);            // Uvs data from RAK12019\n\n// From RAK12010\nSerial.print(\"Lux: \");\nSerial.print(lux);\nSerial.println(\" lx \");\nSerial.print(\"White: \");\nSerial.println(white);\nSerial.print(\"Raw ALS: \");\nSerial.println(raw_als);\n\n// Result of uvi to be displayed via RAK14003 module\nif (uvi <= 0.4)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, HIGH);\n}\n\nelse if (uvi > 0.5 && uvi <= 1)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 1.5 && uvi <= 2)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 2.5 && uvi <= 3)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 3.5 && uvi <= 4)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 4.5 && uvi <= 5)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 5.5 && uvi <= 6)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 6.5 && uvi <= 7)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 7.5 && uvi <= 8)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 8.5 && uvi <= 9.5)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, LOW);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi >= 10)\n{\nmcp.digitalWrite(LED_0, LOW);\nmcp.digitalWrite(LED_1, LOW);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\ndelay(10000);\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void) {\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void) {\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data) {\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class) {\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void) {\nif (lmh_join_status_get() != LMH_SET) {\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\ndata = \" Uvi Data: \" + String(uvi) + \" Uvs Data: \" + String(uvs) + \" Lux Data: \" + String(lux) + \" lx \" ;\n\nSerial.println(data);\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\nuint16_t uvi_data = uvi;            // Uvi data from RAK12019\nuint32_t uvs_data = uvs;            // Uvs data from RAK12019\nuint32_t lux_data = lux;            // Lux data from RAK12010\n\nm_lora_app_data.buffer[i++] = 0x01;  // byte[0]\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\n// Data from RAK12019 module\nm_lora_app_data.buffer[i++] = (uint8_t)((uvi_data & 0x0000FF00) >> 8);     // byte[1]\nm_lora_app_data.buffer[i++] = (uint8_t)(uvi_data & 0x000000FF);            // byte[2]\n\n// Data from RAK12019 module\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0xFF000000) >> 24);    // byte[3]\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0x00FF0000) >> 16);    // byte[4]\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0x0000FF00) >> 8);     // byte[5]\nm_lora_app_data.buffer[i++] = (uint8_t)(uvs_data & 0x000000FF);            // byte[6]\n\n// Data from RAK12010 module\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0xFF000000) >> 24);    // byte[7]\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0x00FF0000) >> 16);    // byte[8]\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0x0000FF00) >> 8);     // byte[9]\nm_lora_app_data.buffer[i++] = (uint8_t)(lux_data & 0x000000FF);            // byte[10]\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS) {\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n} else {\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xE9, 0x0D, 0x28, 0x1D, 0x92, 0x3D, 0xE4, 0x9F, 0xD9, 0xF7, 0xE0, 0x5F, 0x39, 0x10, 0x55, 0x71 };\n\n```  \n> **Image:** OTAA device successfully registered to TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "ef7d3dab5c4e23f5ad16e3838093289d", "product_family": "wisblock", "product_id": "kit6-light-and-color", "category": "How-To", "title": "WisBlock IoT Education Kit - Light & Color Quick Start Guide > WisBlock IoT Education Kit - Light & Color Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock IoT Education Kit - Light & Color using TTN and Qubitro > UV Index & UV Intensity Monitoring LoRaWAN Application > LoRaWAN Code for UV Index & UV Intensity Monitoring > Programming UV Index & UV Intensity Monitoring Device with Arduino IDE [CODE]", "content": "mcp.pinMode(LED_7, OUTPUT);     // Green LED\nmcp.pinMode(LED_8, OUTPUT);     // Green LED\nmcp.pinMode(LED_9, OUTPUT);     // Green LED; Bottom", "keywords": ["Arduino IDE", "RAK4631", "UV Index", "UV Intensity", "LoRaWAN", "SX126x-Arduino"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **UV Index & UV Intensity Monitoring** device. Just copy the code below for **UV Index & UV Intensity Monitoring LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the example </summary>  \n```c\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h>  //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n#include \"UVlight_LTR390.h\"                // http://librarymanager/All#RAK12019_LTR390\nUVlight_LTR390 ltr = UVlight_LTR390();\n\n#include \"Light_VEML7700.h\"                // http://librarymanager/All#Light_veml7700\nLight_VEML7700 VMEL = Light_VEML7700();\n\nuint16_t uvi;\nuint32_t uvs;\nuint32_t lux;\nuint32_t white;\nuint32_t raw_als;\n\n#include <Adafruit_MCP23X17.h>  //http://librarymanager/All#Adafruit_MCP23017\nAdafruit_MCP23X17 mcp;\n\n// Added definitions for the functionality of RAK14003\nconst uint8_t LED_0 = 0;      // PA0 (17) of MCP23017\nconst uint8_t LED_1 = 1;      // PA1 (18) of MCP23017\nconst uint8_t LED_2 = 2;      // PA2 (19) of MCP23017\nconst uint8_t LED_3 = 3;      // PA3 (20) of MCP23017\nconst uint8_t LED_4 = 4;      // PA4 (21) of MCP23017\nconst uint8_t LED_5 = 5;      // PA5 (22) of MCP23017\nconst uint8_t LED_6 = 6;      // PA6 (23) of MCP23017\nconst uint8_t LED_7 = 7;      // PA7 (24) of MCP23017\nconst uint8_t LED_8 = 8;      // PB0 (25) of MCP23017\nconst uint8_t LED_9 = 9;      // PB1 (26) of MCP23017\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define RAK4631_BOARD true\n#else\n#define RAK4631_BOARD false\n#endif\n\nbool doOTAA = true;                                               // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                                       /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                                     /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5                               /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                                        /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;                           /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;                 /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                              /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = { LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF };\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = { BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler };\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xE9, 0x0D, 0x28, 0x1D, 0x92, 0x3D, 0xE4, 0x9F, 0xD9, 0xF7, 0xE0, 0x5F, 0x39, 0x10, 0x55, 0x71 };\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };\nuint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                                            /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];               //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = { m_lora_app_data_buffer, 0, 0, 0, 0 };  //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {\n\n// Initialize Serial for debug output\npinMode(LED_BLUE, OUTPUT);\ndigitalWrite(LED_BLUE, HIGH);\n\n// Sensor Power Switch\npinMode(WB_IO2, OUTPUT);\ndigitalWrite(WB_IO2, HIGH);\n\n// Reset RAK14003 module\npinMode(WB_IO4, OUTPUT);\ndigitalWrite(WB_IO4, HIGH);\ndelay(10);\ndigitalWrite(WB_IO4, LOW);\ndelay(10);\ndigitalWrite(WB_IO4, HIGH);\ndelay(10);\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial) {\nif ((millis() - timeout) < 5000) {\ndelay(100);\n} else {\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA) {\nSerial.println(\"Type: OTAA\");\n} else {\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion) {\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA) {\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n} else {\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0) {\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"================================\");\nSerial.println(\"RAK12019 + RAK12010 LoRaWAN Code\");\nSerial.println(\"================================\");\n\nif (!VMEL.begin())\n{\nSerial.println(\"Sensor not found\");\nwhile (1);\n}\n\nVMEL.setGain(VEML7700_GAIN_1);\nVMEL.setIntegrationTime(VEML7700_IT_800MS);\n\nSerial.print(F(\"Gain: \"));\nswitch (VMEL.getGain())\n{\ncase VEML7700_GAIN_1: Serial.println(\"1\"); break;\ncase VEML7700_GAIN_2: Serial.println(\"2\"); break;\ncase VEML7700_GAIN_1_4: Serial.println(\"1/4\"); break;\ncase VEML7700_GAIN_1_8: Serial.println(\"1/8\"); break;\n}\n\nSerial.print(F(\"Integration Time (ms): \"));\nswitch (VMEL.getIntegrationTime())\n{\ncase VEML7700_IT_25MS: Serial.println(\"25\"); break;\ncase VEML7700_IT_50MS: Serial.println(\"50\"); break;\ncase VEML7700_IT_100MS: Serial.println(\"100\"); break;\ncase VEML7700_IT_200MS: Serial.println(\"200\"); break;\ncase VEML7700_IT_400MS: Serial.println(\"400\"); break;\ncase VEML7700_IT_800MS: Serial.println(\"800\"); break;\n}\n\nSerial.println(\"RAK12019 test\");\nWire.begin();\nif (!ltr.init())\n{\nSerial.println(\"Couldn't find LTR sensor!\");\nwhile (1)\ndelay(10);\n}\nSerial.println(\"Found LTR390 sensor!\");\n\n//set to LTR390_MODE_UVS,get ultraviolet light data.\nltr.setMode(LTR390_MODE_UVS);  // UVS Mode\n\nSerial.println(\"In UVS mode\");\n\nltr.setGain(LTR390_GAIN_3);\nSerial.print(\"Gain : \");\nswitch (ltr.getGain())\n{\ncase LTR390_GAIN_1:\nSerial.println(1);\nbreak;\ncase LTR390_GAIN_3:\nSerial.println(3);\nbreak;\ncase LTR390_GAIN_6:\nSerial.println(6);\nbreak;\ncase LTR390_GAIN_9:\nSerial.println(9);\nbreak;\ncase LTR390_GAIN_18:\nSerial.println(18);\nbreak;\ndefault:\nSerial.println(\"Failed to set gain\");\nbreak;\n}\nltr.setResolution(LTR390_RESOLUTION_16BIT);\nSerial.print(\"Integration Time (ms): \");\nswitch (ltr.getResolution())\n{\ncase LTR390_RESOLUTION_13BIT:\nSerial.println(13);\nbreak;\ncase LTR390_RESOLUTION_16BIT:\nSerial.println(16);\nbreak;\ncase LTR390_RESOLUTION_17BIT:\nSerial.println(17);\nbreak;\ncase LTR390_RESOLUTION_18BIT:\nSerial.println(18);\nbreak;\ncase LTR390_RESOLUTION_19BIT:\nSerial.println(19);\nbreak;\ncase LTR390_RESOLUTION_20BIT:\nSerial.println(20);\nbreak;\ndefault:\nSerial.println(\"Failed to set Integration Time\");\nbreak;\n}\n\nltr.setThresholds(100, 1000); //Set the interrupt output threshold range for lower and upper.\n\nltr.configInterrupt(true, LTR390_MODE_UVS);\n\n// For RAK14003\nmcp.begin_I2C(0x24);\n\n// Added for the functionality of RAK14003\n\nWire.begin();    // initialize I2C serial bus\n\n// Configuration of MCP23017 I/O ports\nmcp.pinMode(LED_0, OUTPUT);     // Red LED; Top most\nmcp.pinMode(LED_1, OUTPUT);     // Red LED\nmcp.pinMode(LED_2, OUTPUT);     // Orange LED\nmcp.pinMode(LED_3, OUTPUT);     // Orange LED\nmcp.pinMode(LED_4, OUTPUT);     // Orange LED\nmcp.pinMode(LED_5, OUTPUT);     // Green LED\nmcp.pinMode(LED_6, OUTPUT);     // Green LED\nmcp.pinMode(LED_7, OUTPUT);     // Green LED\nmcp.pinMode(LED_8, OUTPUT);     // Green LED\nmcp.pinMode(LED_9, OUTPUT);     // Green LED; Bottom\n\n// Initially Turn OFF all LEDs\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, HIGH);\n\n}\n\nvoid loop() {\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\n// Trial # 1\n// Data from RAK12019\nif (ltr.newDataAvailable())\n{\nuvi = ltr.getUVI();\nuvs = ltr.readUVS();\n}\n\n// Data from RAK12010\nlux = VMEL.readLux();\nwhite = VMEL.readWhite();\nraw_als = VMEL.readALS();\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\n\n// From RAK12019 module\nSerial.print(\"UVI: \");\nSerial.println(uvi);          // Uvi data from RAK12019\nSerial.print(\"UVS: \");\nSerial.println(uvs);            // Uvs data from RAK12019\n\n// From RAK12010\nSerial.print(\"Lux: \");\nSerial.print(lux);\nSerial.println(\" lx \");\nSerial.print(\"White: \");\nSerial.println(white);\nSerial.print(\"Raw ALS: \");\nSerial.println(raw_als);\n\n// Result of uvi to be displayed via RAK14003 module\nif (uvi <= 0.4)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, HIGH);\n}\n\nelse if (uvi > 0.5 && uvi <= 1)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 1.5 && uvi <= 2)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 2.5 && uvi <= 3)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 3.5 && uvi <= 4)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 4.5 && uvi <= 5)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 5.5 && uvi <= 6)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 6.5 && uvi <= 7)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 7.5 && uvi <= 8)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 8.5 && uvi <= 9.5)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, LOW);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi >= 10)\n{\nmcp.digitalWrite(LED_0, LOW);\nmcp.digitalWrite(LED_1, LOW);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\ndelay(10000);\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void) {\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void) {\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data) {\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class) {\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void) {\nif (lmh_join_status_get() != LMH_SET) {\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\ndata = \" Uvi Data: \" + String(uvi) + \" Uvs Data: \" + String(uvs) + \" Lux Data: \" + String(lux) + \" lx \" ;\n\nSerial.println(data);\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\nuint16_t uvi_data = uvi;            // Uvi data from RAK12019\nuint32_t uvs_data = uvs;            // Uvs data from RAK12019\nuint32_t lux_data = lux;            // Lux data from RAK12010\n\nm_lora_app_data.buffer[i++] = 0x01;  // byte[0]\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\n// Data from RAK12019 module\nm_lora_app_data.buffer[i++] = (uint8_t)((uvi_data & 0x0000FF00) >> 8);     // byte[1]\nm_lora_app_data.buffer[i++] = (uint8_t)(uvi_data & 0x000000FF);            // byte[2]\n\n// Data from RAK12019 module\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0xFF000000) >> 24);    // byte[3]\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0x00FF0000) >> 16);    // byte[4]\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0x0000FF00) >> 8);     // byte[5]\nm_lora_app_data.buffer[i++] = (uint8_t)(uvs_data & 0x000000FF);            // byte[6]\n\n// Data from RAK12010 module\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0xFF000000) >> 24);    // byte[7]\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0x00FF0000) >> 16);    // byte[8]\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0x0000FF00) >> 8);     // byte[9]\nm_lora_app_data.buffer[i++] = (uint8_t)(lux_data & 0x000000FF);            // byte[10]\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS) {\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n} else {\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xE9, 0x0D, 0x28, 0x1D, 0x92, 0x3D, 0xE4, 0x9F, 0xD9, 0xF7, 0xE0, 0x5F, 0x39, 0x10, 0x55, 0x71 };\n\n```  \n> **Image:** OTAA device successfully registered to TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "7d40d92f78a6a574b24738134888f9a8", "product_family": "wisblock", "product_id": "kit6-light-and-color", "category": "How-To", "title": "WisBlock IoT Education Kit - Light & Color Quick Start Guide > WisBlock IoT Education Kit - Light & Color Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock IoT Education Kit - Light & Color using TTN and Qubitro > UV Index & UV Intensity Monitoring LoRaWAN Application > LoRaWAN Code for UV Index & UV Intensity Monitoring > Programming UV Index & UV Intensity Monitoring Device with Arduino IDE [CODE]", "content": "// Initially Turn OFF all LEDs\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, HIGH);\n\n}\n\nvoid loop() {\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.", "keywords": ["Arduino IDE", "RAK4631", "UV Index", "UV Intensity", "LoRaWAN", "SX126x-Arduino"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **UV Index & UV Intensity Monitoring** device. Just copy the code below for **UV Index & UV Intensity Monitoring LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the example </summary>  \n```c\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h>  //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n#include \"UVlight_LTR390.h\"                // http://librarymanager/All#RAK12019_LTR390\nUVlight_LTR390 ltr = UVlight_LTR390();\n\n#include \"Light_VEML7700.h\"                // http://librarymanager/All#Light_veml7700\nLight_VEML7700 VMEL = Light_VEML7700();\n\nuint16_t uvi;\nuint32_t uvs;\nuint32_t lux;\nuint32_t white;\nuint32_t raw_als;\n\n#include <Adafruit_MCP23X17.h>  //http://librarymanager/All#Adafruit_MCP23017\nAdafruit_MCP23X17 mcp;\n\n// Added definitions for the functionality of RAK14003\nconst uint8_t LED_0 = 0;      // PA0 (17) of MCP23017\nconst uint8_t LED_1 = 1;      // PA1 (18) of MCP23017\nconst uint8_t LED_2 = 2;      // PA2 (19) of MCP23017\nconst uint8_t LED_3 = 3;      // PA3 (20) of MCP23017\nconst uint8_t LED_4 = 4;      // PA4 (21) of MCP23017\nconst uint8_t LED_5 = 5;      // PA5 (22) of MCP23017\nconst uint8_t LED_6 = 6;      // PA6 (23) of MCP23017\nconst uint8_t LED_7 = 7;      // PA7 (24) of MCP23017\nconst uint8_t LED_8 = 8;      // PB0 (25) of MCP23017\nconst uint8_t LED_9 = 9;      // PB1 (26) of MCP23017\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define RAK4631_BOARD true\n#else\n#define RAK4631_BOARD false\n#endif\n\nbool doOTAA = true;                                               // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                                       /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                                     /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5                               /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                                        /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;                           /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;                 /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                              /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = { LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF };\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = { BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler };\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xE9, 0x0D, 0x28, 0x1D, 0x92, 0x3D, 0xE4, 0x9F, 0xD9, 0xF7, 0xE0, 0x5F, 0x39, 0x10, 0x55, 0x71 };\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };\nuint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                                            /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];               //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = { m_lora_app_data_buffer, 0, 0, 0, 0 };  //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {\n\n// Initialize Serial for debug output\npinMode(LED_BLUE, OUTPUT);\ndigitalWrite(LED_BLUE, HIGH);\n\n// Sensor Power Switch\npinMode(WB_IO2, OUTPUT);\ndigitalWrite(WB_IO2, HIGH);\n\n// Reset RAK14003 module\npinMode(WB_IO4, OUTPUT);\ndigitalWrite(WB_IO4, HIGH);\ndelay(10);\ndigitalWrite(WB_IO4, LOW);\ndelay(10);\ndigitalWrite(WB_IO4, HIGH);\ndelay(10);\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial) {\nif ((millis() - timeout) < 5000) {\ndelay(100);\n} else {\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA) {\nSerial.println(\"Type: OTAA\");\n} else {\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion) {\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA) {\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n} else {\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0) {\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"================================\");\nSerial.println(\"RAK12019 + RAK12010 LoRaWAN Code\");\nSerial.println(\"================================\");\n\nif (!VMEL.begin())\n{\nSerial.println(\"Sensor not found\");\nwhile (1);\n}\n\nVMEL.setGain(VEML7700_GAIN_1);\nVMEL.setIntegrationTime(VEML7700_IT_800MS);\n\nSerial.print(F(\"Gain: \"));\nswitch (VMEL.getGain())\n{\ncase VEML7700_GAIN_1: Serial.println(\"1\"); break;\ncase VEML7700_GAIN_2: Serial.println(\"2\"); break;\ncase VEML7700_GAIN_1_4: Serial.println(\"1/4\"); break;\ncase VEML7700_GAIN_1_8: Serial.println(\"1/8\"); break;\n}\n\nSerial.print(F(\"Integration Time (ms): \"));\nswitch (VMEL.getIntegrationTime())\n{\ncase VEML7700_IT_25MS: Serial.println(\"25\"); break;\ncase VEML7700_IT_50MS: Serial.println(\"50\"); break;\ncase VEML7700_IT_100MS: Serial.println(\"100\"); break;\ncase VEML7700_IT_200MS: Serial.println(\"200\"); break;\ncase VEML7700_IT_400MS: Serial.println(\"400\"); break;\ncase VEML7700_IT_800MS: Serial.println(\"800\"); break;\n}\n\nSerial.println(\"RAK12019 test\");\nWire.begin();\nif (!ltr.init())\n{\nSerial.println(\"Couldn't find LTR sensor!\");\nwhile (1)\ndelay(10);\n}\nSerial.println(\"Found LTR390 sensor!\");\n\n//set to LTR390_MODE_UVS,get ultraviolet light data.\nltr.setMode(LTR390_MODE_UVS);  // UVS Mode\n\nSerial.println(\"In UVS mode\");\n\nltr.setGain(LTR390_GAIN_3);\nSerial.print(\"Gain : \");\nswitch (ltr.getGain())\n{\ncase LTR390_GAIN_1:\nSerial.println(1);\nbreak;\ncase LTR390_GAIN_3:\nSerial.println(3);\nbreak;\ncase LTR390_GAIN_6:\nSerial.println(6);\nbreak;\ncase LTR390_GAIN_9:\nSerial.println(9);\nbreak;\ncase LTR390_GAIN_18:\nSerial.println(18);\nbreak;\ndefault:\nSerial.println(\"Failed to set gain\");\nbreak;\n}\nltr.setResolution(LTR390_RESOLUTION_16BIT);\nSerial.print(\"Integration Time (ms): \");\nswitch (ltr.getResolution())\n{\ncase LTR390_RESOLUTION_13BIT:\nSerial.println(13);\nbreak;\ncase LTR390_RESOLUTION_16BIT:\nSerial.println(16);\nbreak;\ncase LTR390_RESOLUTION_17BIT:\nSerial.println(17);\nbreak;\ncase LTR390_RESOLUTION_18BIT:\nSerial.println(18);\nbreak;\ncase LTR390_RESOLUTION_19BIT:\nSerial.println(19);\nbreak;\ncase LTR390_RESOLUTION_20BIT:\nSerial.println(20);\nbreak;\ndefault:\nSerial.println(\"Failed to set Integration Time\");\nbreak;\n}\n\nltr.setThresholds(100, 1000); //Set the interrupt output threshold range for lower and upper.\n\nltr.configInterrupt(true, LTR390_MODE_UVS);\n\n// For RAK14003\nmcp.begin_I2C(0x24);\n\n// Added for the functionality of RAK14003\n\nWire.begin();    // initialize I2C serial bus\n\n// Configuration of MCP23017 I/O ports\nmcp.pinMode(LED_0, OUTPUT);     // Red LED; Top most\nmcp.pinMode(LED_1, OUTPUT);     // Red LED\nmcp.pinMode(LED_2, OUTPUT);     // Orange LED\nmcp.pinMode(LED_3, OUTPUT);     // Orange LED\nmcp.pinMode(LED_4, OUTPUT);     // Orange LED\nmcp.pinMode(LED_5, OUTPUT);     // Green LED\nmcp.pinMode(LED_6, OUTPUT);     // Green LED\nmcp.pinMode(LED_7, OUTPUT);     // Green LED\nmcp.pinMode(LED_8, OUTPUT);     // Green LED\nmcp.pinMode(LED_9, OUTPUT);     // Green LED; Bottom\n\n// Initially Turn OFF all LEDs\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, HIGH);\n\n}\n\nvoid loop() {\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\n// Trial # 1\n// Data from RAK12019\nif (ltr.newDataAvailable())\n{\nuvi = ltr.getUVI();\nuvs = ltr.readUVS();\n}\n\n// Data from RAK12010\nlux = VMEL.readLux();\nwhite = VMEL.readWhite();\nraw_als = VMEL.readALS();\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\n\n// From RAK12019 module\nSerial.print(\"UVI: \");\nSerial.println(uvi);          // Uvi data from RAK12019\nSerial.print(\"UVS: \");\nSerial.println(uvs);            // Uvs data from RAK12019\n\n// From RAK12010\nSerial.print(\"Lux: \");\nSerial.print(lux);\nSerial.println(\" lx \");\nSerial.print(\"White: \");\nSerial.println(white);\nSerial.print(\"Raw ALS: \");\nSerial.println(raw_als);\n\n// Result of uvi to be displayed via RAK14003 module\nif (uvi <= 0.4)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, HIGH);\n}\n\nelse if (uvi > 0.5 && uvi <= 1)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 1.5 && uvi <= 2)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 2.5 && uvi <= 3)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 3.5 && uvi <= 4)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 4.5 && uvi <= 5)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 5.5 && uvi <= 6)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 6.5 && uvi <= 7)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 7.5 && uvi <= 8)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 8.5 && uvi <= 9.5)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, LOW);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi >= 10)\n{\nmcp.digitalWrite(LED_0, LOW);\nmcp.digitalWrite(LED_1, LOW);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\ndelay(10000);\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void) {\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void) {\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data) {\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class) {\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void) {\nif (lmh_join_status_get() != LMH_SET) {\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\ndata = \" Uvi Data: \" + String(uvi) + \" Uvs Data: \" + String(uvs) + \" Lux Data: \" + String(lux) + \" lx \" ;\n\nSerial.println(data);\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\nuint16_t uvi_data = uvi;            // Uvi data from RAK12019\nuint32_t uvs_data = uvs;            // Uvs data from RAK12019\nuint32_t lux_data = lux;            // Lux data from RAK12010\n\nm_lora_app_data.buffer[i++] = 0x01;  // byte[0]\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\n// Data from RAK12019 module\nm_lora_app_data.buffer[i++] = (uint8_t)((uvi_data & 0x0000FF00) >> 8);     // byte[1]\nm_lora_app_data.buffer[i++] = (uint8_t)(uvi_data & 0x000000FF);            // byte[2]\n\n// Data from RAK12019 module\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0xFF000000) >> 24);    // byte[3]\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0x00FF0000) >> 16);    // byte[4]\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0x0000FF00) >> 8);     // byte[5]\nm_lora_app_data.buffer[i++] = (uint8_t)(uvs_data & 0x000000FF);            // byte[6]\n\n// Data from RAK12010 module\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0xFF000000) >> 24);    // byte[7]\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0x00FF0000) >> 16);    // byte[8]\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0x0000FF00) >> 8);     // byte[9]\nm_lora_app_data.buffer[i++] = (uint8_t)(lux_data & 0x000000FF);            // byte[10]\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS) {\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n} else {\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xE9, 0x0D, 0x28, 0x1D, 0x92, 0x3D, 0xE4, 0x9F, 0xD9, 0xF7, 0xE0, 0x5F, 0x39, 0x10, 0x55, 0x71 };\n\n```  \n> **Image:** OTAA device successfully registered to TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "5f13bf09869f786f49bf5a45b3a4e53a", "product_family": "wisblock", "product_id": "kit6-light-and-color", "category": "How-To", "title": "WisBlock IoT Education Kit - Light & Color Quick Start Guide > WisBlock IoT Education Kit - Light & Color Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock IoT Education Kit - Light & Color using TTN and Qubitro > UV Index & UV Intensity Monitoring LoRaWAN Application > LoRaWAN Code for UV Index & UV Intensity Monitoring > Programming UV Index & UV Intensity Monitoring Device with Arduino IDE [CODE]", "content": "// Trial # 1\n// Data from RAK12019\nif (ltr.newDataAvailable())\n{\nuvi = ltr.getUVI();\nuvs = ltr.readUVS();\n}\n\n// Data from RAK12010\nlux = VMEL.readLux();\nwhite = VMEL.readWhite();\nraw_als = VMEL.readALS();\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)", "keywords": ["Arduino IDE", "RAK4631", "UV Index", "UV Intensity", "LoRaWAN", "SX126x-Arduino"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **UV Index & UV Intensity Monitoring** device. Just copy the code below for **UV Index & UV Intensity Monitoring LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the example </summary>  \n```c\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h>  //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n#include \"UVlight_LTR390.h\"                // http://librarymanager/All#RAK12019_LTR390\nUVlight_LTR390 ltr = UVlight_LTR390();\n\n#include \"Light_VEML7700.h\"                // http://librarymanager/All#Light_veml7700\nLight_VEML7700 VMEL = Light_VEML7700();\n\nuint16_t uvi;\nuint32_t uvs;\nuint32_t lux;\nuint32_t white;\nuint32_t raw_als;\n\n#include <Adafruit_MCP23X17.h>  //http://librarymanager/All#Adafruit_MCP23017\nAdafruit_MCP23X17 mcp;\n\n// Added definitions for the functionality of RAK14003\nconst uint8_t LED_0 = 0;      // PA0 (17) of MCP23017\nconst uint8_t LED_1 = 1;      // PA1 (18) of MCP23017\nconst uint8_t LED_2 = 2;      // PA2 (19) of MCP23017\nconst uint8_t LED_3 = 3;      // PA3 (20) of MCP23017\nconst uint8_t LED_4 = 4;      // PA4 (21) of MCP23017\nconst uint8_t LED_5 = 5;      // PA5 (22) of MCP23017\nconst uint8_t LED_6 = 6;      // PA6 (23) of MCP23017\nconst uint8_t LED_7 = 7;      // PA7 (24) of MCP23017\nconst uint8_t LED_8 = 8;      // PB0 (25) of MCP23017\nconst uint8_t LED_9 = 9;      // PB1 (26) of MCP23017\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define RAK4631_BOARD true\n#else\n#define RAK4631_BOARD false\n#endif\n\nbool doOTAA = true;                                               // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                                       /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                                     /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5                               /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                                        /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;                           /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;                 /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                              /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = { LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF };\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = { BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler };\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xE9, 0x0D, 0x28, 0x1D, 0x92, 0x3D, 0xE4, 0x9F, 0xD9, 0xF7, 0xE0, 0x5F, 0x39, 0x10, 0x55, 0x71 };\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };\nuint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                                            /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];               //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = { m_lora_app_data_buffer, 0, 0, 0, 0 };  //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {\n\n// Initialize Serial for debug output\npinMode(LED_BLUE, OUTPUT);\ndigitalWrite(LED_BLUE, HIGH);\n\n// Sensor Power Switch\npinMode(WB_IO2, OUTPUT);\ndigitalWrite(WB_IO2, HIGH);\n\n// Reset RAK14003 module\npinMode(WB_IO4, OUTPUT);\ndigitalWrite(WB_IO4, HIGH);\ndelay(10);\ndigitalWrite(WB_IO4, LOW);\ndelay(10);\ndigitalWrite(WB_IO4, HIGH);\ndelay(10);\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial) {\nif ((millis() - timeout) < 5000) {\ndelay(100);\n} else {\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA) {\nSerial.println(\"Type: OTAA\");\n} else {\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion) {\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA) {\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n} else {\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0) {\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"================================\");\nSerial.println(\"RAK12019 + RAK12010 LoRaWAN Code\");\nSerial.println(\"================================\");\n\nif (!VMEL.begin())\n{\nSerial.println(\"Sensor not found\");\nwhile (1);\n}\n\nVMEL.setGain(VEML7700_GAIN_1);\nVMEL.setIntegrationTime(VEML7700_IT_800MS);\n\nSerial.print(F(\"Gain: \"));\nswitch (VMEL.getGain())\n{\ncase VEML7700_GAIN_1: Serial.println(\"1\"); break;\ncase VEML7700_GAIN_2: Serial.println(\"2\"); break;\ncase VEML7700_GAIN_1_4: Serial.println(\"1/4\"); break;\ncase VEML7700_GAIN_1_8: Serial.println(\"1/8\"); break;\n}\n\nSerial.print(F(\"Integration Time (ms): \"));\nswitch (VMEL.getIntegrationTime())\n{\ncase VEML7700_IT_25MS: Serial.println(\"25\"); break;\ncase VEML7700_IT_50MS: Serial.println(\"50\"); break;\ncase VEML7700_IT_100MS: Serial.println(\"100\"); break;\ncase VEML7700_IT_200MS: Serial.println(\"200\"); break;\ncase VEML7700_IT_400MS: Serial.println(\"400\"); break;\ncase VEML7700_IT_800MS: Serial.println(\"800\"); break;\n}\n\nSerial.println(\"RAK12019 test\");\nWire.begin();\nif (!ltr.init())\n{\nSerial.println(\"Couldn't find LTR sensor!\");\nwhile (1)\ndelay(10);\n}\nSerial.println(\"Found LTR390 sensor!\");\n\n//set to LTR390_MODE_UVS,get ultraviolet light data.\nltr.setMode(LTR390_MODE_UVS);  // UVS Mode\n\nSerial.println(\"In UVS mode\");\n\nltr.setGain(LTR390_GAIN_3);\nSerial.print(\"Gain : \");\nswitch (ltr.getGain())\n{\ncase LTR390_GAIN_1:\nSerial.println(1);\nbreak;\ncase LTR390_GAIN_3:\nSerial.println(3);\nbreak;\ncase LTR390_GAIN_6:\nSerial.println(6);\nbreak;\ncase LTR390_GAIN_9:\nSerial.println(9);\nbreak;\ncase LTR390_GAIN_18:\nSerial.println(18);\nbreak;\ndefault:\nSerial.println(\"Failed to set gain\");\nbreak;\n}\nltr.setResolution(LTR390_RESOLUTION_16BIT);\nSerial.print(\"Integration Time (ms): \");\nswitch (ltr.getResolution())\n{\ncase LTR390_RESOLUTION_13BIT:\nSerial.println(13);\nbreak;\ncase LTR390_RESOLUTION_16BIT:\nSerial.println(16);\nbreak;\ncase LTR390_RESOLUTION_17BIT:\nSerial.println(17);\nbreak;\ncase LTR390_RESOLUTION_18BIT:\nSerial.println(18);\nbreak;\ncase LTR390_RESOLUTION_19BIT:\nSerial.println(19);\nbreak;\ncase LTR390_RESOLUTION_20BIT:\nSerial.println(20);\nbreak;\ndefault:\nSerial.println(\"Failed to set Integration Time\");\nbreak;\n}\n\nltr.setThresholds(100, 1000); //Set the interrupt output threshold range for lower and upper.\n\nltr.configInterrupt(true, LTR390_MODE_UVS);\n\n// For RAK14003\nmcp.begin_I2C(0x24);\n\n// Added for the functionality of RAK14003\n\nWire.begin();    // initialize I2C serial bus\n\n// Configuration of MCP23017 I/O ports\nmcp.pinMode(LED_0, OUTPUT);     // Red LED; Top most\nmcp.pinMode(LED_1, OUTPUT);     // Red LED\nmcp.pinMode(LED_2, OUTPUT);     // Orange LED\nmcp.pinMode(LED_3, OUTPUT);     // Orange LED\nmcp.pinMode(LED_4, OUTPUT);     // Orange LED\nmcp.pinMode(LED_5, OUTPUT);     // Green LED\nmcp.pinMode(LED_6, OUTPUT);     // Green LED\nmcp.pinMode(LED_7, OUTPUT);     // Green LED\nmcp.pinMode(LED_8, OUTPUT);     // Green LED\nmcp.pinMode(LED_9, OUTPUT);     // Green LED; Bottom\n\n// Initially Turn OFF all LEDs\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, HIGH);\n\n}\n\nvoid loop() {\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\n// Trial # 1\n// Data from RAK12019\nif (ltr.newDataAvailable())\n{\nuvi = ltr.getUVI();\nuvs = ltr.readUVS();\n}\n\n// Data from RAK12010\nlux = VMEL.readLux();\nwhite = VMEL.readWhite();\nraw_als = VMEL.readALS();\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\n\n// From RAK12019 module\nSerial.print(\"UVI: \");\nSerial.println(uvi);          // Uvi data from RAK12019\nSerial.print(\"UVS: \");\nSerial.println(uvs);            // Uvs data from RAK12019\n\n// From RAK12010\nSerial.print(\"Lux: \");\nSerial.print(lux);\nSerial.println(\" lx \");\nSerial.print(\"White: \");\nSerial.println(white);\nSerial.print(\"Raw ALS: \");\nSerial.println(raw_als);\n\n// Result of uvi to be displayed via RAK14003 module\nif (uvi <= 0.4)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, HIGH);\n}\n\nelse if (uvi > 0.5 && uvi <= 1)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 1.5 && uvi <= 2)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 2.5 && uvi <= 3)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 3.5 && uvi <= 4)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 4.5 && uvi <= 5)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 5.5 && uvi <= 6)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 6.5 && uvi <= 7)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 7.5 && uvi <= 8)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 8.5 && uvi <= 9.5)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, LOW);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi >= 10)\n{\nmcp.digitalWrite(LED_0, LOW);\nmcp.digitalWrite(LED_1, LOW);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\ndelay(10000);\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void) {\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void) {\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data) {\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class) {\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void) {\nif (lmh_join_status_get() != LMH_SET) {\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\ndata = \" Uvi Data: \" + String(uvi) + \" Uvs Data: \" + String(uvs) + \" Lux Data: \" + String(lux) + \" lx \" ;\n\nSerial.println(data);\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\nuint16_t uvi_data = uvi;            // Uvi data from RAK12019\nuint32_t uvs_data = uvs;            // Uvs data from RAK12019\nuint32_t lux_data = lux;            // Lux data from RAK12010\n\nm_lora_app_data.buffer[i++] = 0x01;  // byte[0]\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\n// Data from RAK12019 module\nm_lora_app_data.buffer[i++] = (uint8_t)((uvi_data & 0x0000FF00) >> 8);     // byte[1]\nm_lora_app_data.buffer[i++] = (uint8_t)(uvi_data & 0x000000FF);            // byte[2]\n\n// Data from RAK12019 module\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0xFF000000) >> 24);    // byte[3]\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0x00FF0000) >> 16);    // byte[4]\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0x0000FF00) >> 8);     // byte[5]\nm_lora_app_data.buffer[i++] = (uint8_t)(uvs_data & 0x000000FF);            // byte[6]\n\n// Data from RAK12010 module\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0xFF000000) >> 24);    // byte[7]\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0x00FF0000) >> 16);    // byte[8]\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0x0000FF00) >> 8);     // byte[9]\nm_lora_app_data.buffer[i++] = (uint8_t)(lux_data & 0x000000FF);            // byte[10]\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS) {\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n} else {\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xE9, 0x0D, 0x28, 0x1D, 0x92, 0x3D, 0xE4, 0x9F, 0xD9, 0xF7, 0xE0, 0x5F, 0x39, 0x10, 0x55, 0x71 };\n\n```  \n> **Image:** OTAA device successfully registered to TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "70cccd561b51273908d2a2d7b3ea61c2", "product_family": "wisblock", "product_id": "kit6-light-and-color", "category": "How-To", "title": "WisBlock IoT Education Kit - Light & Color Quick Start Guide > WisBlock IoT Education Kit - Light & Color Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock IoT Education Kit - Light & Color using TTN and Qubitro > UV Index & UV Intensity Monitoring LoRaWAN Application > LoRaWAN Code for UV Index & UV Intensity Monitoring > Programming UV Index & UV Intensity Monitoring Device with Arduino IDE [CODE]", "content": "// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\n\n// From RAK12019 module\nSerial.print(\"UVI: \");\nSerial.println(uvi);          // Uvi data from RAK12019\nSerial.print(\"UVS: \");\nSerial.println(uvs);            // Uvs data from RAK12019\n\n// From RAK12010\nSerial.print(\"Lux: \");\nSerial.print(lux);\nSerial.println(\" lx \");\nSerial.print(\"White: \");\nSerial.println(white);\nSerial.print(\"Raw ALS: \");\nSerial.println(raw_als);", "keywords": ["Arduino IDE", "RAK4631", "UV Index", "UV Intensity", "LoRaWAN", "SX126x-Arduino"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **UV Index & UV Intensity Monitoring** device. Just copy the code below for **UV Index & UV Intensity Monitoring LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the example </summary>  \n```c\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h>  //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n#include \"UVlight_LTR390.h\"                // http://librarymanager/All#RAK12019_LTR390\nUVlight_LTR390 ltr = UVlight_LTR390();\n\n#include \"Light_VEML7700.h\"                // http://librarymanager/All#Light_veml7700\nLight_VEML7700 VMEL = Light_VEML7700();\n\nuint16_t uvi;\nuint32_t uvs;\nuint32_t lux;\nuint32_t white;\nuint32_t raw_als;\n\n#include <Adafruit_MCP23X17.h>  //http://librarymanager/All#Adafruit_MCP23017\nAdafruit_MCP23X17 mcp;\n\n// Added definitions for the functionality of RAK14003\nconst uint8_t LED_0 = 0;      // PA0 (17) of MCP23017\nconst uint8_t LED_1 = 1;      // PA1 (18) of MCP23017\nconst uint8_t LED_2 = 2;      // PA2 (19) of MCP23017\nconst uint8_t LED_3 = 3;      // PA3 (20) of MCP23017\nconst uint8_t LED_4 = 4;      // PA4 (21) of MCP23017\nconst uint8_t LED_5 = 5;      // PA5 (22) of MCP23017\nconst uint8_t LED_6 = 6;      // PA6 (23) of MCP23017\nconst uint8_t LED_7 = 7;      // PA7 (24) of MCP23017\nconst uint8_t LED_8 = 8;      // PB0 (25) of MCP23017\nconst uint8_t LED_9 = 9;      // PB1 (26) of MCP23017\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define RAK4631_BOARD true\n#else\n#define RAK4631_BOARD false\n#endif\n\nbool doOTAA = true;                                               // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                                       /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                                     /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5                               /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                                        /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;                           /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;                 /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                              /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = { LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF };\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = { BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler };\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xE9, 0x0D, 0x28, 0x1D, 0x92, 0x3D, 0xE4, 0x9F, 0xD9, 0xF7, 0xE0, 0x5F, 0x39, 0x10, 0x55, 0x71 };\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };\nuint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                                            /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];               //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = { m_lora_app_data_buffer, 0, 0, 0, 0 };  //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {\n\n// Initialize Serial for debug output\npinMode(LED_BLUE, OUTPUT);\ndigitalWrite(LED_BLUE, HIGH);\n\n// Sensor Power Switch\npinMode(WB_IO2, OUTPUT);\ndigitalWrite(WB_IO2, HIGH);\n\n// Reset RAK14003 module\npinMode(WB_IO4, OUTPUT);\ndigitalWrite(WB_IO4, HIGH);\ndelay(10);\ndigitalWrite(WB_IO4, LOW);\ndelay(10);\ndigitalWrite(WB_IO4, HIGH);\ndelay(10);\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial) {\nif ((millis() - timeout) < 5000) {\ndelay(100);\n} else {\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA) {\nSerial.println(\"Type: OTAA\");\n} else {\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion) {\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA) {\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n} else {\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0) {\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"================================\");\nSerial.println(\"RAK12019 + RAK12010 LoRaWAN Code\");\nSerial.println(\"================================\");\n\nif (!VMEL.begin())\n{\nSerial.println(\"Sensor not found\");\nwhile (1);\n}\n\nVMEL.setGain(VEML7700_GAIN_1);\nVMEL.setIntegrationTime(VEML7700_IT_800MS);\n\nSerial.print(F(\"Gain: \"));\nswitch (VMEL.getGain())\n{\ncase VEML7700_GAIN_1: Serial.println(\"1\"); break;\ncase VEML7700_GAIN_2: Serial.println(\"2\"); break;\ncase VEML7700_GAIN_1_4: Serial.println(\"1/4\"); break;\ncase VEML7700_GAIN_1_8: Serial.println(\"1/8\"); break;\n}\n\nSerial.print(F(\"Integration Time (ms): \"));\nswitch (VMEL.getIntegrationTime())\n{\ncase VEML7700_IT_25MS: Serial.println(\"25\"); break;\ncase VEML7700_IT_50MS: Serial.println(\"50\"); break;\ncase VEML7700_IT_100MS: Serial.println(\"100\"); break;\ncase VEML7700_IT_200MS: Serial.println(\"200\"); break;\ncase VEML7700_IT_400MS: Serial.println(\"400\"); break;\ncase VEML7700_IT_800MS: Serial.println(\"800\"); break;\n}\n\nSerial.println(\"RAK12019 test\");\nWire.begin();\nif (!ltr.init())\n{\nSerial.println(\"Couldn't find LTR sensor!\");\nwhile (1)\ndelay(10);\n}\nSerial.println(\"Found LTR390 sensor!\");\n\n//set to LTR390_MODE_UVS,get ultraviolet light data.\nltr.setMode(LTR390_MODE_UVS);  // UVS Mode\n\nSerial.println(\"In UVS mode\");\n\nltr.setGain(LTR390_GAIN_3);\nSerial.print(\"Gain : \");\nswitch (ltr.getGain())\n{\ncase LTR390_GAIN_1:\nSerial.println(1);\nbreak;\ncase LTR390_GAIN_3:\nSerial.println(3);\nbreak;\ncase LTR390_GAIN_6:\nSerial.println(6);\nbreak;\ncase LTR390_GAIN_9:\nSerial.println(9);\nbreak;\ncase LTR390_GAIN_18:\nSerial.println(18);\nbreak;\ndefault:\nSerial.println(\"Failed to set gain\");\nbreak;\n}\nltr.setResolution(LTR390_RESOLUTION_16BIT);\nSerial.print(\"Integration Time (ms): \");\nswitch (ltr.getResolution())\n{\ncase LTR390_RESOLUTION_13BIT:\nSerial.println(13);\nbreak;\ncase LTR390_RESOLUTION_16BIT:\nSerial.println(16);\nbreak;\ncase LTR390_RESOLUTION_17BIT:\nSerial.println(17);\nbreak;\ncase LTR390_RESOLUTION_18BIT:\nSerial.println(18);\nbreak;\ncase LTR390_RESOLUTION_19BIT:\nSerial.println(19);\nbreak;\ncase LTR390_RESOLUTION_20BIT:\nSerial.println(20);\nbreak;\ndefault:\nSerial.println(\"Failed to set Integration Time\");\nbreak;\n}\n\nltr.setThresholds(100, 1000); //Set the interrupt output threshold range for lower and upper.\n\nltr.configInterrupt(true, LTR390_MODE_UVS);\n\n// For RAK14003\nmcp.begin_I2C(0x24);\n\n// Added for the functionality of RAK14003\n\nWire.begin();    // initialize I2C serial bus\n\n// Configuration of MCP23017 I/O ports\nmcp.pinMode(LED_0, OUTPUT);     // Red LED; Top most\nmcp.pinMode(LED_1, OUTPUT);     // Red LED\nmcp.pinMode(LED_2, OUTPUT);     // Orange LED\nmcp.pinMode(LED_3, OUTPUT);     // Orange LED\nmcp.pinMode(LED_4, OUTPUT);     // Orange LED\nmcp.pinMode(LED_5, OUTPUT);     // Green LED\nmcp.pinMode(LED_6, OUTPUT);     // Green LED\nmcp.pinMode(LED_7, OUTPUT);     // Green LED\nmcp.pinMode(LED_8, OUTPUT);     // Green LED\nmcp.pinMode(LED_9, OUTPUT);     // Green LED; Bottom\n\n// Initially Turn OFF all LEDs\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, HIGH);\n\n}\n\nvoid loop() {\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\n// Trial # 1\n// Data from RAK12019\nif (ltr.newDataAvailable())\n{\nuvi = ltr.getUVI();\nuvs = ltr.readUVS();\n}\n\n// Data from RAK12010\nlux = VMEL.readLux();\nwhite = VMEL.readWhite();\nraw_als = VMEL.readALS();\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\n\n// From RAK12019 module\nSerial.print(\"UVI: \");\nSerial.println(uvi);          // Uvi data from RAK12019\nSerial.print(\"UVS: \");\nSerial.println(uvs);            // Uvs data from RAK12019\n\n// From RAK12010\nSerial.print(\"Lux: \");\nSerial.print(lux);\nSerial.println(\" lx \");\nSerial.print(\"White: \");\nSerial.println(white);\nSerial.print(\"Raw ALS: \");\nSerial.println(raw_als);\n\n// Result of uvi to be displayed via RAK14003 module\nif (uvi <= 0.4)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, HIGH);\n}\n\nelse if (uvi > 0.5 && uvi <= 1)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 1.5 && uvi <= 2)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 2.5 && uvi <= 3)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 3.5 && uvi <= 4)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 4.5 && uvi <= 5)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 5.5 && uvi <= 6)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 6.5 && uvi <= 7)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 7.5 && uvi <= 8)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 8.5 && uvi <= 9.5)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, LOW);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi >= 10)\n{\nmcp.digitalWrite(LED_0, LOW);\nmcp.digitalWrite(LED_1, LOW);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\ndelay(10000);\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void) {\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void) {\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data) {\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class) {\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void) {\nif (lmh_join_status_get() != LMH_SET) {\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\ndata = \" Uvi Data: \" + String(uvi) + \" Uvs Data: \" + String(uvs) + \" Lux Data: \" + String(lux) + \" lx \" ;\n\nSerial.println(data);\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\nuint16_t uvi_data = uvi;            // Uvi data from RAK12019\nuint32_t uvs_data = uvs;            // Uvs data from RAK12019\nuint32_t lux_data = lux;            // Lux data from RAK12010\n\nm_lora_app_data.buffer[i++] = 0x01;  // byte[0]\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\n// Data from RAK12019 module\nm_lora_app_data.buffer[i++] = (uint8_t)((uvi_data & 0x0000FF00) >> 8);     // byte[1]\nm_lora_app_data.buffer[i++] = (uint8_t)(uvi_data & 0x000000FF);            // byte[2]\n\n// Data from RAK12019 module\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0xFF000000) >> 24);    // byte[3]\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0x00FF0000) >> 16);    // byte[4]\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0x0000FF00) >> 8);     // byte[5]\nm_lora_app_data.buffer[i++] = (uint8_t)(uvs_data & 0x000000FF);            // byte[6]\n\n// Data from RAK12010 module\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0xFF000000) >> 24);    // byte[7]\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0x00FF0000) >> 16);    // byte[8]\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0x0000FF00) >> 8);     // byte[9]\nm_lora_app_data.buffer[i++] = (uint8_t)(lux_data & 0x000000FF);            // byte[10]\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS) {\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n} else {\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xE9, 0x0D, 0x28, 0x1D, 0x92, 0x3D, 0xE4, 0x9F, 0xD9, 0xF7, 0xE0, 0x5F, 0x39, 0x10, 0x55, 0x71 };\n\n```  \n> **Image:** OTAA device successfully registered to TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "897eea89580c5f4f2e7f086a32e8d979", "product_family": "wisblock", "product_id": "kit6-light-and-color", "category": "How-To", "title": "WisBlock IoT Education Kit - Light & Color Quick Start Guide > WisBlock IoT Education Kit - Light & Color Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock IoT Education Kit - Light & Color using TTN and Qubitro > UV Index & UV Intensity Monitoring LoRaWAN Application > LoRaWAN Code for UV Index & UV Intensity Monitoring > Programming UV Index & UV Intensity Monitoring Device with Arduino IDE [CODE]", "content": "// Result of uvi to be displayed via RAK14003 module\nif (uvi <= 0.4)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, HIGH);\n}", "keywords": ["Arduino IDE", "RAK4631", "UV Index", "UV Intensity", "LoRaWAN", "SX126x-Arduino"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **UV Index & UV Intensity Monitoring** device. Just copy the code below for **UV Index & UV Intensity Monitoring LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the example </summary>  \n```c\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h>  //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n#include \"UVlight_LTR390.h\"                // http://librarymanager/All#RAK12019_LTR390\nUVlight_LTR390 ltr = UVlight_LTR390();\n\n#include \"Light_VEML7700.h\"                // http://librarymanager/All#Light_veml7700\nLight_VEML7700 VMEL = Light_VEML7700();\n\nuint16_t uvi;\nuint32_t uvs;\nuint32_t lux;\nuint32_t white;\nuint32_t raw_als;\n\n#include <Adafruit_MCP23X17.h>  //http://librarymanager/All#Adafruit_MCP23017\nAdafruit_MCP23X17 mcp;\n\n// Added definitions for the functionality of RAK14003\nconst uint8_t LED_0 = 0;      // PA0 (17) of MCP23017\nconst uint8_t LED_1 = 1;      // PA1 (18) of MCP23017\nconst uint8_t LED_2 = 2;      // PA2 (19) of MCP23017\nconst uint8_t LED_3 = 3;      // PA3 (20) of MCP23017\nconst uint8_t LED_4 = 4;      // PA4 (21) of MCP23017\nconst uint8_t LED_5 = 5;      // PA5 (22) of MCP23017\nconst uint8_t LED_6 = 6;      // PA6 (23) of MCP23017\nconst uint8_t LED_7 = 7;      // PA7 (24) of MCP23017\nconst uint8_t LED_8 = 8;      // PB0 (25) of MCP23017\nconst uint8_t LED_9 = 9;      // PB1 (26) of MCP23017\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define RAK4631_BOARD true\n#else\n#define RAK4631_BOARD false\n#endif\n\nbool doOTAA = true;                                               // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                                       /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                                     /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5                               /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                                        /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;                           /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;                 /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                              /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = { LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF };\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = { BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler };\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xE9, 0x0D, 0x28, 0x1D, 0x92, 0x3D, 0xE4, 0x9F, 0xD9, 0xF7, 0xE0, 0x5F, 0x39, 0x10, 0x55, 0x71 };\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };\nuint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                                            /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];               //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = { m_lora_app_data_buffer, 0, 0, 0, 0 };  //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {\n\n// Initialize Serial for debug output\npinMode(LED_BLUE, OUTPUT);\ndigitalWrite(LED_BLUE, HIGH);\n\n// Sensor Power Switch\npinMode(WB_IO2, OUTPUT);\ndigitalWrite(WB_IO2, HIGH);\n\n// Reset RAK14003 module\npinMode(WB_IO4, OUTPUT);\ndigitalWrite(WB_IO4, HIGH);\ndelay(10);\ndigitalWrite(WB_IO4, LOW);\ndelay(10);\ndigitalWrite(WB_IO4, HIGH);\ndelay(10);\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial) {\nif ((millis() - timeout) < 5000) {\ndelay(100);\n} else {\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA) {\nSerial.println(\"Type: OTAA\");\n} else {\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion) {\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA) {\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n} else {\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0) {\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"================================\");\nSerial.println(\"RAK12019 + RAK12010 LoRaWAN Code\");\nSerial.println(\"================================\");\n\nif (!VMEL.begin())\n{\nSerial.println(\"Sensor not found\");\nwhile (1);\n}\n\nVMEL.setGain(VEML7700_GAIN_1);\nVMEL.setIntegrationTime(VEML7700_IT_800MS);\n\nSerial.print(F(\"Gain: \"));\nswitch (VMEL.getGain())\n{\ncase VEML7700_GAIN_1: Serial.println(\"1\"); break;\ncase VEML7700_GAIN_2: Serial.println(\"2\"); break;\ncase VEML7700_GAIN_1_4: Serial.println(\"1/4\"); break;\ncase VEML7700_GAIN_1_8: Serial.println(\"1/8\"); break;\n}\n\nSerial.print(F(\"Integration Time (ms): \"));\nswitch (VMEL.getIntegrationTime())\n{\ncase VEML7700_IT_25MS: Serial.println(\"25\"); break;\ncase VEML7700_IT_50MS: Serial.println(\"50\"); break;\ncase VEML7700_IT_100MS: Serial.println(\"100\"); break;\ncase VEML7700_IT_200MS: Serial.println(\"200\"); break;\ncase VEML7700_IT_400MS: Serial.println(\"400\"); break;\ncase VEML7700_IT_800MS: Serial.println(\"800\"); break;\n}\n\nSerial.println(\"RAK12019 test\");\nWire.begin();\nif (!ltr.init())\n{\nSerial.println(\"Couldn't find LTR sensor!\");\nwhile (1)\ndelay(10);\n}\nSerial.println(\"Found LTR390 sensor!\");\n\n//set to LTR390_MODE_UVS,get ultraviolet light data.\nltr.setMode(LTR390_MODE_UVS);  // UVS Mode\n\nSerial.println(\"In UVS mode\");\n\nltr.setGain(LTR390_GAIN_3);\nSerial.print(\"Gain : \");\nswitch (ltr.getGain())\n{\ncase LTR390_GAIN_1:\nSerial.println(1);\nbreak;\ncase LTR390_GAIN_3:\nSerial.println(3);\nbreak;\ncase LTR390_GAIN_6:\nSerial.println(6);\nbreak;\ncase LTR390_GAIN_9:\nSerial.println(9);\nbreak;\ncase LTR390_GAIN_18:\nSerial.println(18);\nbreak;\ndefault:\nSerial.println(\"Failed to set gain\");\nbreak;\n}\nltr.setResolution(LTR390_RESOLUTION_16BIT);\nSerial.print(\"Integration Time (ms): \");\nswitch (ltr.getResolution())\n{\ncase LTR390_RESOLUTION_13BIT:\nSerial.println(13);\nbreak;\ncase LTR390_RESOLUTION_16BIT:\nSerial.println(16);\nbreak;\ncase LTR390_RESOLUTION_17BIT:\nSerial.println(17);\nbreak;\ncase LTR390_RESOLUTION_18BIT:\nSerial.println(18);\nbreak;\ncase LTR390_RESOLUTION_19BIT:\nSerial.println(19);\nbreak;\ncase LTR390_RESOLUTION_20BIT:\nSerial.println(20);\nbreak;\ndefault:\nSerial.println(\"Failed to set Integration Time\");\nbreak;\n}\n\nltr.setThresholds(100, 1000); //Set the interrupt output threshold range for lower and upper.\n\nltr.configInterrupt(true, LTR390_MODE_UVS);\n\n// For RAK14003\nmcp.begin_I2C(0x24);\n\n// Added for the functionality of RAK14003\n\nWire.begin();    // initialize I2C serial bus\n\n// Configuration of MCP23017 I/O ports\nmcp.pinMode(LED_0, OUTPUT);     // Red LED; Top most\nmcp.pinMode(LED_1, OUTPUT);     // Red LED\nmcp.pinMode(LED_2, OUTPUT);     // Orange LED\nmcp.pinMode(LED_3, OUTPUT);     // Orange LED\nmcp.pinMode(LED_4, OUTPUT);     // Orange LED\nmcp.pinMode(LED_5, OUTPUT);     // Green LED\nmcp.pinMode(LED_6, OUTPUT);     // Green LED\nmcp.pinMode(LED_7, OUTPUT);     // Green LED\nmcp.pinMode(LED_8, OUTPUT);     // Green LED\nmcp.pinMode(LED_9, OUTPUT);     // Green LED; Bottom\n\n// Initially Turn OFF all LEDs\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, HIGH);\n\n}\n\nvoid loop() {\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\n// Trial # 1\n// Data from RAK12019\nif (ltr.newDataAvailable())\n{\nuvi = ltr.getUVI();\nuvs = ltr.readUVS();\n}\n\n// Data from RAK12010\nlux = VMEL.readLux();\nwhite = VMEL.readWhite();\nraw_als = VMEL.readALS();\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\n\n// From RAK12019 module\nSerial.print(\"UVI: \");\nSerial.println(uvi);          // Uvi data from RAK12019\nSerial.print(\"UVS: \");\nSerial.println(uvs);            // Uvs data from RAK12019\n\n// From RAK12010\nSerial.print(\"Lux: \");\nSerial.print(lux);\nSerial.println(\" lx \");\nSerial.print(\"White: \");\nSerial.println(white);\nSerial.print(\"Raw ALS: \");\nSerial.println(raw_als);\n\n// Result of uvi to be displayed via RAK14003 module\nif (uvi <= 0.4)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, HIGH);\n}\n\nelse if (uvi > 0.5 && uvi <= 1)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 1.5 && uvi <= 2)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 2.5 && uvi <= 3)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 3.5 && uvi <= 4)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 4.5 && uvi <= 5)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 5.5 && uvi <= 6)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 6.5 && uvi <= 7)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 7.5 && uvi <= 8)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 8.5 && uvi <= 9.5)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, LOW);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi >= 10)\n{\nmcp.digitalWrite(LED_0, LOW);\nmcp.digitalWrite(LED_1, LOW);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\ndelay(10000);\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void) {\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void) {\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data) {\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class) {\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void) {\nif (lmh_join_status_get() != LMH_SET) {\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\ndata = \" Uvi Data: \" + String(uvi) + \" Uvs Data: \" + String(uvs) + \" Lux Data: \" + String(lux) + \" lx \" ;\n\nSerial.println(data);\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\nuint16_t uvi_data = uvi;            // Uvi data from RAK12019\nuint32_t uvs_data = uvs;            // Uvs data from RAK12019\nuint32_t lux_data = lux;            // Lux data from RAK12010\n\nm_lora_app_data.buffer[i++] = 0x01;  // byte[0]\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\n// Data from RAK12019 module\nm_lora_app_data.buffer[i++] = (uint8_t)((uvi_data & 0x0000FF00) >> 8);     // byte[1]\nm_lora_app_data.buffer[i++] = (uint8_t)(uvi_data & 0x000000FF);            // byte[2]\n\n// Data from RAK12019 module\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0xFF000000) >> 24);    // byte[3]\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0x00FF0000) >> 16);    // byte[4]\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0x0000FF00) >> 8);     // byte[5]\nm_lora_app_data.buffer[i++] = (uint8_t)(uvs_data & 0x000000FF);            // byte[6]\n\n// Data from RAK12010 module\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0xFF000000) >> 24);    // byte[7]\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0x00FF0000) >> 16);    // byte[8]\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0x0000FF00) >> 8);     // byte[9]\nm_lora_app_data.buffer[i++] = (uint8_t)(lux_data & 0x000000FF);            // byte[10]\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS) {\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n} else {\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xE9, 0x0D, 0x28, 0x1D, 0x92, 0x3D, 0xE4, 0x9F, 0xD9, 0xF7, 0xE0, 0x5F, 0x39, 0x10, 0x55, 0x71 };\n\n```  \n> **Image:** OTAA device successfully registered to TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "ce84b0829ae81f0181df3f9eb51bd7cf", "product_family": "wisblock", "product_id": "kit6-light-and-color", "category": "How-To", "title": "WisBlock IoT Education Kit - Light & Color Quick Start Guide > WisBlock IoT Education Kit - Light & Color Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock IoT Education Kit - Light & Color using TTN and Qubitro > UV Index & UV Intensity Monitoring LoRaWAN Application > LoRaWAN Code for UV Index & UV Intensity Monitoring > Programming UV Index & UV Intensity Monitoring Device with Arduino IDE [CODE]", "content": "else if (uvi > 0.5 && uvi <= 1)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, LOW);\n}", "keywords": ["Arduino IDE", "RAK4631", "UV Index", "UV Intensity", "LoRaWAN", "SX126x-Arduino"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **UV Index & UV Intensity Monitoring** device. Just copy the code below for **UV Index & UV Intensity Monitoring LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the example </summary>  \n```c\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h>  //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n#include \"UVlight_LTR390.h\"                // http://librarymanager/All#RAK12019_LTR390\nUVlight_LTR390 ltr = UVlight_LTR390();\n\n#include \"Light_VEML7700.h\"                // http://librarymanager/All#Light_veml7700\nLight_VEML7700 VMEL = Light_VEML7700();\n\nuint16_t uvi;\nuint32_t uvs;\nuint32_t lux;\nuint32_t white;\nuint32_t raw_als;\n\n#include <Adafruit_MCP23X17.h>  //http://librarymanager/All#Adafruit_MCP23017\nAdafruit_MCP23X17 mcp;\n\n// Added definitions for the functionality of RAK14003\nconst uint8_t LED_0 = 0;      // PA0 (17) of MCP23017\nconst uint8_t LED_1 = 1;      // PA1 (18) of MCP23017\nconst uint8_t LED_2 = 2;      // PA2 (19) of MCP23017\nconst uint8_t LED_3 = 3;      // PA3 (20) of MCP23017\nconst uint8_t LED_4 = 4;      // PA4 (21) of MCP23017\nconst uint8_t LED_5 = 5;      // PA5 (22) of MCP23017\nconst uint8_t LED_6 = 6;      // PA6 (23) of MCP23017\nconst uint8_t LED_7 = 7;      // PA7 (24) of MCP23017\nconst uint8_t LED_8 = 8;      // PB0 (25) of MCP23017\nconst uint8_t LED_9 = 9;      // PB1 (26) of MCP23017\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define RAK4631_BOARD true\n#else\n#define RAK4631_BOARD false\n#endif\n\nbool doOTAA = true;                                               // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                                       /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                                     /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5                               /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                                        /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;                           /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;                 /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                              /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = { LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF };\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = { BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler };\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xE9, 0x0D, 0x28, 0x1D, 0x92, 0x3D, 0xE4, 0x9F, 0xD9, 0xF7, 0xE0, 0x5F, 0x39, 0x10, 0x55, 0x71 };\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };\nuint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                                            /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];               //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = { m_lora_app_data_buffer, 0, 0, 0, 0 };  //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {\n\n// Initialize Serial for debug output\npinMode(LED_BLUE, OUTPUT);\ndigitalWrite(LED_BLUE, HIGH);\n\n// Sensor Power Switch\npinMode(WB_IO2, OUTPUT);\ndigitalWrite(WB_IO2, HIGH);\n\n// Reset RAK14003 module\npinMode(WB_IO4, OUTPUT);\ndigitalWrite(WB_IO4, HIGH);\ndelay(10);\ndigitalWrite(WB_IO4, LOW);\ndelay(10);\ndigitalWrite(WB_IO4, HIGH);\ndelay(10);\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial) {\nif ((millis() - timeout) < 5000) {\ndelay(100);\n} else {\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA) {\nSerial.println(\"Type: OTAA\");\n} else {\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion) {\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA) {\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n} else {\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0) {\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"================================\");\nSerial.println(\"RAK12019 + RAK12010 LoRaWAN Code\");\nSerial.println(\"================================\");\n\nif (!VMEL.begin())\n{\nSerial.println(\"Sensor not found\");\nwhile (1);\n}\n\nVMEL.setGain(VEML7700_GAIN_1);\nVMEL.setIntegrationTime(VEML7700_IT_800MS);\n\nSerial.print(F(\"Gain: \"));\nswitch (VMEL.getGain())\n{\ncase VEML7700_GAIN_1: Serial.println(\"1\"); break;\ncase VEML7700_GAIN_2: Serial.println(\"2\"); break;\ncase VEML7700_GAIN_1_4: Serial.println(\"1/4\"); break;\ncase VEML7700_GAIN_1_8: Serial.println(\"1/8\"); break;\n}\n\nSerial.print(F(\"Integration Time (ms): \"));\nswitch (VMEL.getIntegrationTime())\n{\ncase VEML7700_IT_25MS: Serial.println(\"25\"); break;\ncase VEML7700_IT_50MS: Serial.println(\"50\"); break;\ncase VEML7700_IT_100MS: Serial.println(\"100\"); break;\ncase VEML7700_IT_200MS: Serial.println(\"200\"); break;\ncase VEML7700_IT_400MS: Serial.println(\"400\"); break;\ncase VEML7700_IT_800MS: Serial.println(\"800\"); break;\n}\n\nSerial.println(\"RAK12019 test\");\nWire.begin();\nif (!ltr.init())\n{\nSerial.println(\"Couldn't find LTR sensor!\");\nwhile (1)\ndelay(10);\n}\nSerial.println(\"Found LTR390 sensor!\");\n\n//set to LTR390_MODE_UVS,get ultraviolet light data.\nltr.setMode(LTR390_MODE_UVS);  // UVS Mode\n\nSerial.println(\"In UVS mode\");\n\nltr.setGain(LTR390_GAIN_3);\nSerial.print(\"Gain : \");\nswitch (ltr.getGain())\n{\ncase LTR390_GAIN_1:\nSerial.println(1);\nbreak;\ncase LTR390_GAIN_3:\nSerial.println(3);\nbreak;\ncase LTR390_GAIN_6:\nSerial.println(6);\nbreak;\ncase LTR390_GAIN_9:\nSerial.println(9);\nbreak;\ncase LTR390_GAIN_18:\nSerial.println(18);\nbreak;\ndefault:\nSerial.println(\"Failed to set gain\");\nbreak;\n}\nltr.setResolution(LTR390_RESOLUTION_16BIT);\nSerial.print(\"Integration Time (ms): \");\nswitch (ltr.getResolution())\n{\ncase LTR390_RESOLUTION_13BIT:\nSerial.println(13);\nbreak;\ncase LTR390_RESOLUTION_16BIT:\nSerial.println(16);\nbreak;\ncase LTR390_RESOLUTION_17BIT:\nSerial.println(17);\nbreak;\ncase LTR390_RESOLUTION_18BIT:\nSerial.println(18);\nbreak;\ncase LTR390_RESOLUTION_19BIT:\nSerial.println(19);\nbreak;\ncase LTR390_RESOLUTION_20BIT:\nSerial.println(20);\nbreak;\ndefault:\nSerial.println(\"Failed to set Integration Time\");\nbreak;\n}\n\nltr.setThresholds(100, 1000); //Set the interrupt output threshold range for lower and upper.\n\nltr.configInterrupt(true, LTR390_MODE_UVS);\n\n// For RAK14003\nmcp.begin_I2C(0x24);\n\n// Added for the functionality of RAK14003\n\nWire.begin();    // initialize I2C serial bus\n\n// Configuration of MCP23017 I/O ports\nmcp.pinMode(LED_0, OUTPUT);     // Red LED; Top most\nmcp.pinMode(LED_1, OUTPUT);     // Red LED\nmcp.pinMode(LED_2, OUTPUT);     // Orange LED\nmcp.pinMode(LED_3, OUTPUT);     // Orange LED\nmcp.pinMode(LED_4, OUTPUT);     // Orange LED\nmcp.pinMode(LED_5, OUTPUT);     // Green LED\nmcp.pinMode(LED_6, OUTPUT);     // Green LED\nmcp.pinMode(LED_7, OUTPUT);     // Green LED\nmcp.pinMode(LED_8, OUTPUT);     // Green LED\nmcp.pinMode(LED_9, OUTPUT);     // Green LED; Bottom\n\n// Initially Turn OFF all LEDs\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, HIGH);\n\n}\n\nvoid loop() {\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\n// Trial # 1\n// Data from RAK12019\nif (ltr.newDataAvailable())\n{\nuvi = ltr.getUVI();\nuvs = ltr.readUVS();\n}\n\n// Data from RAK12010\nlux = VMEL.readLux();\nwhite = VMEL.readWhite();\nraw_als = VMEL.readALS();\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\n\n// From RAK12019 module\nSerial.print(\"UVI: \");\nSerial.println(uvi);          // Uvi data from RAK12019\nSerial.print(\"UVS: \");\nSerial.println(uvs);            // Uvs data from RAK12019\n\n// From RAK12010\nSerial.print(\"Lux: \");\nSerial.print(lux);\nSerial.println(\" lx \");\nSerial.print(\"White: \");\nSerial.println(white);\nSerial.print(\"Raw ALS: \");\nSerial.println(raw_als);\n\n// Result of uvi to be displayed via RAK14003 module\nif (uvi <= 0.4)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, HIGH);\n}\n\nelse if (uvi > 0.5 && uvi <= 1)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 1.5 && uvi <= 2)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 2.5 && uvi <= 3)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 3.5 && uvi <= 4)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 4.5 && uvi <= 5)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 5.5 && uvi <= 6)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 6.5 && uvi <= 7)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 7.5 && uvi <= 8)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 8.5 && uvi <= 9.5)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, LOW);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi >= 10)\n{\nmcp.digitalWrite(LED_0, LOW);\nmcp.digitalWrite(LED_1, LOW);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\ndelay(10000);\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void) {\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void) {\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data) {\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class) {\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void) {\nif (lmh_join_status_get() != LMH_SET) {\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\ndata = \" Uvi Data: \" + String(uvi) + \" Uvs Data: \" + String(uvs) + \" Lux Data: \" + String(lux) + \" lx \" ;\n\nSerial.println(data);\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\nuint16_t uvi_data = uvi;            // Uvi data from RAK12019\nuint32_t uvs_data = uvs;            // Uvs data from RAK12019\nuint32_t lux_data = lux;            // Lux data from RAK12010\n\nm_lora_app_data.buffer[i++] = 0x01;  // byte[0]\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\n// Data from RAK12019 module\nm_lora_app_data.buffer[i++] = (uint8_t)((uvi_data & 0x0000FF00) >> 8);     // byte[1]\nm_lora_app_data.buffer[i++] = (uint8_t)(uvi_data & 0x000000FF);            // byte[2]\n\n// Data from RAK12019 module\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0xFF000000) >> 24);    // byte[3]\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0x00FF0000) >> 16);    // byte[4]\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0x0000FF00) >> 8);     // byte[5]\nm_lora_app_data.buffer[i++] = (uint8_t)(uvs_data & 0x000000FF);            // byte[6]\n\n// Data from RAK12010 module\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0xFF000000) >> 24);    // byte[7]\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0x00FF0000) >> 16);    // byte[8]\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0x0000FF00) >> 8);     // byte[9]\nm_lora_app_data.buffer[i++] = (uint8_t)(lux_data & 0x000000FF);            // byte[10]\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS) {\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n} else {\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xE9, 0x0D, 0x28, 0x1D, 0x92, 0x3D, 0xE4, 0x9F, 0xD9, 0xF7, 0xE0, 0x5F, 0x39, 0x10, 0x55, 0x71 };\n\n```  \n> **Image:** OTAA device successfully registered to TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "8b02102f545534aece0564642cb3e374", "product_family": "wisblock", "product_id": "kit6-light-and-color", "category": "How-To", "title": "WisBlock IoT Education Kit - Light & Color Quick Start Guide > WisBlock IoT Education Kit - Light & Color Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock IoT Education Kit - Light & Color using TTN and Qubitro > UV Index & UV Intensity Monitoring LoRaWAN Application > LoRaWAN Code for UV Index & UV Intensity Monitoring > Programming UV Index & UV Intensity Monitoring Device with Arduino IDE [CODE]", "content": "else if (uvi > 1.5 && uvi <= 2)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}", "keywords": ["Arduino IDE", "RAK4631", "UV Index", "UV Intensity", "LoRaWAN", "SX126x-Arduino"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **UV Index & UV Intensity Monitoring** device. Just copy the code below for **UV Index & UV Intensity Monitoring LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the example </summary>  \n```c\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h>  //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n#include \"UVlight_LTR390.h\"                // http://librarymanager/All#RAK12019_LTR390\nUVlight_LTR390 ltr = UVlight_LTR390();\n\n#include \"Light_VEML7700.h\"                // http://librarymanager/All#Light_veml7700\nLight_VEML7700 VMEL = Light_VEML7700();\n\nuint16_t uvi;\nuint32_t uvs;\nuint32_t lux;\nuint32_t white;\nuint32_t raw_als;\n\n#include <Adafruit_MCP23X17.h>  //http://librarymanager/All#Adafruit_MCP23017\nAdafruit_MCP23X17 mcp;\n\n// Added definitions for the functionality of RAK14003\nconst uint8_t LED_0 = 0;      // PA0 (17) of MCP23017\nconst uint8_t LED_1 = 1;      // PA1 (18) of MCP23017\nconst uint8_t LED_2 = 2;      // PA2 (19) of MCP23017\nconst uint8_t LED_3 = 3;      // PA3 (20) of MCP23017\nconst uint8_t LED_4 = 4;      // PA4 (21) of MCP23017\nconst uint8_t LED_5 = 5;      // PA5 (22) of MCP23017\nconst uint8_t LED_6 = 6;      // PA6 (23) of MCP23017\nconst uint8_t LED_7 = 7;      // PA7 (24) of MCP23017\nconst uint8_t LED_8 = 8;      // PB0 (25) of MCP23017\nconst uint8_t LED_9 = 9;      // PB1 (26) of MCP23017\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define RAK4631_BOARD true\n#else\n#define RAK4631_BOARD false\n#endif\n\nbool doOTAA = true;                                               // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                                       /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                                     /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5                               /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                                        /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;                           /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;                 /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                              /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = { LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF };\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = { BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler };\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xE9, 0x0D, 0x28, 0x1D, 0x92, 0x3D, 0xE4, 0x9F, 0xD9, 0xF7, 0xE0, 0x5F, 0x39, 0x10, 0x55, 0x71 };\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };\nuint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                                            /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];               //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = { m_lora_app_data_buffer, 0, 0, 0, 0 };  //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {\n\n// Initialize Serial for debug output\npinMode(LED_BLUE, OUTPUT);\ndigitalWrite(LED_BLUE, HIGH);\n\n// Sensor Power Switch\npinMode(WB_IO2, OUTPUT);\ndigitalWrite(WB_IO2, HIGH);\n\n// Reset RAK14003 module\npinMode(WB_IO4, OUTPUT);\ndigitalWrite(WB_IO4, HIGH);\ndelay(10);\ndigitalWrite(WB_IO4, LOW);\ndelay(10);\ndigitalWrite(WB_IO4, HIGH);\ndelay(10);\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial) {\nif ((millis() - timeout) < 5000) {\ndelay(100);\n} else {\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA) {\nSerial.println(\"Type: OTAA\");\n} else {\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion) {\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA) {\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n} else {\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0) {\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"================================\");\nSerial.println(\"RAK12019 + RAK12010 LoRaWAN Code\");\nSerial.println(\"================================\");\n\nif (!VMEL.begin())\n{\nSerial.println(\"Sensor not found\");\nwhile (1);\n}\n\nVMEL.setGain(VEML7700_GAIN_1);\nVMEL.setIntegrationTime(VEML7700_IT_800MS);\n\nSerial.print(F(\"Gain: \"));\nswitch (VMEL.getGain())\n{\ncase VEML7700_GAIN_1: Serial.println(\"1\"); break;\ncase VEML7700_GAIN_2: Serial.println(\"2\"); break;\ncase VEML7700_GAIN_1_4: Serial.println(\"1/4\"); break;\ncase VEML7700_GAIN_1_8: Serial.println(\"1/8\"); break;\n}\n\nSerial.print(F(\"Integration Time (ms): \"));\nswitch (VMEL.getIntegrationTime())\n{\ncase VEML7700_IT_25MS: Serial.println(\"25\"); break;\ncase VEML7700_IT_50MS: Serial.println(\"50\"); break;\ncase VEML7700_IT_100MS: Serial.println(\"100\"); break;\ncase VEML7700_IT_200MS: Serial.println(\"200\"); break;\ncase VEML7700_IT_400MS: Serial.println(\"400\"); break;\ncase VEML7700_IT_800MS: Serial.println(\"800\"); break;\n}\n\nSerial.println(\"RAK12019 test\");\nWire.begin();\nif (!ltr.init())\n{\nSerial.println(\"Couldn't find LTR sensor!\");\nwhile (1)\ndelay(10);\n}\nSerial.println(\"Found LTR390 sensor!\");\n\n//set to LTR390_MODE_UVS,get ultraviolet light data.\nltr.setMode(LTR390_MODE_UVS);  // UVS Mode\n\nSerial.println(\"In UVS mode\");\n\nltr.setGain(LTR390_GAIN_3);\nSerial.print(\"Gain : \");\nswitch (ltr.getGain())\n{\ncase LTR390_GAIN_1:\nSerial.println(1);\nbreak;\ncase LTR390_GAIN_3:\nSerial.println(3);\nbreak;\ncase LTR390_GAIN_6:\nSerial.println(6);\nbreak;\ncase LTR390_GAIN_9:\nSerial.println(9);\nbreak;\ncase LTR390_GAIN_18:\nSerial.println(18);\nbreak;\ndefault:\nSerial.println(\"Failed to set gain\");\nbreak;\n}\nltr.setResolution(LTR390_RESOLUTION_16BIT);\nSerial.print(\"Integration Time (ms): \");\nswitch (ltr.getResolution())\n{\ncase LTR390_RESOLUTION_13BIT:\nSerial.println(13);\nbreak;\ncase LTR390_RESOLUTION_16BIT:\nSerial.println(16);\nbreak;\ncase LTR390_RESOLUTION_17BIT:\nSerial.println(17);\nbreak;\ncase LTR390_RESOLUTION_18BIT:\nSerial.println(18);\nbreak;\ncase LTR390_RESOLUTION_19BIT:\nSerial.println(19);\nbreak;\ncase LTR390_RESOLUTION_20BIT:\nSerial.println(20);\nbreak;\ndefault:\nSerial.println(\"Failed to set Integration Time\");\nbreak;\n}\n\nltr.setThresholds(100, 1000); //Set the interrupt output threshold range for lower and upper.\n\nltr.configInterrupt(true, LTR390_MODE_UVS);\n\n// For RAK14003\nmcp.begin_I2C(0x24);\n\n// Added for the functionality of RAK14003\n\nWire.begin();    // initialize I2C serial bus\n\n// Configuration of MCP23017 I/O ports\nmcp.pinMode(LED_0, OUTPUT);     // Red LED; Top most\nmcp.pinMode(LED_1, OUTPUT);     // Red LED\nmcp.pinMode(LED_2, OUTPUT);     // Orange LED\nmcp.pinMode(LED_3, OUTPUT);     // Orange LED\nmcp.pinMode(LED_4, OUTPUT);     // Orange LED\nmcp.pinMode(LED_5, OUTPUT);     // Green LED\nmcp.pinMode(LED_6, OUTPUT);     // Green LED\nmcp.pinMode(LED_7, OUTPUT);     // Green LED\nmcp.pinMode(LED_8, OUTPUT);     // Green LED\nmcp.pinMode(LED_9, OUTPUT);     // Green LED; Bottom\n\n// Initially Turn OFF all LEDs\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, HIGH);\n\n}\n\nvoid loop() {\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\n// Trial # 1\n// Data from RAK12019\nif (ltr.newDataAvailable())\n{\nuvi = ltr.getUVI();\nuvs = ltr.readUVS();\n}\n\n// Data from RAK12010\nlux = VMEL.readLux();\nwhite = VMEL.readWhite();\nraw_als = VMEL.readALS();\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\n\n// From RAK12019 module\nSerial.print(\"UVI: \");\nSerial.println(uvi);          // Uvi data from RAK12019\nSerial.print(\"UVS: \");\nSerial.println(uvs);            // Uvs data from RAK12019\n\n// From RAK12010\nSerial.print(\"Lux: \");\nSerial.print(lux);\nSerial.println(\" lx \");\nSerial.print(\"White: \");\nSerial.println(white);\nSerial.print(\"Raw ALS: \");\nSerial.println(raw_als);\n\n// Result of uvi to be displayed via RAK14003 module\nif (uvi <= 0.4)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, HIGH);\n}\n\nelse if (uvi > 0.5 && uvi <= 1)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 1.5 && uvi <= 2)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 2.5 && uvi <= 3)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 3.5 && uvi <= 4)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 4.5 && uvi <= 5)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 5.5 && uvi <= 6)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 6.5 && uvi <= 7)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 7.5 && uvi <= 8)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 8.5 && uvi <= 9.5)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, LOW);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi >= 10)\n{\nmcp.digitalWrite(LED_0, LOW);\nmcp.digitalWrite(LED_1, LOW);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\ndelay(10000);\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void) {\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void) {\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data) {\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class) {\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void) {\nif (lmh_join_status_get() != LMH_SET) {\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\ndata = \" Uvi Data: \" + String(uvi) + \" Uvs Data: \" + String(uvs) + \" Lux Data: \" + String(lux) + \" lx \" ;\n\nSerial.println(data);\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\nuint16_t uvi_data = uvi;            // Uvi data from RAK12019\nuint32_t uvs_data = uvs;            // Uvs data from RAK12019\nuint32_t lux_data = lux;            // Lux data from RAK12010\n\nm_lora_app_data.buffer[i++] = 0x01;  // byte[0]\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\n// Data from RAK12019 module\nm_lora_app_data.buffer[i++] = (uint8_t)((uvi_data & 0x0000FF00) >> 8);     // byte[1]\nm_lora_app_data.buffer[i++] = (uint8_t)(uvi_data & 0x000000FF);            // byte[2]\n\n// Data from RAK12019 module\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0xFF000000) >> 24);    // byte[3]\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0x00FF0000) >> 16);    // byte[4]\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0x0000FF00) >> 8);     // byte[5]\nm_lora_app_data.buffer[i++] = (uint8_t)(uvs_data & 0x000000FF);            // byte[6]\n\n// Data from RAK12010 module\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0xFF000000) >> 24);    // byte[7]\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0x00FF0000) >> 16);    // byte[8]\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0x0000FF00) >> 8);     // byte[9]\nm_lora_app_data.buffer[i++] = (uint8_t)(lux_data & 0x000000FF);            // byte[10]\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS) {\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n} else {\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xE9, 0x0D, 0x28, 0x1D, 0x92, 0x3D, 0xE4, 0x9F, 0xD9, 0xF7, 0xE0, 0x5F, 0x39, 0x10, 0x55, 0x71 };\n\n```  \n> **Image:** OTAA device successfully registered to TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "933b1c9ce79310b153f715cf88400244", "product_family": "wisblock", "product_id": "kit6-light-and-color", "category": "How-To", "title": "WisBlock IoT Education Kit - Light & Color Quick Start Guide > WisBlock IoT Education Kit - Light & Color Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock IoT Education Kit - Light & Color using TTN and Qubitro > UV Index & UV Intensity Monitoring LoRaWAN Application > LoRaWAN Code for UV Index & UV Intensity Monitoring > Programming UV Index & UV Intensity Monitoring Device with Arduino IDE [CODE]", "content": "else if (uvi > 2.5 && uvi <= 3)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}", "keywords": ["Arduino IDE", "RAK4631", "UV Index", "UV Intensity", "LoRaWAN", "SX126x-Arduino"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **UV Index & UV Intensity Monitoring** device. Just copy the code below for **UV Index & UV Intensity Monitoring LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the example </summary>  \n```c\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h>  //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n#include \"UVlight_LTR390.h\"                // http://librarymanager/All#RAK12019_LTR390\nUVlight_LTR390 ltr = UVlight_LTR390();\n\n#include \"Light_VEML7700.h\"                // http://librarymanager/All#Light_veml7700\nLight_VEML7700 VMEL = Light_VEML7700();\n\nuint16_t uvi;\nuint32_t uvs;\nuint32_t lux;\nuint32_t white;\nuint32_t raw_als;\n\n#include <Adafruit_MCP23X17.h>  //http://librarymanager/All#Adafruit_MCP23017\nAdafruit_MCP23X17 mcp;\n\n// Added definitions for the functionality of RAK14003\nconst uint8_t LED_0 = 0;      // PA0 (17) of MCP23017\nconst uint8_t LED_1 = 1;      // PA1 (18) of MCP23017\nconst uint8_t LED_2 = 2;      // PA2 (19) of MCP23017\nconst uint8_t LED_3 = 3;      // PA3 (20) of MCP23017\nconst uint8_t LED_4 = 4;      // PA4 (21) of MCP23017\nconst uint8_t LED_5 = 5;      // PA5 (22) of MCP23017\nconst uint8_t LED_6 = 6;      // PA6 (23) of MCP23017\nconst uint8_t LED_7 = 7;      // PA7 (24) of MCP23017\nconst uint8_t LED_8 = 8;      // PB0 (25) of MCP23017\nconst uint8_t LED_9 = 9;      // PB1 (26) of MCP23017\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define RAK4631_BOARD true\n#else\n#define RAK4631_BOARD false\n#endif\n\nbool doOTAA = true;                                               // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                                       /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                                     /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5                               /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                                        /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;                           /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;                 /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                              /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = { LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF };\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = { BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler };\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xE9, 0x0D, 0x28, 0x1D, 0x92, 0x3D, 0xE4, 0x9F, 0xD9, 0xF7, 0xE0, 0x5F, 0x39, 0x10, 0x55, 0x71 };\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };\nuint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                                            /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];               //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = { m_lora_app_data_buffer, 0, 0, 0, 0 };  //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {\n\n// Initialize Serial for debug output\npinMode(LED_BLUE, OUTPUT);\ndigitalWrite(LED_BLUE, HIGH);\n\n// Sensor Power Switch\npinMode(WB_IO2, OUTPUT);\ndigitalWrite(WB_IO2, HIGH);\n\n// Reset RAK14003 module\npinMode(WB_IO4, OUTPUT);\ndigitalWrite(WB_IO4, HIGH);\ndelay(10);\ndigitalWrite(WB_IO4, LOW);\ndelay(10);\ndigitalWrite(WB_IO4, HIGH);\ndelay(10);\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial) {\nif ((millis() - timeout) < 5000) {\ndelay(100);\n} else {\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA) {\nSerial.println(\"Type: OTAA\");\n} else {\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion) {\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA) {\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n} else {\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0) {\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"================================\");\nSerial.println(\"RAK12019 + RAK12010 LoRaWAN Code\");\nSerial.println(\"================================\");\n\nif (!VMEL.begin())\n{\nSerial.println(\"Sensor not found\");\nwhile (1);\n}\n\nVMEL.setGain(VEML7700_GAIN_1);\nVMEL.setIntegrationTime(VEML7700_IT_800MS);\n\nSerial.print(F(\"Gain: \"));\nswitch (VMEL.getGain())\n{\ncase VEML7700_GAIN_1: Serial.println(\"1\"); break;\ncase VEML7700_GAIN_2: Serial.println(\"2\"); break;\ncase VEML7700_GAIN_1_4: Serial.println(\"1/4\"); break;\ncase VEML7700_GAIN_1_8: Serial.println(\"1/8\"); break;\n}\n\nSerial.print(F(\"Integration Time (ms): \"));\nswitch (VMEL.getIntegrationTime())\n{\ncase VEML7700_IT_25MS: Serial.println(\"25\"); break;\ncase VEML7700_IT_50MS: Serial.println(\"50\"); break;\ncase VEML7700_IT_100MS: Serial.println(\"100\"); break;\ncase VEML7700_IT_200MS: Serial.println(\"200\"); break;\ncase VEML7700_IT_400MS: Serial.println(\"400\"); break;\ncase VEML7700_IT_800MS: Serial.println(\"800\"); break;\n}\n\nSerial.println(\"RAK12019 test\");\nWire.begin();\nif (!ltr.init())\n{\nSerial.println(\"Couldn't find LTR sensor!\");\nwhile (1)\ndelay(10);\n}\nSerial.println(\"Found LTR390 sensor!\");\n\n//set to LTR390_MODE_UVS,get ultraviolet light data.\nltr.setMode(LTR390_MODE_UVS);  // UVS Mode\n\nSerial.println(\"In UVS mode\");\n\nltr.setGain(LTR390_GAIN_3);\nSerial.print(\"Gain : \");\nswitch (ltr.getGain())\n{\ncase LTR390_GAIN_1:\nSerial.println(1);\nbreak;\ncase LTR390_GAIN_3:\nSerial.println(3);\nbreak;\ncase LTR390_GAIN_6:\nSerial.println(6);\nbreak;\ncase LTR390_GAIN_9:\nSerial.println(9);\nbreak;\ncase LTR390_GAIN_18:\nSerial.println(18);\nbreak;\ndefault:\nSerial.println(\"Failed to set gain\");\nbreak;\n}\nltr.setResolution(LTR390_RESOLUTION_16BIT);\nSerial.print(\"Integration Time (ms): \");\nswitch (ltr.getResolution())\n{\ncase LTR390_RESOLUTION_13BIT:\nSerial.println(13);\nbreak;\ncase LTR390_RESOLUTION_16BIT:\nSerial.println(16);\nbreak;\ncase LTR390_RESOLUTION_17BIT:\nSerial.println(17);\nbreak;\ncase LTR390_RESOLUTION_18BIT:\nSerial.println(18);\nbreak;\ncase LTR390_RESOLUTION_19BIT:\nSerial.println(19);\nbreak;\ncase LTR390_RESOLUTION_20BIT:\nSerial.println(20);\nbreak;\ndefault:\nSerial.println(\"Failed to set Integration Time\");\nbreak;\n}\n\nltr.setThresholds(100, 1000); //Set the interrupt output threshold range for lower and upper.\n\nltr.configInterrupt(true, LTR390_MODE_UVS);\n\n// For RAK14003\nmcp.begin_I2C(0x24);\n\n// Added for the functionality of RAK14003\n\nWire.begin();    // initialize I2C serial bus\n\n// Configuration of MCP23017 I/O ports\nmcp.pinMode(LED_0, OUTPUT);     // Red LED; Top most\nmcp.pinMode(LED_1, OUTPUT);     // Red LED\nmcp.pinMode(LED_2, OUTPUT);     // Orange LED\nmcp.pinMode(LED_3, OUTPUT);     // Orange LED\nmcp.pinMode(LED_4, OUTPUT);     // Orange LED\nmcp.pinMode(LED_5, OUTPUT);     // Green LED\nmcp.pinMode(LED_6, OUTPUT);     // Green LED\nmcp.pinMode(LED_7, OUTPUT);     // Green LED\nmcp.pinMode(LED_8, OUTPUT);     // Green LED\nmcp.pinMode(LED_9, OUTPUT);     // Green LED; Bottom\n\n// Initially Turn OFF all LEDs\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, HIGH);\n\n}\n\nvoid loop() {\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\n// Trial # 1\n// Data from RAK12019\nif (ltr.newDataAvailable())\n{\nuvi = ltr.getUVI();\nuvs = ltr.readUVS();\n}\n\n// Data from RAK12010\nlux = VMEL.readLux();\nwhite = VMEL.readWhite();\nraw_als = VMEL.readALS();\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\n\n// From RAK12019 module\nSerial.print(\"UVI: \");\nSerial.println(uvi);          // Uvi data from RAK12019\nSerial.print(\"UVS: \");\nSerial.println(uvs);            // Uvs data from RAK12019\n\n// From RAK12010\nSerial.print(\"Lux: \");\nSerial.print(lux);\nSerial.println(\" lx \");\nSerial.print(\"White: \");\nSerial.println(white);\nSerial.print(\"Raw ALS: \");\nSerial.println(raw_als);\n\n// Result of uvi to be displayed via RAK14003 module\nif (uvi <= 0.4)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, HIGH);\n}\n\nelse if (uvi > 0.5 && uvi <= 1)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 1.5 && uvi <= 2)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 2.5 && uvi <= 3)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 3.5 && uvi <= 4)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 4.5 && uvi <= 5)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 5.5 && uvi <= 6)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 6.5 && uvi <= 7)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 7.5 && uvi <= 8)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 8.5 && uvi <= 9.5)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, LOW);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi >= 10)\n{\nmcp.digitalWrite(LED_0, LOW);\nmcp.digitalWrite(LED_1, LOW);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\ndelay(10000);\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void) {\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void) {\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data) {\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class) {\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void) {\nif (lmh_join_status_get() != LMH_SET) {\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\ndata = \" Uvi Data: \" + String(uvi) + \" Uvs Data: \" + String(uvs) + \" Lux Data: \" + String(lux) + \" lx \" ;\n\nSerial.println(data);\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\nuint16_t uvi_data = uvi;            // Uvi data from RAK12019\nuint32_t uvs_data = uvs;            // Uvs data from RAK12019\nuint32_t lux_data = lux;            // Lux data from RAK12010\n\nm_lora_app_data.buffer[i++] = 0x01;  // byte[0]\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\n// Data from RAK12019 module\nm_lora_app_data.buffer[i++] = (uint8_t)((uvi_data & 0x0000FF00) >> 8);     // byte[1]\nm_lora_app_data.buffer[i++] = (uint8_t)(uvi_data & 0x000000FF);            // byte[2]\n\n// Data from RAK12019 module\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0xFF000000) >> 24);    // byte[3]\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0x00FF0000) >> 16);    // byte[4]\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0x0000FF00) >> 8);     // byte[5]\nm_lora_app_data.buffer[i++] = (uint8_t)(uvs_data & 0x000000FF);            // byte[6]\n\n// Data from RAK12010 module\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0xFF000000) >> 24);    // byte[7]\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0x00FF0000) >> 16);    // byte[8]\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0x0000FF00) >> 8);     // byte[9]\nm_lora_app_data.buffer[i++] = (uint8_t)(lux_data & 0x000000FF);            // byte[10]\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS) {\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n} else {\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xE9, 0x0D, 0x28, 0x1D, 0x92, 0x3D, 0xE4, 0x9F, 0xD9, 0xF7, 0xE0, 0x5F, 0x39, 0x10, 0x55, 0x71 };\n\n```  \n> **Image:** OTAA device successfully registered to TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "74bb32101fddf954e2abd05d695cad5b", "product_family": "wisblock", "product_id": "kit6-light-and-color", "category": "How-To", "title": "WisBlock IoT Education Kit - Light & Color Quick Start Guide > WisBlock IoT Education Kit - Light & Color Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock IoT Education Kit - Light & Color using TTN and Qubitro > UV Index & UV Intensity Monitoring LoRaWAN Application > LoRaWAN Code for UV Index & UV Intensity Monitoring > Programming UV Index & UV Intensity Monitoring Device with Arduino IDE [CODE]", "content": "else if (uvi > 3.5 && uvi <= 4)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}", "keywords": ["Arduino IDE", "RAK4631", "UV Index", "UV Intensity", "LoRaWAN", "SX126x-Arduino"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **UV Index & UV Intensity Monitoring** device. Just copy the code below for **UV Index & UV Intensity Monitoring LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the example </summary>  \n```c\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h>  //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n#include \"UVlight_LTR390.h\"                // http://librarymanager/All#RAK12019_LTR390\nUVlight_LTR390 ltr = UVlight_LTR390();\n\n#include \"Light_VEML7700.h\"                // http://librarymanager/All#Light_veml7700\nLight_VEML7700 VMEL = Light_VEML7700();\n\nuint16_t uvi;\nuint32_t uvs;\nuint32_t lux;\nuint32_t white;\nuint32_t raw_als;\n\n#include <Adafruit_MCP23X17.h>  //http://librarymanager/All#Adafruit_MCP23017\nAdafruit_MCP23X17 mcp;\n\n// Added definitions for the functionality of RAK14003\nconst uint8_t LED_0 = 0;      // PA0 (17) of MCP23017\nconst uint8_t LED_1 = 1;      // PA1 (18) of MCP23017\nconst uint8_t LED_2 = 2;      // PA2 (19) of MCP23017\nconst uint8_t LED_3 = 3;      // PA3 (20) of MCP23017\nconst uint8_t LED_4 = 4;      // PA4 (21) of MCP23017\nconst uint8_t LED_5 = 5;      // PA5 (22) of MCP23017\nconst uint8_t LED_6 = 6;      // PA6 (23) of MCP23017\nconst uint8_t LED_7 = 7;      // PA7 (24) of MCP23017\nconst uint8_t LED_8 = 8;      // PB0 (25) of MCP23017\nconst uint8_t LED_9 = 9;      // PB1 (26) of MCP23017\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define RAK4631_BOARD true\n#else\n#define RAK4631_BOARD false\n#endif\n\nbool doOTAA = true;                                               // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                                       /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                                     /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5                               /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                                        /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;                           /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;                 /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                              /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = { LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF };\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = { BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler };\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xE9, 0x0D, 0x28, 0x1D, 0x92, 0x3D, 0xE4, 0x9F, 0xD9, 0xF7, 0xE0, 0x5F, 0x39, 0x10, 0x55, 0x71 };\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };\nuint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                                            /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];               //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = { m_lora_app_data_buffer, 0, 0, 0, 0 };  //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {\n\n// Initialize Serial for debug output\npinMode(LED_BLUE, OUTPUT);\ndigitalWrite(LED_BLUE, HIGH);\n\n// Sensor Power Switch\npinMode(WB_IO2, OUTPUT);\ndigitalWrite(WB_IO2, HIGH);\n\n// Reset RAK14003 module\npinMode(WB_IO4, OUTPUT);\ndigitalWrite(WB_IO4, HIGH);\ndelay(10);\ndigitalWrite(WB_IO4, LOW);\ndelay(10);\ndigitalWrite(WB_IO4, HIGH);\ndelay(10);\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial) {\nif ((millis() - timeout) < 5000) {\ndelay(100);\n} else {\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA) {\nSerial.println(\"Type: OTAA\");\n} else {\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion) {\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA) {\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n} else {\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0) {\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"================================\");\nSerial.println(\"RAK12019 + RAK12010 LoRaWAN Code\");\nSerial.println(\"================================\");\n\nif (!VMEL.begin())\n{\nSerial.println(\"Sensor not found\");\nwhile (1);\n}\n\nVMEL.setGain(VEML7700_GAIN_1);\nVMEL.setIntegrationTime(VEML7700_IT_800MS);\n\nSerial.print(F(\"Gain: \"));\nswitch (VMEL.getGain())\n{\ncase VEML7700_GAIN_1: Serial.println(\"1\"); break;\ncase VEML7700_GAIN_2: Serial.println(\"2\"); break;\ncase VEML7700_GAIN_1_4: Serial.println(\"1/4\"); break;\ncase VEML7700_GAIN_1_8: Serial.println(\"1/8\"); break;\n}\n\nSerial.print(F(\"Integration Time (ms): \"));\nswitch (VMEL.getIntegrationTime())\n{\ncase VEML7700_IT_25MS: Serial.println(\"25\"); break;\ncase VEML7700_IT_50MS: Serial.println(\"50\"); break;\ncase VEML7700_IT_100MS: Serial.println(\"100\"); break;\ncase VEML7700_IT_200MS: Serial.println(\"200\"); break;\ncase VEML7700_IT_400MS: Serial.println(\"400\"); break;\ncase VEML7700_IT_800MS: Serial.println(\"800\"); break;\n}\n\nSerial.println(\"RAK12019 test\");\nWire.begin();\nif (!ltr.init())\n{\nSerial.println(\"Couldn't find LTR sensor!\");\nwhile (1)\ndelay(10);\n}\nSerial.println(\"Found LTR390 sensor!\");\n\n//set to LTR390_MODE_UVS,get ultraviolet light data.\nltr.setMode(LTR390_MODE_UVS);  // UVS Mode\n\nSerial.println(\"In UVS mode\");\n\nltr.setGain(LTR390_GAIN_3);\nSerial.print(\"Gain : \");\nswitch (ltr.getGain())\n{\ncase LTR390_GAIN_1:\nSerial.println(1);\nbreak;\ncase LTR390_GAIN_3:\nSerial.println(3);\nbreak;\ncase LTR390_GAIN_6:\nSerial.println(6);\nbreak;\ncase LTR390_GAIN_9:\nSerial.println(9);\nbreak;\ncase LTR390_GAIN_18:\nSerial.println(18);\nbreak;\ndefault:\nSerial.println(\"Failed to set gain\");\nbreak;\n}\nltr.setResolution(LTR390_RESOLUTION_16BIT);\nSerial.print(\"Integration Time (ms): \");\nswitch (ltr.getResolution())\n{\ncase LTR390_RESOLUTION_13BIT:\nSerial.println(13);\nbreak;\ncase LTR390_RESOLUTION_16BIT:\nSerial.println(16);\nbreak;\ncase LTR390_RESOLUTION_17BIT:\nSerial.println(17);\nbreak;\ncase LTR390_RESOLUTION_18BIT:\nSerial.println(18);\nbreak;\ncase LTR390_RESOLUTION_19BIT:\nSerial.println(19);\nbreak;\ncase LTR390_RESOLUTION_20BIT:\nSerial.println(20);\nbreak;\ndefault:\nSerial.println(\"Failed to set Integration Time\");\nbreak;\n}\n\nltr.setThresholds(100, 1000); //Set the interrupt output threshold range for lower and upper.\n\nltr.configInterrupt(true, LTR390_MODE_UVS);\n\n// For RAK14003\nmcp.begin_I2C(0x24);\n\n// Added for the functionality of RAK14003\n\nWire.begin();    // initialize I2C serial bus\n\n// Configuration of MCP23017 I/O ports\nmcp.pinMode(LED_0, OUTPUT);     // Red LED; Top most\nmcp.pinMode(LED_1, OUTPUT);     // Red LED\nmcp.pinMode(LED_2, OUTPUT);     // Orange LED\nmcp.pinMode(LED_3, OUTPUT);     // Orange LED\nmcp.pinMode(LED_4, OUTPUT);     // Orange LED\nmcp.pinMode(LED_5, OUTPUT);     // Green LED\nmcp.pinMode(LED_6, OUTPUT);     // Green LED\nmcp.pinMode(LED_7, OUTPUT);     // Green LED\nmcp.pinMode(LED_8, OUTPUT);     // Green LED\nmcp.pinMode(LED_9, OUTPUT);     // Green LED; Bottom\n\n// Initially Turn OFF all LEDs\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, HIGH);\n\n}\n\nvoid loop() {\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\n// Trial # 1\n// Data from RAK12019\nif (ltr.newDataAvailable())\n{\nuvi = ltr.getUVI();\nuvs = ltr.readUVS();\n}\n\n// Data from RAK12010\nlux = VMEL.readLux();\nwhite = VMEL.readWhite();\nraw_als = VMEL.readALS();\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\n\n// From RAK12019 module\nSerial.print(\"UVI: \");\nSerial.println(uvi);          // Uvi data from RAK12019\nSerial.print(\"UVS: \");\nSerial.println(uvs);            // Uvs data from RAK12019\n\n// From RAK12010\nSerial.print(\"Lux: \");\nSerial.print(lux);\nSerial.println(\" lx \");\nSerial.print(\"White: \");\nSerial.println(white);\nSerial.print(\"Raw ALS: \");\nSerial.println(raw_als);\n\n// Result of uvi to be displayed via RAK14003 module\nif (uvi <= 0.4)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, HIGH);\n}\n\nelse if (uvi > 0.5 && uvi <= 1)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 1.5 && uvi <= 2)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 2.5 && uvi <= 3)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 3.5 && uvi <= 4)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 4.5 && uvi <= 5)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 5.5 && uvi <= 6)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 6.5 && uvi <= 7)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 7.5 && uvi <= 8)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 8.5 && uvi <= 9.5)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, LOW);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi >= 10)\n{\nmcp.digitalWrite(LED_0, LOW);\nmcp.digitalWrite(LED_1, LOW);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\ndelay(10000);\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void) {\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void) {\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data) {\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class) {\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void) {\nif (lmh_join_status_get() != LMH_SET) {\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\ndata = \" Uvi Data: \" + String(uvi) + \" Uvs Data: \" + String(uvs) + \" Lux Data: \" + String(lux) + \" lx \" ;\n\nSerial.println(data);\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\nuint16_t uvi_data = uvi;            // Uvi data from RAK12019\nuint32_t uvs_data = uvs;            // Uvs data from RAK12019\nuint32_t lux_data = lux;            // Lux data from RAK12010\n\nm_lora_app_data.buffer[i++] = 0x01;  // byte[0]\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\n// Data from RAK12019 module\nm_lora_app_data.buffer[i++] = (uint8_t)((uvi_data & 0x0000FF00) >> 8);     // byte[1]\nm_lora_app_data.buffer[i++] = (uint8_t)(uvi_data & 0x000000FF);            // byte[2]\n\n// Data from RAK12019 module\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0xFF000000) >> 24);    // byte[3]\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0x00FF0000) >> 16);    // byte[4]\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0x0000FF00) >> 8);     // byte[5]\nm_lora_app_data.buffer[i++] = (uint8_t)(uvs_data & 0x000000FF);            // byte[6]\n\n// Data from RAK12010 module\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0xFF000000) >> 24);    // byte[7]\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0x00FF0000) >> 16);    // byte[8]\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0x0000FF00) >> 8);     // byte[9]\nm_lora_app_data.buffer[i++] = (uint8_t)(lux_data & 0x000000FF);            // byte[10]\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS) {\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n} else {\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xE9, 0x0D, 0x28, 0x1D, 0x92, 0x3D, 0xE4, 0x9F, 0xD9, 0xF7, 0xE0, 0x5F, 0x39, 0x10, 0x55, 0x71 };\n\n```  \n> **Image:** OTAA device successfully registered to TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "ff34500e132e6f03c2871f6307460a0b", "product_family": "wisblock", "product_id": "kit6-light-and-color", "category": "How-To", "title": "WisBlock IoT Education Kit - Light & Color Quick Start Guide > WisBlock IoT Education Kit - Light & Color Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock IoT Education Kit - Light & Color using TTN and Qubitro > UV Index & UV Intensity Monitoring LoRaWAN Application > LoRaWAN Code for UV Index & UV Intensity Monitoring > Programming UV Index & UV Intensity Monitoring Device with Arduino IDE [CODE]", "content": "else if (uvi > 4.5 && uvi <= 5)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}", "keywords": ["Arduino IDE", "RAK4631", "UV Index", "UV Intensity", "LoRaWAN", "SX126x-Arduino"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **UV Index & UV Intensity Monitoring** device. Just copy the code below for **UV Index & UV Intensity Monitoring LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the example </summary>  \n```c\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h>  //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n#include \"UVlight_LTR390.h\"                // http://librarymanager/All#RAK12019_LTR390\nUVlight_LTR390 ltr = UVlight_LTR390();\n\n#include \"Light_VEML7700.h\"                // http://librarymanager/All#Light_veml7700\nLight_VEML7700 VMEL = Light_VEML7700();\n\nuint16_t uvi;\nuint32_t uvs;\nuint32_t lux;\nuint32_t white;\nuint32_t raw_als;\n\n#include <Adafruit_MCP23X17.h>  //http://librarymanager/All#Adafruit_MCP23017\nAdafruit_MCP23X17 mcp;\n\n// Added definitions for the functionality of RAK14003\nconst uint8_t LED_0 = 0;      // PA0 (17) of MCP23017\nconst uint8_t LED_1 = 1;      // PA1 (18) of MCP23017\nconst uint8_t LED_2 = 2;      // PA2 (19) of MCP23017\nconst uint8_t LED_3 = 3;      // PA3 (20) of MCP23017\nconst uint8_t LED_4 = 4;      // PA4 (21) of MCP23017\nconst uint8_t LED_5 = 5;      // PA5 (22) of MCP23017\nconst uint8_t LED_6 = 6;      // PA6 (23) of MCP23017\nconst uint8_t LED_7 = 7;      // PA7 (24) of MCP23017\nconst uint8_t LED_8 = 8;      // PB0 (25) of MCP23017\nconst uint8_t LED_9 = 9;      // PB1 (26) of MCP23017\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define RAK4631_BOARD true\n#else\n#define RAK4631_BOARD false\n#endif\n\nbool doOTAA = true;                                               // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                                       /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                                     /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5                               /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                                        /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;                           /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;                 /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                              /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = { LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF };\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = { BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler };\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xE9, 0x0D, 0x28, 0x1D, 0x92, 0x3D, 0xE4, 0x9F, 0xD9, 0xF7, 0xE0, 0x5F, 0x39, 0x10, 0x55, 0x71 };\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };\nuint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                                            /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];               //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = { m_lora_app_data_buffer, 0, 0, 0, 0 };  //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {\n\n// Initialize Serial for debug output\npinMode(LED_BLUE, OUTPUT);\ndigitalWrite(LED_BLUE, HIGH);\n\n// Sensor Power Switch\npinMode(WB_IO2, OUTPUT);\ndigitalWrite(WB_IO2, HIGH);\n\n// Reset RAK14003 module\npinMode(WB_IO4, OUTPUT);\ndigitalWrite(WB_IO4, HIGH);\ndelay(10);\ndigitalWrite(WB_IO4, LOW);\ndelay(10);\ndigitalWrite(WB_IO4, HIGH);\ndelay(10);\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial) {\nif ((millis() - timeout) < 5000) {\ndelay(100);\n} else {\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA) {\nSerial.println(\"Type: OTAA\");\n} else {\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion) {\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA) {\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n} else {\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0) {\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"================================\");\nSerial.println(\"RAK12019 + RAK12010 LoRaWAN Code\");\nSerial.println(\"================================\");\n\nif (!VMEL.begin())\n{\nSerial.println(\"Sensor not found\");\nwhile (1);\n}\n\nVMEL.setGain(VEML7700_GAIN_1);\nVMEL.setIntegrationTime(VEML7700_IT_800MS);\n\nSerial.print(F(\"Gain: \"));\nswitch (VMEL.getGain())\n{\ncase VEML7700_GAIN_1: Serial.println(\"1\"); break;\ncase VEML7700_GAIN_2: Serial.println(\"2\"); break;\ncase VEML7700_GAIN_1_4: Serial.println(\"1/4\"); break;\ncase VEML7700_GAIN_1_8: Serial.println(\"1/8\"); break;\n}\n\nSerial.print(F(\"Integration Time (ms): \"));\nswitch (VMEL.getIntegrationTime())\n{\ncase VEML7700_IT_25MS: Serial.println(\"25\"); break;\ncase VEML7700_IT_50MS: Serial.println(\"50\"); break;\ncase VEML7700_IT_100MS: Serial.println(\"100\"); break;\ncase VEML7700_IT_200MS: Serial.println(\"200\"); break;\ncase VEML7700_IT_400MS: Serial.println(\"400\"); break;\ncase VEML7700_IT_800MS: Serial.println(\"800\"); break;\n}\n\nSerial.println(\"RAK12019 test\");\nWire.begin();\nif (!ltr.init())\n{\nSerial.println(\"Couldn't find LTR sensor!\");\nwhile (1)\ndelay(10);\n}\nSerial.println(\"Found LTR390 sensor!\");\n\n//set to LTR390_MODE_UVS,get ultraviolet light data.\nltr.setMode(LTR390_MODE_UVS);  // UVS Mode\n\nSerial.println(\"In UVS mode\");\n\nltr.setGain(LTR390_GAIN_3);\nSerial.print(\"Gain : \");\nswitch (ltr.getGain())\n{\ncase LTR390_GAIN_1:\nSerial.println(1);\nbreak;\ncase LTR390_GAIN_3:\nSerial.println(3);\nbreak;\ncase LTR390_GAIN_6:\nSerial.println(6);\nbreak;\ncase LTR390_GAIN_9:\nSerial.println(9);\nbreak;\ncase LTR390_GAIN_18:\nSerial.println(18);\nbreak;\ndefault:\nSerial.println(\"Failed to set gain\");\nbreak;\n}\nltr.setResolution(LTR390_RESOLUTION_16BIT);\nSerial.print(\"Integration Time (ms): \");\nswitch (ltr.getResolution())\n{\ncase LTR390_RESOLUTION_13BIT:\nSerial.println(13);\nbreak;\ncase LTR390_RESOLUTION_16BIT:\nSerial.println(16);\nbreak;\ncase LTR390_RESOLUTION_17BIT:\nSerial.println(17);\nbreak;\ncase LTR390_RESOLUTION_18BIT:\nSerial.println(18);\nbreak;\ncase LTR390_RESOLUTION_19BIT:\nSerial.println(19);\nbreak;\ncase LTR390_RESOLUTION_20BIT:\nSerial.println(20);\nbreak;\ndefault:\nSerial.println(\"Failed to set Integration Time\");\nbreak;\n}\n\nltr.setThresholds(100, 1000); //Set the interrupt output threshold range for lower and upper.\n\nltr.configInterrupt(true, LTR390_MODE_UVS);\n\n// For RAK14003\nmcp.begin_I2C(0x24);\n\n// Added for the functionality of RAK14003\n\nWire.begin();    // initialize I2C serial bus\n\n// Configuration of MCP23017 I/O ports\nmcp.pinMode(LED_0, OUTPUT);     // Red LED; Top most\nmcp.pinMode(LED_1, OUTPUT);     // Red LED\nmcp.pinMode(LED_2, OUTPUT);     // Orange LED\nmcp.pinMode(LED_3, OUTPUT);     // Orange LED\nmcp.pinMode(LED_4, OUTPUT);     // Orange LED\nmcp.pinMode(LED_5, OUTPUT);     // Green LED\nmcp.pinMode(LED_6, OUTPUT);     // Green LED\nmcp.pinMode(LED_7, OUTPUT);     // Green LED\nmcp.pinMode(LED_8, OUTPUT);     // Green LED\nmcp.pinMode(LED_9, OUTPUT);     // Green LED; Bottom\n\n// Initially Turn OFF all LEDs\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, HIGH);\n\n}\n\nvoid loop() {\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\n// Trial # 1\n// Data from RAK12019\nif (ltr.newDataAvailable())\n{\nuvi = ltr.getUVI();\nuvs = ltr.readUVS();\n}\n\n// Data from RAK12010\nlux = VMEL.readLux();\nwhite = VMEL.readWhite();\nraw_als = VMEL.readALS();\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\n\n// From RAK12019 module\nSerial.print(\"UVI: \");\nSerial.println(uvi);          // Uvi data from RAK12019\nSerial.print(\"UVS: \");\nSerial.println(uvs);            // Uvs data from RAK12019\n\n// From RAK12010\nSerial.print(\"Lux: \");\nSerial.print(lux);\nSerial.println(\" lx \");\nSerial.print(\"White: \");\nSerial.println(white);\nSerial.print(\"Raw ALS: \");\nSerial.println(raw_als);\n\n// Result of uvi to be displayed via RAK14003 module\nif (uvi <= 0.4)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, HIGH);\n}\n\nelse if (uvi > 0.5 && uvi <= 1)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 1.5 && uvi <= 2)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 2.5 && uvi <= 3)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 3.5 && uvi <= 4)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 4.5 && uvi <= 5)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 5.5 && uvi <= 6)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 6.5 && uvi <= 7)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 7.5 && uvi <= 8)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 8.5 && uvi <= 9.5)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, LOW);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi >= 10)\n{\nmcp.digitalWrite(LED_0, LOW);\nmcp.digitalWrite(LED_1, LOW);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\ndelay(10000);\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void) {\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void) {\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data) {\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class) {\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void) {\nif (lmh_join_status_get() != LMH_SET) {\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\ndata = \" Uvi Data: \" + String(uvi) + \" Uvs Data: \" + String(uvs) + \" Lux Data: \" + String(lux) + \" lx \" ;\n\nSerial.println(data);\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\nuint16_t uvi_data = uvi;            // Uvi data from RAK12019\nuint32_t uvs_data = uvs;            // Uvs data from RAK12019\nuint32_t lux_data = lux;            // Lux data from RAK12010\n\nm_lora_app_data.buffer[i++] = 0x01;  // byte[0]\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\n// Data from RAK12019 module\nm_lora_app_data.buffer[i++] = (uint8_t)((uvi_data & 0x0000FF00) >> 8);     // byte[1]\nm_lora_app_data.buffer[i++] = (uint8_t)(uvi_data & 0x000000FF);            // byte[2]\n\n// Data from RAK12019 module\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0xFF000000) >> 24);    // byte[3]\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0x00FF0000) >> 16);    // byte[4]\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0x0000FF00) >> 8);     // byte[5]\nm_lora_app_data.buffer[i++] = (uint8_t)(uvs_data & 0x000000FF);            // byte[6]\n\n// Data from RAK12010 module\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0xFF000000) >> 24);    // byte[7]\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0x00FF0000) >> 16);    // byte[8]\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0x0000FF00) >> 8);     // byte[9]\nm_lora_app_data.buffer[i++] = (uint8_t)(lux_data & 0x000000FF);            // byte[10]\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS) {\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n} else {\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xE9, 0x0D, 0x28, 0x1D, 0x92, 0x3D, 0xE4, 0x9F, 0xD9, 0xF7, 0xE0, 0x5F, 0x39, 0x10, 0x55, 0x71 };\n\n```  \n> **Image:** OTAA device successfully registered to TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "c6c89de63563b0062cbcf0ed79b7a71a", "product_family": "wisblock", "product_id": "kit6-light-and-color", "category": "How-To", "title": "WisBlock IoT Education Kit - Light & Color Quick Start Guide > WisBlock IoT Education Kit - Light & Color Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock IoT Education Kit - Light & Color using TTN and Qubitro > UV Index & UV Intensity Monitoring LoRaWAN Application > LoRaWAN Code for UV Index & UV Intensity Monitoring > Programming UV Index & UV Intensity Monitoring Device with Arduino IDE [CODE]", "content": "else if (uvi > 5.5 && uvi <= 6)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}", "keywords": ["Arduino IDE", "RAK4631", "UV Index", "UV Intensity", "LoRaWAN", "SX126x-Arduino"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **UV Index & UV Intensity Monitoring** device. Just copy the code below for **UV Index & UV Intensity Monitoring LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the example </summary>  \n```c\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h>  //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n#include \"UVlight_LTR390.h\"                // http://librarymanager/All#RAK12019_LTR390\nUVlight_LTR390 ltr = UVlight_LTR390();\n\n#include \"Light_VEML7700.h\"                // http://librarymanager/All#Light_veml7700\nLight_VEML7700 VMEL = Light_VEML7700();\n\nuint16_t uvi;\nuint32_t uvs;\nuint32_t lux;\nuint32_t white;\nuint32_t raw_als;\n\n#include <Adafruit_MCP23X17.h>  //http://librarymanager/All#Adafruit_MCP23017\nAdafruit_MCP23X17 mcp;\n\n// Added definitions for the functionality of RAK14003\nconst uint8_t LED_0 = 0;      // PA0 (17) of MCP23017\nconst uint8_t LED_1 = 1;      // PA1 (18) of MCP23017\nconst uint8_t LED_2 = 2;      // PA2 (19) of MCP23017\nconst uint8_t LED_3 = 3;      // PA3 (20) of MCP23017\nconst uint8_t LED_4 = 4;      // PA4 (21) of MCP23017\nconst uint8_t LED_5 = 5;      // PA5 (22) of MCP23017\nconst uint8_t LED_6 = 6;      // PA6 (23) of MCP23017\nconst uint8_t LED_7 = 7;      // PA7 (24) of MCP23017\nconst uint8_t LED_8 = 8;      // PB0 (25) of MCP23017\nconst uint8_t LED_9 = 9;      // PB1 (26) of MCP23017\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define RAK4631_BOARD true\n#else\n#define RAK4631_BOARD false\n#endif\n\nbool doOTAA = true;                                               // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                                       /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                                     /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5                               /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                                        /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;                           /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;                 /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                              /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = { LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF };\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = { BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler };\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xE9, 0x0D, 0x28, 0x1D, 0x92, 0x3D, 0xE4, 0x9F, 0xD9, 0xF7, 0xE0, 0x5F, 0x39, 0x10, 0x55, 0x71 };\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };\nuint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                                            /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];               //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = { m_lora_app_data_buffer, 0, 0, 0, 0 };  //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {\n\n// Initialize Serial for debug output\npinMode(LED_BLUE, OUTPUT);\ndigitalWrite(LED_BLUE, HIGH);\n\n// Sensor Power Switch\npinMode(WB_IO2, OUTPUT);\ndigitalWrite(WB_IO2, HIGH);\n\n// Reset RAK14003 module\npinMode(WB_IO4, OUTPUT);\ndigitalWrite(WB_IO4, HIGH);\ndelay(10);\ndigitalWrite(WB_IO4, LOW);\ndelay(10);\ndigitalWrite(WB_IO4, HIGH);\ndelay(10);\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial) {\nif ((millis() - timeout) < 5000) {\ndelay(100);\n} else {\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA) {\nSerial.println(\"Type: OTAA\");\n} else {\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion) {\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA) {\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n} else {\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0) {\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"================================\");\nSerial.println(\"RAK12019 + RAK12010 LoRaWAN Code\");\nSerial.println(\"================================\");\n\nif (!VMEL.begin())\n{\nSerial.println(\"Sensor not found\");\nwhile (1);\n}\n\nVMEL.setGain(VEML7700_GAIN_1);\nVMEL.setIntegrationTime(VEML7700_IT_800MS);\n\nSerial.print(F(\"Gain: \"));\nswitch (VMEL.getGain())\n{\ncase VEML7700_GAIN_1: Serial.println(\"1\"); break;\ncase VEML7700_GAIN_2: Serial.println(\"2\"); break;\ncase VEML7700_GAIN_1_4: Serial.println(\"1/4\"); break;\ncase VEML7700_GAIN_1_8: Serial.println(\"1/8\"); break;\n}\n\nSerial.print(F(\"Integration Time (ms): \"));\nswitch (VMEL.getIntegrationTime())\n{\ncase VEML7700_IT_25MS: Serial.println(\"25\"); break;\ncase VEML7700_IT_50MS: Serial.println(\"50\"); break;\ncase VEML7700_IT_100MS: Serial.println(\"100\"); break;\ncase VEML7700_IT_200MS: Serial.println(\"200\"); break;\ncase VEML7700_IT_400MS: Serial.println(\"400\"); break;\ncase VEML7700_IT_800MS: Serial.println(\"800\"); break;\n}\n\nSerial.println(\"RAK12019 test\");\nWire.begin();\nif (!ltr.init())\n{\nSerial.println(\"Couldn't find LTR sensor!\");\nwhile (1)\ndelay(10);\n}\nSerial.println(\"Found LTR390 sensor!\");\n\n//set to LTR390_MODE_UVS,get ultraviolet light data.\nltr.setMode(LTR390_MODE_UVS);  // UVS Mode\n\nSerial.println(\"In UVS mode\");\n\nltr.setGain(LTR390_GAIN_3);\nSerial.print(\"Gain : \");\nswitch (ltr.getGain())\n{\ncase LTR390_GAIN_1:\nSerial.println(1);\nbreak;\ncase LTR390_GAIN_3:\nSerial.println(3);\nbreak;\ncase LTR390_GAIN_6:\nSerial.println(6);\nbreak;\ncase LTR390_GAIN_9:\nSerial.println(9);\nbreak;\ncase LTR390_GAIN_18:\nSerial.println(18);\nbreak;\ndefault:\nSerial.println(\"Failed to set gain\");\nbreak;\n}\nltr.setResolution(LTR390_RESOLUTION_16BIT);\nSerial.print(\"Integration Time (ms): \");\nswitch (ltr.getResolution())\n{\ncase LTR390_RESOLUTION_13BIT:\nSerial.println(13);\nbreak;\ncase LTR390_RESOLUTION_16BIT:\nSerial.println(16);\nbreak;\ncase LTR390_RESOLUTION_17BIT:\nSerial.println(17);\nbreak;\ncase LTR390_RESOLUTION_18BIT:\nSerial.println(18);\nbreak;\ncase LTR390_RESOLUTION_19BIT:\nSerial.println(19);\nbreak;\ncase LTR390_RESOLUTION_20BIT:\nSerial.println(20);\nbreak;\ndefault:\nSerial.println(\"Failed to set Integration Time\");\nbreak;\n}\n\nltr.setThresholds(100, 1000); //Set the interrupt output threshold range for lower and upper.\n\nltr.configInterrupt(true, LTR390_MODE_UVS);\n\n// For RAK14003\nmcp.begin_I2C(0x24);\n\n// Added for the functionality of RAK14003\n\nWire.begin();    // initialize I2C serial bus\n\n// Configuration of MCP23017 I/O ports\nmcp.pinMode(LED_0, OUTPUT);     // Red LED; Top most\nmcp.pinMode(LED_1, OUTPUT);     // Red LED\nmcp.pinMode(LED_2, OUTPUT);     // Orange LED\nmcp.pinMode(LED_3, OUTPUT);     // Orange LED\nmcp.pinMode(LED_4, OUTPUT);     // Orange LED\nmcp.pinMode(LED_5, OUTPUT);     // Green LED\nmcp.pinMode(LED_6, OUTPUT);     // Green LED\nmcp.pinMode(LED_7, OUTPUT);     // Green LED\nmcp.pinMode(LED_8, OUTPUT);     // Green LED\nmcp.pinMode(LED_9, OUTPUT);     // Green LED; Bottom\n\n// Initially Turn OFF all LEDs\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, HIGH);\n\n}\n\nvoid loop() {\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\n// Trial # 1\n// Data from RAK12019\nif (ltr.newDataAvailable())\n{\nuvi = ltr.getUVI();\nuvs = ltr.readUVS();\n}\n\n// Data from RAK12010\nlux = VMEL.readLux();\nwhite = VMEL.readWhite();\nraw_als = VMEL.readALS();\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\n\n// From RAK12019 module\nSerial.print(\"UVI: \");\nSerial.println(uvi);          // Uvi data from RAK12019\nSerial.print(\"UVS: \");\nSerial.println(uvs);            // Uvs data from RAK12019\n\n// From RAK12010\nSerial.print(\"Lux: \");\nSerial.print(lux);\nSerial.println(\" lx \");\nSerial.print(\"White: \");\nSerial.println(white);\nSerial.print(\"Raw ALS: \");\nSerial.println(raw_als);\n\n// Result of uvi to be displayed via RAK14003 module\nif (uvi <= 0.4)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, HIGH);\n}\n\nelse if (uvi > 0.5 && uvi <= 1)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 1.5 && uvi <= 2)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 2.5 && uvi <= 3)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 3.5 && uvi <= 4)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 4.5 && uvi <= 5)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 5.5 && uvi <= 6)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 6.5 && uvi <= 7)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 7.5 && uvi <= 8)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 8.5 && uvi <= 9.5)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, LOW);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi >= 10)\n{\nmcp.digitalWrite(LED_0, LOW);\nmcp.digitalWrite(LED_1, LOW);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\ndelay(10000);\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void) {\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void) {\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data) {\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class) {\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void) {\nif (lmh_join_status_get() != LMH_SET) {\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\ndata = \" Uvi Data: \" + String(uvi) + \" Uvs Data: \" + String(uvs) + \" Lux Data: \" + String(lux) + \" lx \" ;\n\nSerial.println(data);\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\nuint16_t uvi_data = uvi;            // Uvi data from RAK12019\nuint32_t uvs_data = uvs;            // Uvs data from RAK12019\nuint32_t lux_data = lux;            // Lux data from RAK12010\n\nm_lora_app_data.buffer[i++] = 0x01;  // byte[0]\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\n// Data from RAK12019 module\nm_lora_app_data.buffer[i++] = (uint8_t)((uvi_data & 0x0000FF00) >> 8);     // byte[1]\nm_lora_app_data.buffer[i++] = (uint8_t)(uvi_data & 0x000000FF);            // byte[2]\n\n// Data from RAK12019 module\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0xFF000000) >> 24);    // byte[3]\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0x00FF0000) >> 16);    // byte[4]\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0x0000FF00) >> 8);     // byte[5]\nm_lora_app_data.buffer[i++] = (uint8_t)(uvs_data & 0x000000FF);            // byte[6]\n\n// Data from RAK12010 module\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0xFF000000) >> 24);    // byte[7]\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0x00FF0000) >> 16);    // byte[8]\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0x0000FF00) >> 8);     // byte[9]\nm_lora_app_data.buffer[i++] = (uint8_t)(lux_data & 0x000000FF);            // byte[10]\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS) {\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n} else {\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xE9, 0x0D, 0x28, 0x1D, 0x92, 0x3D, 0xE4, 0x9F, 0xD9, 0xF7, 0xE0, 0x5F, 0x39, 0x10, 0x55, 0x71 };\n\n```  \n> **Image:** OTAA device successfully registered to TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "ad594e5afaa7750b1cc046684a09bae1", "product_family": "wisblock", "product_id": "kit6-light-and-color", "category": "How-To", "title": "WisBlock IoT Education Kit - Light & Color Quick Start Guide > WisBlock IoT Education Kit - Light & Color Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock IoT Education Kit - Light & Color using TTN and Qubitro > UV Index & UV Intensity Monitoring LoRaWAN Application > LoRaWAN Code for UV Index & UV Intensity Monitoring > Programming UV Index & UV Intensity Monitoring Device with Arduino IDE [CODE]", "content": "else if (uvi > 6.5 && uvi <= 7)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}", "keywords": ["Arduino IDE", "RAK4631", "UV Index", "UV Intensity", "LoRaWAN", "SX126x-Arduino"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **UV Index & UV Intensity Monitoring** device. Just copy the code below for **UV Index & UV Intensity Monitoring LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the example </summary>  \n```c\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h>  //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n#include \"UVlight_LTR390.h\"                // http://librarymanager/All#RAK12019_LTR390\nUVlight_LTR390 ltr = UVlight_LTR390();\n\n#include \"Light_VEML7700.h\"                // http://librarymanager/All#Light_veml7700\nLight_VEML7700 VMEL = Light_VEML7700();\n\nuint16_t uvi;\nuint32_t uvs;\nuint32_t lux;\nuint32_t white;\nuint32_t raw_als;\n\n#include <Adafruit_MCP23X17.h>  //http://librarymanager/All#Adafruit_MCP23017\nAdafruit_MCP23X17 mcp;\n\n// Added definitions for the functionality of RAK14003\nconst uint8_t LED_0 = 0;      // PA0 (17) of MCP23017\nconst uint8_t LED_1 = 1;      // PA1 (18) of MCP23017\nconst uint8_t LED_2 = 2;      // PA2 (19) of MCP23017\nconst uint8_t LED_3 = 3;      // PA3 (20) of MCP23017\nconst uint8_t LED_4 = 4;      // PA4 (21) of MCP23017\nconst uint8_t LED_5 = 5;      // PA5 (22) of MCP23017\nconst uint8_t LED_6 = 6;      // PA6 (23) of MCP23017\nconst uint8_t LED_7 = 7;      // PA7 (24) of MCP23017\nconst uint8_t LED_8 = 8;      // PB0 (25) of MCP23017\nconst uint8_t LED_9 = 9;      // PB1 (26) of MCP23017\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define RAK4631_BOARD true\n#else\n#define RAK4631_BOARD false\n#endif\n\nbool doOTAA = true;                                               // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                                       /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                                     /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5                               /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                                        /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;                           /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;                 /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                              /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = { LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF };\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = { BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler };\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xE9, 0x0D, 0x28, 0x1D, 0x92, 0x3D, 0xE4, 0x9F, 0xD9, 0xF7, 0xE0, 0x5F, 0x39, 0x10, 0x55, 0x71 };\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };\nuint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                                            /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];               //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = { m_lora_app_data_buffer, 0, 0, 0, 0 };  //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {\n\n// Initialize Serial for debug output\npinMode(LED_BLUE, OUTPUT);\ndigitalWrite(LED_BLUE, HIGH);\n\n// Sensor Power Switch\npinMode(WB_IO2, OUTPUT);\ndigitalWrite(WB_IO2, HIGH);\n\n// Reset RAK14003 module\npinMode(WB_IO4, OUTPUT);\ndigitalWrite(WB_IO4, HIGH);\ndelay(10);\ndigitalWrite(WB_IO4, LOW);\ndelay(10);\ndigitalWrite(WB_IO4, HIGH);\ndelay(10);\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial) {\nif ((millis() - timeout) < 5000) {\ndelay(100);\n} else {\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA) {\nSerial.println(\"Type: OTAA\");\n} else {\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion) {\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA) {\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n} else {\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0) {\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"================================\");\nSerial.println(\"RAK12019 + RAK12010 LoRaWAN Code\");\nSerial.println(\"================================\");\n\nif (!VMEL.begin())\n{\nSerial.println(\"Sensor not found\");\nwhile (1);\n}\n\nVMEL.setGain(VEML7700_GAIN_1);\nVMEL.setIntegrationTime(VEML7700_IT_800MS);\n\nSerial.print(F(\"Gain: \"));\nswitch (VMEL.getGain())\n{\ncase VEML7700_GAIN_1: Serial.println(\"1\"); break;\ncase VEML7700_GAIN_2: Serial.println(\"2\"); break;\ncase VEML7700_GAIN_1_4: Serial.println(\"1/4\"); break;\ncase VEML7700_GAIN_1_8: Serial.println(\"1/8\"); break;\n}\n\nSerial.print(F(\"Integration Time (ms): \"));\nswitch (VMEL.getIntegrationTime())\n{\ncase VEML7700_IT_25MS: Serial.println(\"25\"); break;\ncase VEML7700_IT_50MS: Serial.println(\"50\"); break;\ncase VEML7700_IT_100MS: Serial.println(\"100\"); break;\ncase VEML7700_IT_200MS: Serial.println(\"200\"); break;\ncase VEML7700_IT_400MS: Serial.println(\"400\"); break;\ncase VEML7700_IT_800MS: Serial.println(\"800\"); break;\n}\n\nSerial.println(\"RAK12019 test\");\nWire.begin();\nif (!ltr.init())\n{\nSerial.println(\"Couldn't find LTR sensor!\");\nwhile (1)\ndelay(10);\n}\nSerial.println(\"Found LTR390 sensor!\");\n\n//set to LTR390_MODE_UVS,get ultraviolet light data.\nltr.setMode(LTR390_MODE_UVS);  // UVS Mode\n\nSerial.println(\"In UVS mode\");\n\nltr.setGain(LTR390_GAIN_3);\nSerial.print(\"Gain : \");\nswitch (ltr.getGain())\n{\ncase LTR390_GAIN_1:\nSerial.println(1);\nbreak;\ncase LTR390_GAIN_3:\nSerial.println(3);\nbreak;\ncase LTR390_GAIN_6:\nSerial.println(6);\nbreak;\ncase LTR390_GAIN_9:\nSerial.println(9);\nbreak;\ncase LTR390_GAIN_18:\nSerial.println(18);\nbreak;\ndefault:\nSerial.println(\"Failed to set gain\");\nbreak;\n}\nltr.setResolution(LTR390_RESOLUTION_16BIT);\nSerial.print(\"Integration Time (ms): \");\nswitch (ltr.getResolution())\n{\ncase LTR390_RESOLUTION_13BIT:\nSerial.println(13);\nbreak;\ncase LTR390_RESOLUTION_16BIT:\nSerial.println(16);\nbreak;\ncase LTR390_RESOLUTION_17BIT:\nSerial.println(17);\nbreak;\ncase LTR390_RESOLUTION_18BIT:\nSerial.println(18);\nbreak;\ncase LTR390_RESOLUTION_19BIT:\nSerial.println(19);\nbreak;\ncase LTR390_RESOLUTION_20BIT:\nSerial.println(20);\nbreak;\ndefault:\nSerial.println(\"Failed to set Integration Time\");\nbreak;\n}\n\nltr.setThresholds(100, 1000); //Set the interrupt output threshold range for lower and upper.\n\nltr.configInterrupt(true, LTR390_MODE_UVS);\n\n// For RAK14003\nmcp.begin_I2C(0x24);\n\n// Added for the functionality of RAK14003\n\nWire.begin();    // initialize I2C serial bus\n\n// Configuration of MCP23017 I/O ports\nmcp.pinMode(LED_0, OUTPUT);     // Red LED; Top most\nmcp.pinMode(LED_1, OUTPUT);     // Red LED\nmcp.pinMode(LED_2, OUTPUT);     // Orange LED\nmcp.pinMode(LED_3, OUTPUT);     // Orange LED\nmcp.pinMode(LED_4, OUTPUT);     // Orange LED\nmcp.pinMode(LED_5, OUTPUT);     // Green LED\nmcp.pinMode(LED_6, OUTPUT);     // Green LED\nmcp.pinMode(LED_7, OUTPUT);     // Green LED\nmcp.pinMode(LED_8, OUTPUT);     // Green LED\nmcp.pinMode(LED_9, OUTPUT);     // Green LED; Bottom\n\n// Initially Turn OFF all LEDs\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, HIGH);\n\n}\n\nvoid loop() {\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\n// Trial # 1\n// Data from RAK12019\nif (ltr.newDataAvailable())\n{\nuvi = ltr.getUVI();\nuvs = ltr.readUVS();\n}\n\n// Data from RAK12010\nlux = VMEL.readLux();\nwhite = VMEL.readWhite();\nraw_als = VMEL.readALS();\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\n\n// From RAK12019 module\nSerial.print(\"UVI: \");\nSerial.println(uvi);          // Uvi data from RAK12019\nSerial.print(\"UVS: \");\nSerial.println(uvs);            // Uvs data from RAK12019\n\n// From RAK12010\nSerial.print(\"Lux: \");\nSerial.print(lux);\nSerial.println(\" lx \");\nSerial.print(\"White: \");\nSerial.println(white);\nSerial.print(\"Raw ALS: \");\nSerial.println(raw_als);\n\n// Result of uvi to be displayed via RAK14003 module\nif (uvi <= 0.4)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, HIGH);\n}\n\nelse if (uvi > 0.5 && uvi <= 1)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 1.5 && uvi <= 2)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 2.5 && uvi <= 3)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 3.5 && uvi <= 4)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 4.5 && uvi <= 5)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 5.5 && uvi <= 6)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 6.5 && uvi <= 7)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 7.5 && uvi <= 8)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 8.5 && uvi <= 9.5)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, LOW);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi >= 10)\n{\nmcp.digitalWrite(LED_0, LOW);\nmcp.digitalWrite(LED_1, LOW);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\ndelay(10000);\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void) {\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void) {\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data) {\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class) {\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void) {\nif (lmh_join_status_get() != LMH_SET) {\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\ndata = \" Uvi Data: \" + String(uvi) + \" Uvs Data: \" + String(uvs) + \" Lux Data: \" + String(lux) + \" lx \" ;\n\nSerial.println(data);\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\nuint16_t uvi_data = uvi;            // Uvi data from RAK12019\nuint32_t uvs_data = uvs;            // Uvs data from RAK12019\nuint32_t lux_data = lux;            // Lux data from RAK12010\n\nm_lora_app_data.buffer[i++] = 0x01;  // byte[0]\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\n// Data from RAK12019 module\nm_lora_app_data.buffer[i++] = (uint8_t)((uvi_data & 0x0000FF00) >> 8);     // byte[1]\nm_lora_app_data.buffer[i++] = (uint8_t)(uvi_data & 0x000000FF);            // byte[2]\n\n// Data from RAK12019 module\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0xFF000000) >> 24);    // byte[3]\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0x00FF0000) >> 16);    // byte[4]\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0x0000FF00) >> 8);     // byte[5]\nm_lora_app_data.buffer[i++] = (uint8_t)(uvs_data & 0x000000FF);            // byte[6]\n\n// Data from RAK12010 module\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0xFF000000) >> 24);    // byte[7]\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0x00FF0000) >> 16);    // byte[8]\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0x0000FF00) >> 8);     // byte[9]\nm_lora_app_data.buffer[i++] = (uint8_t)(lux_data & 0x000000FF);            // byte[10]\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS) {\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n} else {\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xE9, 0x0D, 0x28, 0x1D, 0x92, 0x3D, 0xE4, 0x9F, 0xD9, 0xF7, 0xE0, 0x5F, 0x39, 0x10, 0x55, 0x71 };\n\n```  \n> **Image:** OTAA device successfully registered to TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "00e32eb99c145ffccde436e1f280619e", "product_family": "wisblock", "product_id": "kit6-light-and-color", "category": "How-To", "title": "WisBlock IoT Education Kit - Light & Color Quick Start Guide > WisBlock IoT Education Kit - Light & Color Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock IoT Education Kit - Light & Color using TTN and Qubitro > UV Index & UV Intensity Monitoring LoRaWAN Application > LoRaWAN Code for UV Index & UV Intensity Monitoring > Programming UV Index & UV Intensity Monitoring Device with Arduino IDE [CODE]", "content": "else if (uvi > 7.5 && uvi <= 8)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}", "keywords": ["Arduino IDE", "RAK4631", "UV Index", "UV Intensity", "LoRaWAN", "SX126x-Arduino"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **UV Index & UV Intensity Monitoring** device. Just copy the code below for **UV Index & UV Intensity Monitoring LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the example </summary>  \n```c\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h>  //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n#include \"UVlight_LTR390.h\"                // http://librarymanager/All#RAK12019_LTR390\nUVlight_LTR390 ltr = UVlight_LTR390();\n\n#include \"Light_VEML7700.h\"                // http://librarymanager/All#Light_veml7700\nLight_VEML7700 VMEL = Light_VEML7700();\n\nuint16_t uvi;\nuint32_t uvs;\nuint32_t lux;\nuint32_t white;\nuint32_t raw_als;\n\n#include <Adafruit_MCP23X17.h>  //http://librarymanager/All#Adafruit_MCP23017\nAdafruit_MCP23X17 mcp;\n\n// Added definitions for the functionality of RAK14003\nconst uint8_t LED_0 = 0;      // PA0 (17) of MCP23017\nconst uint8_t LED_1 = 1;      // PA1 (18) of MCP23017\nconst uint8_t LED_2 = 2;      // PA2 (19) of MCP23017\nconst uint8_t LED_3 = 3;      // PA3 (20) of MCP23017\nconst uint8_t LED_4 = 4;      // PA4 (21) of MCP23017\nconst uint8_t LED_5 = 5;      // PA5 (22) of MCP23017\nconst uint8_t LED_6 = 6;      // PA6 (23) of MCP23017\nconst uint8_t LED_7 = 7;      // PA7 (24) of MCP23017\nconst uint8_t LED_8 = 8;      // PB0 (25) of MCP23017\nconst uint8_t LED_9 = 9;      // PB1 (26) of MCP23017\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define RAK4631_BOARD true\n#else\n#define RAK4631_BOARD false\n#endif\n\nbool doOTAA = true;                                               // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                                       /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                                     /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5                               /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                                        /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;                           /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;                 /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                              /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = { LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF };\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = { BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler };\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xE9, 0x0D, 0x28, 0x1D, 0x92, 0x3D, 0xE4, 0x9F, 0xD9, 0xF7, 0xE0, 0x5F, 0x39, 0x10, 0x55, 0x71 };\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };\nuint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                                            /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];               //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = { m_lora_app_data_buffer, 0, 0, 0, 0 };  //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {\n\n// Initialize Serial for debug output\npinMode(LED_BLUE, OUTPUT);\ndigitalWrite(LED_BLUE, HIGH);\n\n// Sensor Power Switch\npinMode(WB_IO2, OUTPUT);\ndigitalWrite(WB_IO2, HIGH);\n\n// Reset RAK14003 module\npinMode(WB_IO4, OUTPUT);\ndigitalWrite(WB_IO4, HIGH);\ndelay(10);\ndigitalWrite(WB_IO4, LOW);\ndelay(10);\ndigitalWrite(WB_IO4, HIGH);\ndelay(10);\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial) {\nif ((millis() - timeout) < 5000) {\ndelay(100);\n} else {\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA) {\nSerial.println(\"Type: OTAA\");\n} else {\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion) {\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA) {\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n} else {\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0) {\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"================================\");\nSerial.println(\"RAK12019 + RAK12010 LoRaWAN Code\");\nSerial.println(\"================================\");\n\nif (!VMEL.begin())\n{\nSerial.println(\"Sensor not found\");\nwhile (1);\n}\n\nVMEL.setGain(VEML7700_GAIN_1);\nVMEL.setIntegrationTime(VEML7700_IT_800MS);\n\nSerial.print(F(\"Gain: \"));\nswitch (VMEL.getGain())\n{\ncase VEML7700_GAIN_1: Serial.println(\"1\"); break;\ncase VEML7700_GAIN_2: Serial.println(\"2\"); break;\ncase VEML7700_GAIN_1_4: Serial.println(\"1/4\"); break;\ncase VEML7700_GAIN_1_8: Serial.println(\"1/8\"); break;\n}\n\nSerial.print(F(\"Integration Time (ms): \"));\nswitch (VMEL.getIntegrationTime())\n{\ncase VEML7700_IT_25MS: Serial.println(\"25\"); break;\ncase VEML7700_IT_50MS: Serial.println(\"50\"); break;\ncase VEML7700_IT_100MS: Serial.println(\"100\"); break;\ncase VEML7700_IT_200MS: Serial.println(\"200\"); break;\ncase VEML7700_IT_400MS: Serial.println(\"400\"); break;\ncase VEML7700_IT_800MS: Serial.println(\"800\"); break;\n}\n\nSerial.println(\"RAK12019 test\");\nWire.begin();\nif (!ltr.init())\n{\nSerial.println(\"Couldn't find LTR sensor!\");\nwhile (1)\ndelay(10);\n}\nSerial.println(\"Found LTR390 sensor!\");\n\n//set to LTR390_MODE_UVS,get ultraviolet light data.\nltr.setMode(LTR390_MODE_UVS);  // UVS Mode\n\nSerial.println(\"In UVS mode\");\n\nltr.setGain(LTR390_GAIN_3);\nSerial.print(\"Gain : \");\nswitch (ltr.getGain())\n{\ncase LTR390_GAIN_1:\nSerial.println(1);\nbreak;\ncase LTR390_GAIN_3:\nSerial.println(3);\nbreak;\ncase LTR390_GAIN_6:\nSerial.println(6);\nbreak;\ncase LTR390_GAIN_9:\nSerial.println(9);\nbreak;\ncase LTR390_GAIN_18:\nSerial.println(18);\nbreak;\ndefault:\nSerial.println(\"Failed to set gain\");\nbreak;\n}\nltr.setResolution(LTR390_RESOLUTION_16BIT);\nSerial.print(\"Integration Time (ms): \");\nswitch (ltr.getResolution())\n{\ncase LTR390_RESOLUTION_13BIT:\nSerial.println(13);\nbreak;\ncase LTR390_RESOLUTION_16BIT:\nSerial.println(16);\nbreak;\ncase LTR390_RESOLUTION_17BIT:\nSerial.println(17);\nbreak;\ncase LTR390_RESOLUTION_18BIT:\nSerial.println(18);\nbreak;\ncase LTR390_RESOLUTION_19BIT:\nSerial.println(19);\nbreak;\ncase LTR390_RESOLUTION_20BIT:\nSerial.println(20);\nbreak;\ndefault:\nSerial.println(\"Failed to set Integration Time\");\nbreak;\n}\n\nltr.setThresholds(100, 1000); //Set the interrupt output threshold range for lower and upper.\n\nltr.configInterrupt(true, LTR390_MODE_UVS);\n\n// For RAK14003\nmcp.begin_I2C(0x24);\n\n// Added for the functionality of RAK14003\n\nWire.begin();    // initialize I2C serial bus\n\n// Configuration of MCP23017 I/O ports\nmcp.pinMode(LED_0, OUTPUT);     // Red LED; Top most\nmcp.pinMode(LED_1, OUTPUT);     // Red LED\nmcp.pinMode(LED_2, OUTPUT);     // Orange LED\nmcp.pinMode(LED_3, OUTPUT);     // Orange LED\nmcp.pinMode(LED_4, OUTPUT);     // Orange LED\nmcp.pinMode(LED_5, OUTPUT);     // Green LED\nmcp.pinMode(LED_6, OUTPUT);     // Green LED\nmcp.pinMode(LED_7, OUTPUT);     // Green LED\nmcp.pinMode(LED_8, OUTPUT);     // Green LED\nmcp.pinMode(LED_9, OUTPUT);     // Green LED; Bottom\n\n// Initially Turn OFF all LEDs\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, HIGH);\n\n}\n\nvoid loop() {\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\n// Trial # 1\n// Data from RAK12019\nif (ltr.newDataAvailable())\n{\nuvi = ltr.getUVI();\nuvs = ltr.readUVS();\n}\n\n// Data from RAK12010\nlux = VMEL.readLux();\nwhite = VMEL.readWhite();\nraw_als = VMEL.readALS();\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\n\n// From RAK12019 module\nSerial.print(\"UVI: \");\nSerial.println(uvi);          // Uvi data from RAK12019\nSerial.print(\"UVS: \");\nSerial.println(uvs);            // Uvs data from RAK12019\n\n// From RAK12010\nSerial.print(\"Lux: \");\nSerial.print(lux);\nSerial.println(\" lx \");\nSerial.print(\"White: \");\nSerial.println(white);\nSerial.print(\"Raw ALS: \");\nSerial.println(raw_als);\n\n// Result of uvi to be displayed via RAK14003 module\nif (uvi <= 0.4)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, HIGH);\n}\n\nelse if (uvi > 0.5 && uvi <= 1)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 1.5 && uvi <= 2)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 2.5 && uvi <= 3)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 3.5 && uvi <= 4)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 4.5 && uvi <= 5)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 5.5 && uvi <= 6)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 6.5 && uvi <= 7)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 7.5 && uvi <= 8)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 8.5 && uvi <= 9.5)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, LOW);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi >= 10)\n{\nmcp.digitalWrite(LED_0, LOW);\nmcp.digitalWrite(LED_1, LOW);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\ndelay(10000);\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void) {\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void) {\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data) {\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class) {\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void) {\nif (lmh_join_status_get() != LMH_SET) {\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\ndata = \" Uvi Data: \" + String(uvi) + \" Uvs Data: \" + String(uvs) + \" Lux Data: \" + String(lux) + \" lx \" ;\n\nSerial.println(data);\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\nuint16_t uvi_data = uvi;            // Uvi data from RAK12019\nuint32_t uvs_data = uvs;            // Uvs data from RAK12019\nuint32_t lux_data = lux;            // Lux data from RAK12010\n\nm_lora_app_data.buffer[i++] = 0x01;  // byte[0]\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\n// Data from RAK12019 module\nm_lora_app_data.buffer[i++] = (uint8_t)((uvi_data & 0x0000FF00) >> 8);     // byte[1]\nm_lora_app_data.buffer[i++] = (uint8_t)(uvi_data & 0x000000FF);            // byte[2]\n\n// Data from RAK12019 module\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0xFF000000) >> 24);    // byte[3]\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0x00FF0000) >> 16);    // byte[4]\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0x0000FF00) >> 8);     // byte[5]\nm_lora_app_data.buffer[i++] = (uint8_t)(uvs_data & 0x000000FF);            // byte[6]\n\n// Data from RAK12010 module\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0xFF000000) >> 24);    // byte[7]\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0x00FF0000) >> 16);    // byte[8]\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0x0000FF00) >> 8);     // byte[9]\nm_lora_app_data.buffer[i++] = (uint8_t)(lux_data & 0x000000FF);            // byte[10]\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS) {\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n} else {\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xE9, 0x0D, 0x28, 0x1D, 0x92, 0x3D, 0xE4, 0x9F, 0xD9, 0xF7, 0xE0, 0x5F, 0x39, 0x10, 0x55, 0x71 };\n\n```  \n> **Image:** OTAA device successfully registered to TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "d24deaea4add9a4fe9dc50f0ff4d83aa", "product_family": "wisblock", "product_id": "kit6-light-and-color", "category": "How-To", "title": "WisBlock IoT Education Kit - Light & Color Quick Start Guide > WisBlock IoT Education Kit - Light & Color Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock IoT Education Kit - Light & Color using TTN and Qubitro > UV Index & UV Intensity Monitoring LoRaWAN Application > LoRaWAN Code for UV Index & UV Intensity Monitoring > Programming UV Index & UV Intensity Monitoring Device with Arduino IDE [CODE]", "content": "else if (uvi > 8.5 && uvi <= 9.5)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, LOW);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}", "keywords": ["Arduino IDE", "RAK4631", "UV Index", "UV Intensity", "LoRaWAN", "SX126x-Arduino"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **UV Index & UV Intensity Monitoring** device. Just copy the code below for **UV Index & UV Intensity Monitoring LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the example </summary>  \n```c\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h>  //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n#include \"UVlight_LTR390.h\"                // http://librarymanager/All#RAK12019_LTR390\nUVlight_LTR390 ltr = UVlight_LTR390();\n\n#include \"Light_VEML7700.h\"                // http://librarymanager/All#Light_veml7700\nLight_VEML7700 VMEL = Light_VEML7700();\n\nuint16_t uvi;\nuint32_t uvs;\nuint32_t lux;\nuint32_t white;\nuint32_t raw_als;\n\n#include <Adafruit_MCP23X17.h>  //http://librarymanager/All#Adafruit_MCP23017\nAdafruit_MCP23X17 mcp;\n\n// Added definitions for the functionality of RAK14003\nconst uint8_t LED_0 = 0;      // PA0 (17) of MCP23017\nconst uint8_t LED_1 = 1;      // PA1 (18) of MCP23017\nconst uint8_t LED_2 = 2;      // PA2 (19) of MCP23017\nconst uint8_t LED_3 = 3;      // PA3 (20) of MCP23017\nconst uint8_t LED_4 = 4;      // PA4 (21) of MCP23017\nconst uint8_t LED_5 = 5;      // PA5 (22) of MCP23017\nconst uint8_t LED_6 = 6;      // PA6 (23) of MCP23017\nconst uint8_t LED_7 = 7;      // PA7 (24) of MCP23017\nconst uint8_t LED_8 = 8;      // PB0 (25) of MCP23017\nconst uint8_t LED_9 = 9;      // PB1 (26) of MCP23017\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define RAK4631_BOARD true\n#else\n#define RAK4631_BOARD false\n#endif\n\nbool doOTAA = true;                                               // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                                       /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                                     /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5                               /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                                        /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;                           /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;                 /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                              /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = { LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF };\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = { BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler };\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xE9, 0x0D, 0x28, 0x1D, 0x92, 0x3D, 0xE4, 0x9F, 0xD9, 0xF7, 0xE0, 0x5F, 0x39, 0x10, 0x55, 0x71 };\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };\nuint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                                            /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];               //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = { m_lora_app_data_buffer, 0, 0, 0, 0 };  //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {\n\n// Initialize Serial for debug output\npinMode(LED_BLUE, OUTPUT);\ndigitalWrite(LED_BLUE, HIGH);\n\n// Sensor Power Switch\npinMode(WB_IO2, OUTPUT);\ndigitalWrite(WB_IO2, HIGH);\n\n// Reset RAK14003 module\npinMode(WB_IO4, OUTPUT);\ndigitalWrite(WB_IO4, HIGH);\ndelay(10);\ndigitalWrite(WB_IO4, LOW);\ndelay(10);\ndigitalWrite(WB_IO4, HIGH);\ndelay(10);\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial) {\nif ((millis() - timeout) < 5000) {\ndelay(100);\n} else {\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA) {\nSerial.println(\"Type: OTAA\");\n} else {\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion) {\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA) {\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n} else {\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0) {\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"================================\");\nSerial.println(\"RAK12019 + RAK12010 LoRaWAN Code\");\nSerial.println(\"================================\");\n\nif (!VMEL.begin())\n{\nSerial.println(\"Sensor not found\");\nwhile (1);\n}\n\nVMEL.setGain(VEML7700_GAIN_1);\nVMEL.setIntegrationTime(VEML7700_IT_800MS);\n\nSerial.print(F(\"Gain: \"));\nswitch (VMEL.getGain())\n{\ncase VEML7700_GAIN_1: Serial.println(\"1\"); break;\ncase VEML7700_GAIN_2: Serial.println(\"2\"); break;\ncase VEML7700_GAIN_1_4: Serial.println(\"1/4\"); break;\ncase VEML7700_GAIN_1_8: Serial.println(\"1/8\"); break;\n}\n\nSerial.print(F(\"Integration Time (ms): \"));\nswitch (VMEL.getIntegrationTime())\n{\ncase VEML7700_IT_25MS: Serial.println(\"25\"); break;\ncase VEML7700_IT_50MS: Serial.println(\"50\"); break;\ncase VEML7700_IT_100MS: Serial.println(\"100\"); break;\ncase VEML7700_IT_200MS: Serial.println(\"200\"); break;\ncase VEML7700_IT_400MS: Serial.println(\"400\"); break;\ncase VEML7700_IT_800MS: Serial.println(\"800\"); break;\n}\n\nSerial.println(\"RAK12019 test\");\nWire.begin();\nif (!ltr.init())\n{\nSerial.println(\"Couldn't find LTR sensor!\");\nwhile (1)\ndelay(10);\n}\nSerial.println(\"Found LTR390 sensor!\");\n\n//set to LTR390_MODE_UVS,get ultraviolet light data.\nltr.setMode(LTR390_MODE_UVS);  // UVS Mode\n\nSerial.println(\"In UVS mode\");\n\nltr.setGain(LTR390_GAIN_3);\nSerial.print(\"Gain : \");\nswitch (ltr.getGain())\n{\ncase LTR390_GAIN_1:\nSerial.println(1);\nbreak;\ncase LTR390_GAIN_3:\nSerial.println(3);\nbreak;\ncase LTR390_GAIN_6:\nSerial.println(6);\nbreak;\ncase LTR390_GAIN_9:\nSerial.println(9);\nbreak;\ncase LTR390_GAIN_18:\nSerial.println(18);\nbreak;\ndefault:\nSerial.println(\"Failed to set gain\");\nbreak;\n}\nltr.setResolution(LTR390_RESOLUTION_16BIT);\nSerial.print(\"Integration Time (ms): \");\nswitch (ltr.getResolution())\n{\ncase LTR390_RESOLUTION_13BIT:\nSerial.println(13);\nbreak;\ncase LTR390_RESOLUTION_16BIT:\nSerial.println(16);\nbreak;\ncase LTR390_RESOLUTION_17BIT:\nSerial.println(17);\nbreak;\ncase LTR390_RESOLUTION_18BIT:\nSerial.println(18);\nbreak;\ncase LTR390_RESOLUTION_19BIT:\nSerial.println(19);\nbreak;\ncase LTR390_RESOLUTION_20BIT:\nSerial.println(20);\nbreak;\ndefault:\nSerial.println(\"Failed to set Integration Time\");\nbreak;\n}\n\nltr.setThresholds(100, 1000); //Set the interrupt output threshold range for lower and upper.\n\nltr.configInterrupt(true, LTR390_MODE_UVS);\n\n// For RAK14003\nmcp.begin_I2C(0x24);\n\n// Added for the functionality of RAK14003\n\nWire.begin();    // initialize I2C serial bus\n\n// Configuration of MCP23017 I/O ports\nmcp.pinMode(LED_0, OUTPUT);     // Red LED; Top most\nmcp.pinMode(LED_1, OUTPUT);     // Red LED\nmcp.pinMode(LED_2, OUTPUT);     // Orange LED\nmcp.pinMode(LED_3, OUTPUT);     // Orange LED\nmcp.pinMode(LED_4, OUTPUT);     // Orange LED\nmcp.pinMode(LED_5, OUTPUT);     // Green LED\nmcp.pinMode(LED_6, OUTPUT);     // Green LED\nmcp.pinMode(LED_7, OUTPUT);     // Green LED\nmcp.pinMode(LED_8, OUTPUT);     // Green LED\nmcp.pinMode(LED_9, OUTPUT);     // Green LED; Bottom\n\n// Initially Turn OFF all LEDs\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, HIGH);\n\n}\n\nvoid loop() {\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\n// Trial # 1\n// Data from RAK12019\nif (ltr.newDataAvailable())\n{\nuvi = ltr.getUVI();\nuvs = ltr.readUVS();\n}\n\n// Data from RAK12010\nlux = VMEL.readLux();\nwhite = VMEL.readWhite();\nraw_als = VMEL.readALS();\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\n\n// From RAK12019 module\nSerial.print(\"UVI: \");\nSerial.println(uvi);          // Uvi data from RAK12019\nSerial.print(\"UVS: \");\nSerial.println(uvs);            // Uvs data from RAK12019\n\n// From RAK12010\nSerial.print(\"Lux: \");\nSerial.print(lux);\nSerial.println(\" lx \");\nSerial.print(\"White: \");\nSerial.println(white);\nSerial.print(\"Raw ALS: \");\nSerial.println(raw_als);\n\n// Result of uvi to be displayed via RAK14003 module\nif (uvi <= 0.4)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, HIGH);\n}\n\nelse if (uvi > 0.5 && uvi <= 1)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 1.5 && uvi <= 2)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 2.5 && uvi <= 3)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 3.5 && uvi <= 4)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 4.5 && uvi <= 5)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 5.5 && uvi <= 6)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 6.5 && uvi <= 7)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 7.5 && uvi <= 8)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 8.5 && uvi <= 9.5)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, LOW);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi >= 10)\n{\nmcp.digitalWrite(LED_0, LOW);\nmcp.digitalWrite(LED_1, LOW);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\ndelay(10000);\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void) {\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void) {\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data) {\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class) {\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void) {\nif (lmh_join_status_get() != LMH_SET) {\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\ndata = \" Uvi Data: \" + String(uvi) + \" Uvs Data: \" + String(uvs) + \" Lux Data: \" + String(lux) + \" lx \" ;\n\nSerial.println(data);\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\nuint16_t uvi_data = uvi;            // Uvi data from RAK12019\nuint32_t uvs_data = uvs;            // Uvs data from RAK12019\nuint32_t lux_data = lux;            // Lux data from RAK12010\n\nm_lora_app_data.buffer[i++] = 0x01;  // byte[0]\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\n// Data from RAK12019 module\nm_lora_app_data.buffer[i++] = (uint8_t)((uvi_data & 0x0000FF00) >> 8);     // byte[1]\nm_lora_app_data.buffer[i++] = (uint8_t)(uvi_data & 0x000000FF);            // byte[2]\n\n// Data from RAK12019 module\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0xFF000000) >> 24);    // byte[3]\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0x00FF0000) >> 16);    // byte[4]\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0x0000FF00) >> 8);     // byte[5]\nm_lora_app_data.buffer[i++] = (uint8_t)(uvs_data & 0x000000FF);            // byte[6]\n\n// Data from RAK12010 module\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0xFF000000) >> 24);    // byte[7]\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0x00FF0000) >> 16);    // byte[8]\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0x0000FF00) >> 8);     // byte[9]\nm_lora_app_data.buffer[i++] = (uint8_t)(lux_data & 0x000000FF);            // byte[10]\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS) {\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n} else {\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xE9, 0x0D, 0x28, 0x1D, 0x92, 0x3D, 0xE4, 0x9F, 0xD9, 0xF7, 0xE0, 0x5F, 0x39, 0x10, 0x55, 0x71 };\n\n```  \n> **Image:** OTAA device successfully registered to TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "f92c8653a515d9820118c66b5a80ddec", "product_family": "wisblock", "product_id": "kit6-light-and-color", "category": "How-To", "title": "WisBlock IoT Education Kit - Light & Color Quick Start Guide > WisBlock IoT Education Kit - Light & Color Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock IoT Education Kit - Light & Color using TTN and Qubitro > UV Index & UV Intensity Monitoring LoRaWAN Application > LoRaWAN Code for UV Index & UV Intensity Monitoring > Programming UV Index & UV Intensity Monitoring Device with Arduino IDE [CODE]", "content": "else if (uvi >= 10)\n{\nmcp.digitalWrite(LED_0, LOW);\nmcp.digitalWrite(LED_1, LOW);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\ndelay(10000);\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void) {\nSerial.println(\"OTAA Mode, Network Joined!\");\n}", "keywords": ["Arduino IDE", "RAK4631", "UV Index", "UV Intensity", "LoRaWAN", "SX126x-Arduino"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **UV Index & UV Intensity Monitoring** device. Just copy the code below for **UV Index & UV Intensity Monitoring LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the example </summary>  \n```c\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h>  //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n#include \"UVlight_LTR390.h\"                // http://librarymanager/All#RAK12019_LTR390\nUVlight_LTR390 ltr = UVlight_LTR390();\n\n#include \"Light_VEML7700.h\"                // http://librarymanager/All#Light_veml7700\nLight_VEML7700 VMEL = Light_VEML7700();\n\nuint16_t uvi;\nuint32_t uvs;\nuint32_t lux;\nuint32_t white;\nuint32_t raw_als;\n\n#include <Adafruit_MCP23X17.h>  //http://librarymanager/All#Adafruit_MCP23017\nAdafruit_MCP23X17 mcp;\n\n// Added definitions for the functionality of RAK14003\nconst uint8_t LED_0 = 0;      // PA0 (17) of MCP23017\nconst uint8_t LED_1 = 1;      // PA1 (18) of MCP23017\nconst uint8_t LED_2 = 2;      // PA2 (19) of MCP23017\nconst uint8_t LED_3 = 3;      // PA3 (20) of MCP23017\nconst uint8_t LED_4 = 4;      // PA4 (21) of MCP23017\nconst uint8_t LED_5 = 5;      // PA5 (22) of MCP23017\nconst uint8_t LED_6 = 6;      // PA6 (23) of MCP23017\nconst uint8_t LED_7 = 7;      // PA7 (24) of MCP23017\nconst uint8_t LED_8 = 8;      // PB0 (25) of MCP23017\nconst uint8_t LED_9 = 9;      // PB1 (26) of MCP23017\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define RAK4631_BOARD true\n#else\n#define RAK4631_BOARD false\n#endif\n\nbool doOTAA = true;                                               // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                                       /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                                     /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5                               /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                                        /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;                           /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;                 /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                              /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = { LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF };\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = { BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler };\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xE9, 0x0D, 0x28, 0x1D, 0x92, 0x3D, 0xE4, 0x9F, 0xD9, 0xF7, 0xE0, 0x5F, 0x39, 0x10, 0x55, 0x71 };\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };\nuint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                                            /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];               //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = { m_lora_app_data_buffer, 0, 0, 0, 0 };  //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {\n\n// Initialize Serial for debug output\npinMode(LED_BLUE, OUTPUT);\ndigitalWrite(LED_BLUE, HIGH);\n\n// Sensor Power Switch\npinMode(WB_IO2, OUTPUT);\ndigitalWrite(WB_IO2, HIGH);\n\n// Reset RAK14003 module\npinMode(WB_IO4, OUTPUT);\ndigitalWrite(WB_IO4, HIGH);\ndelay(10);\ndigitalWrite(WB_IO4, LOW);\ndelay(10);\ndigitalWrite(WB_IO4, HIGH);\ndelay(10);\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial) {\nif ((millis() - timeout) < 5000) {\ndelay(100);\n} else {\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA) {\nSerial.println(\"Type: OTAA\");\n} else {\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion) {\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA) {\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n} else {\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0) {\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"================================\");\nSerial.println(\"RAK12019 + RAK12010 LoRaWAN Code\");\nSerial.println(\"================================\");\n\nif (!VMEL.begin())\n{\nSerial.println(\"Sensor not found\");\nwhile (1);\n}\n\nVMEL.setGain(VEML7700_GAIN_1);\nVMEL.setIntegrationTime(VEML7700_IT_800MS);\n\nSerial.print(F(\"Gain: \"));\nswitch (VMEL.getGain())\n{\ncase VEML7700_GAIN_1: Serial.println(\"1\"); break;\ncase VEML7700_GAIN_2: Serial.println(\"2\"); break;\ncase VEML7700_GAIN_1_4: Serial.println(\"1/4\"); break;\ncase VEML7700_GAIN_1_8: Serial.println(\"1/8\"); break;\n}\n\nSerial.print(F(\"Integration Time (ms): \"));\nswitch (VMEL.getIntegrationTime())\n{\ncase VEML7700_IT_25MS: Serial.println(\"25\"); break;\ncase VEML7700_IT_50MS: Serial.println(\"50\"); break;\ncase VEML7700_IT_100MS: Serial.println(\"100\"); break;\ncase VEML7700_IT_200MS: Serial.println(\"200\"); break;\ncase VEML7700_IT_400MS: Serial.println(\"400\"); break;\ncase VEML7700_IT_800MS: Serial.println(\"800\"); break;\n}\n\nSerial.println(\"RAK12019 test\");\nWire.begin();\nif (!ltr.init())\n{\nSerial.println(\"Couldn't find LTR sensor!\");\nwhile (1)\ndelay(10);\n}\nSerial.println(\"Found LTR390 sensor!\");\n\n//set to LTR390_MODE_UVS,get ultraviolet light data.\nltr.setMode(LTR390_MODE_UVS);  // UVS Mode\n\nSerial.println(\"In UVS mode\");\n\nltr.setGain(LTR390_GAIN_3);\nSerial.print(\"Gain : \");\nswitch (ltr.getGain())\n{\ncase LTR390_GAIN_1:\nSerial.println(1);\nbreak;\ncase LTR390_GAIN_3:\nSerial.println(3);\nbreak;\ncase LTR390_GAIN_6:\nSerial.println(6);\nbreak;\ncase LTR390_GAIN_9:\nSerial.println(9);\nbreak;\ncase LTR390_GAIN_18:\nSerial.println(18);\nbreak;\ndefault:\nSerial.println(\"Failed to set gain\");\nbreak;\n}\nltr.setResolution(LTR390_RESOLUTION_16BIT);\nSerial.print(\"Integration Time (ms): \");\nswitch (ltr.getResolution())\n{\ncase LTR390_RESOLUTION_13BIT:\nSerial.println(13);\nbreak;\ncase LTR390_RESOLUTION_16BIT:\nSerial.println(16);\nbreak;\ncase LTR390_RESOLUTION_17BIT:\nSerial.println(17);\nbreak;\ncase LTR390_RESOLUTION_18BIT:\nSerial.println(18);\nbreak;\ncase LTR390_RESOLUTION_19BIT:\nSerial.println(19);\nbreak;\ncase LTR390_RESOLUTION_20BIT:\nSerial.println(20);\nbreak;\ndefault:\nSerial.println(\"Failed to set Integration Time\");\nbreak;\n}\n\nltr.setThresholds(100, 1000); //Set the interrupt output threshold range for lower and upper.\n\nltr.configInterrupt(true, LTR390_MODE_UVS);\n\n// For RAK14003\nmcp.begin_I2C(0x24);\n\n// Added for the functionality of RAK14003\n\nWire.begin();    // initialize I2C serial bus\n\n// Configuration of MCP23017 I/O ports\nmcp.pinMode(LED_0, OUTPUT);     // Red LED; Top most\nmcp.pinMode(LED_1, OUTPUT);     // Red LED\nmcp.pinMode(LED_2, OUTPUT);     // Orange LED\nmcp.pinMode(LED_3, OUTPUT);     // Orange LED\nmcp.pinMode(LED_4, OUTPUT);     // Orange LED\nmcp.pinMode(LED_5, OUTPUT);     // Green LED\nmcp.pinMode(LED_6, OUTPUT);     // Green LED\nmcp.pinMode(LED_7, OUTPUT);     // Green LED\nmcp.pinMode(LED_8, OUTPUT);     // Green LED\nmcp.pinMode(LED_9, OUTPUT);     // Green LED; Bottom\n\n// Initially Turn OFF all LEDs\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, HIGH);\n\n}\n\nvoid loop() {\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\n// Trial # 1\n// Data from RAK12019\nif (ltr.newDataAvailable())\n{\nuvi = ltr.getUVI();\nuvs = ltr.readUVS();\n}\n\n// Data from RAK12010\nlux = VMEL.readLux();\nwhite = VMEL.readWhite();\nraw_als = VMEL.readALS();\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\n\n// From RAK12019 module\nSerial.print(\"UVI: \");\nSerial.println(uvi);          // Uvi data from RAK12019\nSerial.print(\"UVS: \");\nSerial.println(uvs);            // Uvs data from RAK12019\n\n// From RAK12010\nSerial.print(\"Lux: \");\nSerial.print(lux);\nSerial.println(\" lx \");\nSerial.print(\"White: \");\nSerial.println(white);\nSerial.print(\"Raw ALS: \");\nSerial.println(raw_als);\n\n// Result of uvi to be displayed via RAK14003 module\nif (uvi <= 0.4)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, HIGH);\n}\n\nelse if (uvi > 0.5 && uvi <= 1)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 1.5 && uvi <= 2)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 2.5 && uvi <= 3)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 3.5 && uvi <= 4)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 4.5 && uvi <= 5)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 5.5 && uvi <= 6)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 6.5 && uvi <= 7)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 7.5 && uvi <= 8)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 8.5 && uvi <= 9.5)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, LOW);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi >= 10)\n{\nmcp.digitalWrite(LED_0, LOW);\nmcp.digitalWrite(LED_1, LOW);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\ndelay(10000);\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void) {\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void) {\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data) {\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class) {\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void) {\nif (lmh_join_status_get() != LMH_SET) {\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\ndata = \" Uvi Data: \" + String(uvi) + \" Uvs Data: \" + String(uvs) + \" Lux Data: \" + String(lux) + \" lx \" ;\n\nSerial.println(data);\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\nuint16_t uvi_data = uvi;            // Uvi data from RAK12019\nuint32_t uvs_data = uvs;            // Uvs data from RAK12019\nuint32_t lux_data = lux;            // Lux data from RAK12010\n\nm_lora_app_data.buffer[i++] = 0x01;  // byte[0]\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\n// Data from RAK12019 module\nm_lora_app_data.buffer[i++] = (uint8_t)((uvi_data & 0x0000FF00) >> 8);     // byte[1]\nm_lora_app_data.buffer[i++] = (uint8_t)(uvi_data & 0x000000FF);            // byte[2]\n\n// Data from RAK12019 module\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0xFF000000) >> 24);    // byte[3]\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0x00FF0000) >> 16);    // byte[4]\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0x0000FF00) >> 8);     // byte[5]\nm_lora_app_data.buffer[i++] = (uint8_t)(uvs_data & 0x000000FF);            // byte[6]\n\n// Data from RAK12010 module\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0xFF000000) >> 24);    // byte[7]\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0x00FF0000) >> 16);    // byte[8]\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0x0000FF00) >> 8);     // byte[9]\nm_lora_app_data.buffer[i++] = (uint8_t)(lux_data & 0x000000FF);            // byte[10]\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS) {\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n} else {\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xE9, 0x0D, 0x28, 0x1D, 0x92, 0x3D, 0xE4, 0x9F, 0xD9, 0xF7, 0xE0, 0x5F, 0x39, 0x10, 0x55, 0x71 };\n\n```  \n> **Image:** OTAA device successfully registered to TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "8ebd8dc2e5a7385b48bc7e1361c0f8ab", "product_family": "wisblock", "product_id": "kit6-light-and-color", "category": "How-To", "title": "WisBlock IoT Education Kit - Light & Color Quick Start Guide > WisBlock IoT Education Kit - Light & Color Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock IoT Education Kit - Light & Color using TTN and Qubitro > UV Index & UV Intensity Monitoring LoRaWAN Application > LoRaWAN Code for UV Index & UV Intensity Monitoring > Programming UV Index & UV Intensity Monitoring Device with Arduino IDE [CODE]", "content": "/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void) {\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data) {\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",", "keywords": ["Arduino IDE", "RAK4631", "UV Index", "UV Intensity", "LoRaWAN", "SX126x-Arduino"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **UV Index & UV Intensity Monitoring** device. Just copy the code below for **UV Index & UV Intensity Monitoring LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the example </summary>  \n```c\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h>  //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n#include \"UVlight_LTR390.h\"                // http://librarymanager/All#RAK12019_LTR390\nUVlight_LTR390 ltr = UVlight_LTR390();\n\n#include \"Light_VEML7700.h\"                // http://librarymanager/All#Light_veml7700\nLight_VEML7700 VMEL = Light_VEML7700();\n\nuint16_t uvi;\nuint32_t uvs;\nuint32_t lux;\nuint32_t white;\nuint32_t raw_als;\n\n#include <Adafruit_MCP23X17.h>  //http://librarymanager/All#Adafruit_MCP23017\nAdafruit_MCP23X17 mcp;\n\n// Added definitions for the functionality of RAK14003\nconst uint8_t LED_0 = 0;      // PA0 (17) of MCP23017\nconst uint8_t LED_1 = 1;      // PA1 (18) of MCP23017\nconst uint8_t LED_2 = 2;      // PA2 (19) of MCP23017\nconst uint8_t LED_3 = 3;      // PA3 (20) of MCP23017\nconst uint8_t LED_4 = 4;      // PA4 (21) of MCP23017\nconst uint8_t LED_5 = 5;      // PA5 (22) of MCP23017\nconst uint8_t LED_6 = 6;      // PA6 (23) of MCP23017\nconst uint8_t LED_7 = 7;      // PA7 (24) of MCP23017\nconst uint8_t LED_8 = 8;      // PB0 (25) of MCP23017\nconst uint8_t LED_9 = 9;      // PB1 (26) of MCP23017\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define RAK4631_BOARD true\n#else\n#define RAK4631_BOARD false\n#endif\n\nbool doOTAA = true;                                               // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                                       /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                                     /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5                               /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                                        /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;                           /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;                 /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                              /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = { LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF };\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = { BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler };\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xE9, 0x0D, 0x28, 0x1D, 0x92, 0x3D, 0xE4, 0x9F, 0xD9, 0xF7, 0xE0, 0x5F, 0x39, 0x10, 0x55, 0x71 };\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };\nuint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                                            /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];               //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = { m_lora_app_data_buffer, 0, 0, 0, 0 };  //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {\n\n// Initialize Serial for debug output\npinMode(LED_BLUE, OUTPUT);\ndigitalWrite(LED_BLUE, HIGH);\n\n// Sensor Power Switch\npinMode(WB_IO2, OUTPUT);\ndigitalWrite(WB_IO2, HIGH);\n\n// Reset RAK14003 module\npinMode(WB_IO4, OUTPUT);\ndigitalWrite(WB_IO4, HIGH);\ndelay(10);\ndigitalWrite(WB_IO4, LOW);\ndelay(10);\ndigitalWrite(WB_IO4, HIGH);\ndelay(10);\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial) {\nif ((millis() - timeout) < 5000) {\ndelay(100);\n} else {\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA) {\nSerial.println(\"Type: OTAA\");\n} else {\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion) {\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA) {\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n} else {\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0) {\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"================================\");\nSerial.println(\"RAK12019 + RAK12010 LoRaWAN Code\");\nSerial.println(\"================================\");\n\nif (!VMEL.begin())\n{\nSerial.println(\"Sensor not found\");\nwhile (1);\n}\n\nVMEL.setGain(VEML7700_GAIN_1);\nVMEL.setIntegrationTime(VEML7700_IT_800MS);\n\nSerial.print(F(\"Gain: \"));\nswitch (VMEL.getGain())\n{\ncase VEML7700_GAIN_1: Serial.println(\"1\"); break;\ncase VEML7700_GAIN_2: Serial.println(\"2\"); break;\ncase VEML7700_GAIN_1_4: Serial.println(\"1/4\"); break;\ncase VEML7700_GAIN_1_8: Serial.println(\"1/8\"); break;\n}\n\nSerial.print(F(\"Integration Time (ms): \"));\nswitch (VMEL.getIntegrationTime())\n{\ncase VEML7700_IT_25MS: Serial.println(\"25\"); break;\ncase VEML7700_IT_50MS: Serial.println(\"50\"); break;\ncase VEML7700_IT_100MS: Serial.println(\"100\"); break;\ncase VEML7700_IT_200MS: Serial.println(\"200\"); break;\ncase VEML7700_IT_400MS: Serial.println(\"400\"); break;\ncase VEML7700_IT_800MS: Serial.println(\"800\"); break;\n}\n\nSerial.println(\"RAK12019 test\");\nWire.begin();\nif (!ltr.init())\n{\nSerial.println(\"Couldn't find LTR sensor!\");\nwhile (1)\ndelay(10);\n}\nSerial.println(\"Found LTR390 sensor!\");\n\n//set to LTR390_MODE_UVS,get ultraviolet light data.\nltr.setMode(LTR390_MODE_UVS);  // UVS Mode\n\nSerial.println(\"In UVS mode\");\n\nltr.setGain(LTR390_GAIN_3);\nSerial.print(\"Gain : \");\nswitch (ltr.getGain())\n{\ncase LTR390_GAIN_1:\nSerial.println(1);\nbreak;\ncase LTR390_GAIN_3:\nSerial.println(3);\nbreak;\ncase LTR390_GAIN_6:\nSerial.println(6);\nbreak;\ncase LTR390_GAIN_9:\nSerial.println(9);\nbreak;\ncase LTR390_GAIN_18:\nSerial.println(18);\nbreak;\ndefault:\nSerial.println(\"Failed to set gain\");\nbreak;\n}\nltr.setResolution(LTR390_RESOLUTION_16BIT);\nSerial.print(\"Integration Time (ms): \");\nswitch (ltr.getResolution())\n{\ncase LTR390_RESOLUTION_13BIT:\nSerial.println(13);\nbreak;\ncase LTR390_RESOLUTION_16BIT:\nSerial.println(16);\nbreak;\ncase LTR390_RESOLUTION_17BIT:\nSerial.println(17);\nbreak;\ncase LTR390_RESOLUTION_18BIT:\nSerial.println(18);\nbreak;\ncase LTR390_RESOLUTION_19BIT:\nSerial.println(19);\nbreak;\ncase LTR390_RESOLUTION_20BIT:\nSerial.println(20);\nbreak;\ndefault:\nSerial.println(\"Failed to set Integration Time\");\nbreak;\n}\n\nltr.setThresholds(100, 1000); //Set the interrupt output threshold range for lower and upper.\n\nltr.configInterrupt(true, LTR390_MODE_UVS);\n\n// For RAK14003\nmcp.begin_I2C(0x24);\n\n// Added for the functionality of RAK14003\n\nWire.begin();    // initialize I2C serial bus\n\n// Configuration of MCP23017 I/O ports\nmcp.pinMode(LED_0, OUTPUT);     // Red LED; Top most\nmcp.pinMode(LED_1, OUTPUT);     // Red LED\nmcp.pinMode(LED_2, OUTPUT);     // Orange LED\nmcp.pinMode(LED_3, OUTPUT);     // Orange LED\nmcp.pinMode(LED_4, OUTPUT);     // Orange LED\nmcp.pinMode(LED_5, OUTPUT);     // Green LED\nmcp.pinMode(LED_6, OUTPUT);     // Green LED\nmcp.pinMode(LED_7, OUTPUT);     // Green LED\nmcp.pinMode(LED_8, OUTPUT);     // Green LED\nmcp.pinMode(LED_9, OUTPUT);     // Green LED; Bottom\n\n// Initially Turn OFF all LEDs\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, HIGH);\n\n}\n\nvoid loop() {\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\n// Trial # 1\n// Data from RAK12019\nif (ltr.newDataAvailable())\n{\nuvi = ltr.getUVI();\nuvs = ltr.readUVS();\n}\n\n// Data from RAK12010\nlux = VMEL.readLux();\nwhite = VMEL.readWhite();\nraw_als = VMEL.readALS();\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\n\n// From RAK12019 module\nSerial.print(\"UVI: \");\nSerial.println(uvi);          // Uvi data from RAK12019\nSerial.print(\"UVS: \");\nSerial.println(uvs);            // Uvs data from RAK12019\n\n// From RAK12010\nSerial.print(\"Lux: \");\nSerial.print(lux);\nSerial.println(\" lx \");\nSerial.print(\"White: \");\nSerial.println(white);\nSerial.print(\"Raw ALS: \");\nSerial.println(raw_als);\n\n// Result of uvi to be displayed via RAK14003 module\nif (uvi <= 0.4)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, HIGH);\n}\n\nelse if (uvi > 0.5 && uvi <= 1)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 1.5 && uvi <= 2)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 2.5 && uvi <= 3)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 3.5 && uvi <= 4)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 4.5 && uvi <= 5)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 5.5 && uvi <= 6)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 6.5 && uvi <= 7)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 7.5 && uvi <= 8)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 8.5 && uvi <= 9.5)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, LOW);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi >= 10)\n{\nmcp.digitalWrite(LED_0, LOW);\nmcp.digitalWrite(LED_1, LOW);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\ndelay(10000);\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void) {\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void) {\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data) {\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class) {\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void) {\nif (lmh_join_status_get() != LMH_SET) {\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\ndata = \" Uvi Data: \" + String(uvi) + \" Uvs Data: \" + String(uvs) + \" Lux Data: \" + String(lux) + \" lx \" ;\n\nSerial.println(data);\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\nuint16_t uvi_data = uvi;            // Uvi data from RAK12019\nuint32_t uvs_data = uvs;            // Uvs data from RAK12019\nuint32_t lux_data = lux;            // Lux data from RAK12010\n\nm_lora_app_data.buffer[i++] = 0x01;  // byte[0]\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\n// Data from RAK12019 module\nm_lora_app_data.buffer[i++] = (uint8_t)((uvi_data & 0x0000FF00) >> 8);     // byte[1]\nm_lora_app_data.buffer[i++] = (uint8_t)(uvi_data & 0x000000FF);            // byte[2]\n\n// Data from RAK12019 module\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0xFF000000) >> 24);    // byte[3]\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0x00FF0000) >> 16);    // byte[4]\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0x0000FF00) >> 8);     // byte[5]\nm_lora_app_data.buffer[i++] = (uint8_t)(uvs_data & 0x000000FF);            // byte[6]\n\n// Data from RAK12010 module\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0xFF000000) >> 24);    // byte[7]\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0x00FF0000) >> 16);    // byte[8]\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0x0000FF00) >> 8);     // byte[9]\nm_lora_app_data.buffer[i++] = (uint8_t)(lux_data & 0x000000FF);            // byte[10]\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS) {\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n} else {\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xE9, 0x0D, 0x28, 0x1D, 0x92, 0x3D, 0xE4, 0x9F, 0xD9, 0xF7, 0xE0, 0x5F, 0x39, 0x10, 0x55, 0x71 };\n\n```  \n> **Image:** OTAA device successfully registered to TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "3465302e32a1969efb2b65dc0f5d4c0a", "product_family": "wisblock", "product_id": "kit6-light-and-color", "category": "How-To", "title": "WisBlock IoT Education Kit - Light & Color Quick Start Guide > WisBlock IoT Education Kit - Light & Color Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock IoT Education Kit - Light & Color using TTN and Qubitro > UV Index & UV Intensity Monitoring LoRaWAN Application > LoRaWAN Code for UV Index & UV Intensity Monitoring > Programming UV Index & UV Intensity Monitoring Device with Arduino IDE [CODE]", "content": "Serial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}", "keywords": ["Arduino IDE", "RAK4631", "UV Index", "UV Intensity", "LoRaWAN", "SX126x-Arduino"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **UV Index & UV Intensity Monitoring** device. Just copy the code below for **UV Index & UV Intensity Monitoring LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the example </summary>  \n```c\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h>  //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n#include \"UVlight_LTR390.h\"                // http://librarymanager/All#RAK12019_LTR390\nUVlight_LTR390 ltr = UVlight_LTR390();\n\n#include \"Light_VEML7700.h\"                // http://librarymanager/All#Light_veml7700\nLight_VEML7700 VMEL = Light_VEML7700();\n\nuint16_t uvi;\nuint32_t uvs;\nuint32_t lux;\nuint32_t white;\nuint32_t raw_als;\n\n#include <Adafruit_MCP23X17.h>  //http://librarymanager/All#Adafruit_MCP23017\nAdafruit_MCP23X17 mcp;\n\n// Added definitions for the functionality of RAK14003\nconst uint8_t LED_0 = 0;      // PA0 (17) of MCP23017\nconst uint8_t LED_1 = 1;      // PA1 (18) of MCP23017\nconst uint8_t LED_2 = 2;      // PA2 (19) of MCP23017\nconst uint8_t LED_3 = 3;      // PA3 (20) of MCP23017\nconst uint8_t LED_4 = 4;      // PA4 (21) of MCP23017\nconst uint8_t LED_5 = 5;      // PA5 (22) of MCP23017\nconst uint8_t LED_6 = 6;      // PA6 (23) of MCP23017\nconst uint8_t LED_7 = 7;      // PA7 (24) of MCP23017\nconst uint8_t LED_8 = 8;      // PB0 (25) of MCP23017\nconst uint8_t LED_9 = 9;      // PB1 (26) of MCP23017\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define RAK4631_BOARD true\n#else\n#define RAK4631_BOARD false\n#endif\n\nbool doOTAA = true;                                               // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                                       /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                                     /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5                               /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                                        /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;                           /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;                 /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                              /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = { LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF };\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = { BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler };\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xE9, 0x0D, 0x28, 0x1D, 0x92, 0x3D, 0xE4, 0x9F, 0xD9, 0xF7, 0xE0, 0x5F, 0x39, 0x10, 0x55, 0x71 };\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };\nuint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                                            /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];               //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = { m_lora_app_data_buffer, 0, 0, 0, 0 };  //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {\n\n// Initialize Serial for debug output\npinMode(LED_BLUE, OUTPUT);\ndigitalWrite(LED_BLUE, HIGH);\n\n// Sensor Power Switch\npinMode(WB_IO2, OUTPUT);\ndigitalWrite(WB_IO2, HIGH);\n\n// Reset RAK14003 module\npinMode(WB_IO4, OUTPUT);\ndigitalWrite(WB_IO4, HIGH);\ndelay(10);\ndigitalWrite(WB_IO4, LOW);\ndelay(10);\ndigitalWrite(WB_IO4, HIGH);\ndelay(10);\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial) {\nif ((millis() - timeout) < 5000) {\ndelay(100);\n} else {\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA) {\nSerial.println(\"Type: OTAA\");\n} else {\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion) {\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA) {\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n} else {\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0) {\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"================================\");\nSerial.println(\"RAK12019 + RAK12010 LoRaWAN Code\");\nSerial.println(\"================================\");\n\nif (!VMEL.begin())\n{\nSerial.println(\"Sensor not found\");\nwhile (1);\n}\n\nVMEL.setGain(VEML7700_GAIN_1);\nVMEL.setIntegrationTime(VEML7700_IT_800MS);\n\nSerial.print(F(\"Gain: \"));\nswitch (VMEL.getGain())\n{\ncase VEML7700_GAIN_1: Serial.println(\"1\"); break;\ncase VEML7700_GAIN_2: Serial.println(\"2\"); break;\ncase VEML7700_GAIN_1_4: Serial.println(\"1/4\"); break;\ncase VEML7700_GAIN_1_8: Serial.println(\"1/8\"); break;\n}\n\nSerial.print(F(\"Integration Time (ms): \"));\nswitch (VMEL.getIntegrationTime())\n{\ncase VEML7700_IT_25MS: Serial.println(\"25\"); break;\ncase VEML7700_IT_50MS: Serial.println(\"50\"); break;\ncase VEML7700_IT_100MS: Serial.println(\"100\"); break;\ncase VEML7700_IT_200MS: Serial.println(\"200\"); break;\ncase VEML7700_IT_400MS: Serial.println(\"400\"); break;\ncase VEML7700_IT_800MS: Serial.println(\"800\"); break;\n}\n\nSerial.println(\"RAK12019 test\");\nWire.begin();\nif (!ltr.init())\n{\nSerial.println(\"Couldn't find LTR sensor!\");\nwhile (1)\ndelay(10);\n}\nSerial.println(\"Found LTR390 sensor!\");\n\n//set to LTR390_MODE_UVS,get ultraviolet light data.\nltr.setMode(LTR390_MODE_UVS);  // UVS Mode\n\nSerial.println(\"In UVS mode\");\n\nltr.setGain(LTR390_GAIN_3);\nSerial.print(\"Gain : \");\nswitch (ltr.getGain())\n{\ncase LTR390_GAIN_1:\nSerial.println(1);\nbreak;\ncase LTR390_GAIN_3:\nSerial.println(3);\nbreak;\ncase LTR390_GAIN_6:\nSerial.println(6);\nbreak;\ncase LTR390_GAIN_9:\nSerial.println(9);\nbreak;\ncase LTR390_GAIN_18:\nSerial.println(18);\nbreak;\ndefault:\nSerial.println(\"Failed to set gain\");\nbreak;\n}\nltr.setResolution(LTR390_RESOLUTION_16BIT);\nSerial.print(\"Integration Time (ms): \");\nswitch (ltr.getResolution())\n{\ncase LTR390_RESOLUTION_13BIT:\nSerial.println(13);\nbreak;\ncase LTR390_RESOLUTION_16BIT:\nSerial.println(16);\nbreak;\ncase LTR390_RESOLUTION_17BIT:\nSerial.println(17);\nbreak;\ncase LTR390_RESOLUTION_18BIT:\nSerial.println(18);\nbreak;\ncase LTR390_RESOLUTION_19BIT:\nSerial.println(19);\nbreak;\ncase LTR390_RESOLUTION_20BIT:\nSerial.println(20);\nbreak;\ndefault:\nSerial.println(\"Failed to set Integration Time\");\nbreak;\n}\n\nltr.setThresholds(100, 1000); //Set the interrupt output threshold range for lower and upper.\n\nltr.configInterrupt(true, LTR390_MODE_UVS);\n\n// For RAK14003\nmcp.begin_I2C(0x24);\n\n// Added for the functionality of RAK14003\n\nWire.begin();    // initialize I2C serial bus\n\n// Configuration of MCP23017 I/O ports\nmcp.pinMode(LED_0, OUTPUT);     // Red LED; Top most\nmcp.pinMode(LED_1, OUTPUT);     // Red LED\nmcp.pinMode(LED_2, OUTPUT);     // Orange LED\nmcp.pinMode(LED_3, OUTPUT);     // Orange LED\nmcp.pinMode(LED_4, OUTPUT);     // Orange LED\nmcp.pinMode(LED_5, OUTPUT);     // Green LED\nmcp.pinMode(LED_6, OUTPUT);     // Green LED\nmcp.pinMode(LED_7, OUTPUT);     // Green LED\nmcp.pinMode(LED_8, OUTPUT);     // Green LED\nmcp.pinMode(LED_9, OUTPUT);     // Green LED; Bottom\n\n// Initially Turn OFF all LEDs\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, HIGH);\n\n}\n\nvoid loop() {\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\n// Trial # 1\n// Data from RAK12019\nif (ltr.newDataAvailable())\n{\nuvi = ltr.getUVI();\nuvs = ltr.readUVS();\n}\n\n// Data from RAK12010\nlux = VMEL.readLux();\nwhite = VMEL.readWhite();\nraw_als = VMEL.readALS();\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\n\n// From RAK12019 module\nSerial.print(\"UVI: \");\nSerial.println(uvi);          // Uvi data from RAK12019\nSerial.print(\"UVS: \");\nSerial.println(uvs);            // Uvs data from RAK12019\n\n// From RAK12010\nSerial.print(\"Lux: \");\nSerial.print(lux);\nSerial.println(\" lx \");\nSerial.print(\"White: \");\nSerial.println(white);\nSerial.print(\"Raw ALS: \");\nSerial.println(raw_als);\n\n// Result of uvi to be displayed via RAK14003 module\nif (uvi <= 0.4)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, HIGH);\n}\n\nelse if (uvi > 0.5 && uvi <= 1)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 1.5 && uvi <= 2)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 2.5 && uvi <= 3)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 3.5 && uvi <= 4)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 4.5 && uvi <= 5)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 5.5 && uvi <= 6)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 6.5 && uvi <= 7)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 7.5 && uvi <= 8)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 8.5 && uvi <= 9.5)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, LOW);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi >= 10)\n{\nmcp.digitalWrite(LED_0, LOW);\nmcp.digitalWrite(LED_1, LOW);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\ndelay(10000);\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void) {\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void) {\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data) {\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class) {\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void) {\nif (lmh_join_status_get() != LMH_SET) {\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\ndata = \" Uvi Data: \" + String(uvi) + \" Uvs Data: \" + String(uvs) + \" Lux Data: \" + String(lux) + \" lx \" ;\n\nSerial.println(data);\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\nuint16_t uvi_data = uvi;            // Uvi data from RAK12019\nuint32_t uvs_data = uvs;            // Uvs data from RAK12019\nuint32_t lux_data = lux;            // Lux data from RAK12010\n\nm_lora_app_data.buffer[i++] = 0x01;  // byte[0]\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\n// Data from RAK12019 module\nm_lora_app_data.buffer[i++] = (uint8_t)((uvi_data & 0x0000FF00) >> 8);     // byte[1]\nm_lora_app_data.buffer[i++] = (uint8_t)(uvi_data & 0x000000FF);            // byte[2]\n\n// Data from RAK12019 module\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0xFF000000) >> 24);    // byte[3]\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0x00FF0000) >> 16);    // byte[4]\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0x0000FF00) >> 8);     // byte[5]\nm_lora_app_data.buffer[i++] = (uint8_t)(uvs_data & 0x000000FF);            // byte[6]\n\n// Data from RAK12010 module\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0xFF000000) >> 24);    // byte[7]\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0x00FF0000) >> 16);    // byte[8]\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0x0000FF00) >> 8);     // byte[9]\nm_lora_app_data.buffer[i++] = (uint8_t)(lux_data & 0x000000FF);            // byte[10]\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS) {\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n} else {\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xE9, 0x0D, 0x28, 0x1D, 0x92, 0x3D, 0xE4, 0x9F, 0xD9, 0xF7, 0xE0, 0x5F, 0x39, 0x10, 0x55, 0x71 };\n\n```  \n> **Image:** OTAA device successfully registered to TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "c92c3a8621af156ea8d33bd2ebf88f68", "product_family": "wisblock", "product_id": "kit6-light-and-color", "category": "How-To", "title": "WisBlock IoT Education Kit - Light & Color Quick Start Guide > WisBlock IoT Education Kit - Light & Color Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock IoT Education Kit - Light & Color using TTN and Qubitro > UV Index & UV Intensity Monitoring LoRaWAN Application > LoRaWAN Code for UV Index & UV Intensity Monitoring > Programming UV Index & UV Intensity Monitoring Device with Arduino IDE [CODE]", "content": "void lorawan_confirm_class_handler(DeviceClass_t Class) {\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void) {\nif (lmh_join_status_get() != LMH_SET) {\n//Not joined, try again later\nreturn;\n}", "keywords": ["Arduino IDE", "RAK4631", "UV Index", "UV Intensity", "LoRaWAN", "SX126x-Arduino"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **UV Index & UV Intensity Monitoring** device. Just copy the code below for **UV Index & UV Intensity Monitoring LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the example </summary>  \n```c\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h>  //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n#include \"UVlight_LTR390.h\"                // http://librarymanager/All#RAK12019_LTR390\nUVlight_LTR390 ltr = UVlight_LTR390();\n\n#include \"Light_VEML7700.h\"                // http://librarymanager/All#Light_veml7700\nLight_VEML7700 VMEL = Light_VEML7700();\n\nuint16_t uvi;\nuint32_t uvs;\nuint32_t lux;\nuint32_t white;\nuint32_t raw_als;\n\n#include <Adafruit_MCP23X17.h>  //http://librarymanager/All#Adafruit_MCP23017\nAdafruit_MCP23X17 mcp;\n\n// Added definitions for the functionality of RAK14003\nconst uint8_t LED_0 = 0;      // PA0 (17) of MCP23017\nconst uint8_t LED_1 = 1;      // PA1 (18) of MCP23017\nconst uint8_t LED_2 = 2;      // PA2 (19) of MCP23017\nconst uint8_t LED_3 = 3;      // PA3 (20) of MCP23017\nconst uint8_t LED_4 = 4;      // PA4 (21) of MCP23017\nconst uint8_t LED_5 = 5;      // PA5 (22) of MCP23017\nconst uint8_t LED_6 = 6;      // PA6 (23) of MCP23017\nconst uint8_t LED_7 = 7;      // PA7 (24) of MCP23017\nconst uint8_t LED_8 = 8;      // PB0 (25) of MCP23017\nconst uint8_t LED_9 = 9;      // PB1 (26) of MCP23017\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define RAK4631_BOARD true\n#else\n#define RAK4631_BOARD false\n#endif\n\nbool doOTAA = true;                                               // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                                       /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                                     /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5                               /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                                        /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;                           /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;                 /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                              /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = { LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF };\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = { BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler };\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xE9, 0x0D, 0x28, 0x1D, 0x92, 0x3D, 0xE4, 0x9F, 0xD9, 0xF7, 0xE0, 0x5F, 0x39, 0x10, 0x55, 0x71 };\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };\nuint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                                            /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];               //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = { m_lora_app_data_buffer, 0, 0, 0, 0 };  //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {\n\n// Initialize Serial for debug output\npinMode(LED_BLUE, OUTPUT);\ndigitalWrite(LED_BLUE, HIGH);\n\n// Sensor Power Switch\npinMode(WB_IO2, OUTPUT);\ndigitalWrite(WB_IO2, HIGH);\n\n// Reset RAK14003 module\npinMode(WB_IO4, OUTPUT);\ndigitalWrite(WB_IO4, HIGH);\ndelay(10);\ndigitalWrite(WB_IO4, LOW);\ndelay(10);\ndigitalWrite(WB_IO4, HIGH);\ndelay(10);\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial) {\nif ((millis() - timeout) < 5000) {\ndelay(100);\n} else {\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA) {\nSerial.println(\"Type: OTAA\");\n} else {\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion) {\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA) {\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n} else {\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0) {\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"================================\");\nSerial.println(\"RAK12019 + RAK12010 LoRaWAN Code\");\nSerial.println(\"================================\");\n\nif (!VMEL.begin())\n{\nSerial.println(\"Sensor not found\");\nwhile (1);\n}\n\nVMEL.setGain(VEML7700_GAIN_1);\nVMEL.setIntegrationTime(VEML7700_IT_800MS);\n\nSerial.print(F(\"Gain: \"));\nswitch (VMEL.getGain())\n{\ncase VEML7700_GAIN_1: Serial.println(\"1\"); break;\ncase VEML7700_GAIN_2: Serial.println(\"2\"); break;\ncase VEML7700_GAIN_1_4: Serial.println(\"1/4\"); break;\ncase VEML7700_GAIN_1_8: Serial.println(\"1/8\"); break;\n}\n\nSerial.print(F(\"Integration Time (ms): \"));\nswitch (VMEL.getIntegrationTime())\n{\ncase VEML7700_IT_25MS: Serial.println(\"25\"); break;\ncase VEML7700_IT_50MS: Serial.println(\"50\"); break;\ncase VEML7700_IT_100MS: Serial.println(\"100\"); break;\ncase VEML7700_IT_200MS: Serial.println(\"200\"); break;\ncase VEML7700_IT_400MS: Serial.println(\"400\"); break;\ncase VEML7700_IT_800MS: Serial.println(\"800\"); break;\n}\n\nSerial.println(\"RAK12019 test\");\nWire.begin();\nif (!ltr.init())\n{\nSerial.println(\"Couldn't find LTR sensor!\");\nwhile (1)\ndelay(10);\n}\nSerial.println(\"Found LTR390 sensor!\");\n\n//set to LTR390_MODE_UVS,get ultraviolet light data.\nltr.setMode(LTR390_MODE_UVS);  // UVS Mode\n\nSerial.println(\"In UVS mode\");\n\nltr.setGain(LTR390_GAIN_3);\nSerial.print(\"Gain : \");\nswitch (ltr.getGain())\n{\ncase LTR390_GAIN_1:\nSerial.println(1);\nbreak;\ncase LTR390_GAIN_3:\nSerial.println(3);\nbreak;\ncase LTR390_GAIN_6:\nSerial.println(6);\nbreak;\ncase LTR390_GAIN_9:\nSerial.println(9);\nbreak;\ncase LTR390_GAIN_18:\nSerial.println(18);\nbreak;\ndefault:\nSerial.println(\"Failed to set gain\");\nbreak;\n}\nltr.setResolution(LTR390_RESOLUTION_16BIT);\nSerial.print(\"Integration Time (ms): \");\nswitch (ltr.getResolution())\n{\ncase LTR390_RESOLUTION_13BIT:\nSerial.println(13);\nbreak;\ncase LTR390_RESOLUTION_16BIT:\nSerial.println(16);\nbreak;\ncase LTR390_RESOLUTION_17BIT:\nSerial.println(17);\nbreak;\ncase LTR390_RESOLUTION_18BIT:\nSerial.println(18);\nbreak;\ncase LTR390_RESOLUTION_19BIT:\nSerial.println(19);\nbreak;\ncase LTR390_RESOLUTION_20BIT:\nSerial.println(20);\nbreak;\ndefault:\nSerial.println(\"Failed to set Integration Time\");\nbreak;\n}\n\nltr.setThresholds(100, 1000); //Set the interrupt output threshold range for lower and upper.\n\nltr.configInterrupt(true, LTR390_MODE_UVS);\n\n// For RAK14003\nmcp.begin_I2C(0x24);\n\n// Added for the functionality of RAK14003\n\nWire.begin();    // initialize I2C serial bus\n\n// Configuration of MCP23017 I/O ports\nmcp.pinMode(LED_0, OUTPUT);     // Red LED; Top most\nmcp.pinMode(LED_1, OUTPUT);     // Red LED\nmcp.pinMode(LED_2, OUTPUT);     // Orange LED\nmcp.pinMode(LED_3, OUTPUT);     // Orange LED\nmcp.pinMode(LED_4, OUTPUT);     // Orange LED\nmcp.pinMode(LED_5, OUTPUT);     // Green LED\nmcp.pinMode(LED_6, OUTPUT);     // Green LED\nmcp.pinMode(LED_7, OUTPUT);     // Green LED\nmcp.pinMode(LED_8, OUTPUT);     // Green LED\nmcp.pinMode(LED_9, OUTPUT);     // Green LED; Bottom\n\n// Initially Turn OFF all LEDs\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, HIGH);\n\n}\n\nvoid loop() {\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\n// Trial # 1\n// Data from RAK12019\nif (ltr.newDataAvailable())\n{\nuvi = ltr.getUVI();\nuvs = ltr.readUVS();\n}\n\n// Data from RAK12010\nlux = VMEL.readLux();\nwhite = VMEL.readWhite();\nraw_als = VMEL.readALS();\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\n\n// From RAK12019 module\nSerial.print(\"UVI: \");\nSerial.println(uvi);          // Uvi data from RAK12019\nSerial.print(\"UVS: \");\nSerial.println(uvs);            // Uvs data from RAK12019\n\n// From RAK12010\nSerial.print(\"Lux: \");\nSerial.print(lux);\nSerial.println(\" lx \");\nSerial.print(\"White: \");\nSerial.println(white);\nSerial.print(\"Raw ALS: \");\nSerial.println(raw_als);\n\n// Result of uvi to be displayed via RAK14003 module\nif (uvi <= 0.4)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, HIGH);\n}\n\nelse if (uvi > 0.5 && uvi <= 1)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 1.5 && uvi <= 2)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 2.5 && uvi <= 3)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 3.5 && uvi <= 4)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 4.5 && uvi <= 5)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 5.5 && uvi <= 6)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 6.5 && uvi <= 7)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 7.5 && uvi <= 8)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 8.5 && uvi <= 9.5)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, LOW);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi >= 10)\n{\nmcp.digitalWrite(LED_0, LOW);\nmcp.digitalWrite(LED_1, LOW);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\ndelay(10000);\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void) {\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void) {\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data) {\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class) {\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void) {\nif (lmh_join_status_get() != LMH_SET) {\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\ndata = \" Uvi Data: \" + String(uvi) + \" Uvs Data: \" + String(uvs) + \" Lux Data: \" + String(lux) + \" lx \" ;\n\nSerial.println(data);\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\nuint16_t uvi_data = uvi;            // Uvi data from RAK12019\nuint32_t uvs_data = uvs;            // Uvs data from RAK12019\nuint32_t lux_data = lux;            // Lux data from RAK12010\n\nm_lora_app_data.buffer[i++] = 0x01;  // byte[0]\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\n// Data from RAK12019 module\nm_lora_app_data.buffer[i++] = (uint8_t)((uvi_data & 0x0000FF00) >> 8);     // byte[1]\nm_lora_app_data.buffer[i++] = (uint8_t)(uvi_data & 0x000000FF);            // byte[2]\n\n// Data from RAK12019 module\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0xFF000000) >> 24);    // byte[3]\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0x00FF0000) >> 16);    // byte[4]\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0x0000FF00) >> 8);     // byte[5]\nm_lora_app_data.buffer[i++] = (uint8_t)(uvs_data & 0x000000FF);            // byte[6]\n\n// Data from RAK12010 module\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0xFF000000) >> 24);    // byte[7]\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0x00FF0000) >> 16);    // byte[8]\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0x0000FF00) >> 8);     // byte[9]\nm_lora_app_data.buffer[i++] = (uint8_t)(lux_data & 0x000000FF);            // byte[10]\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS) {\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n} else {\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xE9, 0x0D, 0x28, 0x1D, 0x92, 0x3D, 0xE4, 0x9F, 0xD9, 0xF7, 0xE0, 0x5F, 0x39, 0x10, 0x55, 0x71 };\n\n```  \n> **Image:** OTAA device successfully registered to TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "e0063264c87e5a9043ab7797d9e7a197", "product_family": "wisblock", "product_id": "kit6-light-and-color", "category": "How-To", "title": "WisBlock IoT Education Kit - Light & Color Quick Start Guide > WisBlock IoT Education Kit - Light & Color Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock IoT Education Kit - Light & Color using TTN and Qubitro > UV Index & UV Intensity Monitoring LoRaWAN Application > LoRaWAN Code for UV Index & UV Intensity Monitoring > Programming UV Index & UV Intensity Monitoring Device with Arduino IDE [CODE]", "content": "Serial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\ndata = \" Uvi Data: \" + String(uvi) + \" Uvs Data: \" + String(uvs) + \" Lux Data: \" + String(lux) + \" lx \" ;\n\nSerial.println(data);", "keywords": ["Arduino IDE", "RAK4631", "UV Index", "UV Intensity", "LoRaWAN", "SX126x-Arduino"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **UV Index & UV Intensity Monitoring** device. Just copy the code below for **UV Index & UV Intensity Monitoring LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the example </summary>  \n```c\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h>  //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n#include \"UVlight_LTR390.h\"                // http://librarymanager/All#RAK12019_LTR390\nUVlight_LTR390 ltr = UVlight_LTR390();\n\n#include \"Light_VEML7700.h\"                // http://librarymanager/All#Light_veml7700\nLight_VEML7700 VMEL = Light_VEML7700();\n\nuint16_t uvi;\nuint32_t uvs;\nuint32_t lux;\nuint32_t white;\nuint32_t raw_als;\n\n#include <Adafruit_MCP23X17.h>  //http://librarymanager/All#Adafruit_MCP23017\nAdafruit_MCP23X17 mcp;\n\n// Added definitions for the functionality of RAK14003\nconst uint8_t LED_0 = 0;      // PA0 (17) of MCP23017\nconst uint8_t LED_1 = 1;      // PA1 (18) of MCP23017\nconst uint8_t LED_2 = 2;      // PA2 (19) of MCP23017\nconst uint8_t LED_3 = 3;      // PA3 (20) of MCP23017\nconst uint8_t LED_4 = 4;      // PA4 (21) of MCP23017\nconst uint8_t LED_5 = 5;      // PA5 (22) of MCP23017\nconst uint8_t LED_6 = 6;      // PA6 (23) of MCP23017\nconst uint8_t LED_7 = 7;      // PA7 (24) of MCP23017\nconst uint8_t LED_8 = 8;      // PB0 (25) of MCP23017\nconst uint8_t LED_9 = 9;      // PB1 (26) of MCP23017\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define RAK4631_BOARD true\n#else\n#define RAK4631_BOARD false\n#endif\n\nbool doOTAA = true;                                               // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                                       /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                                     /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5                               /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                                        /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;                           /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;                 /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                              /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = { LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF };\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = { BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler };\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xE9, 0x0D, 0x28, 0x1D, 0x92, 0x3D, 0xE4, 0x9F, 0xD9, 0xF7, 0xE0, 0x5F, 0x39, 0x10, 0x55, 0x71 };\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };\nuint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                                            /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];               //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = { m_lora_app_data_buffer, 0, 0, 0, 0 };  //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {\n\n// Initialize Serial for debug output\npinMode(LED_BLUE, OUTPUT);\ndigitalWrite(LED_BLUE, HIGH);\n\n// Sensor Power Switch\npinMode(WB_IO2, OUTPUT);\ndigitalWrite(WB_IO2, HIGH);\n\n// Reset RAK14003 module\npinMode(WB_IO4, OUTPUT);\ndigitalWrite(WB_IO4, HIGH);\ndelay(10);\ndigitalWrite(WB_IO4, LOW);\ndelay(10);\ndigitalWrite(WB_IO4, HIGH);\ndelay(10);\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial) {\nif ((millis() - timeout) < 5000) {\ndelay(100);\n} else {\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA) {\nSerial.println(\"Type: OTAA\");\n} else {\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion) {\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA) {\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n} else {\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0) {\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"================================\");\nSerial.println(\"RAK12019 + RAK12010 LoRaWAN Code\");\nSerial.println(\"================================\");\n\nif (!VMEL.begin())\n{\nSerial.println(\"Sensor not found\");\nwhile (1);\n}\n\nVMEL.setGain(VEML7700_GAIN_1);\nVMEL.setIntegrationTime(VEML7700_IT_800MS);\n\nSerial.print(F(\"Gain: \"));\nswitch (VMEL.getGain())\n{\ncase VEML7700_GAIN_1: Serial.println(\"1\"); break;\ncase VEML7700_GAIN_2: Serial.println(\"2\"); break;\ncase VEML7700_GAIN_1_4: Serial.println(\"1/4\"); break;\ncase VEML7700_GAIN_1_8: Serial.println(\"1/8\"); break;\n}\n\nSerial.print(F(\"Integration Time (ms): \"));\nswitch (VMEL.getIntegrationTime())\n{\ncase VEML7700_IT_25MS: Serial.println(\"25\"); break;\ncase VEML7700_IT_50MS: Serial.println(\"50\"); break;\ncase VEML7700_IT_100MS: Serial.println(\"100\"); break;\ncase VEML7700_IT_200MS: Serial.println(\"200\"); break;\ncase VEML7700_IT_400MS: Serial.println(\"400\"); break;\ncase VEML7700_IT_800MS: Serial.println(\"800\"); break;\n}\n\nSerial.println(\"RAK12019 test\");\nWire.begin();\nif (!ltr.init())\n{\nSerial.println(\"Couldn't find LTR sensor!\");\nwhile (1)\ndelay(10);\n}\nSerial.println(\"Found LTR390 sensor!\");\n\n//set to LTR390_MODE_UVS,get ultraviolet light data.\nltr.setMode(LTR390_MODE_UVS);  // UVS Mode\n\nSerial.println(\"In UVS mode\");\n\nltr.setGain(LTR390_GAIN_3);\nSerial.print(\"Gain : \");\nswitch (ltr.getGain())\n{\ncase LTR390_GAIN_1:\nSerial.println(1);\nbreak;\ncase LTR390_GAIN_3:\nSerial.println(3);\nbreak;\ncase LTR390_GAIN_6:\nSerial.println(6);\nbreak;\ncase LTR390_GAIN_9:\nSerial.println(9);\nbreak;\ncase LTR390_GAIN_18:\nSerial.println(18);\nbreak;\ndefault:\nSerial.println(\"Failed to set gain\");\nbreak;\n}\nltr.setResolution(LTR390_RESOLUTION_16BIT);\nSerial.print(\"Integration Time (ms): \");\nswitch (ltr.getResolution())\n{\ncase LTR390_RESOLUTION_13BIT:\nSerial.println(13);\nbreak;\ncase LTR390_RESOLUTION_16BIT:\nSerial.println(16);\nbreak;\ncase LTR390_RESOLUTION_17BIT:\nSerial.println(17);\nbreak;\ncase LTR390_RESOLUTION_18BIT:\nSerial.println(18);\nbreak;\ncase LTR390_RESOLUTION_19BIT:\nSerial.println(19);\nbreak;\ncase LTR390_RESOLUTION_20BIT:\nSerial.println(20);\nbreak;\ndefault:\nSerial.println(\"Failed to set Integration Time\");\nbreak;\n}\n\nltr.setThresholds(100, 1000); //Set the interrupt output threshold range for lower and upper.\n\nltr.configInterrupt(true, LTR390_MODE_UVS);\n\n// For RAK14003\nmcp.begin_I2C(0x24);\n\n// Added for the functionality of RAK14003\n\nWire.begin();    // initialize I2C serial bus\n\n// Configuration of MCP23017 I/O ports\nmcp.pinMode(LED_0, OUTPUT);     // Red LED; Top most\nmcp.pinMode(LED_1, OUTPUT);     // Red LED\nmcp.pinMode(LED_2, OUTPUT);     // Orange LED\nmcp.pinMode(LED_3, OUTPUT);     // Orange LED\nmcp.pinMode(LED_4, OUTPUT);     // Orange LED\nmcp.pinMode(LED_5, OUTPUT);     // Green LED\nmcp.pinMode(LED_6, OUTPUT);     // Green LED\nmcp.pinMode(LED_7, OUTPUT);     // Green LED\nmcp.pinMode(LED_8, OUTPUT);     // Green LED\nmcp.pinMode(LED_9, OUTPUT);     // Green LED; Bottom\n\n// Initially Turn OFF all LEDs\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, HIGH);\n\n}\n\nvoid loop() {\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\n// Trial # 1\n// Data from RAK12019\nif (ltr.newDataAvailable())\n{\nuvi = ltr.getUVI();\nuvs = ltr.readUVS();\n}\n\n// Data from RAK12010\nlux = VMEL.readLux();\nwhite = VMEL.readWhite();\nraw_als = VMEL.readALS();\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\n\n// From RAK12019 module\nSerial.print(\"UVI: \");\nSerial.println(uvi);          // Uvi data from RAK12019\nSerial.print(\"UVS: \");\nSerial.println(uvs);            // Uvs data from RAK12019\n\n// From RAK12010\nSerial.print(\"Lux: \");\nSerial.print(lux);\nSerial.println(\" lx \");\nSerial.print(\"White: \");\nSerial.println(white);\nSerial.print(\"Raw ALS: \");\nSerial.println(raw_als);\n\n// Result of uvi to be displayed via RAK14003 module\nif (uvi <= 0.4)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, HIGH);\n}\n\nelse if (uvi > 0.5 && uvi <= 1)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 1.5 && uvi <= 2)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 2.5 && uvi <= 3)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 3.5 && uvi <= 4)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 4.5 && uvi <= 5)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 5.5 && uvi <= 6)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 6.5 && uvi <= 7)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 7.5 && uvi <= 8)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 8.5 && uvi <= 9.5)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, LOW);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi >= 10)\n{\nmcp.digitalWrite(LED_0, LOW);\nmcp.digitalWrite(LED_1, LOW);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\ndelay(10000);\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void) {\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void) {\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data) {\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class) {\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void) {\nif (lmh_join_status_get() != LMH_SET) {\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\ndata = \" Uvi Data: \" + String(uvi) + \" Uvs Data: \" + String(uvs) + \" Lux Data: \" + String(lux) + \" lx \" ;\n\nSerial.println(data);\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\nuint16_t uvi_data = uvi;            // Uvi data from RAK12019\nuint32_t uvs_data = uvs;            // Uvs data from RAK12019\nuint32_t lux_data = lux;            // Lux data from RAK12010\n\nm_lora_app_data.buffer[i++] = 0x01;  // byte[0]\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\n// Data from RAK12019 module\nm_lora_app_data.buffer[i++] = (uint8_t)((uvi_data & 0x0000FF00) >> 8);     // byte[1]\nm_lora_app_data.buffer[i++] = (uint8_t)(uvi_data & 0x000000FF);            // byte[2]\n\n// Data from RAK12019 module\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0xFF000000) >> 24);    // byte[3]\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0x00FF0000) >> 16);    // byte[4]\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0x0000FF00) >> 8);     // byte[5]\nm_lora_app_data.buffer[i++] = (uint8_t)(uvs_data & 0x000000FF);            // byte[6]\n\n// Data from RAK12010 module\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0xFF000000) >> 24);    // byte[7]\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0x00FF0000) >> 16);    // byte[8]\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0x0000FF00) >> 8);     // byte[9]\nm_lora_app_data.buffer[i++] = (uint8_t)(lux_data & 0x000000FF);            // byte[10]\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS) {\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n} else {\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xE9, 0x0D, 0x28, 0x1D, 0x92, 0x3D, 0xE4, 0x9F, 0xD9, 0xF7, 0xE0, 0x5F, 0x39, 0x10, 0x55, 0x71 };\n\n```  \n> **Image:** OTAA device successfully registered to TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "2be5ea3a685b554d6c41eb5a80813152", "product_family": "wisblock", "product_id": "kit6-light-and-color", "category": "How-To", "title": "WisBlock IoT Education Kit - Light & Color Quick Start Guide > WisBlock IoT Education Kit - Light & Color Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock IoT Education Kit - Light & Color using TTN and Qubitro > UV Index & UV Intensity Monitoring LoRaWAN Application > LoRaWAN Code for UV Index & UV Intensity Monitoring > Programming UV Index & UV Intensity Monitoring Device with Arduino IDE [CODE]", "content": "Serial.println(data);\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\nuint16_t uvi_data = uvi;            // Uvi data from RAK12019\nuint32_t uvs_data = uvs;            // Uvs data from RAK12019\nuint32_t lux_data = lux;            // Lux data from RAK12010\n\nm_lora_app_data.buffer[i++] = 0x01;  // byte[0]", "keywords": ["Arduino IDE", "RAK4631", "UV Index", "UV Intensity", "LoRaWAN", "SX126x-Arduino"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **UV Index & UV Intensity Monitoring** device. Just copy the code below for **UV Index & UV Intensity Monitoring LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the example </summary>  \n```c\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h>  //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n#include \"UVlight_LTR390.h\"                // http://librarymanager/All#RAK12019_LTR390\nUVlight_LTR390 ltr = UVlight_LTR390();\n\n#include \"Light_VEML7700.h\"                // http://librarymanager/All#Light_veml7700\nLight_VEML7700 VMEL = Light_VEML7700();\n\nuint16_t uvi;\nuint32_t uvs;\nuint32_t lux;\nuint32_t white;\nuint32_t raw_als;\n\n#include <Adafruit_MCP23X17.h>  //http://librarymanager/All#Adafruit_MCP23017\nAdafruit_MCP23X17 mcp;\n\n// Added definitions for the functionality of RAK14003\nconst uint8_t LED_0 = 0;      // PA0 (17) of MCP23017\nconst uint8_t LED_1 = 1;      // PA1 (18) of MCP23017\nconst uint8_t LED_2 = 2;      // PA2 (19) of MCP23017\nconst uint8_t LED_3 = 3;      // PA3 (20) of MCP23017\nconst uint8_t LED_4 = 4;      // PA4 (21) of MCP23017\nconst uint8_t LED_5 = 5;      // PA5 (22) of MCP23017\nconst uint8_t LED_6 = 6;      // PA6 (23) of MCP23017\nconst uint8_t LED_7 = 7;      // PA7 (24) of MCP23017\nconst uint8_t LED_8 = 8;      // PB0 (25) of MCP23017\nconst uint8_t LED_9 = 9;      // PB1 (26) of MCP23017\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define RAK4631_BOARD true\n#else\n#define RAK4631_BOARD false\n#endif\n\nbool doOTAA = true;                                               // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                                       /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                                     /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5                               /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                                        /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;                           /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;                 /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                              /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = { LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF };\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = { BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler };\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xE9, 0x0D, 0x28, 0x1D, 0x92, 0x3D, 0xE4, 0x9F, 0xD9, 0xF7, 0xE0, 0x5F, 0x39, 0x10, 0x55, 0x71 };\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };\nuint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                                            /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];               //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = { m_lora_app_data_buffer, 0, 0, 0, 0 };  //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {\n\n// Initialize Serial for debug output\npinMode(LED_BLUE, OUTPUT);\ndigitalWrite(LED_BLUE, HIGH);\n\n// Sensor Power Switch\npinMode(WB_IO2, OUTPUT);\ndigitalWrite(WB_IO2, HIGH);\n\n// Reset RAK14003 module\npinMode(WB_IO4, OUTPUT);\ndigitalWrite(WB_IO4, HIGH);\ndelay(10);\ndigitalWrite(WB_IO4, LOW);\ndelay(10);\ndigitalWrite(WB_IO4, HIGH);\ndelay(10);\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial) {\nif ((millis() - timeout) < 5000) {\ndelay(100);\n} else {\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA) {\nSerial.println(\"Type: OTAA\");\n} else {\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion) {\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA) {\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n} else {\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0) {\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"================================\");\nSerial.println(\"RAK12019 + RAK12010 LoRaWAN Code\");\nSerial.println(\"================================\");\n\nif (!VMEL.begin())\n{\nSerial.println(\"Sensor not found\");\nwhile (1);\n}\n\nVMEL.setGain(VEML7700_GAIN_1);\nVMEL.setIntegrationTime(VEML7700_IT_800MS);\n\nSerial.print(F(\"Gain: \"));\nswitch (VMEL.getGain())\n{\ncase VEML7700_GAIN_1: Serial.println(\"1\"); break;\ncase VEML7700_GAIN_2: Serial.println(\"2\"); break;\ncase VEML7700_GAIN_1_4: Serial.println(\"1/4\"); break;\ncase VEML7700_GAIN_1_8: Serial.println(\"1/8\"); break;\n}\n\nSerial.print(F(\"Integration Time (ms): \"));\nswitch (VMEL.getIntegrationTime())\n{\ncase VEML7700_IT_25MS: Serial.println(\"25\"); break;\ncase VEML7700_IT_50MS: Serial.println(\"50\"); break;\ncase VEML7700_IT_100MS: Serial.println(\"100\"); break;\ncase VEML7700_IT_200MS: Serial.println(\"200\"); break;\ncase VEML7700_IT_400MS: Serial.println(\"400\"); break;\ncase VEML7700_IT_800MS: Serial.println(\"800\"); break;\n}\n\nSerial.println(\"RAK12019 test\");\nWire.begin();\nif (!ltr.init())\n{\nSerial.println(\"Couldn't find LTR sensor!\");\nwhile (1)\ndelay(10);\n}\nSerial.println(\"Found LTR390 sensor!\");\n\n//set to LTR390_MODE_UVS,get ultraviolet light data.\nltr.setMode(LTR390_MODE_UVS);  // UVS Mode\n\nSerial.println(\"In UVS mode\");\n\nltr.setGain(LTR390_GAIN_3);\nSerial.print(\"Gain : \");\nswitch (ltr.getGain())\n{\ncase LTR390_GAIN_1:\nSerial.println(1);\nbreak;\ncase LTR390_GAIN_3:\nSerial.println(3);\nbreak;\ncase LTR390_GAIN_6:\nSerial.println(6);\nbreak;\ncase LTR390_GAIN_9:\nSerial.println(9);\nbreak;\ncase LTR390_GAIN_18:\nSerial.println(18);\nbreak;\ndefault:\nSerial.println(\"Failed to set gain\");\nbreak;\n}\nltr.setResolution(LTR390_RESOLUTION_16BIT);\nSerial.print(\"Integration Time (ms): \");\nswitch (ltr.getResolution())\n{\ncase LTR390_RESOLUTION_13BIT:\nSerial.println(13);\nbreak;\ncase LTR390_RESOLUTION_16BIT:\nSerial.println(16);\nbreak;\ncase LTR390_RESOLUTION_17BIT:\nSerial.println(17);\nbreak;\ncase LTR390_RESOLUTION_18BIT:\nSerial.println(18);\nbreak;\ncase LTR390_RESOLUTION_19BIT:\nSerial.println(19);\nbreak;\ncase LTR390_RESOLUTION_20BIT:\nSerial.println(20);\nbreak;\ndefault:\nSerial.println(\"Failed to set Integration Time\");\nbreak;\n}\n\nltr.setThresholds(100, 1000); //Set the interrupt output threshold range for lower and upper.\n\nltr.configInterrupt(true, LTR390_MODE_UVS);\n\n// For RAK14003\nmcp.begin_I2C(0x24);\n\n// Added for the functionality of RAK14003\n\nWire.begin();    // initialize I2C serial bus\n\n// Configuration of MCP23017 I/O ports\nmcp.pinMode(LED_0, OUTPUT);     // Red LED; Top most\nmcp.pinMode(LED_1, OUTPUT);     // Red LED\nmcp.pinMode(LED_2, OUTPUT);     // Orange LED\nmcp.pinMode(LED_3, OUTPUT);     // Orange LED\nmcp.pinMode(LED_4, OUTPUT);     // Orange LED\nmcp.pinMode(LED_5, OUTPUT);     // Green LED\nmcp.pinMode(LED_6, OUTPUT);     // Green LED\nmcp.pinMode(LED_7, OUTPUT);     // Green LED\nmcp.pinMode(LED_8, OUTPUT);     // Green LED\nmcp.pinMode(LED_9, OUTPUT);     // Green LED; Bottom\n\n// Initially Turn OFF all LEDs\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, HIGH);\n\n}\n\nvoid loop() {\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\n// Trial # 1\n// Data from RAK12019\nif (ltr.newDataAvailable())\n{\nuvi = ltr.getUVI();\nuvs = ltr.readUVS();\n}\n\n// Data from RAK12010\nlux = VMEL.readLux();\nwhite = VMEL.readWhite();\nraw_als = VMEL.readALS();\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\n\n// From RAK12019 module\nSerial.print(\"UVI: \");\nSerial.println(uvi);          // Uvi data from RAK12019\nSerial.print(\"UVS: \");\nSerial.println(uvs);            // Uvs data from RAK12019\n\n// From RAK12010\nSerial.print(\"Lux: \");\nSerial.print(lux);\nSerial.println(\" lx \");\nSerial.print(\"White: \");\nSerial.println(white);\nSerial.print(\"Raw ALS: \");\nSerial.println(raw_als);\n\n// Result of uvi to be displayed via RAK14003 module\nif (uvi <= 0.4)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, HIGH);\n}\n\nelse if (uvi > 0.5 && uvi <= 1)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 1.5 && uvi <= 2)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 2.5 && uvi <= 3)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 3.5 && uvi <= 4)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 4.5 && uvi <= 5)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 5.5 && uvi <= 6)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 6.5 && uvi <= 7)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 7.5 && uvi <= 8)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 8.5 && uvi <= 9.5)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, LOW);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi >= 10)\n{\nmcp.digitalWrite(LED_0, LOW);\nmcp.digitalWrite(LED_1, LOW);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\ndelay(10000);\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void) {\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void) {\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data) {\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class) {\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void) {\nif (lmh_join_status_get() != LMH_SET) {\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\ndata = \" Uvi Data: \" + String(uvi) + \" Uvs Data: \" + String(uvs) + \" Lux Data: \" + String(lux) + \" lx \" ;\n\nSerial.println(data);\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\nuint16_t uvi_data = uvi;            // Uvi data from RAK12019\nuint32_t uvs_data = uvs;            // Uvs data from RAK12019\nuint32_t lux_data = lux;            // Lux data from RAK12010\n\nm_lora_app_data.buffer[i++] = 0x01;  // byte[0]\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\n// Data from RAK12019 module\nm_lora_app_data.buffer[i++] = (uint8_t)((uvi_data & 0x0000FF00) >> 8);     // byte[1]\nm_lora_app_data.buffer[i++] = (uint8_t)(uvi_data & 0x000000FF);            // byte[2]\n\n// Data from RAK12019 module\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0xFF000000) >> 24);    // byte[3]\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0x00FF0000) >> 16);    // byte[4]\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0x0000FF00) >> 8);     // byte[5]\nm_lora_app_data.buffer[i++] = (uint8_t)(uvs_data & 0x000000FF);            // byte[6]\n\n// Data from RAK12010 module\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0xFF000000) >> 24);    // byte[7]\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0x00FF0000) >> 16);    // byte[8]\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0x0000FF00) >> 8);     // byte[9]\nm_lora_app_data.buffer[i++] = (uint8_t)(lux_data & 0x000000FF);            // byte[10]\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS) {\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n} else {\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xE9, 0x0D, 0x28, 0x1D, 0x92, 0x3D, 0xE4, 0x9F, 0xD9, 0xF7, 0xE0, 0x5F, 0x39, 0x10, 0x55, 0x71 };\n\n```  \n> **Image:** OTAA device successfully registered to TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "ed31566a03e60bbd260eb77b1fd8bb30", "product_family": "wisblock", "product_id": "kit6-light-and-color", "category": "How-To", "title": "WisBlock IoT Education Kit - Light & Color Quick Start Guide > WisBlock IoT Education Kit - Light & Color Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock IoT Education Kit - Light & Color using TTN and Qubitro > UV Index & UV Intensity Monitoring LoRaWAN Application > LoRaWAN Code for UV Index & UV Intensity Monitoring > Programming UV Index & UV Intensity Monitoring Device with Arduino IDE [CODE]", "content": "m_lora_app_data.buffer[i++] = 0x01;  // byte[0]\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\n// Data from RAK12019 module\nm_lora_app_data.buffer[i++] = (uint8_t)((uvi_data & 0x0000FF00) >> 8);     // byte[1]\nm_lora_app_data.buffer[i++] = (uint8_t)(uvi_data & 0x000000FF);            // byte[2]", "keywords": ["Arduino IDE", "RAK4631", "UV Index", "UV Intensity", "LoRaWAN", "SX126x-Arduino"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **UV Index & UV Intensity Monitoring** device. Just copy the code below for **UV Index & UV Intensity Monitoring LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the example </summary>  \n```c\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h>  //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n#include \"UVlight_LTR390.h\"                // http://librarymanager/All#RAK12019_LTR390\nUVlight_LTR390 ltr = UVlight_LTR390();\n\n#include \"Light_VEML7700.h\"                // http://librarymanager/All#Light_veml7700\nLight_VEML7700 VMEL = Light_VEML7700();\n\nuint16_t uvi;\nuint32_t uvs;\nuint32_t lux;\nuint32_t white;\nuint32_t raw_als;\n\n#include <Adafruit_MCP23X17.h>  //http://librarymanager/All#Adafruit_MCP23017\nAdafruit_MCP23X17 mcp;\n\n// Added definitions for the functionality of RAK14003\nconst uint8_t LED_0 = 0;      // PA0 (17) of MCP23017\nconst uint8_t LED_1 = 1;      // PA1 (18) of MCP23017\nconst uint8_t LED_2 = 2;      // PA2 (19) of MCP23017\nconst uint8_t LED_3 = 3;      // PA3 (20) of MCP23017\nconst uint8_t LED_4 = 4;      // PA4 (21) of MCP23017\nconst uint8_t LED_5 = 5;      // PA5 (22) of MCP23017\nconst uint8_t LED_6 = 6;      // PA6 (23) of MCP23017\nconst uint8_t LED_7 = 7;      // PA7 (24) of MCP23017\nconst uint8_t LED_8 = 8;      // PB0 (25) of MCP23017\nconst uint8_t LED_9 = 9;      // PB1 (26) of MCP23017\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define RAK4631_BOARD true\n#else\n#define RAK4631_BOARD false\n#endif\n\nbool doOTAA = true;                                               // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                                       /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                                     /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5                               /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                                        /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;                           /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;                 /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                              /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = { LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF };\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = { BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler };\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xE9, 0x0D, 0x28, 0x1D, 0x92, 0x3D, 0xE4, 0x9F, 0xD9, 0xF7, 0xE0, 0x5F, 0x39, 0x10, 0x55, 0x71 };\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };\nuint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                                            /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];               //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = { m_lora_app_data_buffer, 0, 0, 0, 0 };  //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {\n\n// Initialize Serial for debug output\npinMode(LED_BLUE, OUTPUT);\ndigitalWrite(LED_BLUE, HIGH);\n\n// Sensor Power Switch\npinMode(WB_IO2, OUTPUT);\ndigitalWrite(WB_IO2, HIGH);\n\n// Reset RAK14003 module\npinMode(WB_IO4, OUTPUT);\ndigitalWrite(WB_IO4, HIGH);\ndelay(10);\ndigitalWrite(WB_IO4, LOW);\ndelay(10);\ndigitalWrite(WB_IO4, HIGH);\ndelay(10);\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial) {\nif ((millis() - timeout) < 5000) {\ndelay(100);\n} else {\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA) {\nSerial.println(\"Type: OTAA\");\n} else {\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion) {\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA) {\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n} else {\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0) {\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"================================\");\nSerial.println(\"RAK12019 + RAK12010 LoRaWAN Code\");\nSerial.println(\"================================\");\n\nif (!VMEL.begin())\n{\nSerial.println(\"Sensor not found\");\nwhile (1);\n}\n\nVMEL.setGain(VEML7700_GAIN_1);\nVMEL.setIntegrationTime(VEML7700_IT_800MS);\n\nSerial.print(F(\"Gain: \"));\nswitch (VMEL.getGain())\n{\ncase VEML7700_GAIN_1: Serial.println(\"1\"); break;\ncase VEML7700_GAIN_2: Serial.println(\"2\"); break;\ncase VEML7700_GAIN_1_4: Serial.println(\"1/4\"); break;\ncase VEML7700_GAIN_1_8: Serial.println(\"1/8\"); break;\n}\n\nSerial.print(F(\"Integration Time (ms): \"));\nswitch (VMEL.getIntegrationTime())\n{\ncase VEML7700_IT_25MS: Serial.println(\"25\"); break;\ncase VEML7700_IT_50MS: Serial.println(\"50\"); break;\ncase VEML7700_IT_100MS: Serial.println(\"100\"); break;\ncase VEML7700_IT_200MS: Serial.println(\"200\"); break;\ncase VEML7700_IT_400MS: Serial.println(\"400\"); break;\ncase VEML7700_IT_800MS: Serial.println(\"800\"); break;\n}\n\nSerial.println(\"RAK12019 test\");\nWire.begin();\nif (!ltr.init())\n{\nSerial.println(\"Couldn't find LTR sensor!\");\nwhile (1)\ndelay(10);\n}\nSerial.println(\"Found LTR390 sensor!\");\n\n//set to LTR390_MODE_UVS,get ultraviolet light data.\nltr.setMode(LTR390_MODE_UVS);  // UVS Mode\n\nSerial.println(\"In UVS mode\");\n\nltr.setGain(LTR390_GAIN_3);\nSerial.print(\"Gain : \");\nswitch (ltr.getGain())\n{\ncase LTR390_GAIN_1:\nSerial.println(1);\nbreak;\ncase LTR390_GAIN_3:\nSerial.println(3);\nbreak;\ncase LTR390_GAIN_6:\nSerial.println(6);\nbreak;\ncase LTR390_GAIN_9:\nSerial.println(9);\nbreak;\ncase LTR390_GAIN_18:\nSerial.println(18);\nbreak;\ndefault:\nSerial.println(\"Failed to set gain\");\nbreak;\n}\nltr.setResolution(LTR390_RESOLUTION_16BIT);\nSerial.print(\"Integration Time (ms): \");\nswitch (ltr.getResolution())\n{\ncase LTR390_RESOLUTION_13BIT:\nSerial.println(13);\nbreak;\ncase LTR390_RESOLUTION_16BIT:\nSerial.println(16);\nbreak;\ncase LTR390_RESOLUTION_17BIT:\nSerial.println(17);\nbreak;\ncase LTR390_RESOLUTION_18BIT:\nSerial.println(18);\nbreak;\ncase LTR390_RESOLUTION_19BIT:\nSerial.println(19);\nbreak;\ncase LTR390_RESOLUTION_20BIT:\nSerial.println(20);\nbreak;\ndefault:\nSerial.println(\"Failed to set Integration Time\");\nbreak;\n}\n\nltr.setThresholds(100, 1000); //Set the interrupt output threshold range for lower and upper.\n\nltr.configInterrupt(true, LTR390_MODE_UVS);\n\n// For RAK14003\nmcp.begin_I2C(0x24);\n\n// Added for the functionality of RAK14003\n\nWire.begin();    // initialize I2C serial bus\n\n// Configuration of MCP23017 I/O ports\nmcp.pinMode(LED_0, OUTPUT);     // Red LED; Top most\nmcp.pinMode(LED_1, OUTPUT);     // Red LED\nmcp.pinMode(LED_2, OUTPUT);     // Orange LED\nmcp.pinMode(LED_3, OUTPUT);     // Orange LED\nmcp.pinMode(LED_4, OUTPUT);     // Orange LED\nmcp.pinMode(LED_5, OUTPUT);     // Green LED\nmcp.pinMode(LED_6, OUTPUT);     // Green LED\nmcp.pinMode(LED_7, OUTPUT);     // Green LED\nmcp.pinMode(LED_8, OUTPUT);     // Green LED\nmcp.pinMode(LED_9, OUTPUT);     // Green LED; Bottom\n\n// Initially Turn OFF all LEDs\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, HIGH);\n\n}\n\nvoid loop() {\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\n// Trial # 1\n// Data from RAK12019\nif (ltr.newDataAvailable())\n{\nuvi = ltr.getUVI();\nuvs = ltr.readUVS();\n}\n\n// Data from RAK12010\nlux = VMEL.readLux();\nwhite = VMEL.readWhite();\nraw_als = VMEL.readALS();\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\n\n// From RAK12019 module\nSerial.print(\"UVI: \");\nSerial.println(uvi);          // Uvi data from RAK12019\nSerial.print(\"UVS: \");\nSerial.println(uvs);            // Uvs data from RAK12019\n\n// From RAK12010\nSerial.print(\"Lux: \");\nSerial.print(lux);\nSerial.println(\" lx \");\nSerial.print(\"White: \");\nSerial.println(white);\nSerial.print(\"Raw ALS: \");\nSerial.println(raw_als);\n\n// Result of uvi to be displayed via RAK14003 module\nif (uvi <= 0.4)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, HIGH);\n}\n\nelse if (uvi > 0.5 && uvi <= 1)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 1.5 && uvi <= 2)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 2.5 && uvi <= 3)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 3.5 && uvi <= 4)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 4.5 && uvi <= 5)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 5.5 && uvi <= 6)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 6.5 && uvi <= 7)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 7.5 && uvi <= 8)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 8.5 && uvi <= 9.5)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, LOW);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi >= 10)\n{\nmcp.digitalWrite(LED_0, LOW);\nmcp.digitalWrite(LED_1, LOW);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\ndelay(10000);\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void) {\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void) {\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data) {\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class) {\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void) {\nif (lmh_join_status_get() != LMH_SET) {\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\ndata = \" Uvi Data: \" + String(uvi) + \" Uvs Data: \" + String(uvs) + \" Lux Data: \" + String(lux) + \" lx \" ;\n\nSerial.println(data);\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\nuint16_t uvi_data = uvi;            // Uvi data from RAK12019\nuint32_t uvs_data = uvs;            // Uvs data from RAK12019\nuint32_t lux_data = lux;            // Lux data from RAK12010\n\nm_lora_app_data.buffer[i++] = 0x01;  // byte[0]\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\n// Data from RAK12019 module\nm_lora_app_data.buffer[i++] = (uint8_t)((uvi_data & 0x0000FF00) >> 8);     // byte[1]\nm_lora_app_data.buffer[i++] = (uint8_t)(uvi_data & 0x000000FF);            // byte[2]\n\n// Data from RAK12019 module\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0xFF000000) >> 24);    // byte[3]\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0x00FF0000) >> 16);    // byte[4]\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0x0000FF00) >> 8);     // byte[5]\nm_lora_app_data.buffer[i++] = (uint8_t)(uvs_data & 0x000000FF);            // byte[6]\n\n// Data from RAK12010 module\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0xFF000000) >> 24);    // byte[7]\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0x00FF0000) >> 16);    // byte[8]\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0x0000FF00) >> 8);     // byte[9]\nm_lora_app_data.buffer[i++] = (uint8_t)(lux_data & 0x000000FF);            // byte[10]\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS) {\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n} else {\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xE9, 0x0D, 0x28, 0x1D, 0x92, 0x3D, 0xE4, 0x9F, 0xD9, 0xF7, 0xE0, 0x5F, 0x39, 0x10, 0x55, 0x71 };\n\n```  \n> **Image:** OTAA device successfully registered to TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "9466d600b9f56435932f06c57d7e5aca", "product_family": "wisblock", "product_id": "kit6-light-and-color", "category": "How-To", "title": "WisBlock IoT Education Kit - Light & Color Quick Start Guide > WisBlock IoT Education Kit - Light & Color Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock IoT Education Kit - Light & Color using TTN and Qubitro > UV Index & UV Intensity Monitoring LoRaWAN Application > LoRaWAN Code for UV Index & UV Intensity Monitoring > Programming UV Index & UV Intensity Monitoring Device with Arduino IDE [CODE]", "content": "// Data from RAK12019 module\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0xFF000000) >> 24);    // byte[3]\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0x00FF0000) >> 16);    // byte[4]\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0x0000FF00) >> 8);     // byte[5]\nm_lora_app_data.buffer[i++] = (uint8_t)(uvs_data & 0x000000FF);            // byte[6]", "keywords": ["Arduino IDE", "RAK4631", "UV Index", "UV Intensity", "LoRaWAN", "SX126x-Arduino"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **UV Index & UV Intensity Monitoring** device. Just copy the code below for **UV Index & UV Intensity Monitoring LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the example </summary>  \n```c\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h>  //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n#include \"UVlight_LTR390.h\"                // http://librarymanager/All#RAK12019_LTR390\nUVlight_LTR390 ltr = UVlight_LTR390();\n\n#include \"Light_VEML7700.h\"                // http://librarymanager/All#Light_veml7700\nLight_VEML7700 VMEL = Light_VEML7700();\n\nuint16_t uvi;\nuint32_t uvs;\nuint32_t lux;\nuint32_t white;\nuint32_t raw_als;\n\n#include <Adafruit_MCP23X17.h>  //http://librarymanager/All#Adafruit_MCP23017\nAdafruit_MCP23X17 mcp;\n\n// Added definitions for the functionality of RAK14003\nconst uint8_t LED_0 = 0;      // PA0 (17) of MCP23017\nconst uint8_t LED_1 = 1;      // PA1 (18) of MCP23017\nconst uint8_t LED_2 = 2;      // PA2 (19) of MCP23017\nconst uint8_t LED_3 = 3;      // PA3 (20) of MCP23017\nconst uint8_t LED_4 = 4;      // PA4 (21) of MCP23017\nconst uint8_t LED_5 = 5;      // PA5 (22) of MCP23017\nconst uint8_t LED_6 = 6;      // PA6 (23) of MCP23017\nconst uint8_t LED_7 = 7;      // PA7 (24) of MCP23017\nconst uint8_t LED_8 = 8;      // PB0 (25) of MCP23017\nconst uint8_t LED_9 = 9;      // PB1 (26) of MCP23017\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define RAK4631_BOARD true\n#else\n#define RAK4631_BOARD false\n#endif\n\nbool doOTAA = true;                                               // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                                       /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                                     /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5                               /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                                        /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;                           /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;                 /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                              /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = { LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF };\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = { BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler };\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xE9, 0x0D, 0x28, 0x1D, 0x92, 0x3D, 0xE4, 0x9F, 0xD9, 0xF7, 0xE0, 0x5F, 0x39, 0x10, 0x55, 0x71 };\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };\nuint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                                            /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];               //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = { m_lora_app_data_buffer, 0, 0, 0, 0 };  //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {\n\n// Initialize Serial for debug output\npinMode(LED_BLUE, OUTPUT);\ndigitalWrite(LED_BLUE, HIGH);\n\n// Sensor Power Switch\npinMode(WB_IO2, OUTPUT);\ndigitalWrite(WB_IO2, HIGH);\n\n// Reset RAK14003 module\npinMode(WB_IO4, OUTPUT);\ndigitalWrite(WB_IO4, HIGH);\ndelay(10);\ndigitalWrite(WB_IO4, LOW);\ndelay(10);\ndigitalWrite(WB_IO4, HIGH);\ndelay(10);\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial) {\nif ((millis() - timeout) < 5000) {\ndelay(100);\n} else {\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA) {\nSerial.println(\"Type: OTAA\");\n} else {\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion) {\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA) {\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n} else {\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0) {\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"================================\");\nSerial.println(\"RAK12019 + RAK12010 LoRaWAN Code\");\nSerial.println(\"================================\");\n\nif (!VMEL.begin())\n{\nSerial.println(\"Sensor not found\");\nwhile (1);\n}\n\nVMEL.setGain(VEML7700_GAIN_1);\nVMEL.setIntegrationTime(VEML7700_IT_800MS);\n\nSerial.print(F(\"Gain: \"));\nswitch (VMEL.getGain())\n{\ncase VEML7700_GAIN_1: Serial.println(\"1\"); break;\ncase VEML7700_GAIN_2: Serial.println(\"2\"); break;\ncase VEML7700_GAIN_1_4: Serial.println(\"1/4\"); break;\ncase VEML7700_GAIN_1_8: Serial.println(\"1/8\"); break;\n}\n\nSerial.print(F(\"Integration Time (ms): \"));\nswitch (VMEL.getIntegrationTime())\n{\ncase VEML7700_IT_25MS: Serial.println(\"25\"); break;\ncase VEML7700_IT_50MS: Serial.println(\"50\"); break;\ncase VEML7700_IT_100MS: Serial.println(\"100\"); break;\ncase VEML7700_IT_200MS: Serial.println(\"200\"); break;\ncase VEML7700_IT_400MS: Serial.println(\"400\"); break;\ncase VEML7700_IT_800MS: Serial.println(\"800\"); break;\n}\n\nSerial.println(\"RAK12019 test\");\nWire.begin();\nif (!ltr.init())\n{\nSerial.println(\"Couldn't find LTR sensor!\");\nwhile (1)\ndelay(10);\n}\nSerial.println(\"Found LTR390 sensor!\");\n\n//set to LTR390_MODE_UVS,get ultraviolet light data.\nltr.setMode(LTR390_MODE_UVS);  // UVS Mode\n\nSerial.println(\"In UVS mode\");\n\nltr.setGain(LTR390_GAIN_3);\nSerial.print(\"Gain : \");\nswitch (ltr.getGain())\n{\ncase LTR390_GAIN_1:\nSerial.println(1);\nbreak;\ncase LTR390_GAIN_3:\nSerial.println(3);\nbreak;\ncase LTR390_GAIN_6:\nSerial.println(6);\nbreak;\ncase LTR390_GAIN_9:\nSerial.println(9);\nbreak;\ncase LTR390_GAIN_18:\nSerial.println(18);\nbreak;\ndefault:\nSerial.println(\"Failed to set gain\");\nbreak;\n}\nltr.setResolution(LTR390_RESOLUTION_16BIT);\nSerial.print(\"Integration Time (ms): \");\nswitch (ltr.getResolution())\n{\ncase LTR390_RESOLUTION_13BIT:\nSerial.println(13);\nbreak;\ncase LTR390_RESOLUTION_16BIT:\nSerial.println(16);\nbreak;\ncase LTR390_RESOLUTION_17BIT:\nSerial.println(17);\nbreak;\ncase LTR390_RESOLUTION_18BIT:\nSerial.println(18);\nbreak;\ncase LTR390_RESOLUTION_19BIT:\nSerial.println(19);\nbreak;\ncase LTR390_RESOLUTION_20BIT:\nSerial.println(20);\nbreak;\ndefault:\nSerial.println(\"Failed to set Integration Time\");\nbreak;\n}\n\nltr.setThresholds(100, 1000); //Set the interrupt output threshold range for lower and upper.\n\nltr.configInterrupt(true, LTR390_MODE_UVS);\n\n// For RAK14003\nmcp.begin_I2C(0x24);\n\n// Added for the functionality of RAK14003\n\nWire.begin();    // initialize I2C serial bus\n\n// Configuration of MCP23017 I/O ports\nmcp.pinMode(LED_0, OUTPUT);     // Red LED; Top most\nmcp.pinMode(LED_1, OUTPUT);     // Red LED\nmcp.pinMode(LED_2, OUTPUT);     // Orange LED\nmcp.pinMode(LED_3, OUTPUT);     // Orange LED\nmcp.pinMode(LED_4, OUTPUT);     // Orange LED\nmcp.pinMode(LED_5, OUTPUT);     // Green LED\nmcp.pinMode(LED_6, OUTPUT);     // Green LED\nmcp.pinMode(LED_7, OUTPUT);     // Green LED\nmcp.pinMode(LED_8, OUTPUT);     // Green LED\nmcp.pinMode(LED_9, OUTPUT);     // Green LED; Bottom\n\n// Initially Turn OFF all LEDs\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, HIGH);\n\n}\n\nvoid loop() {\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\n// Trial # 1\n// Data from RAK12019\nif (ltr.newDataAvailable())\n{\nuvi = ltr.getUVI();\nuvs = ltr.readUVS();\n}\n\n// Data from RAK12010\nlux = VMEL.readLux();\nwhite = VMEL.readWhite();\nraw_als = VMEL.readALS();\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\n\n// From RAK12019 module\nSerial.print(\"UVI: \");\nSerial.println(uvi);          // Uvi data from RAK12019\nSerial.print(\"UVS: \");\nSerial.println(uvs);            // Uvs data from RAK12019\n\n// From RAK12010\nSerial.print(\"Lux: \");\nSerial.print(lux);\nSerial.println(\" lx \");\nSerial.print(\"White: \");\nSerial.println(white);\nSerial.print(\"Raw ALS: \");\nSerial.println(raw_als);\n\n// Result of uvi to be displayed via RAK14003 module\nif (uvi <= 0.4)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, HIGH);\n}\n\nelse if (uvi > 0.5 && uvi <= 1)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 1.5 && uvi <= 2)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 2.5 && uvi <= 3)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 3.5 && uvi <= 4)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 4.5 && uvi <= 5)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 5.5 && uvi <= 6)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 6.5 && uvi <= 7)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 7.5 && uvi <= 8)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 8.5 && uvi <= 9.5)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, LOW);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi >= 10)\n{\nmcp.digitalWrite(LED_0, LOW);\nmcp.digitalWrite(LED_1, LOW);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\ndelay(10000);\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void) {\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void) {\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data) {\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class) {\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void) {\nif (lmh_join_status_get() != LMH_SET) {\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\ndata = \" Uvi Data: \" + String(uvi) + \" Uvs Data: \" + String(uvs) + \" Lux Data: \" + String(lux) + \" lx \" ;\n\nSerial.println(data);\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\nuint16_t uvi_data = uvi;            // Uvi data from RAK12019\nuint32_t uvs_data = uvs;            // Uvs data from RAK12019\nuint32_t lux_data = lux;            // Lux data from RAK12010\n\nm_lora_app_data.buffer[i++] = 0x01;  // byte[0]\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\n// Data from RAK12019 module\nm_lora_app_data.buffer[i++] = (uint8_t)((uvi_data & 0x0000FF00) >> 8);     // byte[1]\nm_lora_app_data.buffer[i++] = (uint8_t)(uvi_data & 0x000000FF);            // byte[2]\n\n// Data from RAK12019 module\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0xFF000000) >> 24);    // byte[3]\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0x00FF0000) >> 16);    // byte[4]\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0x0000FF00) >> 8);     // byte[5]\nm_lora_app_data.buffer[i++] = (uint8_t)(uvs_data & 0x000000FF);            // byte[6]\n\n// Data from RAK12010 module\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0xFF000000) >> 24);    // byte[7]\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0x00FF0000) >> 16);    // byte[8]\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0x0000FF00) >> 8);     // byte[9]\nm_lora_app_data.buffer[i++] = (uint8_t)(lux_data & 0x000000FF);            // byte[10]\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS) {\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n} else {\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xE9, 0x0D, 0x28, 0x1D, 0x92, 0x3D, 0xE4, 0x9F, 0xD9, 0xF7, 0xE0, 0x5F, 0x39, 0x10, 0x55, 0x71 };\n\n```  \n> **Image:** OTAA device successfully registered to TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "051dbb1e20412bf0e898ac7ac034e767", "product_family": "wisblock", "product_id": "kit6-light-and-color", "category": "How-To", "title": "WisBlock IoT Education Kit - Light & Color Quick Start Guide > WisBlock IoT Education Kit - Light & Color Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock IoT Education Kit - Light & Color using TTN and Qubitro > UV Index & UV Intensity Monitoring LoRaWAN Application > LoRaWAN Code for UV Index & UV Intensity Monitoring > Programming UV Index & UV Intensity Monitoring Device with Arduino IDE [CODE]", "content": "// Data from RAK12010 module\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0xFF000000) >> 24);    // byte[7]\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0x00FF0000) >> 16);    // byte[8]\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0x0000FF00) >> 8);     // byte[9]\nm_lora_app_data.buffer[i++] = (uint8_t)(lux_data & 0x000000FF);            // byte[10]\n\nm_lora_app_data.buffsize = i;", "keywords": ["Arduino IDE", "RAK4631", "UV Index", "UV Intensity", "LoRaWAN", "SX126x-Arduino"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **UV Index & UV Intensity Monitoring** device. Just copy the code below for **UV Index & UV Intensity Monitoring LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the example </summary>  \n```c\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h>  //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n#include \"UVlight_LTR390.h\"                // http://librarymanager/All#RAK12019_LTR390\nUVlight_LTR390 ltr = UVlight_LTR390();\n\n#include \"Light_VEML7700.h\"                // http://librarymanager/All#Light_veml7700\nLight_VEML7700 VMEL = Light_VEML7700();\n\nuint16_t uvi;\nuint32_t uvs;\nuint32_t lux;\nuint32_t white;\nuint32_t raw_als;\n\n#include <Adafruit_MCP23X17.h>  //http://librarymanager/All#Adafruit_MCP23017\nAdafruit_MCP23X17 mcp;\n\n// Added definitions for the functionality of RAK14003\nconst uint8_t LED_0 = 0;      // PA0 (17) of MCP23017\nconst uint8_t LED_1 = 1;      // PA1 (18) of MCP23017\nconst uint8_t LED_2 = 2;      // PA2 (19) of MCP23017\nconst uint8_t LED_3 = 3;      // PA3 (20) of MCP23017\nconst uint8_t LED_4 = 4;      // PA4 (21) of MCP23017\nconst uint8_t LED_5 = 5;      // PA5 (22) of MCP23017\nconst uint8_t LED_6 = 6;      // PA6 (23) of MCP23017\nconst uint8_t LED_7 = 7;      // PA7 (24) of MCP23017\nconst uint8_t LED_8 = 8;      // PB0 (25) of MCP23017\nconst uint8_t LED_9 = 9;      // PB1 (26) of MCP23017\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define RAK4631_BOARD true\n#else\n#define RAK4631_BOARD false\n#endif\n\nbool doOTAA = true;                                               // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                                       /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                                     /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5                               /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                                        /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;                           /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;                 /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                              /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = { LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF };\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = { BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler };\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xE9, 0x0D, 0x28, 0x1D, 0x92, 0x3D, 0xE4, 0x9F, 0xD9, 0xF7, 0xE0, 0x5F, 0x39, 0x10, 0x55, 0x71 };\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };\nuint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                                            /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];               //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = { m_lora_app_data_buffer, 0, 0, 0, 0 };  //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {\n\n// Initialize Serial for debug output\npinMode(LED_BLUE, OUTPUT);\ndigitalWrite(LED_BLUE, HIGH);\n\n// Sensor Power Switch\npinMode(WB_IO2, OUTPUT);\ndigitalWrite(WB_IO2, HIGH);\n\n// Reset RAK14003 module\npinMode(WB_IO4, OUTPUT);\ndigitalWrite(WB_IO4, HIGH);\ndelay(10);\ndigitalWrite(WB_IO4, LOW);\ndelay(10);\ndigitalWrite(WB_IO4, HIGH);\ndelay(10);\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial) {\nif ((millis() - timeout) < 5000) {\ndelay(100);\n} else {\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA) {\nSerial.println(\"Type: OTAA\");\n} else {\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion) {\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA) {\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n} else {\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0) {\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"================================\");\nSerial.println(\"RAK12019 + RAK12010 LoRaWAN Code\");\nSerial.println(\"================================\");\n\nif (!VMEL.begin())\n{\nSerial.println(\"Sensor not found\");\nwhile (1);\n}\n\nVMEL.setGain(VEML7700_GAIN_1);\nVMEL.setIntegrationTime(VEML7700_IT_800MS);\n\nSerial.print(F(\"Gain: \"));\nswitch (VMEL.getGain())\n{\ncase VEML7700_GAIN_1: Serial.println(\"1\"); break;\ncase VEML7700_GAIN_2: Serial.println(\"2\"); break;\ncase VEML7700_GAIN_1_4: Serial.println(\"1/4\"); break;\ncase VEML7700_GAIN_1_8: Serial.println(\"1/8\"); break;\n}\n\nSerial.print(F(\"Integration Time (ms): \"));\nswitch (VMEL.getIntegrationTime())\n{\ncase VEML7700_IT_25MS: Serial.println(\"25\"); break;\ncase VEML7700_IT_50MS: Serial.println(\"50\"); break;\ncase VEML7700_IT_100MS: Serial.println(\"100\"); break;\ncase VEML7700_IT_200MS: Serial.println(\"200\"); break;\ncase VEML7700_IT_400MS: Serial.println(\"400\"); break;\ncase VEML7700_IT_800MS: Serial.println(\"800\"); break;\n}\n\nSerial.println(\"RAK12019 test\");\nWire.begin();\nif (!ltr.init())\n{\nSerial.println(\"Couldn't find LTR sensor!\");\nwhile (1)\ndelay(10);\n}\nSerial.println(\"Found LTR390 sensor!\");\n\n//set to LTR390_MODE_UVS,get ultraviolet light data.\nltr.setMode(LTR390_MODE_UVS);  // UVS Mode\n\nSerial.println(\"In UVS mode\");\n\nltr.setGain(LTR390_GAIN_3);\nSerial.print(\"Gain : \");\nswitch (ltr.getGain())\n{\ncase LTR390_GAIN_1:\nSerial.println(1);\nbreak;\ncase LTR390_GAIN_3:\nSerial.println(3);\nbreak;\ncase LTR390_GAIN_6:\nSerial.println(6);\nbreak;\ncase LTR390_GAIN_9:\nSerial.println(9);\nbreak;\ncase LTR390_GAIN_18:\nSerial.println(18);\nbreak;\ndefault:\nSerial.println(\"Failed to set gain\");\nbreak;\n}\nltr.setResolution(LTR390_RESOLUTION_16BIT);\nSerial.print(\"Integration Time (ms): \");\nswitch (ltr.getResolution())\n{\ncase LTR390_RESOLUTION_13BIT:\nSerial.println(13);\nbreak;\ncase LTR390_RESOLUTION_16BIT:\nSerial.println(16);\nbreak;\ncase LTR390_RESOLUTION_17BIT:\nSerial.println(17);\nbreak;\ncase LTR390_RESOLUTION_18BIT:\nSerial.println(18);\nbreak;\ncase LTR390_RESOLUTION_19BIT:\nSerial.println(19);\nbreak;\ncase LTR390_RESOLUTION_20BIT:\nSerial.println(20);\nbreak;\ndefault:\nSerial.println(\"Failed to set Integration Time\");\nbreak;\n}\n\nltr.setThresholds(100, 1000); //Set the interrupt output threshold range for lower and upper.\n\nltr.configInterrupt(true, LTR390_MODE_UVS);\n\n// For RAK14003\nmcp.begin_I2C(0x24);\n\n// Added for the functionality of RAK14003\n\nWire.begin();    // initialize I2C serial bus\n\n// Configuration of MCP23017 I/O ports\nmcp.pinMode(LED_0, OUTPUT);     // Red LED; Top most\nmcp.pinMode(LED_1, OUTPUT);     // Red LED\nmcp.pinMode(LED_2, OUTPUT);     // Orange LED\nmcp.pinMode(LED_3, OUTPUT);     // Orange LED\nmcp.pinMode(LED_4, OUTPUT);     // Orange LED\nmcp.pinMode(LED_5, OUTPUT);     // Green LED\nmcp.pinMode(LED_6, OUTPUT);     // Green LED\nmcp.pinMode(LED_7, OUTPUT);     // Green LED\nmcp.pinMode(LED_8, OUTPUT);     // Green LED\nmcp.pinMode(LED_9, OUTPUT);     // Green LED; Bottom\n\n// Initially Turn OFF all LEDs\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, HIGH);\n\n}\n\nvoid loop() {\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\n// Trial # 1\n// Data from RAK12019\nif (ltr.newDataAvailable())\n{\nuvi = ltr.getUVI();\nuvs = ltr.readUVS();\n}\n\n// Data from RAK12010\nlux = VMEL.readLux();\nwhite = VMEL.readWhite();\nraw_als = VMEL.readALS();\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\n\n// From RAK12019 module\nSerial.print(\"UVI: \");\nSerial.println(uvi);          // Uvi data from RAK12019\nSerial.print(\"UVS: \");\nSerial.println(uvs);            // Uvs data from RAK12019\n\n// From RAK12010\nSerial.print(\"Lux: \");\nSerial.print(lux);\nSerial.println(\" lx \");\nSerial.print(\"White: \");\nSerial.println(white);\nSerial.print(\"Raw ALS: \");\nSerial.println(raw_als);\n\n// Result of uvi to be displayed via RAK14003 module\nif (uvi <= 0.4)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, HIGH);\n}\n\nelse if (uvi > 0.5 && uvi <= 1)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 1.5 && uvi <= 2)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 2.5 && uvi <= 3)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 3.5 && uvi <= 4)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 4.5 && uvi <= 5)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 5.5 && uvi <= 6)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 6.5 && uvi <= 7)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 7.5 && uvi <= 8)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 8.5 && uvi <= 9.5)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, LOW);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi >= 10)\n{\nmcp.digitalWrite(LED_0, LOW);\nmcp.digitalWrite(LED_1, LOW);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\ndelay(10000);\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void) {\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void) {\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data) {\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class) {\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void) {\nif (lmh_join_status_get() != LMH_SET) {\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\ndata = \" Uvi Data: \" + String(uvi) + \" Uvs Data: \" + String(uvs) + \" Lux Data: \" + String(lux) + \" lx \" ;\n\nSerial.println(data);\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\nuint16_t uvi_data = uvi;            // Uvi data from RAK12019\nuint32_t uvs_data = uvs;            // Uvs data from RAK12019\nuint32_t lux_data = lux;            // Lux data from RAK12010\n\nm_lora_app_data.buffer[i++] = 0x01;  // byte[0]\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\n// Data from RAK12019 module\nm_lora_app_data.buffer[i++] = (uint8_t)((uvi_data & 0x0000FF00) >> 8);     // byte[1]\nm_lora_app_data.buffer[i++] = (uint8_t)(uvi_data & 0x000000FF);            // byte[2]\n\n// Data from RAK12019 module\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0xFF000000) >> 24);    // byte[3]\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0x00FF0000) >> 16);    // byte[4]\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0x0000FF00) >> 8);     // byte[5]\nm_lora_app_data.buffer[i++] = (uint8_t)(uvs_data & 0x000000FF);            // byte[6]\n\n// Data from RAK12010 module\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0xFF000000) >> 24);    // byte[7]\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0x00FF0000) >> 16);    // byte[8]\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0x0000FF00) >> 8);     // byte[9]\nm_lora_app_data.buffer[i++] = (uint8_t)(lux_data & 0x000000FF);            // byte[10]\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS) {\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n} else {\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xE9, 0x0D, 0x28, 0x1D, 0x92, 0x3D, 0xE4, 0x9F, 0xD9, 0xF7, 0xE0, 0x5F, 0x39, 0x10, 0x55, 0x71 };\n\n```  \n> **Image:** OTAA device successfully registered to TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "d47bab29576d1622bc1bc2fd13b9937d", "product_family": "wisblock", "product_id": "kit6-light-and-color", "category": "How-To", "title": "WisBlock IoT Education Kit - Light & Color Quick Start Guide > WisBlock IoT Education Kit - Light & Color Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock IoT Education Kit - Light & Color using TTN and Qubitro > UV Index & UV Intensity Monitoring LoRaWAN Application > LoRaWAN Code for UV Index & UV Intensity Monitoring > Programming UV Index & UV Intensity Monitoring Device with Arduino IDE [CODE]", "content": "lmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS) {\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n} else {\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.", "keywords": ["Arduino IDE", "RAK4631", "UV Index", "UV Intensity", "LoRaWAN", "SX126x-Arduino"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **UV Index & UV Intensity Monitoring** device. Just copy the code below for **UV Index & UV Intensity Monitoring LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the example </summary>  \n```c\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h>  //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n#include \"UVlight_LTR390.h\"                // http://librarymanager/All#RAK12019_LTR390\nUVlight_LTR390 ltr = UVlight_LTR390();\n\n#include \"Light_VEML7700.h\"                // http://librarymanager/All#Light_veml7700\nLight_VEML7700 VMEL = Light_VEML7700();\n\nuint16_t uvi;\nuint32_t uvs;\nuint32_t lux;\nuint32_t white;\nuint32_t raw_als;\n\n#include <Adafruit_MCP23X17.h>  //http://librarymanager/All#Adafruit_MCP23017\nAdafruit_MCP23X17 mcp;\n\n// Added definitions for the functionality of RAK14003\nconst uint8_t LED_0 = 0;      // PA0 (17) of MCP23017\nconst uint8_t LED_1 = 1;      // PA1 (18) of MCP23017\nconst uint8_t LED_2 = 2;      // PA2 (19) of MCP23017\nconst uint8_t LED_3 = 3;      // PA3 (20) of MCP23017\nconst uint8_t LED_4 = 4;      // PA4 (21) of MCP23017\nconst uint8_t LED_5 = 5;      // PA5 (22) of MCP23017\nconst uint8_t LED_6 = 6;      // PA6 (23) of MCP23017\nconst uint8_t LED_7 = 7;      // PA7 (24) of MCP23017\nconst uint8_t LED_8 = 8;      // PB0 (25) of MCP23017\nconst uint8_t LED_9 = 9;      // PB1 (26) of MCP23017\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define RAK4631_BOARD true\n#else\n#define RAK4631_BOARD false\n#endif\n\nbool doOTAA = true;                                               // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                                       /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                                     /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5                               /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                                        /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;                           /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;                 /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                              /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = { LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF };\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = { BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler };\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xE9, 0x0D, 0x28, 0x1D, 0x92, 0x3D, 0xE4, 0x9F, 0xD9, 0xF7, 0xE0, 0x5F, 0x39, 0x10, 0x55, 0x71 };\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };\nuint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                                            /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];               //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = { m_lora_app_data_buffer, 0, 0, 0, 0 };  //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {\n\n// Initialize Serial for debug output\npinMode(LED_BLUE, OUTPUT);\ndigitalWrite(LED_BLUE, HIGH);\n\n// Sensor Power Switch\npinMode(WB_IO2, OUTPUT);\ndigitalWrite(WB_IO2, HIGH);\n\n// Reset RAK14003 module\npinMode(WB_IO4, OUTPUT);\ndigitalWrite(WB_IO4, HIGH);\ndelay(10);\ndigitalWrite(WB_IO4, LOW);\ndelay(10);\ndigitalWrite(WB_IO4, HIGH);\ndelay(10);\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial) {\nif ((millis() - timeout) < 5000) {\ndelay(100);\n} else {\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA) {\nSerial.println(\"Type: OTAA\");\n} else {\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion) {\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA) {\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n} else {\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0) {\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"================================\");\nSerial.println(\"RAK12019 + RAK12010 LoRaWAN Code\");\nSerial.println(\"================================\");\n\nif (!VMEL.begin())\n{\nSerial.println(\"Sensor not found\");\nwhile (1);\n}\n\nVMEL.setGain(VEML7700_GAIN_1);\nVMEL.setIntegrationTime(VEML7700_IT_800MS);\n\nSerial.print(F(\"Gain: \"));\nswitch (VMEL.getGain())\n{\ncase VEML7700_GAIN_1: Serial.println(\"1\"); break;\ncase VEML7700_GAIN_2: Serial.println(\"2\"); break;\ncase VEML7700_GAIN_1_4: Serial.println(\"1/4\"); break;\ncase VEML7700_GAIN_1_8: Serial.println(\"1/8\"); break;\n}\n\nSerial.print(F(\"Integration Time (ms): \"));\nswitch (VMEL.getIntegrationTime())\n{\ncase VEML7700_IT_25MS: Serial.println(\"25\"); break;\ncase VEML7700_IT_50MS: Serial.println(\"50\"); break;\ncase VEML7700_IT_100MS: Serial.println(\"100\"); break;\ncase VEML7700_IT_200MS: Serial.println(\"200\"); break;\ncase VEML7700_IT_400MS: Serial.println(\"400\"); break;\ncase VEML7700_IT_800MS: Serial.println(\"800\"); break;\n}\n\nSerial.println(\"RAK12019 test\");\nWire.begin();\nif (!ltr.init())\n{\nSerial.println(\"Couldn't find LTR sensor!\");\nwhile (1)\ndelay(10);\n}\nSerial.println(\"Found LTR390 sensor!\");\n\n//set to LTR390_MODE_UVS,get ultraviolet light data.\nltr.setMode(LTR390_MODE_UVS);  // UVS Mode\n\nSerial.println(\"In UVS mode\");\n\nltr.setGain(LTR390_GAIN_3);\nSerial.print(\"Gain : \");\nswitch (ltr.getGain())\n{\ncase LTR390_GAIN_1:\nSerial.println(1);\nbreak;\ncase LTR390_GAIN_3:\nSerial.println(3);\nbreak;\ncase LTR390_GAIN_6:\nSerial.println(6);\nbreak;\ncase LTR390_GAIN_9:\nSerial.println(9);\nbreak;\ncase LTR390_GAIN_18:\nSerial.println(18);\nbreak;\ndefault:\nSerial.println(\"Failed to set gain\");\nbreak;\n}\nltr.setResolution(LTR390_RESOLUTION_16BIT);\nSerial.print(\"Integration Time (ms): \");\nswitch (ltr.getResolution())\n{\ncase LTR390_RESOLUTION_13BIT:\nSerial.println(13);\nbreak;\ncase LTR390_RESOLUTION_16BIT:\nSerial.println(16);\nbreak;\ncase LTR390_RESOLUTION_17BIT:\nSerial.println(17);\nbreak;\ncase LTR390_RESOLUTION_18BIT:\nSerial.println(18);\nbreak;\ncase LTR390_RESOLUTION_19BIT:\nSerial.println(19);\nbreak;\ncase LTR390_RESOLUTION_20BIT:\nSerial.println(20);\nbreak;\ndefault:\nSerial.println(\"Failed to set Integration Time\");\nbreak;\n}\n\nltr.setThresholds(100, 1000); //Set the interrupt output threshold range for lower and upper.\n\nltr.configInterrupt(true, LTR390_MODE_UVS);\n\n// For RAK14003\nmcp.begin_I2C(0x24);\n\n// Added for the functionality of RAK14003\n\nWire.begin();    // initialize I2C serial bus\n\n// Configuration of MCP23017 I/O ports\nmcp.pinMode(LED_0, OUTPUT);     // Red LED; Top most\nmcp.pinMode(LED_1, OUTPUT);     // Red LED\nmcp.pinMode(LED_2, OUTPUT);     // Orange LED\nmcp.pinMode(LED_3, OUTPUT);     // Orange LED\nmcp.pinMode(LED_4, OUTPUT);     // Orange LED\nmcp.pinMode(LED_5, OUTPUT);     // Green LED\nmcp.pinMode(LED_6, OUTPUT);     // Green LED\nmcp.pinMode(LED_7, OUTPUT);     // Green LED\nmcp.pinMode(LED_8, OUTPUT);     // Green LED\nmcp.pinMode(LED_9, OUTPUT);     // Green LED; Bottom\n\n// Initially Turn OFF all LEDs\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, HIGH);\n\n}\n\nvoid loop() {\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\n// Trial # 1\n// Data from RAK12019\nif (ltr.newDataAvailable())\n{\nuvi = ltr.getUVI();\nuvs = ltr.readUVS();\n}\n\n// Data from RAK12010\nlux = VMEL.readLux();\nwhite = VMEL.readWhite();\nraw_als = VMEL.readALS();\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\n\n// From RAK12019 module\nSerial.print(\"UVI: \");\nSerial.println(uvi);          // Uvi data from RAK12019\nSerial.print(\"UVS: \");\nSerial.println(uvs);            // Uvs data from RAK12019\n\n// From RAK12010\nSerial.print(\"Lux: \");\nSerial.print(lux);\nSerial.println(\" lx \");\nSerial.print(\"White: \");\nSerial.println(white);\nSerial.print(\"Raw ALS: \");\nSerial.println(raw_als);\n\n// Result of uvi to be displayed via RAK14003 module\nif (uvi <= 0.4)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, HIGH);\n}\n\nelse if (uvi > 0.5 && uvi <= 1)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 1.5 && uvi <= 2)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 2.5 && uvi <= 3)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 3.5 && uvi <= 4)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 4.5 && uvi <= 5)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 5.5 && uvi <= 6)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 6.5 && uvi <= 7)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 7.5 && uvi <= 8)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 8.5 && uvi <= 9.5)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, LOW);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi >= 10)\n{\nmcp.digitalWrite(LED_0, LOW);\nmcp.digitalWrite(LED_1, LOW);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\ndelay(10000);\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void) {\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void) {\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data) {\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class) {\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void) {\nif (lmh_join_status_get() != LMH_SET) {\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\ndata = \" Uvi Data: \" + String(uvi) + \" Uvs Data: \" + String(uvs) + \" Lux Data: \" + String(lux) + \" lx \" ;\n\nSerial.println(data);\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\nuint16_t uvi_data = uvi;            // Uvi data from RAK12019\nuint32_t uvs_data = uvs;            // Uvs data from RAK12019\nuint32_t lux_data = lux;            // Lux data from RAK12010\n\nm_lora_app_data.buffer[i++] = 0x01;  // byte[0]\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\n// Data from RAK12019 module\nm_lora_app_data.buffer[i++] = (uint8_t)((uvi_data & 0x0000FF00) >> 8);     // byte[1]\nm_lora_app_data.buffer[i++] = (uint8_t)(uvi_data & 0x000000FF);            // byte[2]\n\n// Data from RAK12019 module\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0xFF000000) >> 24);    // byte[3]\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0x00FF0000) >> 16);    // byte[4]\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0x0000FF00) >> 8);     // byte[5]\nm_lora_app_data.buffer[i++] = (uint8_t)(uvs_data & 0x000000FF);            // byte[6]\n\n// Data from RAK12010 module\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0xFF000000) >> 24);    // byte[7]\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0x00FF0000) >> 16);    // byte[8]\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0x0000FF00) >> 8);     // byte[9]\nm_lora_app_data.buffer[i++] = (uint8_t)(lux_data & 0x000000FF);            // byte[10]\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS) {\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n} else {\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xE9, 0x0D, 0x28, 0x1D, 0x92, 0x3D, 0xE4, 0x9F, 0xD9, 0xF7, 0xE0, 0x5F, 0x39, 0x10, 0x55, 0x71 };\n\n```  \n> **Image:** OTAA device successfully registered to TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "64b422a58e05916546ea06ab29bc8eb8", "product_family": "wisblock", "product_id": "kit6-light-and-color", "category": "How-To", "title": "WisBlock IoT Education Kit - Light & Color Quick Start Guide > WisBlock IoT Education Kit - Light & Color Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock IoT Education Kit - Light & Color using TTN and Qubitro > UV Index & UV Intensity Monitoring LoRaWAN Application > LoRaWAN Code for UV Index & UV Intensity Monitoring > Programming UV Index & UV Intensity Monitoring Device with Arduino IDE [CODE]", "content": "- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |", "keywords": ["Arduino IDE", "RAK4631", "UV Index", "UV Intensity", "LoRaWAN", "SX126x-Arduino"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **UV Index & UV Intensity Monitoring** device. Just copy the code below for **UV Index & UV Intensity Monitoring LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the example </summary>  \n```c\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h>  //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n#include \"UVlight_LTR390.h\"                // http://librarymanager/All#RAK12019_LTR390\nUVlight_LTR390 ltr = UVlight_LTR390();\n\n#include \"Light_VEML7700.h\"                // http://librarymanager/All#Light_veml7700\nLight_VEML7700 VMEL = Light_VEML7700();\n\nuint16_t uvi;\nuint32_t uvs;\nuint32_t lux;\nuint32_t white;\nuint32_t raw_als;\n\n#include <Adafruit_MCP23X17.h>  //http://librarymanager/All#Adafruit_MCP23017\nAdafruit_MCP23X17 mcp;\n\n// Added definitions for the functionality of RAK14003\nconst uint8_t LED_0 = 0;      // PA0 (17) of MCP23017\nconst uint8_t LED_1 = 1;      // PA1 (18) of MCP23017\nconst uint8_t LED_2 = 2;      // PA2 (19) of MCP23017\nconst uint8_t LED_3 = 3;      // PA3 (20) of MCP23017\nconst uint8_t LED_4 = 4;      // PA4 (21) of MCP23017\nconst uint8_t LED_5 = 5;      // PA5 (22) of MCP23017\nconst uint8_t LED_6 = 6;      // PA6 (23) of MCP23017\nconst uint8_t LED_7 = 7;      // PA7 (24) of MCP23017\nconst uint8_t LED_8 = 8;      // PB0 (25) of MCP23017\nconst uint8_t LED_9 = 9;      // PB1 (26) of MCP23017\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define RAK4631_BOARD true\n#else\n#define RAK4631_BOARD false\n#endif\n\nbool doOTAA = true;                                               // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                                       /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                                     /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5                               /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                                        /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;                           /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;                 /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                              /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = { LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF };\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = { BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler };\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xE9, 0x0D, 0x28, 0x1D, 0x92, 0x3D, 0xE4, 0x9F, 0xD9, 0xF7, 0xE0, 0x5F, 0x39, 0x10, 0x55, 0x71 };\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };\nuint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                                            /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];               //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = { m_lora_app_data_buffer, 0, 0, 0, 0 };  //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {\n\n// Initialize Serial for debug output\npinMode(LED_BLUE, OUTPUT);\ndigitalWrite(LED_BLUE, HIGH);\n\n// Sensor Power Switch\npinMode(WB_IO2, OUTPUT);\ndigitalWrite(WB_IO2, HIGH);\n\n// Reset RAK14003 module\npinMode(WB_IO4, OUTPUT);\ndigitalWrite(WB_IO4, HIGH);\ndelay(10);\ndigitalWrite(WB_IO4, LOW);\ndelay(10);\ndigitalWrite(WB_IO4, HIGH);\ndelay(10);\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial) {\nif ((millis() - timeout) < 5000) {\ndelay(100);\n} else {\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA) {\nSerial.println(\"Type: OTAA\");\n} else {\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion) {\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA) {\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n} else {\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0) {\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"================================\");\nSerial.println(\"RAK12019 + RAK12010 LoRaWAN Code\");\nSerial.println(\"================================\");\n\nif (!VMEL.begin())\n{\nSerial.println(\"Sensor not found\");\nwhile (1);\n}\n\nVMEL.setGain(VEML7700_GAIN_1);\nVMEL.setIntegrationTime(VEML7700_IT_800MS);\n\nSerial.print(F(\"Gain: \"));\nswitch (VMEL.getGain())\n{\ncase VEML7700_GAIN_1: Serial.println(\"1\"); break;\ncase VEML7700_GAIN_2: Serial.println(\"2\"); break;\ncase VEML7700_GAIN_1_4: Serial.println(\"1/4\"); break;\ncase VEML7700_GAIN_1_8: Serial.println(\"1/8\"); break;\n}\n\nSerial.print(F(\"Integration Time (ms): \"));\nswitch (VMEL.getIntegrationTime())\n{\ncase VEML7700_IT_25MS: Serial.println(\"25\"); break;\ncase VEML7700_IT_50MS: Serial.println(\"50\"); break;\ncase VEML7700_IT_100MS: Serial.println(\"100\"); break;\ncase VEML7700_IT_200MS: Serial.println(\"200\"); break;\ncase VEML7700_IT_400MS: Serial.println(\"400\"); break;\ncase VEML7700_IT_800MS: Serial.println(\"800\"); break;\n}\n\nSerial.println(\"RAK12019 test\");\nWire.begin();\nif (!ltr.init())\n{\nSerial.println(\"Couldn't find LTR sensor!\");\nwhile (1)\ndelay(10);\n}\nSerial.println(\"Found LTR390 sensor!\");\n\n//set to LTR390_MODE_UVS,get ultraviolet light data.\nltr.setMode(LTR390_MODE_UVS);  // UVS Mode\n\nSerial.println(\"In UVS mode\");\n\nltr.setGain(LTR390_GAIN_3);\nSerial.print(\"Gain : \");\nswitch (ltr.getGain())\n{\ncase LTR390_GAIN_1:\nSerial.println(1);\nbreak;\ncase LTR390_GAIN_3:\nSerial.println(3);\nbreak;\ncase LTR390_GAIN_6:\nSerial.println(6);\nbreak;\ncase LTR390_GAIN_9:\nSerial.println(9);\nbreak;\ncase LTR390_GAIN_18:\nSerial.println(18);\nbreak;\ndefault:\nSerial.println(\"Failed to set gain\");\nbreak;\n}\nltr.setResolution(LTR390_RESOLUTION_16BIT);\nSerial.print(\"Integration Time (ms): \");\nswitch (ltr.getResolution())\n{\ncase LTR390_RESOLUTION_13BIT:\nSerial.println(13);\nbreak;\ncase LTR390_RESOLUTION_16BIT:\nSerial.println(16);\nbreak;\ncase LTR390_RESOLUTION_17BIT:\nSerial.println(17);\nbreak;\ncase LTR390_RESOLUTION_18BIT:\nSerial.println(18);\nbreak;\ncase LTR390_RESOLUTION_19BIT:\nSerial.println(19);\nbreak;\ncase LTR390_RESOLUTION_20BIT:\nSerial.println(20);\nbreak;\ndefault:\nSerial.println(\"Failed to set Integration Time\");\nbreak;\n}\n\nltr.setThresholds(100, 1000); //Set the interrupt output threshold range for lower and upper.\n\nltr.configInterrupt(true, LTR390_MODE_UVS);\n\n// For RAK14003\nmcp.begin_I2C(0x24);\n\n// Added for the functionality of RAK14003\n\nWire.begin();    // initialize I2C serial bus\n\n// Configuration of MCP23017 I/O ports\nmcp.pinMode(LED_0, OUTPUT);     // Red LED; Top most\nmcp.pinMode(LED_1, OUTPUT);     // Red LED\nmcp.pinMode(LED_2, OUTPUT);     // Orange LED\nmcp.pinMode(LED_3, OUTPUT);     // Orange LED\nmcp.pinMode(LED_4, OUTPUT);     // Orange LED\nmcp.pinMode(LED_5, OUTPUT);     // Green LED\nmcp.pinMode(LED_6, OUTPUT);     // Green LED\nmcp.pinMode(LED_7, OUTPUT);     // Green LED\nmcp.pinMode(LED_8, OUTPUT);     // Green LED\nmcp.pinMode(LED_9, OUTPUT);     // Green LED; Bottom\n\n// Initially Turn OFF all LEDs\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, HIGH);\n\n}\n\nvoid loop() {\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\n// Trial # 1\n// Data from RAK12019\nif (ltr.newDataAvailable())\n{\nuvi = ltr.getUVI();\nuvs = ltr.readUVS();\n}\n\n// Data from RAK12010\nlux = VMEL.readLux();\nwhite = VMEL.readWhite();\nraw_als = VMEL.readALS();\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\n\n// From RAK12019 module\nSerial.print(\"UVI: \");\nSerial.println(uvi);          // Uvi data from RAK12019\nSerial.print(\"UVS: \");\nSerial.println(uvs);            // Uvs data from RAK12019\n\n// From RAK12010\nSerial.print(\"Lux: \");\nSerial.print(lux);\nSerial.println(\" lx \");\nSerial.print(\"White: \");\nSerial.println(white);\nSerial.print(\"Raw ALS: \");\nSerial.println(raw_als);\n\n// Result of uvi to be displayed via RAK14003 module\nif (uvi <= 0.4)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, HIGH);\n}\n\nelse if (uvi > 0.5 && uvi <= 1)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 1.5 && uvi <= 2)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 2.5 && uvi <= 3)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 3.5 && uvi <= 4)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 4.5 && uvi <= 5)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 5.5 && uvi <= 6)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 6.5 && uvi <= 7)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 7.5 && uvi <= 8)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 8.5 && uvi <= 9.5)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, LOW);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi >= 10)\n{\nmcp.digitalWrite(LED_0, LOW);\nmcp.digitalWrite(LED_1, LOW);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\ndelay(10000);\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void) {\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void) {\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data) {\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class) {\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void) {\nif (lmh_join_status_get() != LMH_SET) {\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\ndata = \" Uvi Data: \" + String(uvi) + \" Uvs Data: \" + String(uvs) + \" Lux Data: \" + String(lux) + \" lx \" ;\n\nSerial.println(data);\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\nuint16_t uvi_data = uvi;            // Uvi data from RAK12019\nuint32_t uvs_data = uvs;            // Uvs data from RAK12019\nuint32_t lux_data = lux;            // Lux data from RAK12010\n\nm_lora_app_data.buffer[i++] = 0x01;  // byte[0]\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\n// Data from RAK12019 module\nm_lora_app_data.buffer[i++] = (uint8_t)((uvi_data & 0x0000FF00) >> 8);     // byte[1]\nm_lora_app_data.buffer[i++] = (uint8_t)(uvi_data & 0x000000FF);            // byte[2]\n\n// Data from RAK12019 module\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0xFF000000) >> 24);    // byte[3]\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0x00FF0000) >> 16);    // byte[4]\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0x0000FF00) >> 8);     // byte[5]\nm_lora_app_data.buffer[i++] = (uint8_t)(uvs_data & 0x000000FF);            // byte[6]\n\n// Data from RAK12010 module\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0xFF000000) >> 24);    // byte[7]\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0x00FF0000) >> 16);    // byte[8]\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0x0000FF00) >> 8);     // byte[9]\nm_lora_app_data.buffer[i++] = (uint8_t)(lux_data & 0x000000FF);            // byte[10]\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS) {\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n} else {\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xE9, 0x0D, 0x28, 0x1D, 0x92, 0x3D, 0xE4, 0x9F, 0xD9, 0xF7, 0xE0, 0x5F, 0x39, 0x10, 0x55, 0x71 };\n\n```  \n> **Image:** OTAA device successfully registered to TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "c0a97471343fcb666351684d119f4cc6", "product_family": "wisblock", "product_id": "kit6-light-and-color", "category": "How-To", "title": "WisBlock IoT Education Kit - Light & Color Quick Start Guide > WisBlock IoT Education Kit - Light & Color Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock IoT Education Kit - Light & Color using TTN and Qubitro > UV Index & UV Intensity Monitoring LoRaWAN Application > LoRaWAN Code for UV Index & UV Intensity Monitoring > Programming UV Index & UV Intensity Monitoring Device with Arduino IDE [CODE]", "content": "|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |", "keywords": ["Arduino IDE", "RAK4631", "UV Index", "UV Intensity", "LoRaWAN", "SX126x-Arduino"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **UV Index & UV Intensity Monitoring** device. Just copy the code below for **UV Index & UV Intensity Monitoring LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the example </summary>  \n```c\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h>  //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n#include \"UVlight_LTR390.h\"                // http://librarymanager/All#RAK12019_LTR390\nUVlight_LTR390 ltr = UVlight_LTR390();\n\n#include \"Light_VEML7700.h\"                // http://librarymanager/All#Light_veml7700\nLight_VEML7700 VMEL = Light_VEML7700();\n\nuint16_t uvi;\nuint32_t uvs;\nuint32_t lux;\nuint32_t white;\nuint32_t raw_als;\n\n#include <Adafruit_MCP23X17.h>  //http://librarymanager/All#Adafruit_MCP23017\nAdafruit_MCP23X17 mcp;\n\n// Added definitions for the functionality of RAK14003\nconst uint8_t LED_0 = 0;      // PA0 (17) of MCP23017\nconst uint8_t LED_1 = 1;      // PA1 (18) of MCP23017\nconst uint8_t LED_2 = 2;      // PA2 (19) of MCP23017\nconst uint8_t LED_3 = 3;      // PA3 (20) of MCP23017\nconst uint8_t LED_4 = 4;      // PA4 (21) of MCP23017\nconst uint8_t LED_5 = 5;      // PA5 (22) of MCP23017\nconst uint8_t LED_6 = 6;      // PA6 (23) of MCP23017\nconst uint8_t LED_7 = 7;      // PA7 (24) of MCP23017\nconst uint8_t LED_8 = 8;      // PB0 (25) of MCP23017\nconst uint8_t LED_9 = 9;      // PB1 (26) of MCP23017\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define RAK4631_BOARD true\n#else\n#define RAK4631_BOARD false\n#endif\n\nbool doOTAA = true;                                               // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                                       /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                                     /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5                               /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                                        /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;                           /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;                 /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                              /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = { LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF };\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = { BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler };\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xE9, 0x0D, 0x28, 0x1D, 0x92, 0x3D, 0xE4, 0x9F, 0xD9, 0xF7, 0xE0, 0x5F, 0x39, 0x10, 0x55, 0x71 };\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };\nuint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                                            /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];               //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = { m_lora_app_data_buffer, 0, 0, 0, 0 };  //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {\n\n// Initialize Serial for debug output\npinMode(LED_BLUE, OUTPUT);\ndigitalWrite(LED_BLUE, HIGH);\n\n// Sensor Power Switch\npinMode(WB_IO2, OUTPUT);\ndigitalWrite(WB_IO2, HIGH);\n\n// Reset RAK14003 module\npinMode(WB_IO4, OUTPUT);\ndigitalWrite(WB_IO4, HIGH);\ndelay(10);\ndigitalWrite(WB_IO4, LOW);\ndelay(10);\ndigitalWrite(WB_IO4, HIGH);\ndelay(10);\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial) {\nif ((millis() - timeout) < 5000) {\ndelay(100);\n} else {\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA) {\nSerial.println(\"Type: OTAA\");\n} else {\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion) {\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA) {\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n} else {\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0) {\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"================================\");\nSerial.println(\"RAK12019 + RAK12010 LoRaWAN Code\");\nSerial.println(\"================================\");\n\nif (!VMEL.begin())\n{\nSerial.println(\"Sensor not found\");\nwhile (1);\n}\n\nVMEL.setGain(VEML7700_GAIN_1);\nVMEL.setIntegrationTime(VEML7700_IT_800MS);\n\nSerial.print(F(\"Gain: \"));\nswitch (VMEL.getGain())\n{\ncase VEML7700_GAIN_1: Serial.println(\"1\"); break;\ncase VEML7700_GAIN_2: Serial.println(\"2\"); break;\ncase VEML7700_GAIN_1_4: Serial.println(\"1/4\"); break;\ncase VEML7700_GAIN_1_8: Serial.println(\"1/8\"); break;\n}\n\nSerial.print(F(\"Integration Time (ms): \"));\nswitch (VMEL.getIntegrationTime())\n{\ncase VEML7700_IT_25MS: Serial.println(\"25\"); break;\ncase VEML7700_IT_50MS: Serial.println(\"50\"); break;\ncase VEML7700_IT_100MS: Serial.println(\"100\"); break;\ncase VEML7700_IT_200MS: Serial.println(\"200\"); break;\ncase VEML7700_IT_400MS: Serial.println(\"400\"); break;\ncase VEML7700_IT_800MS: Serial.println(\"800\"); break;\n}\n\nSerial.println(\"RAK12019 test\");\nWire.begin();\nif (!ltr.init())\n{\nSerial.println(\"Couldn't find LTR sensor!\");\nwhile (1)\ndelay(10);\n}\nSerial.println(\"Found LTR390 sensor!\");\n\n//set to LTR390_MODE_UVS,get ultraviolet light data.\nltr.setMode(LTR390_MODE_UVS);  // UVS Mode\n\nSerial.println(\"In UVS mode\");\n\nltr.setGain(LTR390_GAIN_3);\nSerial.print(\"Gain : \");\nswitch (ltr.getGain())\n{\ncase LTR390_GAIN_1:\nSerial.println(1);\nbreak;\ncase LTR390_GAIN_3:\nSerial.println(3);\nbreak;\ncase LTR390_GAIN_6:\nSerial.println(6);\nbreak;\ncase LTR390_GAIN_9:\nSerial.println(9);\nbreak;\ncase LTR390_GAIN_18:\nSerial.println(18);\nbreak;\ndefault:\nSerial.println(\"Failed to set gain\");\nbreak;\n}\nltr.setResolution(LTR390_RESOLUTION_16BIT);\nSerial.print(\"Integration Time (ms): \");\nswitch (ltr.getResolution())\n{\ncase LTR390_RESOLUTION_13BIT:\nSerial.println(13);\nbreak;\ncase LTR390_RESOLUTION_16BIT:\nSerial.println(16);\nbreak;\ncase LTR390_RESOLUTION_17BIT:\nSerial.println(17);\nbreak;\ncase LTR390_RESOLUTION_18BIT:\nSerial.println(18);\nbreak;\ncase LTR390_RESOLUTION_19BIT:\nSerial.println(19);\nbreak;\ncase LTR390_RESOLUTION_20BIT:\nSerial.println(20);\nbreak;\ndefault:\nSerial.println(\"Failed to set Integration Time\");\nbreak;\n}\n\nltr.setThresholds(100, 1000); //Set the interrupt output threshold range for lower and upper.\n\nltr.configInterrupt(true, LTR390_MODE_UVS);\n\n// For RAK14003\nmcp.begin_I2C(0x24);\n\n// Added for the functionality of RAK14003\n\nWire.begin();    // initialize I2C serial bus\n\n// Configuration of MCP23017 I/O ports\nmcp.pinMode(LED_0, OUTPUT);     // Red LED; Top most\nmcp.pinMode(LED_1, OUTPUT);     // Red LED\nmcp.pinMode(LED_2, OUTPUT);     // Orange LED\nmcp.pinMode(LED_3, OUTPUT);     // Orange LED\nmcp.pinMode(LED_4, OUTPUT);     // Orange LED\nmcp.pinMode(LED_5, OUTPUT);     // Green LED\nmcp.pinMode(LED_6, OUTPUT);     // Green LED\nmcp.pinMode(LED_7, OUTPUT);     // Green LED\nmcp.pinMode(LED_8, OUTPUT);     // Green LED\nmcp.pinMode(LED_9, OUTPUT);     // Green LED; Bottom\n\n// Initially Turn OFF all LEDs\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, HIGH);\n\n}\n\nvoid loop() {\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\n// Trial # 1\n// Data from RAK12019\nif (ltr.newDataAvailable())\n{\nuvi = ltr.getUVI();\nuvs = ltr.readUVS();\n}\n\n// Data from RAK12010\nlux = VMEL.readLux();\nwhite = VMEL.readWhite();\nraw_als = VMEL.readALS();\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\n\n// From RAK12019 module\nSerial.print(\"UVI: \");\nSerial.println(uvi);          // Uvi data from RAK12019\nSerial.print(\"UVS: \");\nSerial.println(uvs);            // Uvs data from RAK12019\n\n// From RAK12010\nSerial.print(\"Lux: \");\nSerial.print(lux);\nSerial.println(\" lx \");\nSerial.print(\"White: \");\nSerial.println(white);\nSerial.print(\"Raw ALS: \");\nSerial.println(raw_als);\n\n// Result of uvi to be displayed via RAK14003 module\nif (uvi <= 0.4)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, HIGH);\n}\n\nelse if (uvi > 0.5 && uvi <= 1)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 1.5 && uvi <= 2)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 2.5 && uvi <= 3)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 3.5 && uvi <= 4)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 4.5 && uvi <= 5)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 5.5 && uvi <= 6)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 6.5 && uvi <= 7)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 7.5 && uvi <= 8)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 8.5 && uvi <= 9.5)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, LOW);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi >= 10)\n{\nmcp.digitalWrite(LED_0, LOW);\nmcp.digitalWrite(LED_1, LOW);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\ndelay(10000);\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void) {\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void) {\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data) {\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class) {\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void) {\nif (lmh_join_status_get() != LMH_SET) {\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\ndata = \" Uvi Data: \" + String(uvi) + \" Uvs Data: \" + String(uvs) + \" Lux Data: \" + String(lux) + \" lx \" ;\n\nSerial.println(data);\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\nuint16_t uvi_data = uvi;            // Uvi data from RAK12019\nuint32_t uvs_data = uvs;            // Uvs data from RAK12019\nuint32_t lux_data = lux;            // Lux data from RAK12010\n\nm_lora_app_data.buffer[i++] = 0x01;  // byte[0]\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\n// Data from RAK12019 module\nm_lora_app_data.buffer[i++] = (uint8_t)((uvi_data & 0x0000FF00) >> 8);     // byte[1]\nm_lora_app_data.buffer[i++] = (uint8_t)(uvi_data & 0x000000FF);            // byte[2]\n\n// Data from RAK12019 module\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0xFF000000) >> 24);    // byte[3]\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0x00FF0000) >> 16);    // byte[4]\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0x0000FF00) >> 8);     // byte[5]\nm_lora_app_data.buffer[i++] = (uint8_t)(uvs_data & 0x000000FF);            // byte[6]\n\n// Data from RAK12010 module\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0xFF000000) >> 24);    // byte[7]\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0x00FF0000) >> 16);    // byte[8]\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0x0000FF00) >> 8);     // byte[9]\nm_lora_app_data.buffer[i++] = (uint8_t)(lux_data & 0x000000FF);            // byte[10]\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS) {\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n} else {\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xE9, 0x0D, 0x28, 0x1D, 0x92, 0x3D, 0xE4, 0x9F, 0xD9, 0xF7, 0xE0, 0x5F, 0x39, 0x10, 0x55, 0x71 };\n\n```  \n> **Image:** OTAA device successfully registered to TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "71ba07fda2937627fdc77e3909dba491", "product_family": "wisblock", "product_id": "kit6-light-and-color", "category": "How-To", "title": "WisBlock IoT Education Kit - Light & Color Quick Start Guide > WisBlock IoT Education Kit - Light & Color Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock IoT Education Kit - Light & Color using TTN and Qubitro > UV Index & UV Intensity Monitoring LoRaWAN Application > LoRaWAN Code for UV Index & UV Intensity Monitoring > Programming UV Index & UV Intensity Monitoring Device with Arduino IDE [CODE]", "content": "|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |", "keywords": ["Arduino IDE", "RAK4631", "UV Index", "UV Intensity", "LoRaWAN", "SX126x-Arduino"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **UV Index & UV Intensity Monitoring** device. Just copy the code below for **UV Index & UV Intensity Monitoring LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the example </summary>  \n```c\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h>  //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n#include \"UVlight_LTR390.h\"                // http://librarymanager/All#RAK12019_LTR390\nUVlight_LTR390 ltr = UVlight_LTR390();\n\n#include \"Light_VEML7700.h\"                // http://librarymanager/All#Light_veml7700\nLight_VEML7700 VMEL = Light_VEML7700();\n\nuint16_t uvi;\nuint32_t uvs;\nuint32_t lux;\nuint32_t white;\nuint32_t raw_als;\n\n#include <Adafruit_MCP23X17.h>  //http://librarymanager/All#Adafruit_MCP23017\nAdafruit_MCP23X17 mcp;\n\n// Added definitions for the functionality of RAK14003\nconst uint8_t LED_0 = 0;      // PA0 (17) of MCP23017\nconst uint8_t LED_1 = 1;      // PA1 (18) of MCP23017\nconst uint8_t LED_2 = 2;      // PA2 (19) of MCP23017\nconst uint8_t LED_3 = 3;      // PA3 (20) of MCP23017\nconst uint8_t LED_4 = 4;      // PA4 (21) of MCP23017\nconst uint8_t LED_5 = 5;      // PA5 (22) of MCP23017\nconst uint8_t LED_6 = 6;      // PA6 (23) of MCP23017\nconst uint8_t LED_7 = 7;      // PA7 (24) of MCP23017\nconst uint8_t LED_8 = 8;      // PB0 (25) of MCP23017\nconst uint8_t LED_9 = 9;      // PB1 (26) of MCP23017\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define RAK4631_BOARD true\n#else\n#define RAK4631_BOARD false\n#endif\n\nbool doOTAA = true;                                               // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                                       /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                                     /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5                               /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                                        /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;                           /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;                 /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                              /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = { LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF };\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = { BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler };\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xE9, 0x0D, 0x28, 0x1D, 0x92, 0x3D, 0xE4, 0x9F, 0xD9, 0xF7, 0xE0, 0x5F, 0x39, 0x10, 0x55, 0x71 };\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };\nuint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                                            /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];               //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = { m_lora_app_data_buffer, 0, 0, 0, 0 };  //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {\n\n// Initialize Serial for debug output\npinMode(LED_BLUE, OUTPUT);\ndigitalWrite(LED_BLUE, HIGH);\n\n// Sensor Power Switch\npinMode(WB_IO2, OUTPUT);\ndigitalWrite(WB_IO2, HIGH);\n\n// Reset RAK14003 module\npinMode(WB_IO4, OUTPUT);\ndigitalWrite(WB_IO4, HIGH);\ndelay(10);\ndigitalWrite(WB_IO4, LOW);\ndelay(10);\ndigitalWrite(WB_IO4, HIGH);\ndelay(10);\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial) {\nif ((millis() - timeout) < 5000) {\ndelay(100);\n} else {\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA) {\nSerial.println(\"Type: OTAA\");\n} else {\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion) {\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA) {\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n} else {\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0) {\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"================================\");\nSerial.println(\"RAK12019 + RAK12010 LoRaWAN Code\");\nSerial.println(\"================================\");\n\nif (!VMEL.begin())\n{\nSerial.println(\"Sensor not found\");\nwhile (1);\n}\n\nVMEL.setGain(VEML7700_GAIN_1);\nVMEL.setIntegrationTime(VEML7700_IT_800MS);\n\nSerial.print(F(\"Gain: \"));\nswitch (VMEL.getGain())\n{\ncase VEML7700_GAIN_1: Serial.println(\"1\"); break;\ncase VEML7700_GAIN_2: Serial.println(\"2\"); break;\ncase VEML7700_GAIN_1_4: Serial.println(\"1/4\"); break;\ncase VEML7700_GAIN_1_8: Serial.println(\"1/8\"); break;\n}\n\nSerial.print(F(\"Integration Time (ms): \"));\nswitch (VMEL.getIntegrationTime())\n{\ncase VEML7700_IT_25MS: Serial.println(\"25\"); break;\ncase VEML7700_IT_50MS: Serial.println(\"50\"); break;\ncase VEML7700_IT_100MS: Serial.println(\"100\"); break;\ncase VEML7700_IT_200MS: Serial.println(\"200\"); break;\ncase VEML7700_IT_400MS: Serial.println(\"400\"); break;\ncase VEML7700_IT_800MS: Serial.println(\"800\"); break;\n}\n\nSerial.println(\"RAK12019 test\");\nWire.begin();\nif (!ltr.init())\n{\nSerial.println(\"Couldn't find LTR sensor!\");\nwhile (1)\ndelay(10);\n}\nSerial.println(\"Found LTR390 sensor!\");\n\n//set to LTR390_MODE_UVS,get ultraviolet light data.\nltr.setMode(LTR390_MODE_UVS);  // UVS Mode\n\nSerial.println(\"In UVS mode\");\n\nltr.setGain(LTR390_GAIN_3);\nSerial.print(\"Gain : \");\nswitch (ltr.getGain())\n{\ncase LTR390_GAIN_1:\nSerial.println(1);\nbreak;\ncase LTR390_GAIN_3:\nSerial.println(3);\nbreak;\ncase LTR390_GAIN_6:\nSerial.println(6);\nbreak;\ncase LTR390_GAIN_9:\nSerial.println(9);\nbreak;\ncase LTR390_GAIN_18:\nSerial.println(18);\nbreak;\ndefault:\nSerial.println(\"Failed to set gain\");\nbreak;\n}\nltr.setResolution(LTR390_RESOLUTION_16BIT);\nSerial.print(\"Integration Time (ms): \");\nswitch (ltr.getResolution())\n{\ncase LTR390_RESOLUTION_13BIT:\nSerial.println(13);\nbreak;\ncase LTR390_RESOLUTION_16BIT:\nSerial.println(16);\nbreak;\ncase LTR390_RESOLUTION_17BIT:\nSerial.println(17);\nbreak;\ncase LTR390_RESOLUTION_18BIT:\nSerial.println(18);\nbreak;\ncase LTR390_RESOLUTION_19BIT:\nSerial.println(19);\nbreak;\ncase LTR390_RESOLUTION_20BIT:\nSerial.println(20);\nbreak;\ndefault:\nSerial.println(\"Failed to set Integration Time\");\nbreak;\n}\n\nltr.setThresholds(100, 1000); //Set the interrupt output threshold range for lower and upper.\n\nltr.configInterrupt(true, LTR390_MODE_UVS);\n\n// For RAK14003\nmcp.begin_I2C(0x24);\n\n// Added for the functionality of RAK14003\n\nWire.begin();    // initialize I2C serial bus\n\n// Configuration of MCP23017 I/O ports\nmcp.pinMode(LED_0, OUTPUT);     // Red LED; Top most\nmcp.pinMode(LED_1, OUTPUT);     // Red LED\nmcp.pinMode(LED_2, OUTPUT);     // Orange LED\nmcp.pinMode(LED_3, OUTPUT);     // Orange LED\nmcp.pinMode(LED_4, OUTPUT);     // Orange LED\nmcp.pinMode(LED_5, OUTPUT);     // Green LED\nmcp.pinMode(LED_6, OUTPUT);     // Green LED\nmcp.pinMode(LED_7, OUTPUT);     // Green LED\nmcp.pinMode(LED_8, OUTPUT);     // Green LED\nmcp.pinMode(LED_9, OUTPUT);     // Green LED; Bottom\n\n// Initially Turn OFF all LEDs\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, HIGH);\n\n}\n\nvoid loop() {\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\n// Trial # 1\n// Data from RAK12019\nif (ltr.newDataAvailable())\n{\nuvi = ltr.getUVI();\nuvs = ltr.readUVS();\n}\n\n// Data from RAK12010\nlux = VMEL.readLux();\nwhite = VMEL.readWhite();\nraw_als = VMEL.readALS();\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\n\n// From RAK12019 module\nSerial.print(\"UVI: \");\nSerial.println(uvi);          // Uvi data from RAK12019\nSerial.print(\"UVS: \");\nSerial.println(uvs);            // Uvs data from RAK12019\n\n// From RAK12010\nSerial.print(\"Lux: \");\nSerial.print(lux);\nSerial.println(\" lx \");\nSerial.print(\"White: \");\nSerial.println(white);\nSerial.print(\"Raw ALS: \");\nSerial.println(raw_als);\n\n// Result of uvi to be displayed via RAK14003 module\nif (uvi <= 0.4)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, HIGH);\n}\n\nelse if (uvi > 0.5 && uvi <= 1)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 1.5 && uvi <= 2)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 2.5 && uvi <= 3)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 3.5 && uvi <= 4)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 4.5 && uvi <= 5)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 5.5 && uvi <= 6)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 6.5 && uvi <= 7)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 7.5 && uvi <= 8)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 8.5 && uvi <= 9.5)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, LOW);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi >= 10)\n{\nmcp.digitalWrite(LED_0, LOW);\nmcp.digitalWrite(LED_1, LOW);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\ndelay(10000);\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void) {\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void) {\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data) {\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class) {\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void) {\nif (lmh_join_status_get() != LMH_SET) {\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\ndata = \" Uvi Data: \" + String(uvi) + \" Uvs Data: \" + String(uvs) + \" Lux Data: \" + String(lux) + \" lx \" ;\n\nSerial.println(data);\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\nuint16_t uvi_data = uvi;            // Uvi data from RAK12019\nuint32_t uvs_data = uvs;            // Uvs data from RAK12019\nuint32_t lux_data = lux;            // Lux data from RAK12010\n\nm_lora_app_data.buffer[i++] = 0x01;  // byte[0]\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\n// Data from RAK12019 module\nm_lora_app_data.buffer[i++] = (uint8_t)((uvi_data & 0x0000FF00) >> 8);     // byte[1]\nm_lora_app_data.buffer[i++] = (uint8_t)(uvi_data & 0x000000FF);            // byte[2]\n\n// Data from RAK12019 module\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0xFF000000) >> 24);    // byte[3]\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0x00FF0000) >> 16);    // byte[4]\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0x0000FF00) >> 8);     // byte[5]\nm_lora_app_data.buffer[i++] = (uint8_t)(uvs_data & 0x000000FF);            // byte[6]\n\n// Data from RAK12010 module\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0xFF000000) >> 24);    // byte[7]\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0x00FF0000) >> 16);    // byte[8]\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0x0000FF00) >> 8);     // byte[9]\nm_lora_app_data.buffer[i++] = (uint8_t)(lux_data & 0x000000FF);            // byte[10]\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS) {\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n} else {\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xE9, 0x0D, 0x28, 0x1D, 0x92, 0x3D, 0xE4, 0x9F, 0xD9, 0xF7, 0xE0, 0x5F, 0x39, 0x10, 0x55, 0x71 };\n\n```  \n> **Image:** OTAA device successfully registered to TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "5cb1f825ffd8a889d684853532df8f01", "product_family": "wisblock", "product_id": "kit6-light-and-color", "category": "How-To", "title": "WisBlock IoT Education Kit - Light & Color Quick Start Guide > WisBlock IoT Education Kit - Light & Color Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock IoT Education Kit - Light & Color using TTN and Qubitro > UV Index & UV Intensity Monitoring LoRaWAN Application > LoRaWAN Code for UV Index & UV Intensity Monitoring > Programming UV Index & UV Intensity Monitoring Device with Arduino IDE [CODE]", "content": "|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |", "keywords": ["Arduino IDE", "RAK4631", "UV Index", "UV Intensity", "LoRaWAN", "SX126x-Arduino"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **UV Index & UV Intensity Monitoring** device. Just copy the code below for **UV Index & UV Intensity Monitoring LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the example </summary>  \n```c\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h>  //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n#include \"UVlight_LTR390.h\"                // http://librarymanager/All#RAK12019_LTR390\nUVlight_LTR390 ltr = UVlight_LTR390();\n\n#include \"Light_VEML7700.h\"                // http://librarymanager/All#Light_veml7700\nLight_VEML7700 VMEL = Light_VEML7700();\n\nuint16_t uvi;\nuint32_t uvs;\nuint32_t lux;\nuint32_t white;\nuint32_t raw_als;\n\n#include <Adafruit_MCP23X17.h>  //http://librarymanager/All#Adafruit_MCP23017\nAdafruit_MCP23X17 mcp;\n\n// Added definitions for the functionality of RAK14003\nconst uint8_t LED_0 = 0;      // PA0 (17) of MCP23017\nconst uint8_t LED_1 = 1;      // PA1 (18) of MCP23017\nconst uint8_t LED_2 = 2;      // PA2 (19) of MCP23017\nconst uint8_t LED_3 = 3;      // PA3 (20) of MCP23017\nconst uint8_t LED_4 = 4;      // PA4 (21) of MCP23017\nconst uint8_t LED_5 = 5;      // PA5 (22) of MCP23017\nconst uint8_t LED_6 = 6;      // PA6 (23) of MCP23017\nconst uint8_t LED_7 = 7;      // PA7 (24) of MCP23017\nconst uint8_t LED_8 = 8;      // PB0 (25) of MCP23017\nconst uint8_t LED_9 = 9;      // PB1 (26) of MCP23017\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define RAK4631_BOARD true\n#else\n#define RAK4631_BOARD false\n#endif\n\nbool doOTAA = true;                                               // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                                       /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                                     /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5                               /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                                        /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;                           /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;                 /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                              /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = { LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF };\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = { BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler };\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xE9, 0x0D, 0x28, 0x1D, 0x92, 0x3D, 0xE4, 0x9F, 0xD9, 0xF7, 0xE0, 0x5F, 0x39, 0x10, 0x55, 0x71 };\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };\nuint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                                            /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];               //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = { m_lora_app_data_buffer, 0, 0, 0, 0 };  //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {\n\n// Initialize Serial for debug output\npinMode(LED_BLUE, OUTPUT);\ndigitalWrite(LED_BLUE, HIGH);\n\n// Sensor Power Switch\npinMode(WB_IO2, OUTPUT);\ndigitalWrite(WB_IO2, HIGH);\n\n// Reset RAK14003 module\npinMode(WB_IO4, OUTPUT);\ndigitalWrite(WB_IO4, HIGH);\ndelay(10);\ndigitalWrite(WB_IO4, LOW);\ndelay(10);\ndigitalWrite(WB_IO4, HIGH);\ndelay(10);\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial) {\nif ((millis() - timeout) < 5000) {\ndelay(100);\n} else {\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA) {\nSerial.println(\"Type: OTAA\");\n} else {\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion) {\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA) {\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n} else {\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0) {\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"================================\");\nSerial.println(\"RAK12019 + RAK12010 LoRaWAN Code\");\nSerial.println(\"================================\");\n\nif (!VMEL.begin())\n{\nSerial.println(\"Sensor not found\");\nwhile (1);\n}\n\nVMEL.setGain(VEML7700_GAIN_1);\nVMEL.setIntegrationTime(VEML7700_IT_800MS);\n\nSerial.print(F(\"Gain: \"));\nswitch (VMEL.getGain())\n{\ncase VEML7700_GAIN_1: Serial.println(\"1\"); break;\ncase VEML7700_GAIN_2: Serial.println(\"2\"); break;\ncase VEML7700_GAIN_1_4: Serial.println(\"1/4\"); break;\ncase VEML7700_GAIN_1_8: Serial.println(\"1/8\"); break;\n}\n\nSerial.print(F(\"Integration Time (ms): \"));\nswitch (VMEL.getIntegrationTime())\n{\ncase VEML7700_IT_25MS: Serial.println(\"25\"); break;\ncase VEML7700_IT_50MS: Serial.println(\"50\"); break;\ncase VEML7700_IT_100MS: Serial.println(\"100\"); break;\ncase VEML7700_IT_200MS: Serial.println(\"200\"); break;\ncase VEML7700_IT_400MS: Serial.println(\"400\"); break;\ncase VEML7700_IT_800MS: Serial.println(\"800\"); break;\n}\n\nSerial.println(\"RAK12019 test\");\nWire.begin();\nif (!ltr.init())\n{\nSerial.println(\"Couldn't find LTR sensor!\");\nwhile (1)\ndelay(10);\n}\nSerial.println(\"Found LTR390 sensor!\");\n\n//set to LTR390_MODE_UVS,get ultraviolet light data.\nltr.setMode(LTR390_MODE_UVS);  // UVS Mode\n\nSerial.println(\"In UVS mode\");\n\nltr.setGain(LTR390_GAIN_3);\nSerial.print(\"Gain : \");\nswitch (ltr.getGain())\n{\ncase LTR390_GAIN_1:\nSerial.println(1);\nbreak;\ncase LTR390_GAIN_3:\nSerial.println(3);\nbreak;\ncase LTR390_GAIN_6:\nSerial.println(6);\nbreak;\ncase LTR390_GAIN_9:\nSerial.println(9);\nbreak;\ncase LTR390_GAIN_18:\nSerial.println(18);\nbreak;\ndefault:\nSerial.println(\"Failed to set gain\");\nbreak;\n}\nltr.setResolution(LTR390_RESOLUTION_16BIT);\nSerial.print(\"Integration Time (ms): \");\nswitch (ltr.getResolution())\n{\ncase LTR390_RESOLUTION_13BIT:\nSerial.println(13);\nbreak;\ncase LTR390_RESOLUTION_16BIT:\nSerial.println(16);\nbreak;\ncase LTR390_RESOLUTION_17BIT:\nSerial.println(17);\nbreak;\ncase LTR390_RESOLUTION_18BIT:\nSerial.println(18);\nbreak;\ncase LTR390_RESOLUTION_19BIT:\nSerial.println(19);\nbreak;\ncase LTR390_RESOLUTION_20BIT:\nSerial.println(20);\nbreak;\ndefault:\nSerial.println(\"Failed to set Integration Time\");\nbreak;\n}\n\nltr.setThresholds(100, 1000); //Set the interrupt output threshold range for lower and upper.\n\nltr.configInterrupt(true, LTR390_MODE_UVS);\n\n// For RAK14003\nmcp.begin_I2C(0x24);\n\n// Added for the functionality of RAK14003\n\nWire.begin();    // initialize I2C serial bus\n\n// Configuration of MCP23017 I/O ports\nmcp.pinMode(LED_0, OUTPUT);     // Red LED; Top most\nmcp.pinMode(LED_1, OUTPUT);     // Red LED\nmcp.pinMode(LED_2, OUTPUT);     // Orange LED\nmcp.pinMode(LED_3, OUTPUT);     // Orange LED\nmcp.pinMode(LED_4, OUTPUT);     // Orange LED\nmcp.pinMode(LED_5, OUTPUT);     // Green LED\nmcp.pinMode(LED_6, OUTPUT);     // Green LED\nmcp.pinMode(LED_7, OUTPUT);     // Green LED\nmcp.pinMode(LED_8, OUTPUT);     // Green LED\nmcp.pinMode(LED_9, OUTPUT);     // Green LED; Bottom\n\n// Initially Turn OFF all LEDs\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, HIGH);\n\n}\n\nvoid loop() {\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\n// Trial # 1\n// Data from RAK12019\nif (ltr.newDataAvailable())\n{\nuvi = ltr.getUVI();\nuvs = ltr.readUVS();\n}\n\n// Data from RAK12010\nlux = VMEL.readLux();\nwhite = VMEL.readWhite();\nraw_als = VMEL.readALS();\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\n\n// From RAK12019 module\nSerial.print(\"UVI: \");\nSerial.println(uvi);          // Uvi data from RAK12019\nSerial.print(\"UVS: \");\nSerial.println(uvs);            // Uvs data from RAK12019\n\n// From RAK12010\nSerial.print(\"Lux: \");\nSerial.print(lux);\nSerial.println(\" lx \");\nSerial.print(\"White: \");\nSerial.println(white);\nSerial.print(\"Raw ALS: \");\nSerial.println(raw_als);\n\n// Result of uvi to be displayed via RAK14003 module\nif (uvi <= 0.4)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, HIGH);\n}\n\nelse if (uvi > 0.5 && uvi <= 1)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 1.5 && uvi <= 2)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 2.5 && uvi <= 3)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 3.5 && uvi <= 4)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 4.5 && uvi <= 5)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 5.5 && uvi <= 6)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 6.5 && uvi <= 7)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 7.5 && uvi <= 8)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 8.5 && uvi <= 9.5)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, LOW);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi >= 10)\n{\nmcp.digitalWrite(LED_0, LOW);\nmcp.digitalWrite(LED_1, LOW);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\ndelay(10000);\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void) {\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void) {\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data) {\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class) {\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void) {\nif (lmh_join_status_get() != LMH_SET) {\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\ndata = \" Uvi Data: \" + String(uvi) + \" Uvs Data: \" + String(uvs) + \" Lux Data: \" + String(lux) + \" lx \" ;\n\nSerial.println(data);\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\nuint16_t uvi_data = uvi;            // Uvi data from RAK12019\nuint32_t uvs_data = uvs;            // Uvs data from RAK12019\nuint32_t lux_data = lux;            // Lux data from RAK12010\n\nm_lora_app_data.buffer[i++] = 0x01;  // byte[0]\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\n// Data from RAK12019 module\nm_lora_app_data.buffer[i++] = (uint8_t)((uvi_data & 0x0000FF00) >> 8);     // byte[1]\nm_lora_app_data.buffer[i++] = (uint8_t)(uvi_data & 0x000000FF);            // byte[2]\n\n// Data from RAK12019 module\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0xFF000000) >> 24);    // byte[3]\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0x00FF0000) >> 16);    // byte[4]\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0x0000FF00) >> 8);     // byte[5]\nm_lora_app_data.buffer[i++] = (uint8_t)(uvs_data & 0x000000FF);            // byte[6]\n\n// Data from RAK12010 module\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0xFF000000) >> 24);    // byte[7]\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0x00FF0000) >> 16);    // byte[8]\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0x0000FF00) >> 8);     // byte[9]\nm_lora_app_data.buffer[i++] = (uint8_t)(lux_data & 0x000000FF);            // byte[10]\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS) {\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n} else {\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xE9, 0x0D, 0x28, 0x1D, 0x92, 0x3D, 0xE4, 0x9F, 0xD9, 0xF7, 0xE0, 0x5F, 0x39, 0x10, 0x55, 0x71 };\n\n```  \n> **Image:** OTAA device successfully registered to TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "3ca52c4d6f06bda5600a7400cd35a5e1", "product_family": "wisblock", "product_id": "kit6-light-and-color", "category": "How-To", "title": "WisBlock IoT Education Kit - Light & Color Quick Start Guide > WisBlock IoT Education Kit - Light & Color Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock IoT Education Kit - Light & Color using TTN and Qubitro > UV Index & UV Intensity Monitoring LoRaWAN Application > LoRaWAN Code for UV Index & UV Intensity Monitoring > Programming UV Index & UV Intensity Monitoring Device with Arduino IDE [CODE]", "content": "|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```", "keywords": ["Arduino IDE", "RAK4631", "UV Index", "UV Intensity", "LoRaWAN", "SX126x-Arduino"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **UV Index & UV Intensity Monitoring** device. Just copy the code below for **UV Index & UV Intensity Monitoring LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the example </summary>  \n```c\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h>  //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n#include \"UVlight_LTR390.h\"                // http://librarymanager/All#RAK12019_LTR390\nUVlight_LTR390 ltr = UVlight_LTR390();\n\n#include \"Light_VEML7700.h\"                // http://librarymanager/All#Light_veml7700\nLight_VEML7700 VMEL = Light_VEML7700();\n\nuint16_t uvi;\nuint32_t uvs;\nuint32_t lux;\nuint32_t white;\nuint32_t raw_als;\n\n#include <Adafruit_MCP23X17.h>  //http://librarymanager/All#Adafruit_MCP23017\nAdafruit_MCP23X17 mcp;\n\n// Added definitions for the functionality of RAK14003\nconst uint8_t LED_0 = 0;      // PA0 (17) of MCP23017\nconst uint8_t LED_1 = 1;      // PA1 (18) of MCP23017\nconst uint8_t LED_2 = 2;      // PA2 (19) of MCP23017\nconst uint8_t LED_3 = 3;      // PA3 (20) of MCP23017\nconst uint8_t LED_4 = 4;      // PA4 (21) of MCP23017\nconst uint8_t LED_5 = 5;      // PA5 (22) of MCP23017\nconst uint8_t LED_6 = 6;      // PA6 (23) of MCP23017\nconst uint8_t LED_7 = 7;      // PA7 (24) of MCP23017\nconst uint8_t LED_8 = 8;      // PB0 (25) of MCP23017\nconst uint8_t LED_9 = 9;      // PB1 (26) of MCP23017\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define RAK4631_BOARD true\n#else\n#define RAK4631_BOARD false\n#endif\n\nbool doOTAA = true;                                               // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                                       /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                                     /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5                               /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                                        /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;                           /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;                 /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                              /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = { LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF };\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = { BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler };\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xE9, 0x0D, 0x28, 0x1D, 0x92, 0x3D, 0xE4, 0x9F, 0xD9, 0xF7, 0xE0, 0x5F, 0x39, 0x10, 0x55, 0x71 };\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };\nuint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                                            /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];               //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = { m_lora_app_data_buffer, 0, 0, 0, 0 };  //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {\n\n// Initialize Serial for debug output\npinMode(LED_BLUE, OUTPUT);\ndigitalWrite(LED_BLUE, HIGH);\n\n// Sensor Power Switch\npinMode(WB_IO2, OUTPUT);\ndigitalWrite(WB_IO2, HIGH);\n\n// Reset RAK14003 module\npinMode(WB_IO4, OUTPUT);\ndigitalWrite(WB_IO4, HIGH);\ndelay(10);\ndigitalWrite(WB_IO4, LOW);\ndelay(10);\ndigitalWrite(WB_IO4, HIGH);\ndelay(10);\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial) {\nif ((millis() - timeout) < 5000) {\ndelay(100);\n} else {\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA) {\nSerial.println(\"Type: OTAA\");\n} else {\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion) {\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA) {\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n} else {\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0) {\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"================================\");\nSerial.println(\"RAK12019 + RAK12010 LoRaWAN Code\");\nSerial.println(\"================================\");\n\nif (!VMEL.begin())\n{\nSerial.println(\"Sensor not found\");\nwhile (1);\n}\n\nVMEL.setGain(VEML7700_GAIN_1);\nVMEL.setIntegrationTime(VEML7700_IT_800MS);\n\nSerial.print(F(\"Gain: \"));\nswitch (VMEL.getGain())\n{\ncase VEML7700_GAIN_1: Serial.println(\"1\"); break;\ncase VEML7700_GAIN_2: Serial.println(\"2\"); break;\ncase VEML7700_GAIN_1_4: Serial.println(\"1/4\"); break;\ncase VEML7700_GAIN_1_8: Serial.println(\"1/8\"); break;\n}\n\nSerial.print(F(\"Integration Time (ms): \"));\nswitch (VMEL.getIntegrationTime())\n{\ncase VEML7700_IT_25MS: Serial.println(\"25\"); break;\ncase VEML7700_IT_50MS: Serial.println(\"50\"); break;\ncase VEML7700_IT_100MS: Serial.println(\"100\"); break;\ncase VEML7700_IT_200MS: Serial.println(\"200\"); break;\ncase VEML7700_IT_400MS: Serial.println(\"400\"); break;\ncase VEML7700_IT_800MS: Serial.println(\"800\"); break;\n}\n\nSerial.println(\"RAK12019 test\");\nWire.begin();\nif (!ltr.init())\n{\nSerial.println(\"Couldn't find LTR sensor!\");\nwhile (1)\ndelay(10);\n}\nSerial.println(\"Found LTR390 sensor!\");\n\n//set to LTR390_MODE_UVS,get ultraviolet light data.\nltr.setMode(LTR390_MODE_UVS);  // UVS Mode\n\nSerial.println(\"In UVS mode\");\n\nltr.setGain(LTR390_GAIN_3);\nSerial.print(\"Gain : \");\nswitch (ltr.getGain())\n{\ncase LTR390_GAIN_1:\nSerial.println(1);\nbreak;\ncase LTR390_GAIN_3:\nSerial.println(3);\nbreak;\ncase LTR390_GAIN_6:\nSerial.println(6);\nbreak;\ncase LTR390_GAIN_9:\nSerial.println(9);\nbreak;\ncase LTR390_GAIN_18:\nSerial.println(18);\nbreak;\ndefault:\nSerial.println(\"Failed to set gain\");\nbreak;\n}\nltr.setResolution(LTR390_RESOLUTION_16BIT);\nSerial.print(\"Integration Time (ms): \");\nswitch (ltr.getResolution())\n{\ncase LTR390_RESOLUTION_13BIT:\nSerial.println(13);\nbreak;\ncase LTR390_RESOLUTION_16BIT:\nSerial.println(16);\nbreak;\ncase LTR390_RESOLUTION_17BIT:\nSerial.println(17);\nbreak;\ncase LTR390_RESOLUTION_18BIT:\nSerial.println(18);\nbreak;\ncase LTR390_RESOLUTION_19BIT:\nSerial.println(19);\nbreak;\ncase LTR390_RESOLUTION_20BIT:\nSerial.println(20);\nbreak;\ndefault:\nSerial.println(\"Failed to set Integration Time\");\nbreak;\n}\n\nltr.setThresholds(100, 1000); //Set the interrupt output threshold range for lower and upper.\n\nltr.configInterrupt(true, LTR390_MODE_UVS);\n\n// For RAK14003\nmcp.begin_I2C(0x24);\n\n// Added for the functionality of RAK14003\n\nWire.begin();    // initialize I2C serial bus\n\n// Configuration of MCP23017 I/O ports\nmcp.pinMode(LED_0, OUTPUT);     // Red LED; Top most\nmcp.pinMode(LED_1, OUTPUT);     // Red LED\nmcp.pinMode(LED_2, OUTPUT);     // Orange LED\nmcp.pinMode(LED_3, OUTPUT);     // Orange LED\nmcp.pinMode(LED_4, OUTPUT);     // Orange LED\nmcp.pinMode(LED_5, OUTPUT);     // Green LED\nmcp.pinMode(LED_6, OUTPUT);     // Green LED\nmcp.pinMode(LED_7, OUTPUT);     // Green LED\nmcp.pinMode(LED_8, OUTPUT);     // Green LED\nmcp.pinMode(LED_9, OUTPUT);     // Green LED; Bottom\n\n// Initially Turn OFF all LEDs\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, HIGH);\n\n}\n\nvoid loop() {\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\n// Trial # 1\n// Data from RAK12019\nif (ltr.newDataAvailable())\n{\nuvi = ltr.getUVI();\nuvs = ltr.readUVS();\n}\n\n// Data from RAK12010\nlux = VMEL.readLux();\nwhite = VMEL.readWhite();\nraw_als = VMEL.readALS();\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\n\n// From RAK12019 module\nSerial.print(\"UVI: \");\nSerial.println(uvi);          // Uvi data from RAK12019\nSerial.print(\"UVS: \");\nSerial.println(uvs);            // Uvs data from RAK12019\n\n// From RAK12010\nSerial.print(\"Lux: \");\nSerial.print(lux);\nSerial.println(\" lx \");\nSerial.print(\"White: \");\nSerial.println(white);\nSerial.print(\"Raw ALS: \");\nSerial.println(raw_als);\n\n// Result of uvi to be displayed via RAK14003 module\nif (uvi <= 0.4)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, HIGH);\n}\n\nelse if (uvi > 0.5 && uvi <= 1)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 1.5 && uvi <= 2)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 2.5 && uvi <= 3)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 3.5 && uvi <= 4)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 4.5 && uvi <= 5)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 5.5 && uvi <= 6)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 6.5 && uvi <= 7)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 7.5 && uvi <= 8)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 8.5 && uvi <= 9.5)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, LOW);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi >= 10)\n{\nmcp.digitalWrite(LED_0, LOW);\nmcp.digitalWrite(LED_1, LOW);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\ndelay(10000);\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void) {\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void) {\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data) {\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class) {\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void) {\nif (lmh_join_status_get() != LMH_SET) {\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\ndata = \" Uvi Data: \" + String(uvi) + \" Uvs Data: \" + String(uvs) + \" Lux Data: \" + String(lux) + \" lx \" ;\n\nSerial.println(data);\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\nuint16_t uvi_data = uvi;            // Uvi data from RAK12019\nuint32_t uvs_data = uvs;            // Uvs data from RAK12019\nuint32_t lux_data = lux;            // Lux data from RAK12010\n\nm_lora_app_data.buffer[i++] = 0x01;  // byte[0]\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\n// Data from RAK12019 module\nm_lora_app_data.buffer[i++] = (uint8_t)((uvi_data & 0x0000FF00) >> 8);     // byte[1]\nm_lora_app_data.buffer[i++] = (uint8_t)(uvi_data & 0x000000FF);            // byte[2]\n\n// Data from RAK12019 module\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0xFF000000) >> 24);    // byte[3]\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0x00FF0000) >> 16);    // byte[4]\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0x0000FF00) >> 8);     // byte[5]\nm_lora_app_data.buffer[i++] = (uint8_t)(uvs_data & 0x000000FF);            // byte[6]\n\n// Data from RAK12010 module\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0xFF000000) >> 24);    // byte[7]\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0x00FF0000) >> 16);    // byte[8]\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0x0000FF00) >> 8);     // byte[9]\nm_lora_app_data.buffer[i++] = (uint8_t)(lux_data & 0x000000FF);            // byte[10]\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS) {\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n} else {\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xE9, 0x0D, 0x28, 0x1D, 0x92, 0x3D, 0xE4, 0x9F, 0xD9, 0xF7, 0xE0, 0x5F, 0x39, 0x10, 0x55, 0x71 };\n\n```  \n> **Image:** OTAA device successfully registered to TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "3da90bfd321bf61edd31b1cf1c1a1acf", "product_family": "wisblock", "product_id": "kit6-light-and-color", "category": "How-To", "title": "WisBlock IoT Education Kit - Light & Color Quick Start Guide > WisBlock IoT Education Kit - Light & Color Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock IoT Education Kit - Light & Color using TTN and Qubitro > UV Index & UV Intensity Monitoring LoRaWAN Application > LoRaWAN Code for UV Index & UV Intensity Monitoring > Programming UV Index & UV Intensity Monitoring Device with Arduino IDE [CODE]", "content": "```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```", "keywords": ["Arduino IDE", "RAK4631", "UV Index", "UV Intensity", "LoRaWAN", "SX126x-Arduino"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **UV Index & UV Intensity Monitoring** device. Just copy the code below for **UV Index & UV Intensity Monitoring LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the example </summary>  \n```c\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h>  //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n#include \"UVlight_LTR390.h\"                // http://librarymanager/All#RAK12019_LTR390\nUVlight_LTR390 ltr = UVlight_LTR390();\n\n#include \"Light_VEML7700.h\"                // http://librarymanager/All#Light_veml7700\nLight_VEML7700 VMEL = Light_VEML7700();\n\nuint16_t uvi;\nuint32_t uvs;\nuint32_t lux;\nuint32_t white;\nuint32_t raw_als;\n\n#include <Adafruit_MCP23X17.h>  //http://librarymanager/All#Adafruit_MCP23017\nAdafruit_MCP23X17 mcp;\n\n// Added definitions for the functionality of RAK14003\nconst uint8_t LED_0 = 0;      // PA0 (17) of MCP23017\nconst uint8_t LED_1 = 1;      // PA1 (18) of MCP23017\nconst uint8_t LED_2 = 2;      // PA2 (19) of MCP23017\nconst uint8_t LED_3 = 3;      // PA3 (20) of MCP23017\nconst uint8_t LED_4 = 4;      // PA4 (21) of MCP23017\nconst uint8_t LED_5 = 5;      // PA5 (22) of MCP23017\nconst uint8_t LED_6 = 6;      // PA6 (23) of MCP23017\nconst uint8_t LED_7 = 7;      // PA7 (24) of MCP23017\nconst uint8_t LED_8 = 8;      // PB0 (25) of MCP23017\nconst uint8_t LED_9 = 9;      // PB1 (26) of MCP23017\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define RAK4631_BOARD true\n#else\n#define RAK4631_BOARD false\n#endif\n\nbool doOTAA = true;                                               // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                                       /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                                     /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5                               /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                                        /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;                           /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;                 /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                              /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = { LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF };\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = { BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler };\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xE9, 0x0D, 0x28, 0x1D, 0x92, 0x3D, 0xE4, 0x9F, 0xD9, 0xF7, 0xE0, 0x5F, 0x39, 0x10, 0x55, 0x71 };\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };\nuint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                                            /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];               //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = { m_lora_app_data_buffer, 0, 0, 0, 0 };  //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {\n\n// Initialize Serial for debug output\npinMode(LED_BLUE, OUTPUT);\ndigitalWrite(LED_BLUE, HIGH);\n\n// Sensor Power Switch\npinMode(WB_IO2, OUTPUT);\ndigitalWrite(WB_IO2, HIGH);\n\n// Reset RAK14003 module\npinMode(WB_IO4, OUTPUT);\ndigitalWrite(WB_IO4, HIGH);\ndelay(10);\ndigitalWrite(WB_IO4, LOW);\ndelay(10);\ndigitalWrite(WB_IO4, HIGH);\ndelay(10);\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial) {\nif ((millis() - timeout) < 5000) {\ndelay(100);\n} else {\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA) {\nSerial.println(\"Type: OTAA\");\n} else {\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion) {\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA) {\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n} else {\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0) {\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"================================\");\nSerial.println(\"RAK12019 + RAK12010 LoRaWAN Code\");\nSerial.println(\"================================\");\n\nif (!VMEL.begin())\n{\nSerial.println(\"Sensor not found\");\nwhile (1);\n}\n\nVMEL.setGain(VEML7700_GAIN_1);\nVMEL.setIntegrationTime(VEML7700_IT_800MS);\n\nSerial.print(F(\"Gain: \"));\nswitch (VMEL.getGain())\n{\ncase VEML7700_GAIN_1: Serial.println(\"1\"); break;\ncase VEML7700_GAIN_2: Serial.println(\"2\"); break;\ncase VEML7700_GAIN_1_4: Serial.println(\"1/4\"); break;\ncase VEML7700_GAIN_1_8: Serial.println(\"1/8\"); break;\n}\n\nSerial.print(F(\"Integration Time (ms): \"));\nswitch (VMEL.getIntegrationTime())\n{\ncase VEML7700_IT_25MS: Serial.println(\"25\"); break;\ncase VEML7700_IT_50MS: Serial.println(\"50\"); break;\ncase VEML7700_IT_100MS: Serial.println(\"100\"); break;\ncase VEML7700_IT_200MS: Serial.println(\"200\"); break;\ncase VEML7700_IT_400MS: Serial.println(\"400\"); break;\ncase VEML7700_IT_800MS: Serial.println(\"800\"); break;\n}\n\nSerial.println(\"RAK12019 test\");\nWire.begin();\nif (!ltr.init())\n{\nSerial.println(\"Couldn't find LTR sensor!\");\nwhile (1)\ndelay(10);\n}\nSerial.println(\"Found LTR390 sensor!\");\n\n//set to LTR390_MODE_UVS,get ultraviolet light data.\nltr.setMode(LTR390_MODE_UVS);  // UVS Mode\n\nSerial.println(\"In UVS mode\");\n\nltr.setGain(LTR390_GAIN_3);\nSerial.print(\"Gain : \");\nswitch (ltr.getGain())\n{\ncase LTR390_GAIN_1:\nSerial.println(1);\nbreak;\ncase LTR390_GAIN_3:\nSerial.println(3);\nbreak;\ncase LTR390_GAIN_6:\nSerial.println(6);\nbreak;\ncase LTR390_GAIN_9:\nSerial.println(9);\nbreak;\ncase LTR390_GAIN_18:\nSerial.println(18);\nbreak;\ndefault:\nSerial.println(\"Failed to set gain\");\nbreak;\n}\nltr.setResolution(LTR390_RESOLUTION_16BIT);\nSerial.print(\"Integration Time (ms): \");\nswitch (ltr.getResolution())\n{\ncase LTR390_RESOLUTION_13BIT:\nSerial.println(13);\nbreak;\ncase LTR390_RESOLUTION_16BIT:\nSerial.println(16);\nbreak;\ncase LTR390_RESOLUTION_17BIT:\nSerial.println(17);\nbreak;\ncase LTR390_RESOLUTION_18BIT:\nSerial.println(18);\nbreak;\ncase LTR390_RESOLUTION_19BIT:\nSerial.println(19);\nbreak;\ncase LTR390_RESOLUTION_20BIT:\nSerial.println(20);\nbreak;\ndefault:\nSerial.println(\"Failed to set Integration Time\");\nbreak;\n}\n\nltr.setThresholds(100, 1000); //Set the interrupt output threshold range for lower and upper.\n\nltr.configInterrupt(true, LTR390_MODE_UVS);\n\n// For RAK14003\nmcp.begin_I2C(0x24);\n\n// Added for the functionality of RAK14003\n\nWire.begin();    // initialize I2C serial bus\n\n// Configuration of MCP23017 I/O ports\nmcp.pinMode(LED_0, OUTPUT);     // Red LED; Top most\nmcp.pinMode(LED_1, OUTPUT);     // Red LED\nmcp.pinMode(LED_2, OUTPUT);     // Orange LED\nmcp.pinMode(LED_3, OUTPUT);     // Orange LED\nmcp.pinMode(LED_4, OUTPUT);     // Orange LED\nmcp.pinMode(LED_5, OUTPUT);     // Green LED\nmcp.pinMode(LED_6, OUTPUT);     // Green LED\nmcp.pinMode(LED_7, OUTPUT);     // Green LED\nmcp.pinMode(LED_8, OUTPUT);     // Green LED\nmcp.pinMode(LED_9, OUTPUT);     // Green LED; Bottom\n\n// Initially Turn OFF all LEDs\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, HIGH);\n\n}\n\nvoid loop() {\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\n// Trial # 1\n// Data from RAK12019\nif (ltr.newDataAvailable())\n{\nuvi = ltr.getUVI();\nuvs = ltr.readUVS();\n}\n\n// Data from RAK12010\nlux = VMEL.readLux();\nwhite = VMEL.readWhite();\nraw_als = VMEL.readALS();\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\n\n// From RAK12019 module\nSerial.print(\"UVI: \");\nSerial.println(uvi);          // Uvi data from RAK12019\nSerial.print(\"UVS: \");\nSerial.println(uvs);            // Uvs data from RAK12019\n\n// From RAK12010\nSerial.print(\"Lux: \");\nSerial.print(lux);\nSerial.println(\" lx \");\nSerial.print(\"White: \");\nSerial.println(white);\nSerial.print(\"Raw ALS: \");\nSerial.println(raw_als);\n\n// Result of uvi to be displayed via RAK14003 module\nif (uvi <= 0.4)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, HIGH);\n}\n\nelse if (uvi > 0.5 && uvi <= 1)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 1.5 && uvi <= 2)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 2.5 && uvi <= 3)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 3.5 && uvi <= 4)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 4.5 && uvi <= 5)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 5.5 && uvi <= 6)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 6.5 && uvi <= 7)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 7.5 && uvi <= 8)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 8.5 && uvi <= 9.5)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, LOW);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi >= 10)\n{\nmcp.digitalWrite(LED_0, LOW);\nmcp.digitalWrite(LED_1, LOW);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\ndelay(10000);\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void) {\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void) {\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data) {\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class) {\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void) {\nif (lmh_join_status_get() != LMH_SET) {\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\ndata = \" Uvi Data: \" + String(uvi) + \" Uvs Data: \" + String(uvs) + \" Lux Data: \" + String(lux) + \" lx \" ;\n\nSerial.println(data);\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\nuint16_t uvi_data = uvi;            // Uvi data from RAK12019\nuint32_t uvs_data = uvs;            // Uvs data from RAK12019\nuint32_t lux_data = lux;            // Lux data from RAK12010\n\nm_lora_app_data.buffer[i++] = 0x01;  // byte[0]\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\n// Data from RAK12019 module\nm_lora_app_data.buffer[i++] = (uint8_t)((uvi_data & 0x0000FF00) >> 8);     // byte[1]\nm_lora_app_data.buffer[i++] = (uint8_t)(uvi_data & 0x000000FF);            // byte[2]\n\n// Data from RAK12019 module\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0xFF000000) >> 24);    // byte[3]\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0x00FF0000) >> 16);    // byte[4]\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0x0000FF00) >> 8);     // byte[5]\nm_lora_app_data.buffer[i++] = (uint8_t)(uvs_data & 0x000000FF);            // byte[6]\n\n// Data from RAK12010 module\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0xFF000000) >> 24);    // byte[7]\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0x00FF0000) >> 16);    // byte[8]\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0x0000FF00) >> 8);     // byte[9]\nm_lora_app_data.buffer[i++] = (uint8_t)(lux_data & 0x000000FF);            // byte[10]\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS) {\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n} else {\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xE9, 0x0D, 0x28, 0x1D, 0x92, 0x3D, 0xE4, 0x9F, 0xD9, 0xF7, 0xE0, 0x5F, 0x39, 0x10, 0x55, 0x71 };\n\n```  \n> **Image:** OTAA device successfully registered to TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "b3a36ce9e4c1d9b7ecdbc2f7e9d44c86", "product_family": "wisblock", "product_id": "kit6-light-and-color", "category": "How-To", "title": "WisBlock IoT Education Kit - Light & Color Quick Start Guide > WisBlock IoT Education Kit - Light & Color Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock IoT Education Kit - Light & Color using TTN and Qubitro > UV Index & UV Intensity Monitoring LoRaWAN Application > LoRaWAN Code for UV Index & UV Intensity Monitoring > Programming UV Index & UV Intensity Monitoring Device with Arduino IDE [CODE]", "content": "```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c", "keywords": ["Arduino IDE", "RAK4631", "UV Index", "UV Intensity", "LoRaWAN", "SX126x-Arduino"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **UV Index & UV Intensity Monitoring** device. Just copy the code below for **UV Index & UV Intensity Monitoring LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the example </summary>  \n```c\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h>  //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n#include \"UVlight_LTR390.h\"                // http://librarymanager/All#RAK12019_LTR390\nUVlight_LTR390 ltr = UVlight_LTR390();\n\n#include \"Light_VEML7700.h\"                // http://librarymanager/All#Light_veml7700\nLight_VEML7700 VMEL = Light_VEML7700();\n\nuint16_t uvi;\nuint32_t uvs;\nuint32_t lux;\nuint32_t white;\nuint32_t raw_als;\n\n#include <Adafruit_MCP23X17.h>  //http://librarymanager/All#Adafruit_MCP23017\nAdafruit_MCP23X17 mcp;\n\n// Added definitions for the functionality of RAK14003\nconst uint8_t LED_0 = 0;      // PA0 (17) of MCP23017\nconst uint8_t LED_1 = 1;      // PA1 (18) of MCP23017\nconst uint8_t LED_2 = 2;      // PA2 (19) of MCP23017\nconst uint8_t LED_3 = 3;      // PA3 (20) of MCP23017\nconst uint8_t LED_4 = 4;      // PA4 (21) of MCP23017\nconst uint8_t LED_5 = 5;      // PA5 (22) of MCP23017\nconst uint8_t LED_6 = 6;      // PA6 (23) of MCP23017\nconst uint8_t LED_7 = 7;      // PA7 (24) of MCP23017\nconst uint8_t LED_8 = 8;      // PB0 (25) of MCP23017\nconst uint8_t LED_9 = 9;      // PB1 (26) of MCP23017\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define RAK4631_BOARD true\n#else\n#define RAK4631_BOARD false\n#endif\n\nbool doOTAA = true;                                               // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                                       /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                                     /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5                               /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                                        /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;                           /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;                 /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                              /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = { LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF };\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = { BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler };\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xE9, 0x0D, 0x28, 0x1D, 0x92, 0x3D, 0xE4, 0x9F, 0xD9, 0xF7, 0xE0, 0x5F, 0x39, 0x10, 0x55, 0x71 };\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };\nuint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                                            /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];               //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = { m_lora_app_data_buffer, 0, 0, 0, 0 };  //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {\n\n// Initialize Serial for debug output\npinMode(LED_BLUE, OUTPUT);\ndigitalWrite(LED_BLUE, HIGH);\n\n// Sensor Power Switch\npinMode(WB_IO2, OUTPUT);\ndigitalWrite(WB_IO2, HIGH);\n\n// Reset RAK14003 module\npinMode(WB_IO4, OUTPUT);\ndigitalWrite(WB_IO4, HIGH);\ndelay(10);\ndigitalWrite(WB_IO4, LOW);\ndelay(10);\ndigitalWrite(WB_IO4, HIGH);\ndelay(10);\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial) {\nif ((millis() - timeout) < 5000) {\ndelay(100);\n} else {\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA) {\nSerial.println(\"Type: OTAA\");\n} else {\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion) {\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA) {\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n} else {\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0) {\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"================================\");\nSerial.println(\"RAK12019 + RAK12010 LoRaWAN Code\");\nSerial.println(\"================================\");\n\nif (!VMEL.begin())\n{\nSerial.println(\"Sensor not found\");\nwhile (1);\n}\n\nVMEL.setGain(VEML7700_GAIN_1);\nVMEL.setIntegrationTime(VEML7700_IT_800MS);\n\nSerial.print(F(\"Gain: \"));\nswitch (VMEL.getGain())\n{\ncase VEML7700_GAIN_1: Serial.println(\"1\"); break;\ncase VEML7700_GAIN_2: Serial.println(\"2\"); break;\ncase VEML7700_GAIN_1_4: Serial.println(\"1/4\"); break;\ncase VEML7700_GAIN_1_8: Serial.println(\"1/8\"); break;\n}\n\nSerial.print(F(\"Integration Time (ms): \"));\nswitch (VMEL.getIntegrationTime())\n{\ncase VEML7700_IT_25MS: Serial.println(\"25\"); break;\ncase VEML7700_IT_50MS: Serial.println(\"50\"); break;\ncase VEML7700_IT_100MS: Serial.println(\"100\"); break;\ncase VEML7700_IT_200MS: Serial.println(\"200\"); break;\ncase VEML7700_IT_400MS: Serial.println(\"400\"); break;\ncase VEML7700_IT_800MS: Serial.println(\"800\"); break;\n}\n\nSerial.println(\"RAK12019 test\");\nWire.begin();\nif (!ltr.init())\n{\nSerial.println(\"Couldn't find LTR sensor!\");\nwhile (1)\ndelay(10);\n}\nSerial.println(\"Found LTR390 sensor!\");\n\n//set to LTR390_MODE_UVS,get ultraviolet light data.\nltr.setMode(LTR390_MODE_UVS);  // UVS Mode\n\nSerial.println(\"In UVS mode\");\n\nltr.setGain(LTR390_GAIN_3);\nSerial.print(\"Gain : \");\nswitch (ltr.getGain())\n{\ncase LTR390_GAIN_1:\nSerial.println(1);\nbreak;\ncase LTR390_GAIN_3:\nSerial.println(3);\nbreak;\ncase LTR390_GAIN_6:\nSerial.println(6);\nbreak;\ncase LTR390_GAIN_9:\nSerial.println(9);\nbreak;\ncase LTR390_GAIN_18:\nSerial.println(18);\nbreak;\ndefault:\nSerial.println(\"Failed to set gain\");\nbreak;\n}\nltr.setResolution(LTR390_RESOLUTION_16BIT);\nSerial.print(\"Integration Time (ms): \");\nswitch (ltr.getResolution())\n{\ncase LTR390_RESOLUTION_13BIT:\nSerial.println(13);\nbreak;\ncase LTR390_RESOLUTION_16BIT:\nSerial.println(16);\nbreak;\ncase LTR390_RESOLUTION_17BIT:\nSerial.println(17);\nbreak;\ncase LTR390_RESOLUTION_18BIT:\nSerial.println(18);\nbreak;\ncase LTR390_RESOLUTION_19BIT:\nSerial.println(19);\nbreak;\ncase LTR390_RESOLUTION_20BIT:\nSerial.println(20);\nbreak;\ndefault:\nSerial.println(\"Failed to set Integration Time\");\nbreak;\n}\n\nltr.setThresholds(100, 1000); //Set the interrupt output threshold range for lower and upper.\n\nltr.configInterrupt(true, LTR390_MODE_UVS);\n\n// For RAK14003\nmcp.begin_I2C(0x24);\n\n// Added for the functionality of RAK14003\n\nWire.begin();    // initialize I2C serial bus\n\n// Configuration of MCP23017 I/O ports\nmcp.pinMode(LED_0, OUTPUT);     // Red LED; Top most\nmcp.pinMode(LED_1, OUTPUT);     // Red LED\nmcp.pinMode(LED_2, OUTPUT);     // Orange LED\nmcp.pinMode(LED_3, OUTPUT);     // Orange LED\nmcp.pinMode(LED_4, OUTPUT);     // Orange LED\nmcp.pinMode(LED_5, OUTPUT);     // Green LED\nmcp.pinMode(LED_6, OUTPUT);     // Green LED\nmcp.pinMode(LED_7, OUTPUT);     // Green LED\nmcp.pinMode(LED_8, OUTPUT);     // Green LED\nmcp.pinMode(LED_9, OUTPUT);     // Green LED; Bottom\n\n// Initially Turn OFF all LEDs\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, HIGH);\n\n}\n\nvoid loop() {\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\n// Trial # 1\n// Data from RAK12019\nif (ltr.newDataAvailable())\n{\nuvi = ltr.getUVI();\nuvs = ltr.readUVS();\n}\n\n// Data from RAK12010\nlux = VMEL.readLux();\nwhite = VMEL.readWhite();\nraw_als = VMEL.readALS();\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\n\n// From RAK12019 module\nSerial.print(\"UVI: \");\nSerial.println(uvi);          // Uvi data from RAK12019\nSerial.print(\"UVS: \");\nSerial.println(uvs);            // Uvs data from RAK12019\n\n// From RAK12010\nSerial.print(\"Lux: \");\nSerial.print(lux);\nSerial.println(\" lx \");\nSerial.print(\"White: \");\nSerial.println(white);\nSerial.print(\"Raw ALS: \");\nSerial.println(raw_als);\n\n// Result of uvi to be displayed via RAK14003 module\nif (uvi <= 0.4)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, HIGH);\n}\n\nelse if (uvi > 0.5 && uvi <= 1)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 1.5 && uvi <= 2)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 2.5 && uvi <= 3)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 3.5 && uvi <= 4)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 4.5 && uvi <= 5)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 5.5 && uvi <= 6)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 6.5 && uvi <= 7)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 7.5 && uvi <= 8)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 8.5 && uvi <= 9.5)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, LOW);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi >= 10)\n{\nmcp.digitalWrite(LED_0, LOW);\nmcp.digitalWrite(LED_1, LOW);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\ndelay(10000);\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void) {\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void) {\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data) {\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class) {\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void) {\nif (lmh_join_status_get() != LMH_SET) {\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\ndata = \" Uvi Data: \" + String(uvi) + \" Uvs Data: \" + String(uvs) + \" Lux Data: \" + String(lux) + \" lx \" ;\n\nSerial.println(data);\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\nuint16_t uvi_data = uvi;            // Uvi data from RAK12019\nuint32_t uvs_data = uvs;            // Uvs data from RAK12019\nuint32_t lux_data = lux;            // Lux data from RAK12010\n\nm_lora_app_data.buffer[i++] = 0x01;  // byte[0]\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\n// Data from RAK12019 module\nm_lora_app_data.buffer[i++] = (uint8_t)((uvi_data & 0x0000FF00) >> 8);     // byte[1]\nm_lora_app_data.buffer[i++] = (uint8_t)(uvi_data & 0x000000FF);            // byte[2]\n\n// Data from RAK12019 module\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0xFF000000) >> 24);    // byte[3]\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0x00FF0000) >> 16);    // byte[4]\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0x0000FF00) >> 8);     // byte[5]\nm_lora_app_data.buffer[i++] = (uint8_t)(uvs_data & 0x000000FF);            // byte[6]\n\n// Data from RAK12010 module\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0xFF000000) >> 24);    // byte[7]\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0x00FF0000) >> 16);    // byte[8]\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0x0000FF00) >> 8);     // byte[9]\nm_lora_app_data.buffer[i++] = (uint8_t)(lux_data & 0x000000FF);            // byte[10]\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS) {\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n} else {\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xE9, 0x0D, 0x28, 0x1D, 0x92, 0x3D, 0xE4, 0x9F, 0xD9, 0xF7, 0xE0, 0x5F, 0x39, 0x10, 0x55, 0x71 };\n\n```  \n> **Image:** OTAA device successfully registered to TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "ba4093d0dd9db80b3e95b410bfc5d097", "product_family": "wisblock", "product_id": "kit6-light-and-color", "category": "How-To", "title": "WisBlock IoT Education Kit - Light & Color Quick Start Guide > WisBlock IoT Education Kit - Light & Color Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock IoT Education Kit - Light & Color using TTN and Qubitro > UV Index & UV Intensity Monitoring LoRaWAN Application > LoRaWAN Code for UV Index & UV Intensity Monitoring > Programming UV Index & UV Intensity Monitoring Device with Arduino IDE [CODE]", "content": "//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xE9, 0x0D, 0x28, 0x1D, 0x92, 0x3D, 0xE4, 0x9F, 0xD9, 0xF7, 0xE0, 0x5F, 0x39, 0x10, 0x55, 0x71 };", "keywords": ["Arduino IDE", "RAK4631", "UV Index", "UV Intensity", "LoRaWAN", "SX126x-Arduino"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **UV Index & UV Intensity Monitoring** device. Just copy the code below for **UV Index & UV Intensity Monitoring LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the example </summary>  \n```c\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h>  //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n#include \"UVlight_LTR390.h\"                // http://librarymanager/All#RAK12019_LTR390\nUVlight_LTR390 ltr = UVlight_LTR390();\n\n#include \"Light_VEML7700.h\"                // http://librarymanager/All#Light_veml7700\nLight_VEML7700 VMEL = Light_VEML7700();\n\nuint16_t uvi;\nuint32_t uvs;\nuint32_t lux;\nuint32_t white;\nuint32_t raw_als;\n\n#include <Adafruit_MCP23X17.h>  //http://librarymanager/All#Adafruit_MCP23017\nAdafruit_MCP23X17 mcp;\n\n// Added definitions for the functionality of RAK14003\nconst uint8_t LED_0 = 0;      // PA0 (17) of MCP23017\nconst uint8_t LED_1 = 1;      // PA1 (18) of MCP23017\nconst uint8_t LED_2 = 2;      // PA2 (19) of MCP23017\nconst uint8_t LED_3 = 3;      // PA3 (20) of MCP23017\nconst uint8_t LED_4 = 4;      // PA4 (21) of MCP23017\nconst uint8_t LED_5 = 5;      // PA5 (22) of MCP23017\nconst uint8_t LED_6 = 6;      // PA6 (23) of MCP23017\nconst uint8_t LED_7 = 7;      // PA7 (24) of MCP23017\nconst uint8_t LED_8 = 8;      // PB0 (25) of MCP23017\nconst uint8_t LED_9 = 9;      // PB1 (26) of MCP23017\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define RAK4631_BOARD true\n#else\n#define RAK4631_BOARD false\n#endif\n\nbool doOTAA = true;                                               // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                                       /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                                     /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5                               /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                                        /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;                           /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;                 /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                              /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = { LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF };\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = { BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler };\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xE9, 0x0D, 0x28, 0x1D, 0x92, 0x3D, 0xE4, 0x9F, 0xD9, 0xF7, 0xE0, 0x5F, 0x39, 0x10, 0x55, 0x71 };\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };\nuint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                                            /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];               //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = { m_lora_app_data_buffer, 0, 0, 0, 0 };  //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {\n\n// Initialize Serial for debug output\npinMode(LED_BLUE, OUTPUT);\ndigitalWrite(LED_BLUE, HIGH);\n\n// Sensor Power Switch\npinMode(WB_IO2, OUTPUT);\ndigitalWrite(WB_IO2, HIGH);\n\n// Reset RAK14003 module\npinMode(WB_IO4, OUTPUT);\ndigitalWrite(WB_IO4, HIGH);\ndelay(10);\ndigitalWrite(WB_IO4, LOW);\ndelay(10);\ndigitalWrite(WB_IO4, HIGH);\ndelay(10);\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial) {\nif ((millis() - timeout) < 5000) {\ndelay(100);\n} else {\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA) {\nSerial.println(\"Type: OTAA\");\n} else {\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion) {\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA) {\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n} else {\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0) {\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"================================\");\nSerial.println(\"RAK12019 + RAK12010 LoRaWAN Code\");\nSerial.println(\"================================\");\n\nif (!VMEL.begin())\n{\nSerial.println(\"Sensor not found\");\nwhile (1);\n}\n\nVMEL.setGain(VEML7700_GAIN_1);\nVMEL.setIntegrationTime(VEML7700_IT_800MS);\n\nSerial.print(F(\"Gain: \"));\nswitch (VMEL.getGain())\n{\ncase VEML7700_GAIN_1: Serial.println(\"1\"); break;\ncase VEML7700_GAIN_2: Serial.println(\"2\"); break;\ncase VEML7700_GAIN_1_4: Serial.println(\"1/4\"); break;\ncase VEML7700_GAIN_1_8: Serial.println(\"1/8\"); break;\n}\n\nSerial.print(F(\"Integration Time (ms): \"));\nswitch (VMEL.getIntegrationTime())\n{\ncase VEML7700_IT_25MS: Serial.println(\"25\"); break;\ncase VEML7700_IT_50MS: Serial.println(\"50\"); break;\ncase VEML7700_IT_100MS: Serial.println(\"100\"); break;\ncase VEML7700_IT_200MS: Serial.println(\"200\"); break;\ncase VEML7700_IT_400MS: Serial.println(\"400\"); break;\ncase VEML7700_IT_800MS: Serial.println(\"800\"); break;\n}\n\nSerial.println(\"RAK12019 test\");\nWire.begin();\nif (!ltr.init())\n{\nSerial.println(\"Couldn't find LTR sensor!\");\nwhile (1)\ndelay(10);\n}\nSerial.println(\"Found LTR390 sensor!\");\n\n//set to LTR390_MODE_UVS,get ultraviolet light data.\nltr.setMode(LTR390_MODE_UVS);  // UVS Mode\n\nSerial.println(\"In UVS mode\");\n\nltr.setGain(LTR390_GAIN_3);\nSerial.print(\"Gain : \");\nswitch (ltr.getGain())\n{\ncase LTR390_GAIN_1:\nSerial.println(1);\nbreak;\ncase LTR390_GAIN_3:\nSerial.println(3);\nbreak;\ncase LTR390_GAIN_6:\nSerial.println(6);\nbreak;\ncase LTR390_GAIN_9:\nSerial.println(9);\nbreak;\ncase LTR390_GAIN_18:\nSerial.println(18);\nbreak;\ndefault:\nSerial.println(\"Failed to set gain\");\nbreak;\n}\nltr.setResolution(LTR390_RESOLUTION_16BIT);\nSerial.print(\"Integration Time (ms): \");\nswitch (ltr.getResolution())\n{\ncase LTR390_RESOLUTION_13BIT:\nSerial.println(13);\nbreak;\ncase LTR390_RESOLUTION_16BIT:\nSerial.println(16);\nbreak;\ncase LTR390_RESOLUTION_17BIT:\nSerial.println(17);\nbreak;\ncase LTR390_RESOLUTION_18BIT:\nSerial.println(18);\nbreak;\ncase LTR390_RESOLUTION_19BIT:\nSerial.println(19);\nbreak;\ncase LTR390_RESOLUTION_20BIT:\nSerial.println(20);\nbreak;\ndefault:\nSerial.println(\"Failed to set Integration Time\");\nbreak;\n}\n\nltr.setThresholds(100, 1000); //Set the interrupt output threshold range for lower and upper.\n\nltr.configInterrupt(true, LTR390_MODE_UVS);\n\n// For RAK14003\nmcp.begin_I2C(0x24);\n\n// Added for the functionality of RAK14003\n\nWire.begin();    // initialize I2C serial bus\n\n// Configuration of MCP23017 I/O ports\nmcp.pinMode(LED_0, OUTPUT);     // Red LED; Top most\nmcp.pinMode(LED_1, OUTPUT);     // Red LED\nmcp.pinMode(LED_2, OUTPUT);     // Orange LED\nmcp.pinMode(LED_3, OUTPUT);     // Orange LED\nmcp.pinMode(LED_4, OUTPUT);     // Orange LED\nmcp.pinMode(LED_5, OUTPUT);     // Green LED\nmcp.pinMode(LED_6, OUTPUT);     // Green LED\nmcp.pinMode(LED_7, OUTPUT);     // Green LED\nmcp.pinMode(LED_8, OUTPUT);     // Green LED\nmcp.pinMode(LED_9, OUTPUT);     // Green LED; Bottom\n\n// Initially Turn OFF all LEDs\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, HIGH);\n\n}\n\nvoid loop() {\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\n// Trial # 1\n// Data from RAK12019\nif (ltr.newDataAvailable())\n{\nuvi = ltr.getUVI();\nuvs = ltr.readUVS();\n}\n\n// Data from RAK12010\nlux = VMEL.readLux();\nwhite = VMEL.readWhite();\nraw_als = VMEL.readALS();\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\n\n// From RAK12019 module\nSerial.print(\"UVI: \");\nSerial.println(uvi);          // Uvi data from RAK12019\nSerial.print(\"UVS: \");\nSerial.println(uvs);            // Uvs data from RAK12019\n\n// From RAK12010\nSerial.print(\"Lux: \");\nSerial.print(lux);\nSerial.println(\" lx \");\nSerial.print(\"White: \");\nSerial.println(white);\nSerial.print(\"Raw ALS: \");\nSerial.println(raw_als);\n\n// Result of uvi to be displayed via RAK14003 module\nif (uvi <= 0.4)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, HIGH);\n}\n\nelse if (uvi > 0.5 && uvi <= 1)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 1.5 && uvi <= 2)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 2.5 && uvi <= 3)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 3.5 && uvi <= 4)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 4.5 && uvi <= 5)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 5.5 && uvi <= 6)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 6.5 && uvi <= 7)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 7.5 && uvi <= 8)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 8.5 && uvi <= 9.5)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, LOW);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi >= 10)\n{\nmcp.digitalWrite(LED_0, LOW);\nmcp.digitalWrite(LED_1, LOW);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\ndelay(10000);\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void) {\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void) {\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data) {\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class) {\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void) {\nif (lmh_join_status_get() != LMH_SET) {\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\ndata = \" Uvi Data: \" + String(uvi) + \" Uvs Data: \" + String(uvs) + \" Lux Data: \" + String(lux) + \" lx \" ;\n\nSerial.println(data);\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\nuint16_t uvi_data = uvi;            // Uvi data from RAK12019\nuint32_t uvs_data = uvs;            // Uvs data from RAK12019\nuint32_t lux_data = lux;            // Lux data from RAK12010\n\nm_lora_app_data.buffer[i++] = 0x01;  // byte[0]\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\n// Data from RAK12019 module\nm_lora_app_data.buffer[i++] = (uint8_t)((uvi_data & 0x0000FF00) >> 8);     // byte[1]\nm_lora_app_data.buffer[i++] = (uint8_t)(uvi_data & 0x000000FF);            // byte[2]\n\n// Data from RAK12019 module\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0xFF000000) >> 24);    // byte[3]\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0x00FF0000) >> 16);    // byte[4]\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0x0000FF00) >> 8);     // byte[5]\nm_lora_app_data.buffer[i++] = (uint8_t)(uvs_data & 0x000000FF);            // byte[6]\n\n// Data from RAK12010 module\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0xFF000000) >> 24);    // byte[7]\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0x00FF0000) >> 16);    // byte[8]\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0x0000FF00) >> 8);     // byte[9]\nm_lora_app_data.buffer[i++] = (uint8_t)(lux_data & 0x000000FF);            // byte[10]\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS) {\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n} else {\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xE9, 0x0D, 0x28, 0x1D, 0x92, 0x3D, 0xE4, 0x9F, 0xD9, 0xF7, 0xE0, 0x5F, 0x39, 0x10, 0x55, 0x71 };\n\n```  \n> **Image:** OTAA device successfully registered to TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "40aa88b3a587e7a9ea0f61556b694999", "product_family": "wisblock", "product_id": "kit6-light-and-color", "category": "How-To", "title": "WisBlock IoT Education Kit - Light & Color Quick Start Guide > WisBlock IoT Education Kit - Light & Color Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock IoT Education Kit - Light & Color using TTN and Qubitro > UV Index & UV Intensity Monitoring LoRaWAN Application > LoRaWAN Code for UV Index & UV Intensity Monitoring > Programming UV Index & UV Intensity Monitoring Device with Arduino IDE [CODE]", "content": "```  \n> **Image:** OTAA device successfully registered to TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.", "keywords": ["Arduino IDE", "RAK4631", "UV Index", "UV Intensity", "LoRaWAN", "SX126x-Arduino"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **UV Index & UV Intensity Monitoring** device. Just copy the code below for **UV Index & UV Intensity Monitoring LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the example </summary>  \n```c\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h>  //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n#include \"UVlight_LTR390.h\"                // http://librarymanager/All#RAK12019_LTR390\nUVlight_LTR390 ltr = UVlight_LTR390();\n\n#include \"Light_VEML7700.h\"                // http://librarymanager/All#Light_veml7700\nLight_VEML7700 VMEL = Light_VEML7700();\n\nuint16_t uvi;\nuint32_t uvs;\nuint32_t lux;\nuint32_t white;\nuint32_t raw_als;\n\n#include <Adafruit_MCP23X17.h>  //http://librarymanager/All#Adafruit_MCP23017\nAdafruit_MCP23X17 mcp;\n\n// Added definitions for the functionality of RAK14003\nconst uint8_t LED_0 = 0;      // PA0 (17) of MCP23017\nconst uint8_t LED_1 = 1;      // PA1 (18) of MCP23017\nconst uint8_t LED_2 = 2;      // PA2 (19) of MCP23017\nconst uint8_t LED_3 = 3;      // PA3 (20) of MCP23017\nconst uint8_t LED_4 = 4;      // PA4 (21) of MCP23017\nconst uint8_t LED_5 = 5;      // PA5 (22) of MCP23017\nconst uint8_t LED_6 = 6;      // PA6 (23) of MCP23017\nconst uint8_t LED_7 = 7;      // PA7 (24) of MCP23017\nconst uint8_t LED_8 = 8;      // PB0 (25) of MCP23017\nconst uint8_t LED_9 = 9;      // PB1 (26) of MCP23017\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define RAK4631_BOARD true\n#else\n#define RAK4631_BOARD false\n#endif\n\nbool doOTAA = true;                                               // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                                       /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                                     /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5                               /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                                        /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;                           /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;                 /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                              /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = { LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF };\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = { BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler };\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xE9, 0x0D, 0x28, 0x1D, 0x92, 0x3D, 0xE4, 0x9F, 0xD9, 0xF7, 0xE0, 0x5F, 0x39, 0x10, 0x55, 0x71 };\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };\nuint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                                            /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];               //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = { m_lora_app_data_buffer, 0, 0, 0, 0 };  //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {\n\n// Initialize Serial for debug output\npinMode(LED_BLUE, OUTPUT);\ndigitalWrite(LED_BLUE, HIGH);\n\n// Sensor Power Switch\npinMode(WB_IO2, OUTPUT);\ndigitalWrite(WB_IO2, HIGH);\n\n// Reset RAK14003 module\npinMode(WB_IO4, OUTPUT);\ndigitalWrite(WB_IO4, HIGH);\ndelay(10);\ndigitalWrite(WB_IO4, LOW);\ndelay(10);\ndigitalWrite(WB_IO4, HIGH);\ndelay(10);\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial) {\nif ((millis() - timeout) < 5000) {\ndelay(100);\n} else {\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA) {\nSerial.println(\"Type: OTAA\");\n} else {\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion) {\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA) {\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n} else {\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0) {\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"================================\");\nSerial.println(\"RAK12019 + RAK12010 LoRaWAN Code\");\nSerial.println(\"================================\");\n\nif (!VMEL.begin())\n{\nSerial.println(\"Sensor not found\");\nwhile (1);\n}\n\nVMEL.setGain(VEML7700_GAIN_1);\nVMEL.setIntegrationTime(VEML7700_IT_800MS);\n\nSerial.print(F(\"Gain: \"));\nswitch (VMEL.getGain())\n{\ncase VEML7700_GAIN_1: Serial.println(\"1\"); break;\ncase VEML7700_GAIN_2: Serial.println(\"2\"); break;\ncase VEML7700_GAIN_1_4: Serial.println(\"1/4\"); break;\ncase VEML7700_GAIN_1_8: Serial.println(\"1/8\"); break;\n}\n\nSerial.print(F(\"Integration Time (ms): \"));\nswitch (VMEL.getIntegrationTime())\n{\ncase VEML7700_IT_25MS: Serial.println(\"25\"); break;\ncase VEML7700_IT_50MS: Serial.println(\"50\"); break;\ncase VEML7700_IT_100MS: Serial.println(\"100\"); break;\ncase VEML7700_IT_200MS: Serial.println(\"200\"); break;\ncase VEML7700_IT_400MS: Serial.println(\"400\"); break;\ncase VEML7700_IT_800MS: Serial.println(\"800\"); break;\n}\n\nSerial.println(\"RAK12019 test\");\nWire.begin();\nif (!ltr.init())\n{\nSerial.println(\"Couldn't find LTR sensor!\");\nwhile (1)\ndelay(10);\n}\nSerial.println(\"Found LTR390 sensor!\");\n\n//set to LTR390_MODE_UVS,get ultraviolet light data.\nltr.setMode(LTR390_MODE_UVS);  // UVS Mode\n\nSerial.println(\"In UVS mode\");\n\nltr.setGain(LTR390_GAIN_3);\nSerial.print(\"Gain : \");\nswitch (ltr.getGain())\n{\ncase LTR390_GAIN_1:\nSerial.println(1);\nbreak;\ncase LTR390_GAIN_3:\nSerial.println(3);\nbreak;\ncase LTR390_GAIN_6:\nSerial.println(6);\nbreak;\ncase LTR390_GAIN_9:\nSerial.println(9);\nbreak;\ncase LTR390_GAIN_18:\nSerial.println(18);\nbreak;\ndefault:\nSerial.println(\"Failed to set gain\");\nbreak;\n}\nltr.setResolution(LTR390_RESOLUTION_16BIT);\nSerial.print(\"Integration Time (ms): \");\nswitch (ltr.getResolution())\n{\ncase LTR390_RESOLUTION_13BIT:\nSerial.println(13);\nbreak;\ncase LTR390_RESOLUTION_16BIT:\nSerial.println(16);\nbreak;\ncase LTR390_RESOLUTION_17BIT:\nSerial.println(17);\nbreak;\ncase LTR390_RESOLUTION_18BIT:\nSerial.println(18);\nbreak;\ncase LTR390_RESOLUTION_19BIT:\nSerial.println(19);\nbreak;\ncase LTR390_RESOLUTION_20BIT:\nSerial.println(20);\nbreak;\ndefault:\nSerial.println(\"Failed to set Integration Time\");\nbreak;\n}\n\nltr.setThresholds(100, 1000); //Set the interrupt output threshold range for lower and upper.\n\nltr.configInterrupt(true, LTR390_MODE_UVS);\n\n// For RAK14003\nmcp.begin_I2C(0x24);\n\n// Added for the functionality of RAK14003\n\nWire.begin();    // initialize I2C serial bus\n\n// Configuration of MCP23017 I/O ports\nmcp.pinMode(LED_0, OUTPUT);     // Red LED; Top most\nmcp.pinMode(LED_1, OUTPUT);     // Red LED\nmcp.pinMode(LED_2, OUTPUT);     // Orange LED\nmcp.pinMode(LED_3, OUTPUT);     // Orange LED\nmcp.pinMode(LED_4, OUTPUT);     // Orange LED\nmcp.pinMode(LED_5, OUTPUT);     // Green LED\nmcp.pinMode(LED_6, OUTPUT);     // Green LED\nmcp.pinMode(LED_7, OUTPUT);     // Green LED\nmcp.pinMode(LED_8, OUTPUT);     // Green LED\nmcp.pinMode(LED_9, OUTPUT);     // Green LED; Bottom\n\n// Initially Turn OFF all LEDs\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, HIGH);\n\n}\n\nvoid loop() {\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\n// Trial # 1\n// Data from RAK12019\nif (ltr.newDataAvailable())\n{\nuvi = ltr.getUVI();\nuvs = ltr.readUVS();\n}\n\n// Data from RAK12010\nlux = VMEL.readLux();\nwhite = VMEL.readWhite();\nraw_als = VMEL.readALS();\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\n\n// From RAK12019 module\nSerial.print(\"UVI: \");\nSerial.println(uvi);          // Uvi data from RAK12019\nSerial.print(\"UVS: \");\nSerial.println(uvs);            // Uvs data from RAK12019\n\n// From RAK12010\nSerial.print(\"Lux: \");\nSerial.print(lux);\nSerial.println(\" lx \");\nSerial.print(\"White: \");\nSerial.println(white);\nSerial.print(\"Raw ALS: \");\nSerial.println(raw_als);\n\n// Result of uvi to be displayed via RAK14003 module\nif (uvi <= 0.4)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, HIGH);\n}\n\nelse if (uvi > 0.5 && uvi <= 1)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 1.5 && uvi <= 2)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 2.5 && uvi <= 3)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 3.5 && uvi <= 4)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 4.5 && uvi <= 5)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 5.5 && uvi <= 6)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 6.5 && uvi <= 7)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 7.5 && uvi <= 8)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 8.5 && uvi <= 9.5)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, LOW);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi >= 10)\n{\nmcp.digitalWrite(LED_0, LOW);\nmcp.digitalWrite(LED_1, LOW);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\ndelay(10000);\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void) {\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void) {\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data) {\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class) {\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void) {\nif (lmh_join_status_get() != LMH_SET) {\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\ndata = \" Uvi Data: \" + String(uvi) + \" Uvs Data: \" + String(uvs) + \" Lux Data: \" + String(lux) + \" lx \" ;\n\nSerial.println(data);\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\nuint16_t uvi_data = uvi;            // Uvi data from RAK12019\nuint32_t uvs_data = uvs;            // Uvs data from RAK12019\nuint32_t lux_data = lux;            // Lux data from RAK12010\n\nm_lora_app_data.buffer[i++] = 0x01;  // byte[0]\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\n// Data from RAK12019 module\nm_lora_app_data.buffer[i++] = (uint8_t)((uvi_data & 0x0000FF00) >> 8);     // byte[1]\nm_lora_app_data.buffer[i++] = (uint8_t)(uvi_data & 0x000000FF);            // byte[2]\n\n// Data from RAK12019 module\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0xFF000000) >> 24);    // byte[3]\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0x00FF0000) >> 16);    // byte[4]\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0x0000FF00) >> 8);     // byte[5]\nm_lora_app_data.buffer[i++] = (uint8_t)(uvs_data & 0x000000FF);            // byte[6]\n\n// Data from RAK12010 module\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0xFF000000) >> 24);    // byte[7]\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0x00FF0000) >> 16);    // byte[8]\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0x0000FF00) >> 8);     // byte[9]\nm_lora_app_data.buffer[i++] = (uint8_t)(lux_data & 0x000000FF);            // byte[10]\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS) {\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n} else {\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xE9, 0x0D, 0x28, 0x1D, 0x92, 0x3D, 0xE4, 0x9F, 0xD9, 0xF7, 0xE0, 0x5F, 0x39, 0x10, 0x55, 0x71 };\n\n```  \n> **Image:** OTAA device successfully registered to TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "9e453f0d0cafaffde303cb0572b91b15", "product_family": "wisblock", "product_id": "kit6-light-and-color", "category": "How-To", "title": "WisBlock IoT Education Kit - Light & Color Quick Start Guide > WisBlock IoT Education Kit - Light & Color Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock IoT Education Kit - Light & Color using TTN and Qubitro > UV Index & UV Intensity Monitoring LoRaWAN Application > LoRaWAN Code for UV Index & UV Intensity Monitoring > Programming UV Index & UV Intensity Monitoring Device with Arduino IDE [CODE]", "content": "> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board", "keywords": ["Arduino IDE", "RAK4631", "UV Index", "UV Intensity", "LoRaWAN", "SX126x-Arduino"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **UV Index & UV Intensity Monitoring** device. Just copy the code below for **UV Index & UV Intensity Monitoring LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the example </summary>  \n```c\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h>  //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n#include \"UVlight_LTR390.h\"                // http://librarymanager/All#RAK12019_LTR390\nUVlight_LTR390 ltr = UVlight_LTR390();\n\n#include \"Light_VEML7700.h\"                // http://librarymanager/All#Light_veml7700\nLight_VEML7700 VMEL = Light_VEML7700();\n\nuint16_t uvi;\nuint32_t uvs;\nuint32_t lux;\nuint32_t white;\nuint32_t raw_als;\n\n#include <Adafruit_MCP23X17.h>  //http://librarymanager/All#Adafruit_MCP23017\nAdafruit_MCP23X17 mcp;\n\n// Added definitions for the functionality of RAK14003\nconst uint8_t LED_0 = 0;      // PA0 (17) of MCP23017\nconst uint8_t LED_1 = 1;      // PA1 (18) of MCP23017\nconst uint8_t LED_2 = 2;      // PA2 (19) of MCP23017\nconst uint8_t LED_3 = 3;      // PA3 (20) of MCP23017\nconst uint8_t LED_4 = 4;      // PA4 (21) of MCP23017\nconst uint8_t LED_5 = 5;      // PA5 (22) of MCP23017\nconst uint8_t LED_6 = 6;      // PA6 (23) of MCP23017\nconst uint8_t LED_7 = 7;      // PA7 (24) of MCP23017\nconst uint8_t LED_8 = 8;      // PB0 (25) of MCP23017\nconst uint8_t LED_9 = 9;      // PB1 (26) of MCP23017\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define RAK4631_BOARD true\n#else\n#define RAK4631_BOARD false\n#endif\n\nbool doOTAA = true;                                               // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                                       /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                                     /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5                               /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                                        /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;                           /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;                 /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                              /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = { LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF };\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = { BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler };\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xE9, 0x0D, 0x28, 0x1D, 0x92, 0x3D, 0xE4, 0x9F, 0xD9, 0xF7, 0xE0, 0x5F, 0x39, 0x10, 0x55, 0x71 };\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };\nuint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                                            /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];               //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = { m_lora_app_data_buffer, 0, 0, 0, 0 };  //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {\n\n// Initialize Serial for debug output\npinMode(LED_BLUE, OUTPUT);\ndigitalWrite(LED_BLUE, HIGH);\n\n// Sensor Power Switch\npinMode(WB_IO2, OUTPUT);\ndigitalWrite(WB_IO2, HIGH);\n\n// Reset RAK14003 module\npinMode(WB_IO4, OUTPUT);\ndigitalWrite(WB_IO4, HIGH);\ndelay(10);\ndigitalWrite(WB_IO4, LOW);\ndelay(10);\ndigitalWrite(WB_IO4, HIGH);\ndelay(10);\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial) {\nif ((millis() - timeout) < 5000) {\ndelay(100);\n} else {\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA) {\nSerial.println(\"Type: OTAA\");\n} else {\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion) {\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA) {\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n} else {\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0) {\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"================================\");\nSerial.println(\"RAK12019 + RAK12010 LoRaWAN Code\");\nSerial.println(\"================================\");\n\nif (!VMEL.begin())\n{\nSerial.println(\"Sensor not found\");\nwhile (1);\n}\n\nVMEL.setGain(VEML7700_GAIN_1);\nVMEL.setIntegrationTime(VEML7700_IT_800MS);\n\nSerial.print(F(\"Gain: \"));\nswitch (VMEL.getGain())\n{\ncase VEML7700_GAIN_1: Serial.println(\"1\"); break;\ncase VEML7700_GAIN_2: Serial.println(\"2\"); break;\ncase VEML7700_GAIN_1_4: Serial.println(\"1/4\"); break;\ncase VEML7700_GAIN_1_8: Serial.println(\"1/8\"); break;\n}\n\nSerial.print(F(\"Integration Time (ms): \"));\nswitch (VMEL.getIntegrationTime())\n{\ncase VEML7700_IT_25MS: Serial.println(\"25\"); break;\ncase VEML7700_IT_50MS: Serial.println(\"50\"); break;\ncase VEML7700_IT_100MS: Serial.println(\"100\"); break;\ncase VEML7700_IT_200MS: Serial.println(\"200\"); break;\ncase VEML7700_IT_400MS: Serial.println(\"400\"); break;\ncase VEML7700_IT_800MS: Serial.println(\"800\"); break;\n}\n\nSerial.println(\"RAK12019 test\");\nWire.begin();\nif (!ltr.init())\n{\nSerial.println(\"Couldn't find LTR sensor!\");\nwhile (1)\ndelay(10);\n}\nSerial.println(\"Found LTR390 sensor!\");\n\n//set to LTR390_MODE_UVS,get ultraviolet light data.\nltr.setMode(LTR390_MODE_UVS);  // UVS Mode\n\nSerial.println(\"In UVS mode\");\n\nltr.setGain(LTR390_GAIN_3);\nSerial.print(\"Gain : \");\nswitch (ltr.getGain())\n{\ncase LTR390_GAIN_1:\nSerial.println(1);\nbreak;\ncase LTR390_GAIN_3:\nSerial.println(3);\nbreak;\ncase LTR390_GAIN_6:\nSerial.println(6);\nbreak;\ncase LTR390_GAIN_9:\nSerial.println(9);\nbreak;\ncase LTR390_GAIN_18:\nSerial.println(18);\nbreak;\ndefault:\nSerial.println(\"Failed to set gain\");\nbreak;\n}\nltr.setResolution(LTR390_RESOLUTION_16BIT);\nSerial.print(\"Integration Time (ms): \");\nswitch (ltr.getResolution())\n{\ncase LTR390_RESOLUTION_13BIT:\nSerial.println(13);\nbreak;\ncase LTR390_RESOLUTION_16BIT:\nSerial.println(16);\nbreak;\ncase LTR390_RESOLUTION_17BIT:\nSerial.println(17);\nbreak;\ncase LTR390_RESOLUTION_18BIT:\nSerial.println(18);\nbreak;\ncase LTR390_RESOLUTION_19BIT:\nSerial.println(19);\nbreak;\ncase LTR390_RESOLUTION_20BIT:\nSerial.println(20);\nbreak;\ndefault:\nSerial.println(\"Failed to set Integration Time\");\nbreak;\n}\n\nltr.setThresholds(100, 1000); //Set the interrupt output threshold range for lower and upper.\n\nltr.configInterrupt(true, LTR390_MODE_UVS);\n\n// For RAK14003\nmcp.begin_I2C(0x24);\n\n// Added for the functionality of RAK14003\n\nWire.begin();    // initialize I2C serial bus\n\n// Configuration of MCP23017 I/O ports\nmcp.pinMode(LED_0, OUTPUT);     // Red LED; Top most\nmcp.pinMode(LED_1, OUTPUT);     // Red LED\nmcp.pinMode(LED_2, OUTPUT);     // Orange LED\nmcp.pinMode(LED_3, OUTPUT);     // Orange LED\nmcp.pinMode(LED_4, OUTPUT);     // Orange LED\nmcp.pinMode(LED_5, OUTPUT);     // Green LED\nmcp.pinMode(LED_6, OUTPUT);     // Green LED\nmcp.pinMode(LED_7, OUTPUT);     // Green LED\nmcp.pinMode(LED_8, OUTPUT);     // Green LED\nmcp.pinMode(LED_9, OUTPUT);     // Green LED; Bottom\n\n// Initially Turn OFF all LEDs\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, HIGH);\n\n}\n\nvoid loop() {\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\n// Trial # 1\n// Data from RAK12019\nif (ltr.newDataAvailable())\n{\nuvi = ltr.getUVI();\nuvs = ltr.readUVS();\n}\n\n// Data from RAK12010\nlux = VMEL.readLux();\nwhite = VMEL.readWhite();\nraw_als = VMEL.readALS();\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\n\n// From RAK12019 module\nSerial.print(\"UVI: \");\nSerial.println(uvi);          // Uvi data from RAK12019\nSerial.print(\"UVS: \");\nSerial.println(uvs);            // Uvs data from RAK12019\n\n// From RAK12010\nSerial.print(\"Lux: \");\nSerial.print(lux);\nSerial.println(\" lx \");\nSerial.print(\"White: \");\nSerial.println(white);\nSerial.print(\"Raw ALS: \");\nSerial.println(raw_als);\n\n// Result of uvi to be displayed via RAK14003 module\nif (uvi <= 0.4)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, HIGH);\n}\n\nelse if (uvi > 0.5 && uvi <= 1)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, HIGH);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 1.5 && uvi <= 2)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, HIGH);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 2.5 && uvi <= 3)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, HIGH);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 3.5 && uvi <= 4)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, HIGH);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 4.5 && uvi <= 5)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, HIGH);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 5.5 && uvi <= 6)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, HIGH);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 6.5 && uvi <= 7)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, HIGH);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 7.5 && uvi <= 8)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, HIGH);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi > 8.5 && uvi <= 9.5)\n{\nmcp.digitalWrite(LED_0, HIGH);\nmcp.digitalWrite(LED_1, LOW);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\nelse if (uvi >= 10)\n{\nmcp.digitalWrite(LED_0, LOW);\nmcp.digitalWrite(LED_1, LOW);\nmcp.digitalWrite(LED_2, LOW);\nmcp.digitalWrite(LED_3, LOW);\nmcp.digitalWrite(LED_4, LOW);\nmcp.digitalWrite(LED_5, LOW);\nmcp.digitalWrite(LED_6, LOW);\nmcp.digitalWrite(LED_7, LOW);\nmcp.digitalWrite(LED_8, LOW);\nmcp.digitalWrite(LED_9, LOW);\n}\n\ndelay(10000);\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void) {\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void) {\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data) {\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class) {\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void) {\nif (lmh_join_status_get() != LMH_SET) {\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\ndata = \" Uvi Data: \" + String(uvi) + \" Uvs Data: \" + String(uvs) + \" Lux Data: \" + String(lux) + \" lx \" ;\n\nSerial.println(data);\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\nuint16_t uvi_data = uvi;            // Uvi data from RAK12019\nuint32_t uvs_data = uvs;            // Uvs data from RAK12019\nuint32_t lux_data = lux;            // Lux data from RAK12010\n\nm_lora_app_data.buffer[i++] = 0x01;  // byte[0]\n\n// Showing only UV Index (uvi), UV Intensity (uvs) and Lux (lx)\n// Data from RAK12019 module\nm_lora_app_data.buffer[i++] = (uint8_t)((uvi_data & 0x0000FF00) >> 8);     // byte[1]\nm_lora_app_data.buffer[i++] = (uint8_t)(uvi_data & 0x000000FF);            // byte[2]\n\n// Data from RAK12019 module\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0xFF000000) >> 24);    // byte[3]\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0x00FF0000) >> 16);    // byte[4]\nm_lora_app_data.buffer[i++] = (uint8_t)((uvs_data & 0x0000FF00) >> 8);     // byte[5]\nm_lora_app_data.buffer[i++] = (uint8_t)(uvs_data & 0x000000FF);            // byte[6]\n\n// Data from RAK12010 module\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0xFF000000) >> 24);    // byte[7]\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0x00FF0000) >> 16);    // byte[8]\nm_lora_app_data.buffer[i++] = (uint8_t)((lux_data & 0x0000FF00) >> 8);     // byte[9]\nm_lora_app_data.buffer[i++] = (uint8_t)(lux_data & 0x000000FF);            // byte[10]\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS) {\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n} else {\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xE9, 0x0D, 0x28, 0x1D, 0x92, 0x3D, 0xE4, 0x9F, 0xD9, 0xF7, 0xE0, 0x5F, 0x39, 0x10, 0x55, 0x71 };\n\n```  \n> **Image:** OTAA device successfully registered to TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "ad2778c31cd66f167add4e6b361300bf", "product_family": "wisblock", "product_id": "kit6-light-and-color", "category": "Concept", "title": "WisBlock IoT Education Kit - Light & Color Quick Start Guide > WisBlock IoT Education Kit - Light & Color Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock IoT Education Kit - Light & Color using TTN and Qubitro > Light Color Recognizer LoRaWAN Application > Light Color Recognizer LoRaWAN Application Overview", "content": "The **Light Color Recognizer LoRaWAN Application** is used to evaluate the color of the light being monitored using an RGB sensor. It uses **RAK12021** which is an RGB sensor which is based on **TCS37725FN** from AMS. It also uses **RAK14001** RGB LED module which will visualize the color being monitored by **RAK12021** module.  \n> **Image:** Light Color Recognizer device", "keywords": ["Light Color Recognizer", "LoRaWAN", "RAK12021", "RGB sensor", "TCS37725FN", "RAK14001", "RGB LED"], "source_file": "quickstart.md", "token_count": 0, "parent_content": "The **Light Color Recognizer LoRaWAN Application** is used to evaluate the color of the light being monitored using an RGB sensor. It uses **RAK12021** which is an RGB sensor which is based on **TCS37725FN** from AMS. It also uses **RAK14001** RGB LED module which will visualize the color being monitored by **RAK12021** module.  \n> **Image:** Light Color Recognizer device"}
{"id": "40a701aadc3bf9f8ce35ece0021f4748", "product_family": "wisblock", "product_id": "kit6-light-and-color", "category": "How-To", "title": "WisBlock IoT Education Kit - Light & Color Quick Start Guide > WisBlock IoT Education Kit - Light & Color Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock IoT Education Kit - Light & Color using TTN and Qubitro > Light Color Recognizer LoRaWAN Application > Light Color Recognizer - TTN Registration Section and Device Registration > Steps for TTN Account Creation and Device Registration", "content": "1. If you already have an existing TTN account, you may proceed to the next steps. If you haven't created any TTN account, please refer to this [link](#ttn-account-creation) to create one.  \n2. Once done with the TTN account creation, you may now proceed with the device registration. Please refer to this [guide](#device-registration) for your reference. After creating the application and adding the device in TTN, you can proceed on the LoRaWAN Code uploading steps.", "keywords": ["TTN", "account creation", "device registration", "LoRaWAN"], "source_file": "quickstart.md", "token_count": 70, "parent_content": "1. If you already have an existing TTN account, you may proceed to the next steps. If you haven't created any TTN account, please refer to this [link](#ttn-account-creation) to create one.  \n2. Once done with the TTN account creation, you may now proceed with the device registration. Please refer to this [guide](#device-registration) for your reference. After creating the application and adding the device in TTN, you can proceed on the LoRaWAN Code uploading steps."}
{"id": "cc244939eefb5022166a65aa2a448ab1", "product_family": "wisblock", "product_id": "kit6-light-and-color", "category": "How-To", "title": "WisBlock IoT Education Kit - Light & Color Quick Start Guide > WisBlock IoT Education Kit - Light & Color Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock IoT Education Kit - Light & Color using TTN and Qubitro > Light Color Recognizer LoRaWAN Application > LoRaWAN Code for Light Color Recognizer > Programming the Light Color Recognizer Device with Arduino IDE [CODE]", "content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **Light Color Recognizer** device. Just copy the code below for **Light Color Recognizer LoRaWAN Application** and paste it into the **Arduino IDE**.", "keywords": ["Arduino IDE", "RAK4631", "Light Color Recognizer", "LoRaWAN", "programming"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **Light Color Recognizer** device. Just copy the code below for **Light Color Recognizer LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the example </summary>  \n```c\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h>  //http://librarymanager/All#SX126x\n#include <Wire.h>\n#include <NCP5623.h>//http://librarymanager/All#NCP5623 By:RAKWireless\n#include \"TCS3772.h\"  // Click here to get the library: http://librarymanager/All#TCS37725\n// It use WB_IO2 to power up and is conflicting with INT1, so better use in SlotA/SlotC/SlotD.\n\nNCP5623 rgb;\nTCS3772 tcs3772;\nTCS3772_DataScaled tcs3772_data = {0};\n\nuint16_t scale_factor;\n\nuint16_t redColor;\nuint16_t greenColor;\nuint16_t blueColor;\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define RAK4631_BOARD true\n#else\n#define RAK4631_BOARD false\n#endif\n\nbool doOTAA = true;                                               // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                                       /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                                     /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5                               /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                                        /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;                           /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;                 /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                              /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = { LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF };\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = { BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler };\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0x96, 0xBD, 0xC5, 0x98, 0x17, 0x69, 0x8D, 0xFA, 0x1F, 0x64, 0xFE, 0x1C, 0xF9, 0x26, 0x7F, 0x8D };\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };\nuint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                                            /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];               //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = { m_lora_app_data_buffer, 0, 0, 0, 0 };  //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {\n\n// Initialize Serial for debug output\npinMode(LED_BLUE, OUTPUT);\ndigitalWrite(LED_BLUE, HIGH);\n\n// Sensor Power Switch\npinMode(WB_IO2, OUTPUT);\ndigitalWrite(WB_IO2, HIGH);\n\n// enable RAK14001\npinMode(WB_IO6, OUTPUT);\ndigitalWrite(WB_IO6, HIGH);\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial) {\nif ((millis() - timeout) < 5000) {\ndelay(100);\n} else {\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA) {\nSerial.println(\"Type: OTAA\");\n} else {\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion) {\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA) {\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n} else {\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0) {\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"================================\");\nSerial.println(\"RAK12021 + RAK14001 LoRaWAN Code\");\nSerial.println(\"================================\");\n\n// If using Native I2C\nWire.begin();\nWire.setClock(100000);\n\n// Serial.println(\"RAK14001 + RAK12021\");\n\nif (!rgb.begin())\n{\nSerial.println(\"RAK14001 not found on the I2C line\");\nwhile (1);\n}\nelse\n{\nSerial.println(\"RAK14001 Found. Begining execution\");\n}\n\n// set the current output level max, the range is 1 to 31\nrgb.setCurrent(25);\n\nif(tcs3772.begin() == true)\n{\nSerial.println(\"Found sensor.\");\n}\nelse\n{\nSerial.println(\"TCS37725 not found ... check your connections.\");\nwhile(1)\n{\ndelay(10);\n}\n}\ndelay(1000);\n}\n\nvoid loop() {\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\ntcs3772_data = tcs3772.getMeasurement();\n\nscale_factor = tcs3772.autoGain(tcs3772_data.clear);\n\nredColor = tcs3772_data.red;\ngreenColor = tcs3772_data.green;\nblueColor = tcs3772_data.blue;\n\nrgb.setColor(0,0,0);     // Initially OFF\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\nSerial.print(\"  R: \");\nSerial.println(redColor);\nSerial.print(\"  G: \");\nSerial.println(greenColor);\nSerial.print(\"  B: \");\nSerial.println(blueColor);\n\n// The values of redColor, greenColor and blueColor can be varied during the sensing calibration of RAK12021 module\n\nif (((redColor >= 9000) && (redColor <= 65535)) && ((greenColor >= 10000) && (greenColor <= 65535)) && ((blueColor >= 12000) && (blueColor <= 65535)))\n{\nrgb.setColor(255,255,255); // WHITE\n}\n\nelse if (((redColor >= 4000) && (redColor <= 18000)) && ((greenColor >= 1300) && (greenColor <= 5000)) && ((blueColor >= 950) && (blueColor <= 2000)))\n{\nrgb.setColor(255,255,0);  // YELLOW\n}\n\nelse if (((redColor >= 600) && (redColor <= 2000)) && ((greenColor >= 1700) && (greenColor <= 10000)) && ((blueColor >= 6800) && (blueColor <= 27000)))\n{\nrgb.setColor(0,0,255);    // BLUE\n}\n\nelse if (((redColor >= 1400) && (redColor <= 4000)) && ((greenColor >= 1300) && (greenColor <= 10000)) && ((blueColor >= 950) && (blueColor <= 2700)))\n{\nrgb.setColor(0,255,0);    // GREEN\n}\n\nelse if (((redColor >= 3000) && (redColor <= 20000)) && ((greenColor >= 700) && (greenColor <= 2400)) && ((blueColor >= 950) && (blueColor <= 3000)))\n{\nrgb.setColor(255,0,0);    // RED\n}\n\nelse if ((redColor < 1500) && (greenColor < 1400) && (blueColor < 900))\n{\nrgb.setColor(0,0,0);  // OFF\n}\n\ndelay(5000);\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void) {\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void) {\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data) {\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class) {\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void) {\nif (lmh_join_status_get() != LMH_SET) {\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\n// Showing the values of red, green and blue colors from RAK12021\ndata = \" Red: \" + String(redColor) + \" Green: \" + String(greenColor) + \" Blue: \" + String(blueColor);\n\nSerial.println(data);\n\nuint16_t red_data = redColor;\nuint16_t green_data = greenColor;\nuint16_t blue_data = blueColor;\n\nm_lora_app_data.buffer[i++] = 0x01;  // byte[0]\n\n// Red data\nm_lora_app_data.buffer[i++] = (uint8_t)((red_data & 0x0000FF00) >> 8);     // byte[1]\nm_lora_app_data.buffer[i++] = (uint8_t)(red_data & 0x000000FF);            // byte[2]\n\n// Green data\nm_lora_app_data.buffer[i++] = (uint8_t)((green_data & 0x0000FF00) >> 8);   // byte[3]\nm_lora_app_data.buffer[i++] = (uint8_t)(green_data & 0x000000FF);          // byte[4]\n\n// Blue data\nm_lora_app_data.buffer[i++] = (uint8_t)((blue_data & 0x0000FF00) >> 8);    // byte[5]\nm_lora_app_data.buffer[i++] = (uint8_t)(blue_data & 0x000000FF);           // byte[6]\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS) {\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n} else {\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0x96, 0xBD, 0xC5, 0x98, 0x17, 0x69, 0x8D, 0xFA, 0x1F, 0x64, 0xFE, 0x1C, 0xF9, 0x26, 0x7F, 0x8D };\n```  \n> **Image:** OTAA device successfully registered to TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "951450171a4c526cb8c32943c23fcab4", "product_family": "wisblock", "product_id": "kit6-light-and-color", "category": "How-To", "title": "WisBlock IoT Education Kit - Light & Color Quick Start Guide > WisBlock IoT Education Kit - Light & Color Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock IoT Education Kit - Light & Color using TTN and Qubitro > Light Color Recognizer LoRaWAN Application > LoRaWAN Code for Light Color Recognizer > Programming the Light Color Recognizer Device with Arduino IDE [CODE]", "content": "> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the example </summary>  \n```c\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h>  //http://librarymanager/All#SX126x\n#include <Wire.h>\n#include <NCP5623.h>//http://librarymanager/All#NCP5623 By:RAKWireless", "keywords": ["Arduino IDE", "RAK4631", "Light Color Recognizer", "LoRaWAN", "programming"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **Light Color Recognizer** device. Just copy the code below for **Light Color Recognizer LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the example </summary>  \n```c\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h>  //http://librarymanager/All#SX126x\n#include <Wire.h>\n#include <NCP5623.h>//http://librarymanager/All#NCP5623 By:RAKWireless\n#include \"TCS3772.h\"  // Click here to get the library: http://librarymanager/All#TCS37725\n// It use WB_IO2 to power up and is conflicting with INT1, so better use in SlotA/SlotC/SlotD.\n\nNCP5623 rgb;\nTCS3772 tcs3772;\nTCS3772_DataScaled tcs3772_data = {0};\n\nuint16_t scale_factor;\n\nuint16_t redColor;\nuint16_t greenColor;\nuint16_t blueColor;\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define RAK4631_BOARD true\n#else\n#define RAK4631_BOARD false\n#endif\n\nbool doOTAA = true;                                               // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                                       /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                                     /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5                               /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                                        /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;                           /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;                 /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                              /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = { LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF };\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = { BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler };\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0x96, 0xBD, 0xC5, 0x98, 0x17, 0x69, 0x8D, 0xFA, 0x1F, 0x64, 0xFE, 0x1C, 0xF9, 0x26, 0x7F, 0x8D };\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };\nuint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                                            /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];               //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = { m_lora_app_data_buffer, 0, 0, 0, 0 };  //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {\n\n// Initialize Serial for debug output\npinMode(LED_BLUE, OUTPUT);\ndigitalWrite(LED_BLUE, HIGH);\n\n// Sensor Power Switch\npinMode(WB_IO2, OUTPUT);\ndigitalWrite(WB_IO2, HIGH);\n\n// enable RAK14001\npinMode(WB_IO6, OUTPUT);\ndigitalWrite(WB_IO6, HIGH);\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial) {\nif ((millis() - timeout) < 5000) {\ndelay(100);\n} else {\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA) {\nSerial.println(\"Type: OTAA\");\n} else {\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion) {\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA) {\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n} else {\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0) {\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"================================\");\nSerial.println(\"RAK12021 + RAK14001 LoRaWAN Code\");\nSerial.println(\"================================\");\n\n// If using Native I2C\nWire.begin();\nWire.setClock(100000);\n\n// Serial.println(\"RAK14001 + RAK12021\");\n\nif (!rgb.begin())\n{\nSerial.println(\"RAK14001 not found on the I2C line\");\nwhile (1);\n}\nelse\n{\nSerial.println(\"RAK14001 Found. Begining execution\");\n}\n\n// set the current output level max, the range is 1 to 31\nrgb.setCurrent(25);\n\nif(tcs3772.begin() == true)\n{\nSerial.println(\"Found sensor.\");\n}\nelse\n{\nSerial.println(\"TCS37725 not found ... check your connections.\");\nwhile(1)\n{\ndelay(10);\n}\n}\ndelay(1000);\n}\n\nvoid loop() {\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\ntcs3772_data = tcs3772.getMeasurement();\n\nscale_factor = tcs3772.autoGain(tcs3772_data.clear);\n\nredColor = tcs3772_data.red;\ngreenColor = tcs3772_data.green;\nblueColor = tcs3772_data.blue;\n\nrgb.setColor(0,0,0);     // Initially OFF\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\nSerial.print(\"  R: \");\nSerial.println(redColor);\nSerial.print(\"  G: \");\nSerial.println(greenColor);\nSerial.print(\"  B: \");\nSerial.println(blueColor);\n\n// The values of redColor, greenColor and blueColor can be varied during the sensing calibration of RAK12021 module\n\nif (((redColor >= 9000) && (redColor <= 65535)) && ((greenColor >= 10000) && (greenColor <= 65535)) && ((blueColor >= 12000) && (blueColor <= 65535)))\n{\nrgb.setColor(255,255,255); // WHITE\n}\n\nelse if (((redColor >= 4000) && (redColor <= 18000)) && ((greenColor >= 1300) && (greenColor <= 5000)) && ((blueColor >= 950) && (blueColor <= 2000)))\n{\nrgb.setColor(255,255,0);  // YELLOW\n}\n\nelse if (((redColor >= 600) && (redColor <= 2000)) && ((greenColor >= 1700) && (greenColor <= 10000)) && ((blueColor >= 6800) && (blueColor <= 27000)))\n{\nrgb.setColor(0,0,255);    // BLUE\n}\n\nelse if (((redColor >= 1400) && (redColor <= 4000)) && ((greenColor >= 1300) && (greenColor <= 10000)) && ((blueColor >= 950) && (blueColor <= 2700)))\n{\nrgb.setColor(0,255,0);    // GREEN\n}\n\nelse if (((redColor >= 3000) && (redColor <= 20000)) && ((greenColor >= 700) && (greenColor <= 2400)) && ((blueColor >= 950) && (blueColor <= 3000)))\n{\nrgb.setColor(255,0,0);    // RED\n}\n\nelse if ((redColor < 1500) && (greenColor < 1400) && (blueColor < 900))\n{\nrgb.setColor(0,0,0);  // OFF\n}\n\ndelay(5000);\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void) {\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void) {\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data) {\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class) {\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void) {\nif (lmh_join_status_get() != LMH_SET) {\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\n// Showing the values of red, green and blue colors from RAK12021\ndata = \" Red: \" + String(redColor) + \" Green: \" + String(greenColor) + \" Blue: \" + String(blueColor);\n\nSerial.println(data);\n\nuint16_t red_data = redColor;\nuint16_t green_data = greenColor;\nuint16_t blue_data = blueColor;\n\nm_lora_app_data.buffer[i++] = 0x01;  // byte[0]\n\n// Red data\nm_lora_app_data.buffer[i++] = (uint8_t)((red_data & 0x0000FF00) >> 8);     // byte[1]\nm_lora_app_data.buffer[i++] = (uint8_t)(red_data & 0x000000FF);            // byte[2]\n\n// Green data\nm_lora_app_data.buffer[i++] = (uint8_t)((green_data & 0x0000FF00) >> 8);   // byte[3]\nm_lora_app_data.buffer[i++] = (uint8_t)(green_data & 0x000000FF);          // byte[4]\n\n// Blue data\nm_lora_app_data.buffer[i++] = (uint8_t)((blue_data & 0x0000FF00) >> 8);    // byte[5]\nm_lora_app_data.buffer[i++] = (uint8_t)(blue_data & 0x000000FF);           // byte[6]\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS) {\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n} else {\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0x96, 0xBD, 0xC5, 0x98, 0x17, 0x69, 0x8D, 0xFA, 0x1F, 0x64, 0xFE, 0x1C, 0xF9, 0x26, 0x7F, 0x8D };\n```  \n> **Image:** OTAA device successfully registered to TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "3b546a2f212559e9c56e0812b5763e73", "product_family": "wisblock", "product_id": "kit6-light-and-color", "category": "How-To", "title": "WisBlock IoT Education Kit - Light & Color Quick Start Guide > WisBlock IoT Education Kit - Light & Color Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock IoT Education Kit - Light & Color using TTN and Qubitro > Light Color Recognizer LoRaWAN Application > LoRaWAN Code for Light Color Recognizer > Programming the Light Color Recognizer Device with Arduino IDE [CODE]", "content": "#include <Wire.h>\n#include <NCP5623.h>//http://librarymanager/All#NCP5623 By:RAKWireless\n#include \"TCS3772.h\"  // Click here to get the library: http://librarymanager/All#TCS37725\n// It use WB_IO2 to power up and is conflicting with INT1, so better use in SlotA/SlotC/SlotD.", "keywords": ["Arduino IDE", "RAK4631", "Light Color Recognizer", "LoRaWAN", "programming"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **Light Color Recognizer** device. Just copy the code below for **Light Color Recognizer LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the example </summary>  \n```c\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h>  //http://librarymanager/All#SX126x\n#include <Wire.h>\n#include <NCP5623.h>//http://librarymanager/All#NCP5623 By:RAKWireless\n#include \"TCS3772.h\"  // Click here to get the library: http://librarymanager/All#TCS37725\n// It use WB_IO2 to power up and is conflicting with INT1, so better use in SlotA/SlotC/SlotD.\n\nNCP5623 rgb;\nTCS3772 tcs3772;\nTCS3772_DataScaled tcs3772_data = {0};\n\nuint16_t scale_factor;\n\nuint16_t redColor;\nuint16_t greenColor;\nuint16_t blueColor;\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define RAK4631_BOARD true\n#else\n#define RAK4631_BOARD false\n#endif\n\nbool doOTAA = true;                                               // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                                       /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                                     /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5                               /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                                        /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;                           /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;                 /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                              /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = { LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF };\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = { BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler };\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0x96, 0xBD, 0xC5, 0x98, 0x17, 0x69, 0x8D, 0xFA, 0x1F, 0x64, 0xFE, 0x1C, 0xF9, 0x26, 0x7F, 0x8D };\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };\nuint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                                            /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];               //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = { m_lora_app_data_buffer, 0, 0, 0, 0 };  //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {\n\n// Initialize Serial for debug output\npinMode(LED_BLUE, OUTPUT);\ndigitalWrite(LED_BLUE, HIGH);\n\n// Sensor Power Switch\npinMode(WB_IO2, OUTPUT);\ndigitalWrite(WB_IO2, HIGH);\n\n// enable RAK14001\npinMode(WB_IO6, OUTPUT);\ndigitalWrite(WB_IO6, HIGH);\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial) {\nif ((millis() - timeout) < 5000) {\ndelay(100);\n} else {\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA) {\nSerial.println(\"Type: OTAA\");\n} else {\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion) {\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA) {\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n} else {\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0) {\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"================================\");\nSerial.println(\"RAK12021 + RAK14001 LoRaWAN Code\");\nSerial.println(\"================================\");\n\n// If using Native I2C\nWire.begin();\nWire.setClock(100000);\n\n// Serial.println(\"RAK14001 + RAK12021\");\n\nif (!rgb.begin())\n{\nSerial.println(\"RAK14001 not found on the I2C line\");\nwhile (1);\n}\nelse\n{\nSerial.println(\"RAK14001 Found. Begining execution\");\n}\n\n// set the current output level max, the range is 1 to 31\nrgb.setCurrent(25);\n\nif(tcs3772.begin() == true)\n{\nSerial.println(\"Found sensor.\");\n}\nelse\n{\nSerial.println(\"TCS37725 not found ... check your connections.\");\nwhile(1)\n{\ndelay(10);\n}\n}\ndelay(1000);\n}\n\nvoid loop() {\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\ntcs3772_data = tcs3772.getMeasurement();\n\nscale_factor = tcs3772.autoGain(tcs3772_data.clear);\n\nredColor = tcs3772_data.red;\ngreenColor = tcs3772_data.green;\nblueColor = tcs3772_data.blue;\n\nrgb.setColor(0,0,0);     // Initially OFF\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\nSerial.print(\"  R: \");\nSerial.println(redColor);\nSerial.print(\"  G: \");\nSerial.println(greenColor);\nSerial.print(\"  B: \");\nSerial.println(blueColor);\n\n// The values of redColor, greenColor and blueColor can be varied during the sensing calibration of RAK12021 module\n\nif (((redColor >= 9000) && (redColor <= 65535)) && ((greenColor >= 10000) && (greenColor <= 65535)) && ((blueColor >= 12000) && (blueColor <= 65535)))\n{\nrgb.setColor(255,255,255); // WHITE\n}\n\nelse if (((redColor >= 4000) && (redColor <= 18000)) && ((greenColor >= 1300) && (greenColor <= 5000)) && ((blueColor >= 950) && (blueColor <= 2000)))\n{\nrgb.setColor(255,255,0);  // YELLOW\n}\n\nelse if (((redColor >= 600) && (redColor <= 2000)) && ((greenColor >= 1700) && (greenColor <= 10000)) && ((blueColor >= 6800) && (blueColor <= 27000)))\n{\nrgb.setColor(0,0,255);    // BLUE\n}\n\nelse if (((redColor >= 1400) && (redColor <= 4000)) && ((greenColor >= 1300) && (greenColor <= 10000)) && ((blueColor >= 950) && (blueColor <= 2700)))\n{\nrgb.setColor(0,255,0);    // GREEN\n}\n\nelse if (((redColor >= 3000) && (redColor <= 20000)) && ((greenColor >= 700) && (greenColor <= 2400)) && ((blueColor >= 950) && (blueColor <= 3000)))\n{\nrgb.setColor(255,0,0);    // RED\n}\n\nelse if ((redColor < 1500) && (greenColor < 1400) && (blueColor < 900))\n{\nrgb.setColor(0,0,0);  // OFF\n}\n\ndelay(5000);\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void) {\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void) {\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data) {\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class) {\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void) {\nif (lmh_join_status_get() != LMH_SET) {\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\n// Showing the values of red, green and blue colors from RAK12021\ndata = \" Red: \" + String(redColor) + \" Green: \" + String(greenColor) + \" Blue: \" + String(blueColor);\n\nSerial.println(data);\n\nuint16_t red_data = redColor;\nuint16_t green_data = greenColor;\nuint16_t blue_data = blueColor;\n\nm_lora_app_data.buffer[i++] = 0x01;  // byte[0]\n\n// Red data\nm_lora_app_data.buffer[i++] = (uint8_t)((red_data & 0x0000FF00) >> 8);     // byte[1]\nm_lora_app_data.buffer[i++] = (uint8_t)(red_data & 0x000000FF);            // byte[2]\n\n// Green data\nm_lora_app_data.buffer[i++] = (uint8_t)((green_data & 0x0000FF00) >> 8);   // byte[3]\nm_lora_app_data.buffer[i++] = (uint8_t)(green_data & 0x000000FF);          // byte[4]\n\n// Blue data\nm_lora_app_data.buffer[i++] = (uint8_t)((blue_data & 0x0000FF00) >> 8);    // byte[5]\nm_lora_app_data.buffer[i++] = (uint8_t)(blue_data & 0x000000FF);           // byte[6]\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS) {\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n} else {\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0x96, 0xBD, 0xC5, 0x98, 0x17, 0x69, 0x8D, 0xFA, 0x1F, 0x64, 0xFE, 0x1C, 0xF9, 0x26, 0x7F, 0x8D };\n```  \n> **Image:** OTAA device successfully registered to TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "e01076580efeb8092aef79de886c1199", "product_family": "wisblock", "product_id": "kit6-light-and-color", "category": "How-To", "title": "WisBlock IoT Education Kit - Light & Color Quick Start Guide > WisBlock IoT Education Kit - Light & Color Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock IoT Education Kit - Light & Color using TTN and Qubitro > Light Color Recognizer LoRaWAN Application > LoRaWAN Code for Light Color Recognizer > Programming the Light Color Recognizer Device with Arduino IDE [CODE]", "content": "NCP5623 rgb;\nTCS3772 tcs3772;\nTCS3772_DataScaled tcs3772_data = {0};\n\nuint16_t scale_factor;\n\nuint16_t redColor;\nuint16_t greenColor;\nuint16_t blueColor;\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define RAK4631_BOARD true\n#else\n#define RAK4631_BOARD false\n#endif", "keywords": ["Arduino IDE", "RAK4631", "Light Color Recognizer", "LoRaWAN", "programming"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **Light Color Recognizer** device. Just copy the code below for **Light Color Recognizer LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the example </summary>  \n```c\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h>  //http://librarymanager/All#SX126x\n#include <Wire.h>\n#include <NCP5623.h>//http://librarymanager/All#NCP5623 By:RAKWireless\n#include \"TCS3772.h\"  // Click here to get the library: http://librarymanager/All#TCS37725\n// It use WB_IO2 to power up and is conflicting with INT1, so better use in SlotA/SlotC/SlotD.\n\nNCP5623 rgb;\nTCS3772 tcs3772;\nTCS3772_DataScaled tcs3772_data = {0};\n\nuint16_t scale_factor;\n\nuint16_t redColor;\nuint16_t greenColor;\nuint16_t blueColor;\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define RAK4631_BOARD true\n#else\n#define RAK4631_BOARD false\n#endif\n\nbool doOTAA = true;                                               // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                                       /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                                     /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5                               /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                                        /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;                           /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;                 /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                              /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = { LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF };\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = { BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler };\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0x96, 0xBD, 0xC5, 0x98, 0x17, 0x69, 0x8D, 0xFA, 0x1F, 0x64, 0xFE, 0x1C, 0xF9, 0x26, 0x7F, 0x8D };\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };\nuint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                                            /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];               //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = { m_lora_app_data_buffer, 0, 0, 0, 0 };  //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {\n\n// Initialize Serial for debug output\npinMode(LED_BLUE, OUTPUT);\ndigitalWrite(LED_BLUE, HIGH);\n\n// Sensor Power Switch\npinMode(WB_IO2, OUTPUT);\ndigitalWrite(WB_IO2, HIGH);\n\n// enable RAK14001\npinMode(WB_IO6, OUTPUT);\ndigitalWrite(WB_IO6, HIGH);\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial) {\nif ((millis() - timeout) < 5000) {\ndelay(100);\n} else {\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA) {\nSerial.println(\"Type: OTAA\");\n} else {\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion) {\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA) {\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n} else {\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0) {\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"================================\");\nSerial.println(\"RAK12021 + RAK14001 LoRaWAN Code\");\nSerial.println(\"================================\");\n\n// If using Native I2C\nWire.begin();\nWire.setClock(100000);\n\n// Serial.println(\"RAK14001 + RAK12021\");\n\nif (!rgb.begin())\n{\nSerial.println(\"RAK14001 not found on the I2C line\");\nwhile (1);\n}\nelse\n{\nSerial.println(\"RAK14001 Found. Begining execution\");\n}\n\n// set the current output level max, the range is 1 to 31\nrgb.setCurrent(25);\n\nif(tcs3772.begin() == true)\n{\nSerial.println(\"Found sensor.\");\n}\nelse\n{\nSerial.println(\"TCS37725 not found ... check your connections.\");\nwhile(1)\n{\ndelay(10);\n}\n}\ndelay(1000);\n}\n\nvoid loop() {\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\ntcs3772_data = tcs3772.getMeasurement();\n\nscale_factor = tcs3772.autoGain(tcs3772_data.clear);\n\nredColor = tcs3772_data.red;\ngreenColor = tcs3772_data.green;\nblueColor = tcs3772_data.blue;\n\nrgb.setColor(0,0,0);     // Initially OFF\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\nSerial.print(\"  R: \");\nSerial.println(redColor);\nSerial.print(\"  G: \");\nSerial.println(greenColor);\nSerial.print(\"  B: \");\nSerial.println(blueColor);\n\n// The values of redColor, greenColor and blueColor can be varied during the sensing calibration of RAK12021 module\n\nif (((redColor >= 9000) && (redColor <= 65535)) && ((greenColor >= 10000) && (greenColor <= 65535)) && ((blueColor >= 12000) && (blueColor <= 65535)))\n{\nrgb.setColor(255,255,255); // WHITE\n}\n\nelse if (((redColor >= 4000) && (redColor <= 18000)) && ((greenColor >= 1300) && (greenColor <= 5000)) && ((blueColor >= 950) && (blueColor <= 2000)))\n{\nrgb.setColor(255,255,0);  // YELLOW\n}\n\nelse if (((redColor >= 600) && (redColor <= 2000)) && ((greenColor >= 1700) && (greenColor <= 10000)) && ((blueColor >= 6800) && (blueColor <= 27000)))\n{\nrgb.setColor(0,0,255);    // BLUE\n}\n\nelse if (((redColor >= 1400) && (redColor <= 4000)) && ((greenColor >= 1300) && (greenColor <= 10000)) && ((blueColor >= 950) && (blueColor <= 2700)))\n{\nrgb.setColor(0,255,0);    // GREEN\n}\n\nelse if (((redColor >= 3000) && (redColor <= 20000)) && ((greenColor >= 700) && (greenColor <= 2400)) && ((blueColor >= 950) && (blueColor <= 3000)))\n{\nrgb.setColor(255,0,0);    // RED\n}\n\nelse if ((redColor < 1500) && (greenColor < 1400) && (blueColor < 900))\n{\nrgb.setColor(0,0,0);  // OFF\n}\n\ndelay(5000);\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void) {\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void) {\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data) {\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class) {\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void) {\nif (lmh_join_status_get() != LMH_SET) {\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\n// Showing the values of red, green and blue colors from RAK12021\ndata = \" Red: \" + String(redColor) + \" Green: \" + String(greenColor) + \" Blue: \" + String(blueColor);\n\nSerial.println(data);\n\nuint16_t red_data = redColor;\nuint16_t green_data = greenColor;\nuint16_t blue_data = blueColor;\n\nm_lora_app_data.buffer[i++] = 0x01;  // byte[0]\n\n// Red data\nm_lora_app_data.buffer[i++] = (uint8_t)((red_data & 0x0000FF00) >> 8);     // byte[1]\nm_lora_app_data.buffer[i++] = (uint8_t)(red_data & 0x000000FF);            // byte[2]\n\n// Green data\nm_lora_app_data.buffer[i++] = (uint8_t)((green_data & 0x0000FF00) >> 8);   // byte[3]\nm_lora_app_data.buffer[i++] = (uint8_t)(green_data & 0x000000FF);          // byte[4]\n\n// Blue data\nm_lora_app_data.buffer[i++] = (uint8_t)((blue_data & 0x0000FF00) >> 8);    // byte[5]\nm_lora_app_data.buffer[i++] = (uint8_t)(blue_data & 0x000000FF);           // byte[6]\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS) {\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n} else {\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0x96, 0xBD, 0xC5, 0x98, 0x17, 0x69, 0x8D, 0xFA, 0x1F, 0x64, 0xFE, 0x1C, 0xF9, 0x26, 0x7F, 0x8D };\n```  \n> **Image:** OTAA device successfully registered to TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "75a14d642ec57d4172430a56fd265056", "product_family": "wisblock", "product_id": "kit6-light-and-color", "category": "How-To", "title": "WisBlock IoT Education Kit - Light & Color Quick Start Guide > WisBlock IoT Education Kit - Light & Color Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock IoT Education Kit - Light & Color using TTN and Qubitro > Light Color Recognizer LoRaWAN Application > LoRaWAN Code for Light Color Recognizer > Programming the Light Color Recognizer Device with Arduino IDE [CODE]", "content": "bool doOTAA = true;                                               // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                                       /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                                     /*LoRaMac datarates definition, from DR_0 to DR_5*/", "keywords": ["Arduino IDE", "RAK4631", "Light Color Recognizer", "LoRaWAN", "programming"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **Light Color Recognizer** device. Just copy the code below for **Light Color Recognizer LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the example </summary>  \n```c\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h>  //http://librarymanager/All#SX126x\n#include <Wire.h>\n#include <NCP5623.h>//http://librarymanager/All#NCP5623 By:RAKWireless\n#include \"TCS3772.h\"  // Click here to get the library: http://librarymanager/All#TCS37725\n// It use WB_IO2 to power up and is conflicting with INT1, so better use in SlotA/SlotC/SlotD.\n\nNCP5623 rgb;\nTCS3772 tcs3772;\nTCS3772_DataScaled tcs3772_data = {0};\n\nuint16_t scale_factor;\n\nuint16_t redColor;\nuint16_t greenColor;\nuint16_t blueColor;\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define RAK4631_BOARD true\n#else\n#define RAK4631_BOARD false\n#endif\n\nbool doOTAA = true;                                               // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                                       /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                                     /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5                               /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                                        /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;                           /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;                 /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                              /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = { LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF };\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = { BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler };\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0x96, 0xBD, 0xC5, 0x98, 0x17, 0x69, 0x8D, 0xFA, 0x1F, 0x64, 0xFE, 0x1C, 0xF9, 0x26, 0x7F, 0x8D };\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };\nuint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                                            /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];               //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = { m_lora_app_data_buffer, 0, 0, 0, 0 };  //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {\n\n// Initialize Serial for debug output\npinMode(LED_BLUE, OUTPUT);\ndigitalWrite(LED_BLUE, HIGH);\n\n// Sensor Power Switch\npinMode(WB_IO2, OUTPUT);\ndigitalWrite(WB_IO2, HIGH);\n\n// enable RAK14001\npinMode(WB_IO6, OUTPUT);\ndigitalWrite(WB_IO6, HIGH);\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial) {\nif ((millis() - timeout) < 5000) {\ndelay(100);\n} else {\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA) {\nSerial.println(\"Type: OTAA\");\n} else {\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion) {\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA) {\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n} else {\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0) {\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"================================\");\nSerial.println(\"RAK12021 + RAK14001 LoRaWAN Code\");\nSerial.println(\"================================\");\n\n// If using Native I2C\nWire.begin();\nWire.setClock(100000);\n\n// Serial.println(\"RAK14001 + RAK12021\");\n\nif (!rgb.begin())\n{\nSerial.println(\"RAK14001 not found on the I2C line\");\nwhile (1);\n}\nelse\n{\nSerial.println(\"RAK14001 Found. Begining execution\");\n}\n\n// set the current output level max, the range is 1 to 31\nrgb.setCurrent(25);\n\nif(tcs3772.begin() == true)\n{\nSerial.println(\"Found sensor.\");\n}\nelse\n{\nSerial.println(\"TCS37725 not found ... check your connections.\");\nwhile(1)\n{\ndelay(10);\n}\n}\ndelay(1000);\n}\n\nvoid loop() {\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\ntcs3772_data = tcs3772.getMeasurement();\n\nscale_factor = tcs3772.autoGain(tcs3772_data.clear);\n\nredColor = tcs3772_data.red;\ngreenColor = tcs3772_data.green;\nblueColor = tcs3772_data.blue;\n\nrgb.setColor(0,0,0);     // Initially OFF\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\nSerial.print(\"  R: \");\nSerial.println(redColor);\nSerial.print(\"  G: \");\nSerial.println(greenColor);\nSerial.print(\"  B: \");\nSerial.println(blueColor);\n\n// The values of redColor, greenColor and blueColor can be varied during the sensing calibration of RAK12021 module\n\nif (((redColor >= 9000) && (redColor <= 65535)) && ((greenColor >= 10000) && (greenColor <= 65535)) && ((blueColor >= 12000) && (blueColor <= 65535)))\n{\nrgb.setColor(255,255,255); // WHITE\n}\n\nelse if (((redColor >= 4000) && (redColor <= 18000)) && ((greenColor >= 1300) && (greenColor <= 5000)) && ((blueColor >= 950) && (blueColor <= 2000)))\n{\nrgb.setColor(255,255,0);  // YELLOW\n}\n\nelse if (((redColor >= 600) && (redColor <= 2000)) && ((greenColor >= 1700) && (greenColor <= 10000)) && ((blueColor >= 6800) && (blueColor <= 27000)))\n{\nrgb.setColor(0,0,255);    // BLUE\n}\n\nelse if (((redColor >= 1400) && (redColor <= 4000)) && ((greenColor >= 1300) && (greenColor <= 10000)) && ((blueColor >= 950) && (blueColor <= 2700)))\n{\nrgb.setColor(0,255,0);    // GREEN\n}\n\nelse if (((redColor >= 3000) && (redColor <= 20000)) && ((greenColor >= 700) && (greenColor <= 2400)) && ((blueColor >= 950) && (blueColor <= 3000)))\n{\nrgb.setColor(255,0,0);    // RED\n}\n\nelse if ((redColor < 1500) && (greenColor < 1400) && (blueColor < 900))\n{\nrgb.setColor(0,0,0);  // OFF\n}\n\ndelay(5000);\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void) {\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void) {\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data) {\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class) {\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void) {\nif (lmh_join_status_get() != LMH_SET) {\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\n// Showing the values of red, green and blue colors from RAK12021\ndata = \" Red: \" + String(redColor) + \" Green: \" + String(greenColor) + \" Blue: \" + String(blueColor);\n\nSerial.println(data);\n\nuint16_t red_data = redColor;\nuint16_t green_data = greenColor;\nuint16_t blue_data = blueColor;\n\nm_lora_app_data.buffer[i++] = 0x01;  // byte[0]\n\n// Red data\nm_lora_app_data.buffer[i++] = (uint8_t)((red_data & 0x0000FF00) >> 8);     // byte[1]\nm_lora_app_data.buffer[i++] = (uint8_t)(red_data & 0x000000FF);            // byte[2]\n\n// Green data\nm_lora_app_data.buffer[i++] = (uint8_t)((green_data & 0x0000FF00) >> 8);   // byte[3]\nm_lora_app_data.buffer[i++] = (uint8_t)(green_data & 0x000000FF);          // byte[4]\n\n// Blue data\nm_lora_app_data.buffer[i++] = (uint8_t)((blue_data & 0x0000FF00) >> 8);    // byte[5]\nm_lora_app_data.buffer[i++] = (uint8_t)(blue_data & 0x000000FF);           // byte[6]\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS) {\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n} else {\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0x96, 0xBD, 0xC5, 0x98, 0x17, 0x69, 0x8D, 0xFA, 0x1F, 0x64, 0xFE, 0x1C, 0xF9, 0x26, 0x7F, 0x8D };\n```  \n> **Image:** OTAA device successfully registered to TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "61771e80d6d083cdc5d0a386e8d08ab2", "product_family": "wisblock", "product_id": "kit6-light-and-color", "category": "How-To", "title": "WisBlock IoT Education Kit - Light & Color Quick Start Guide > WisBlock IoT Education Kit - Light & Color Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock IoT Education Kit - Light & Color using TTN and Qubitro > Light Color Recognizer LoRaWAN Application > LoRaWAN Code for Light Color Recognizer > Programming the Light Color Recognizer Device with Arduino IDE [CODE]", "content": "#define LORAWAN_TX_POWER TX_POWER_5                               /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                                        /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;                           /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/", "keywords": ["Arduino IDE", "RAK4631", "Light Color Recognizer", "LoRaWAN", "programming"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **Light Color Recognizer** device. Just copy the code below for **Light Color Recognizer LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the example </summary>  \n```c\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h>  //http://librarymanager/All#SX126x\n#include <Wire.h>\n#include <NCP5623.h>//http://librarymanager/All#NCP5623 By:RAKWireless\n#include \"TCS3772.h\"  // Click here to get the library: http://librarymanager/All#TCS37725\n// It use WB_IO2 to power up and is conflicting with INT1, so better use in SlotA/SlotC/SlotD.\n\nNCP5623 rgb;\nTCS3772 tcs3772;\nTCS3772_DataScaled tcs3772_data = {0};\n\nuint16_t scale_factor;\n\nuint16_t redColor;\nuint16_t greenColor;\nuint16_t blueColor;\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define RAK4631_BOARD true\n#else\n#define RAK4631_BOARD false\n#endif\n\nbool doOTAA = true;                                               // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                                       /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                                     /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5                               /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                                        /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;                           /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;                 /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                              /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = { LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF };\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = { BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler };\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0x96, 0xBD, 0xC5, 0x98, 0x17, 0x69, 0x8D, 0xFA, 0x1F, 0x64, 0xFE, 0x1C, 0xF9, 0x26, 0x7F, 0x8D };\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };\nuint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                                            /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];               //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = { m_lora_app_data_buffer, 0, 0, 0, 0 };  //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {\n\n// Initialize Serial for debug output\npinMode(LED_BLUE, OUTPUT);\ndigitalWrite(LED_BLUE, HIGH);\n\n// Sensor Power Switch\npinMode(WB_IO2, OUTPUT);\ndigitalWrite(WB_IO2, HIGH);\n\n// enable RAK14001\npinMode(WB_IO6, OUTPUT);\ndigitalWrite(WB_IO6, HIGH);\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial) {\nif ((millis() - timeout) < 5000) {\ndelay(100);\n} else {\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA) {\nSerial.println(\"Type: OTAA\");\n} else {\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion) {\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA) {\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n} else {\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0) {\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"================================\");\nSerial.println(\"RAK12021 + RAK14001 LoRaWAN Code\");\nSerial.println(\"================================\");\n\n// If using Native I2C\nWire.begin();\nWire.setClock(100000);\n\n// Serial.println(\"RAK14001 + RAK12021\");\n\nif (!rgb.begin())\n{\nSerial.println(\"RAK14001 not found on the I2C line\");\nwhile (1);\n}\nelse\n{\nSerial.println(\"RAK14001 Found. Begining execution\");\n}\n\n// set the current output level max, the range is 1 to 31\nrgb.setCurrent(25);\n\nif(tcs3772.begin() == true)\n{\nSerial.println(\"Found sensor.\");\n}\nelse\n{\nSerial.println(\"TCS37725 not found ... check your connections.\");\nwhile(1)\n{\ndelay(10);\n}\n}\ndelay(1000);\n}\n\nvoid loop() {\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\ntcs3772_data = tcs3772.getMeasurement();\n\nscale_factor = tcs3772.autoGain(tcs3772_data.clear);\n\nredColor = tcs3772_data.red;\ngreenColor = tcs3772_data.green;\nblueColor = tcs3772_data.blue;\n\nrgb.setColor(0,0,0);     // Initially OFF\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\nSerial.print(\"  R: \");\nSerial.println(redColor);\nSerial.print(\"  G: \");\nSerial.println(greenColor);\nSerial.print(\"  B: \");\nSerial.println(blueColor);\n\n// The values of redColor, greenColor and blueColor can be varied during the sensing calibration of RAK12021 module\n\nif (((redColor >= 9000) && (redColor <= 65535)) && ((greenColor >= 10000) && (greenColor <= 65535)) && ((blueColor >= 12000) && (blueColor <= 65535)))\n{\nrgb.setColor(255,255,255); // WHITE\n}\n\nelse if (((redColor >= 4000) && (redColor <= 18000)) && ((greenColor >= 1300) && (greenColor <= 5000)) && ((blueColor >= 950) && (blueColor <= 2000)))\n{\nrgb.setColor(255,255,0);  // YELLOW\n}\n\nelse if (((redColor >= 600) && (redColor <= 2000)) && ((greenColor >= 1700) && (greenColor <= 10000)) && ((blueColor >= 6800) && (blueColor <= 27000)))\n{\nrgb.setColor(0,0,255);    // BLUE\n}\n\nelse if (((redColor >= 1400) && (redColor <= 4000)) && ((greenColor >= 1300) && (greenColor <= 10000)) && ((blueColor >= 950) && (blueColor <= 2700)))\n{\nrgb.setColor(0,255,0);    // GREEN\n}\n\nelse if (((redColor >= 3000) && (redColor <= 20000)) && ((greenColor >= 700) && (greenColor <= 2400)) && ((blueColor >= 950) && (blueColor <= 3000)))\n{\nrgb.setColor(255,0,0);    // RED\n}\n\nelse if ((redColor < 1500) && (greenColor < 1400) && (blueColor < 900))\n{\nrgb.setColor(0,0,0);  // OFF\n}\n\ndelay(5000);\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void) {\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void) {\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data) {\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class) {\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void) {\nif (lmh_join_status_get() != LMH_SET) {\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\n// Showing the values of red, green and blue colors from RAK12021\ndata = \" Red: \" + String(redColor) + \" Green: \" + String(greenColor) + \" Blue: \" + String(blueColor);\n\nSerial.println(data);\n\nuint16_t red_data = redColor;\nuint16_t green_data = greenColor;\nuint16_t blue_data = blueColor;\n\nm_lora_app_data.buffer[i++] = 0x01;  // byte[0]\n\n// Red data\nm_lora_app_data.buffer[i++] = (uint8_t)((red_data & 0x0000FF00) >> 8);     // byte[1]\nm_lora_app_data.buffer[i++] = (uint8_t)(red_data & 0x000000FF);            // byte[2]\n\n// Green data\nm_lora_app_data.buffer[i++] = (uint8_t)((green_data & 0x0000FF00) >> 8);   // byte[3]\nm_lora_app_data.buffer[i++] = (uint8_t)(green_data & 0x000000FF);          // byte[4]\n\n// Blue data\nm_lora_app_data.buffer[i++] = (uint8_t)((blue_data & 0x0000FF00) >> 8);    // byte[5]\nm_lora_app_data.buffer[i++] = (uint8_t)(blue_data & 0x000000FF);           // byte[6]\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS) {\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n} else {\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0x96, 0xBD, 0xC5, 0x98, 0x17, 0x69, 0x8D, 0xFA, 0x1F, 0x64, 0xFE, 0x1C, 0xF9, 0x26, 0x7F, 0x8D };\n```  \n> **Image:** OTAA device successfully registered to TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "ab3addef2b338c961a026857de33b9a7", "product_family": "wisblock", "product_id": "kit6-light-and-color", "category": "How-To", "title": "WisBlock IoT Education Kit - Light & Color Quick Start Guide > WisBlock IoT Education Kit - Light & Color Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock IoT Education Kit - Light & Color using TTN and Qubitro > Light Color Recognizer LoRaWAN Application > LoRaWAN Code for Light Color Recognizer > Programming the Light Color Recognizer Device with Arduino IDE [CODE]", "content": "LoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;                 /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                              /* data port*/", "keywords": ["Arduino IDE", "RAK4631", "Light Color Recognizer", "LoRaWAN", "programming"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **Light Color Recognizer** device. Just copy the code below for **Light Color Recognizer LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the example </summary>  \n```c\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h>  //http://librarymanager/All#SX126x\n#include <Wire.h>\n#include <NCP5623.h>//http://librarymanager/All#NCP5623 By:RAKWireless\n#include \"TCS3772.h\"  // Click here to get the library: http://librarymanager/All#TCS37725\n// It use WB_IO2 to power up and is conflicting with INT1, so better use in SlotA/SlotC/SlotD.\n\nNCP5623 rgb;\nTCS3772 tcs3772;\nTCS3772_DataScaled tcs3772_data = {0};\n\nuint16_t scale_factor;\n\nuint16_t redColor;\nuint16_t greenColor;\nuint16_t blueColor;\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define RAK4631_BOARD true\n#else\n#define RAK4631_BOARD false\n#endif\n\nbool doOTAA = true;                                               // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                                       /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                                     /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5                               /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                                        /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;                           /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;                 /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                              /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = { LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF };\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = { BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler };\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0x96, 0xBD, 0xC5, 0x98, 0x17, 0x69, 0x8D, 0xFA, 0x1F, 0x64, 0xFE, 0x1C, 0xF9, 0x26, 0x7F, 0x8D };\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };\nuint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                                            /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];               //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = { m_lora_app_data_buffer, 0, 0, 0, 0 };  //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {\n\n// Initialize Serial for debug output\npinMode(LED_BLUE, OUTPUT);\ndigitalWrite(LED_BLUE, HIGH);\n\n// Sensor Power Switch\npinMode(WB_IO2, OUTPUT);\ndigitalWrite(WB_IO2, HIGH);\n\n// enable RAK14001\npinMode(WB_IO6, OUTPUT);\ndigitalWrite(WB_IO6, HIGH);\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial) {\nif ((millis() - timeout) < 5000) {\ndelay(100);\n} else {\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA) {\nSerial.println(\"Type: OTAA\");\n} else {\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion) {\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA) {\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n} else {\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0) {\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"================================\");\nSerial.println(\"RAK12021 + RAK14001 LoRaWAN Code\");\nSerial.println(\"================================\");\n\n// If using Native I2C\nWire.begin();\nWire.setClock(100000);\n\n// Serial.println(\"RAK14001 + RAK12021\");\n\nif (!rgb.begin())\n{\nSerial.println(\"RAK14001 not found on the I2C line\");\nwhile (1);\n}\nelse\n{\nSerial.println(\"RAK14001 Found. Begining execution\");\n}\n\n// set the current output level max, the range is 1 to 31\nrgb.setCurrent(25);\n\nif(tcs3772.begin() == true)\n{\nSerial.println(\"Found sensor.\");\n}\nelse\n{\nSerial.println(\"TCS37725 not found ... check your connections.\");\nwhile(1)\n{\ndelay(10);\n}\n}\ndelay(1000);\n}\n\nvoid loop() {\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\ntcs3772_data = tcs3772.getMeasurement();\n\nscale_factor = tcs3772.autoGain(tcs3772_data.clear);\n\nredColor = tcs3772_data.red;\ngreenColor = tcs3772_data.green;\nblueColor = tcs3772_data.blue;\n\nrgb.setColor(0,0,0);     // Initially OFF\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\nSerial.print(\"  R: \");\nSerial.println(redColor);\nSerial.print(\"  G: \");\nSerial.println(greenColor);\nSerial.print(\"  B: \");\nSerial.println(blueColor);\n\n// The values of redColor, greenColor and blueColor can be varied during the sensing calibration of RAK12021 module\n\nif (((redColor >= 9000) && (redColor <= 65535)) && ((greenColor >= 10000) && (greenColor <= 65535)) && ((blueColor >= 12000) && (blueColor <= 65535)))\n{\nrgb.setColor(255,255,255); // WHITE\n}\n\nelse if (((redColor >= 4000) && (redColor <= 18000)) && ((greenColor >= 1300) && (greenColor <= 5000)) && ((blueColor >= 950) && (blueColor <= 2000)))\n{\nrgb.setColor(255,255,0);  // YELLOW\n}\n\nelse if (((redColor >= 600) && (redColor <= 2000)) && ((greenColor >= 1700) && (greenColor <= 10000)) && ((blueColor >= 6800) && (blueColor <= 27000)))\n{\nrgb.setColor(0,0,255);    // BLUE\n}\n\nelse if (((redColor >= 1400) && (redColor <= 4000)) && ((greenColor >= 1300) && (greenColor <= 10000)) && ((blueColor >= 950) && (blueColor <= 2700)))\n{\nrgb.setColor(0,255,0);    // GREEN\n}\n\nelse if (((redColor >= 3000) && (redColor <= 20000)) && ((greenColor >= 700) && (greenColor <= 2400)) && ((blueColor >= 950) && (blueColor <= 3000)))\n{\nrgb.setColor(255,0,0);    // RED\n}\n\nelse if ((redColor < 1500) && (greenColor < 1400) && (blueColor < 900))\n{\nrgb.setColor(0,0,0);  // OFF\n}\n\ndelay(5000);\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void) {\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void) {\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data) {\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class) {\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void) {\nif (lmh_join_status_get() != LMH_SET) {\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\n// Showing the values of red, green and blue colors from RAK12021\ndata = \" Red: \" + String(redColor) + \" Green: \" + String(greenColor) + \" Blue: \" + String(blueColor);\n\nSerial.println(data);\n\nuint16_t red_data = redColor;\nuint16_t green_data = greenColor;\nuint16_t blue_data = blueColor;\n\nm_lora_app_data.buffer[i++] = 0x01;  // byte[0]\n\n// Red data\nm_lora_app_data.buffer[i++] = (uint8_t)((red_data & 0x0000FF00) >> 8);     // byte[1]\nm_lora_app_data.buffer[i++] = (uint8_t)(red_data & 0x000000FF);            // byte[2]\n\n// Green data\nm_lora_app_data.buffer[i++] = (uint8_t)((green_data & 0x0000FF00) >> 8);   // byte[3]\nm_lora_app_data.buffer[i++] = (uint8_t)(green_data & 0x000000FF);          // byte[4]\n\n// Blue data\nm_lora_app_data.buffer[i++] = (uint8_t)((blue_data & 0x0000FF00) >> 8);    // byte[5]\nm_lora_app_data.buffer[i++] = (uint8_t)(blue_data & 0x000000FF);           // byte[6]\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS) {\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n} else {\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0x96, 0xBD, 0xC5, 0x98, 0x17, 0x69, 0x8D, 0xFA, 0x1F, 0x64, 0xFE, 0x1C, 0xF9, 0x26, 0x7F, 0x8D };\n```  \n> **Image:** OTAA device successfully registered to TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "cd27898fbeca10151d66251ea4386ba0", "product_family": "wisblock", "product_id": "kit6-light-and-color", "category": "How-To", "title": "WisBlock IoT Education Kit - Light & Color Quick Start Guide > WisBlock IoT Education Kit - Light & Color Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock IoT Education Kit - Light & Color using TTN and Qubitro > Light Color Recognizer LoRaWAN Application > LoRaWAN Code for Light Color Recognizer > Programming the Light Color Recognizer Device with Arduino IDE [CODE]", "content": "/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = { LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF };", "keywords": ["Arduino IDE", "RAK4631", "Light Color Recognizer", "LoRaWAN", "programming"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **Light Color Recognizer** device. Just copy the code below for **Light Color Recognizer LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the example </summary>  \n```c\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h>  //http://librarymanager/All#SX126x\n#include <Wire.h>\n#include <NCP5623.h>//http://librarymanager/All#NCP5623 By:RAKWireless\n#include \"TCS3772.h\"  // Click here to get the library: http://librarymanager/All#TCS37725\n// It use WB_IO2 to power up and is conflicting with INT1, so better use in SlotA/SlotC/SlotD.\n\nNCP5623 rgb;\nTCS3772 tcs3772;\nTCS3772_DataScaled tcs3772_data = {0};\n\nuint16_t scale_factor;\n\nuint16_t redColor;\nuint16_t greenColor;\nuint16_t blueColor;\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define RAK4631_BOARD true\n#else\n#define RAK4631_BOARD false\n#endif\n\nbool doOTAA = true;                                               // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                                       /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                                     /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5                               /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                                        /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;                           /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;                 /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                              /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = { LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF };\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = { BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler };\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0x96, 0xBD, 0xC5, 0x98, 0x17, 0x69, 0x8D, 0xFA, 0x1F, 0x64, 0xFE, 0x1C, 0xF9, 0x26, 0x7F, 0x8D };\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };\nuint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                                            /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];               //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = { m_lora_app_data_buffer, 0, 0, 0, 0 };  //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {\n\n// Initialize Serial for debug output\npinMode(LED_BLUE, OUTPUT);\ndigitalWrite(LED_BLUE, HIGH);\n\n// Sensor Power Switch\npinMode(WB_IO2, OUTPUT);\ndigitalWrite(WB_IO2, HIGH);\n\n// enable RAK14001\npinMode(WB_IO6, OUTPUT);\ndigitalWrite(WB_IO6, HIGH);\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial) {\nif ((millis() - timeout) < 5000) {\ndelay(100);\n} else {\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA) {\nSerial.println(\"Type: OTAA\");\n} else {\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion) {\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA) {\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n} else {\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0) {\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"================================\");\nSerial.println(\"RAK12021 + RAK14001 LoRaWAN Code\");\nSerial.println(\"================================\");\n\n// If using Native I2C\nWire.begin();\nWire.setClock(100000);\n\n// Serial.println(\"RAK14001 + RAK12021\");\n\nif (!rgb.begin())\n{\nSerial.println(\"RAK14001 not found on the I2C line\");\nwhile (1);\n}\nelse\n{\nSerial.println(\"RAK14001 Found. Begining execution\");\n}\n\n// set the current output level max, the range is 1 to 31\nrgb.setCurrent(25);\n\nif(tcs3772.begin() == true)\n{\nSerial.println(\"Found sensor.\");\n}\nelse\n{\nSerial.println(\"TCS37725 not found ... check your connections.\");\nwhile(1)\n{\ndelay(10);\n}\n}\ndelay(1000);\n}\n\nvoid loop() {\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\ntcs3772_data = tcs3772.getMeasurement();\n\nscale_factor = tcs3772.autoGain(tcs3772_data.clear);\n\nredColor = tcs3772_data.red;\ngreenColor = tcs3772_data.green;\nblueColor = tcs3772_data.blue;\n\nrgb.setColor(0,0,0);     // Initially OFF\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\nSerial.print(\"  R: \");\nSerial.println(redColor);\nSerial.print(\"  G: \");\nSerial.println(greenColor);\nSerial.print(\"  B: \");\nSerial.println(blueColor);\n\n// The values of redColor, greenColor and blueColor can be varied during the sensing calibration of RAK12021 module\n\nif (((redColor >= 9000) && (redColor <= 65535)) && ((greenColor >= 10000) && (greenColor <= 65535)) && ((blueColor >= 12000) && (blueColor <= 65535)))\n{\nrgb.setColor(255,255,255); // WHITE\n}\n\nelse if (((redColor >= 4000) && (redColor <= 18000)) && ((greenColor >= 1300) && (greenColor <= 5000)) && ((blueColor >= 950) && (blueColor <= 2000)))\n{\nrgb.setColor(255,255,0);  // YELLOW\n}\n\nelse if (((redColor >= 600) && (redColor <= 2000)) && ((greenColor >= 1700) && (greenColor <= 10000)) && ((blueColor >= 6800) && (blueColor <= 27000)))\n{\nrgb.setColor(0,0,255);    // BLUE\n}\n\nelse if (((redColor >= 1400) && (redColor <= 4000)) && ((greenColor >= 1300) && (greenColor <= 10000)) && ((blueColor >= 950) && (blueColor <= 2700)))\n{\nrgb.setColor(0,255,0);    // GREEN\n}\n\nelse if (((redColor >= 3000) && (redColor <= 20000)) && ((greenColor >= 700) && (greenColor <= 2400)) && ((blueColor >= 950) && (blueColor <= 3000)))\n{\nrgb.setColor(255,0,0);    // RED\n}\n\nelse if ((redColor < 1500) && (greenColor < 1400) && (blueColor < 900))\n{\nrgb.setColor(0,0,0);  // OFF\n}\n\ndelay(5000);\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void) {\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void) {\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data) {\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class) {\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void) {\nif (lmh_join_status_get() != LMH_SET) {\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\n// Showing the values of red, green and blue colors from RAK12021\ndata = \" Red: \" + String(redColor) + \" Green: \" + String(greenColor) + \" Blue: \" + String(blueColor);\n\nSerial.println(data);\n\nuint16_t red_data = redColor;\nuint16_t green_data = greenColor;\nuint16_t blue_data = blueColor;\n\nm_lora_app_data.buffer[i++] = 0x01;  // byte[0]\n\n// Red data\nm_lora_app_data.buffer[i++] = (uint8_t)((red_data & 0x0000FF00) >> 8);     // byte[1]\nm_lora_app_data.buffer[i++] = (uint8_t)(red_data & 0x000000FF);            // byte[2]\n\n// Green data\nm_lora_app_data.buffer[i++] = (uint8_t)((green_data & 0x0000FF00) >> 8);   // byte[3]\nm_lora_app_data.buffer[i++] = (uint8_t)(green_data & 0x000000FF);          // byte[4]\n\n// Blue data\nm_lora_app_data.buffer[i++] = (uint8_t)((blue_data & 0x0000FF00) >> 8);    // byte[5]\nm_lora_app_data.buffer[i++] = (uint8_t)(blue_data & 0x000000FF);           // byte[6]\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS) {\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n} else {\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0x96, 0xBD, 0xC5, 0x98, 0x17, 0x69, 0x8D, 0xFA, 0x1F, 0x64, 0xFE, 0x1C, 0xF9, 0x26, 0x7F, 0x8D };\n```  \n> **Image:** OTAA device successfully registered to TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "d470fa2f94334175e0f3025e1d0cc883", "product_family": "wisblock", "product_id": "kit6-light-and-color", "category": "How-To", "title": "WisBlock IoT Education Kit - Light & Color Quick Start Guide > WisBlock IoT Education Kit - Light & Color Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock IoT Education Kit - Light & Color using TTN and Qubitro > Light Color Recognizer LoRaWAN Application > LoRaWAN Code for Light Color Recognizer > Programming the Light Color Recognizer Device with Arduino IDE [CODE]", "content": "// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);", "keywords": ["Arduino IDE", "RAK4631", "Light Color Recognizer", "LoRaWAN", "programming"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **Light Color Recognizer** device. Just copy the code below for **Light Color Recognizer LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the example </summary>  \n```c\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h>  //http://librarymanager/All#SX126x\n#include <Wire.h>\n#include <NCP5623.h>//http://librarymanager/All#NCP5623 By:RAKWireless\n#include \"TCS3772.h\"  // Click here to get the library: http://librarymanager/All#TCS37725\n// It use WB_IO2 to power up and is conflicting with INT1, so better use in SlotA/SlotC/SlotD.\n\nNCP5623 rgb;\nTCS3772 tcs3772;\nTCS3772_DataScaled tcs3772_data = {0};\n\nuint16_t scale_factor;\n\nuint16_t redColor;\nuint16_t greenColor;\nuint16_t blueColor;\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define RAK4631_BOARD true\n#else\n#define RAK4631_BOARD false\n#endif\n\nbool doOTAA = true;                                               // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                                       /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                                     /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5                               /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                                        /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;                           /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;                 /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                              /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = { LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF };\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = { BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler };\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0x96, 0xBD, 0xC5, 0x98, 0x17, 0x69, 0x8D, 0xFA, 0x1F, 0x64, 0xFE, 0x1C, 0xF9, 0x26, 0x7F, 0x8D };\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };\nuint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                                            /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];               //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = { m_lora_app_data_buffer, 0, 0, 0, 0 };  //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {\n\n// Initialize Serial for debug output\npinMode(LED_BLUE, OUTPUT);\ndigitalWrite(LED_BLUE, HIGH);\n\n// Sensor Power Switch\npinMode(WB_IO2, OUTPUT);\ndigitalWrite(WB_IO2, HIGH);\n\n// enable RAK14001\npinMode(WB_IO6, OUTPUT);\ndigitalWrite(WB_IO6, HIGH);\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial) {\nif ((millis() - timeout) < 5000) {\ndelay(100);\n} else {\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA) {\nSerial.println(\"Type: OTAA\");\n} else {\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion) {\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA) {\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n} else {\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0) {\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"================================\");\nSerial.println(\"RAK12021 + RAK14001 LoRaWAN Code\");\nSerial.println(\"================================\");\n\n// If using Native I2C\nWire.begin();\nWire.setClock(100000);\n\n// Serial.println(\"RAK14001 + RAK12021\");\n\nif (!rgb.begin())\n{\nSerial.println(\"RAK14001 not found on the I2C line\");\nwhile (1);\n}\nelse\n{\nSerial.println(\"RAK14001 Found. Begining execution\");\n}\n\n// set the current output level max, the range is 1 to 31\nrgb.setCurrent(25);\n\nif(tcs3772.begin() == true)\n{\nSerial.println(\"Found sensor.\");\n}\nelse\n{\nSerial.println(\"TCS37725 not found ... check your connections.\");\nwhile(1)\n{\ndelay(10);\n}\n}\ndelay(1000);\n}\n\nvoid loop() {\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\ntcs3772_data = tcs3772.getMeasurement();\n\nscale_factor = tcs3772.autoGain(tcs3772_data.clear);\n\nredColor = tcs3772_data.red;\ngreenColor = tcs3772_data.green;\nblueColor = tcs3772_data.blue;\n\nrgb.setColor(0,0,0);     // Initially OFF\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\nSerial.print(\"  R: \");\nSerial.println(redColor);\nSerial.print(\"  G: \");\nSerial.println(greenColor);\nSerial.print(\"  B: \");\nSerial.println(blueColor);\n\n// The values of redColor, greenColor and blueColor can be varied during the sensing calibration of RAK12021 module\n\nif (((redColor >= 9000) && (redColor <= 65535)) && ((greenColor >= 10000) && (greenColor <= 65535)) && ((blueColor >= 12000) && (blueColor <= 65535)))\n{\nrgb.setColor(255,255,255); // WHITE\n}\n\nelse if (((redColor >= 4000) && (redColor <= 18000)) && ((greenColor >= 1300) && (greenColor <= 5000)) && ((blueColor >= 950) && (blueColor <= 2000)))\n{\nrgb.setColor(255,255,0);  // YELLOW\n}\n\nelse if (((redColor >= 600) && (redColor <= 2000)) && ((greenColor >= 1700) && (greenColor <= 10000)) && ((blueColor >= 6800) && (blueColor <= 27000)))\n{\nrgb.setColor(0,0,255);    // BLUE\n}\n\nelse if (((redColor >= 1400) && (redColor <= 4000)) && ((greenColor >= 1300) && (greenColor <= 10000)) && ((blueColor >= 950) && (blueColor <= 2700)))\n{\nrgb.setColor(0,255,0);    // GREEN\n}\n\nelse if (((redColor >= 3000) && (redColor <= 20000)) && ((greenColor >= 700) && (greenColor <= 2400)) && ((blueColor >= 950) && (blueColor <= 3000)))\n{\nrgb.setColor(255,0,0);    // RED\n}\n\nelse if ((redColor < 1500) && (greenColor < 1400) && (blueColor < 900))\n{\nrgb.setColor(0,0,0);  // OFF\n}\n\ndelay(5000);\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void) {\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void) {\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data) {\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class) {\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void) {\nif (lmh_join_status_get() != LMH_SET) {\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\n// Showing the values of red, green and blue colors from RAK12021\ndata = \" Red: \" + String(redColor) + \" Green: \" + String(greenColor) + \" Blue: \" + String(blueColor);\n\nSerial.println(data);\n\nuint16_t red_data = redColor;\nuint16_t green_data = greenColor;\nuint16_t blue_data = blueColor;\n\nm_lora_app_data.buffer[i++] = 0x01;  // byte[0]\n\n// Red data\nm_lora_app_data.buffer[i++] = (uint8_t)((red_data & 0x0000FF00) >> 8);     // byte[1]\nm_lora_app_data.buffer[i++] = (uint8_t)(red_data & 0x000000FF);            // byte[2]\n\n// Green data\nm_lora_app_data.buffer[i++] = (uint8_t)((green_data & 0x0000FF00) >> 8);   // byte[3]\nm_lora_app_data.buffer[i++] = (uint8_t)(green_data & 0x000000FF);          // byte[4]\n\n// Blue data\nm_lora_app_data.buffer[i++] = (uint8_t)((blue_data & 0x0000FF00) >> 8);    // byte[5]\nm_lora_app_data.buffer[i++] = (uint8_t)(blue_data & 0x000000FF);           // byte[6]\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS) {\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n} else {\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0x96, 0xBD, 0xC5, 0x98, 0x17, 0x69, 0x8D, 0xFA, 0x1F, 0x64, 0xFE, 0x1C, 0xF9, 0x26, 0x7F, 0x8D };\n```  \n> **Image:** OTAA device successfully registered to TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "65cf834644cf3cf84b4d753194d7934b", "product_family": "wisblock", "product_id": "kit6-light-and-color", "category": "How-To", "title": "WisBlock IoT Education Kit - Light & Color Quick Start Guide > WisBlock IoT Education Kit - Light & Color Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock IoT Education Kit - Light & Color using TTN and Qubitro > Light Color Recognizer LoRaWAN Application > LoRaWAN Code for Light Color Recognizer > Programming the Light Color Recognizer Device with Arduino IDE [CODE]", "content": "/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = { BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler };\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };", "keywords": ["Arduino IDE", "RAK4631", "Light Color Recognizer", "LoRaWAN", "programming"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **Light Color Recognizer** device. Just copy the code below for **Light Color Recognizer LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the example </summary>  \n```c\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h>  //http://librarymanager/All#SX126x\n#include <Wire.h>\n#include <NCP5623.h>//http://librarymanager/All#NCP5623 By:RAKWireless\n#include \"TCS3772.h\"  // Click here to get the library: http://librarymanager/All#TCS37725\n// It use WB_IO2 to power up and is conflicting with INT1, so better use in SlotA/SlotC/SlotD.\n\nNCP5623 rgb;\nTCS3772 tcs3772;\nTCS3772_DataScaled tcs3772_data = {0};\n\nuint16_t scale_factor;\n\nuint16_t redColor;\nuint16_t greenColor;\nuint16_t blueColor;\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define RAK4631_BOARD true\n#else\n#define RAK4631_BOARD false\n#endif\n\nbool doOTAA = true;                                               // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                                       /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                                     /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5                               /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                                        /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;                           /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;                 /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                              /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = { LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF };\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = { BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler };\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0x96, 0xBD, 0xC5, 0x98, 0x17, 0x69, 0x8D, 0xFA, 0x1F, 0x64, 0xFE, 0x1C, 0xF9, 0x26, 0x7F, 0x8D };\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };\nuint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                                            /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];               //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = { m_lora_app_data_buffer, 0, 0, 0, 0 };  //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {\n\n// Initialize Serial for debug output\npinMode(LED_BLUE, OUTPUT);\ndigitalWrite(LED_BLUE, HIGH);\n\n// Sensor Power Switch\npinMode(WB_IO2, OUTPUT);\ndigitalWrite(WB_IO2, HIGH);\n\n// enable RAK14001\npinMode(WB_IO6, OUTPUT);\ndigitalWrite(WB_IO6, HIGH);\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial) {\nif ((millis() - timeout) < 5000) {\ndelay(100);\n} else {\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA) {\nSerial.println(\"Type: OTAA\");\n} else {\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion) {\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA) {\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n} else {\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0) {\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"================================\");\nSerial.println(\"RAK12021 + RAK14001 LoRaWAN Code\");\nSerial.println(\"================================\");\n\n// If using Native I2C\nWire.begin();\nWire.setClock(100000);\n\n// Serial.println(\"RAK14001 + RAK12021\");\n\nif (!rgb.begin())\n{\nSerial.println(\"RAK14001 not found on the I2C line\");\nwhile (1);\n}\nelse\n{\nSerial.println(\"RAK14001 Found. Begining execution\");\n}\n\n// set the current output level max, the range is 1 to 31\nrgb.setCurrent(25);\n\nif(tcs3772.begin() == true)\n{\nSerial.println(\"Found sensor.\");\n}\nelse\n{\nSerial.println(\"TCS37725 not found ... check your connections.\");\nwhile(1)\n{\ndelay(10);\n}\n}\ndelay(1000);\n}\n\nvoid loop() {\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\ntcs3772_data = tcs3772.getMeasurement();\n\nscale_factor = tcs3772.autoGain(tcs3772_data.clear);\n\nredColor = tcs3772_data.red;\ngreenColor = tcs3772_data.green;\nblueColor = tcs3772_data.blue;\n\nrgb.setColor(0,0,0);     // Initially OFF\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\nSerial.print(\"  R: \");\nSerial.println(redColor);\nSerial.print(\"  G: \");\nSerial.println(greenColor);\nSerial.print(\"  B: \");\nSerial.println(blueColor);\n\n// The values of redColor, greenColor and blueColor can be varied during the sensing calibration of RAK12021 module\n\nif (((redColor >= 9000) && (redColor <= 65535)) && ((greenColor >= 10000) && (greenColor <= 65535)) && ((blueColor >= 12000) && (blueColor <= 65535)))\n{\nrgb.setColor(255,255,255); // WHITE\n}\n\nelse if (((redColor >= 4000) && (redColor <= 18000)) && ((greenColor >= 1300) && (greenColor <= 5000)) && ((blueColor >= 950) && (blueColor <= 2000)))\n{\nrgb.setColor(255,255,0);  // YELLOW\n}\n\nelse if (((redColor >= 600) && (redColor <= 2000)) && ((greenColor >= 1700) && (greenColor <= 10000)) && ((blueColor >= 6800) && (blueColor <= 27000)))\n{\nrgb.setColor(0,0,255);    // BLUE\n}\n\nelse if (((redColor >= 1400) && (redColor <= 4000)) && ((greenColor >= 1300) && (greenColor <= 10000)) && ((blueColor >= 950) && (blueColor <= 2700)))\n{\nrgb.setColor(0,255,0);    // GREEN\n}\n\nelse if (((redColor >= 3000) && (redColor <= 20000)) && ((greenColor >= 700) && (greenColor <= 2400)) && ((blueColor >= 950) && (blueColor <= 3000)))\n{\nrgb.setColor(255,0,0);    // RED\n}\n\nelse if ((redColor < 1500) && (greenColor < 1400) && (blueColor < 900))\n{\nrgb.setColor(0,0,0);  // OFF\n}\n\ndelay(5000);\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void) {\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void) {\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data) {\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class) {\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void) {\nif (lmh_join_status_get() != LMH_SET) {\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\n// Showing the values of red, green and blue colors from RAK12021\ndata = \" Red: \" + String(redColor) + \" Green: \" + String(greenColor) + \" Blue: \" + String(blueColor);\n\nSerial.println(data);\n\nuint16_t red_data = redColor;\nuint16_t green_data = greenColor;\nuint16_t blue_data = blueColor;\n\nm_lora_app_data.buffer[i++] = 0x01;  // byte[0]\n\n// Red data\nm_lora_app_data.buffer[i++] = (uint8_t)((red_data & 0x0000FF00) >> 8);     // byte[1]\nm_lora_app_data.buffer[i++] = (uint8_t)(red_data & 0x000000FF);            // byte[2]\n\n// Green data\nm_lora_app_data.buffer[i++] = (uint8_t)((green_data & 0x0000FF00) >> 8);   // byte[3]\nm_lora_app_data.buffer[i++] = (uint8_t)(green_data & 0x000000FF);          // byte[4]\n\n// Blue data\nm_lora_app_data.buffer[i++] = (uint8_t)((blue_data & 0x0000FF00) >> 8);    // byte[5]\nm_lora_app_data.buffer[i++] = (uint8_t)(blue_data & 0x000000FF);           // byte[6]\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS) {\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n} else {\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0x96, 0xBD, 0xC5, 0x98, 0x17, 0x69, 0x8D, 0xFA, 0x1F, 0x64, 0xFE, 0x1C, 0xF9, 0x26, 0x7F, 0x8D };\n```  \n> **Image:** OTAA device successfully registered to TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "cbdddcd195aefcc98f78206e79cbb8d9", "product_family": "wisblock", "product_id": "kit6-light-and-color", "category": "How-To", "title": "WisBlock IoT Education Kit - Light & Color Quick Start Guide > WisBlock IoT Education Kit - Light & Color Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock IoT Education Kit - Light & Color using TTN and Qubitro > Light Color Recognizer LoRaWAN Application > LoRaWAN Code for Light Color Recognizer > Programming the Light Color Recognizer Device with Arduino IDE [CODE]", "content": "uint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0x96, 0xBD, 0xC5, 0x98, 0x17, 0x69, 0x8D, 0xFA, 0x1F, 0x64, 0xFE, 0x1C, 0xF9, 0x26, 0x7F, 0x8D };", "keywords": ["Arduino IDE", "RAK4631", "Light Color Recognizer", "LoRaWAN", "programming"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **Light Color Recognizer** device. Just copy the code below for **Light Color Recognizer LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the example </summary>  \n```c\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h>  //http://librarymanager/All#SX126x\n#include <Wire.h>\n#include <NCP5623.h>//http://librarymanager/All#NCP5623 By:RAKWireless\n#include \"TCS3772.h\"  // Click here to get the library: http://librarymanager/All#TCS37725\n// It use WB_IO2 to power up and is conflicting with INT1, so better use in SlotA/SlotC/SlotD.\n\nNCP5623 rgb;\nTCS3772 tcs3772;\nTCS3772_DataScaled tcs3772_data = {0};\n\nuint16_t scale_factor;\n\nuint16_t redColor;\nuint16_t greenColor;\nuint16_t blueColor;\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define RAK4631_BOARD true\n#else\n#define RAK4631_BOARD false\n#endif\n\nbool doOTAA = true;                                               // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                                       /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                                     /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5                               /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                                        /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;                           /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;                 /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                              /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = { LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF };\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = { BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler };\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0x96, 0xBD, 0xC5, 0x98, 0x17, 0x69, 0x8D, 0xFA, 0x1F, 0x64, 0xFE, 0x1C, 0xF9, 0x26, 0x7F, 0x8D };\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };\nuint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                                            /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];               //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = { m_lora_app_data_buffer, 0, 0, 0, 0 };  //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {\n\n// Initialize Serial for debug output\npinMode(LED_BLUE, OUTPUT);\ndigitalWrite(LED_BLUE, HIGH);\n\n// Sensor Power Switch\npinMode(WB_IO2, OUTPUT);\ndigitalWrite(WB_IO2, HIGH);\n\n// enable RAK14001\npinMode(WB_IO6, OUTPUT);\ndigitalWrite(WB_IO6, HIGH);\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial) {\nif ((millis() - timeout) < 5000) {\ndelay(100);\n} else {\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA) {\nSerial.println(\"Type: OTAA\");\n} else {\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion) {\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA) {\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n} else {\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0) {\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"================================\");\nSerial.println(\"RAK12021 + RAK14001 LoRaWAN Code\");\nSerial.println(\"================================\");\n\n// If using Native I2C\nWire.begin();\nWire.setClock(100000);\n\n// Serial.println(\"RAK14001 + RAK12021\");\n\nif (!rgb.begin())\n{\nSerial.println(\"RAK14001 not found on the I2C line\");\nwhile (1);\n}\nelse\n{\nSerial.println(\"RAK14001 Found. Begining execution\");\n}\n\n// set the current output level max, the range is 1 to 31\nrgb.setCurrent(25);\n\nif(tcs3772.begin() == true)\n{\nSerial.println(\"Found sensor.\");\n}\nelse\n{\nSerial.println(\"TCS37725 not found ... check your connections.\");\nwhile(1)\n{\ndelay(10);\n}\n}\ndelay(1000);\n}\n\nvoid loop() {\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\ntcs3772_data = tcs3772.getMeasurement();\n\nscale_factor = tcs3772.autoGain(tcs3772_data.clear);\n\nredColor = tcs3772_data.red;\ngreenColor = tcs3772_data.green;\nblueColor = tcs3772_data.blue;\n\nrgb.setColor(0,0,0);     // Initially OFF\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\nSerial.print(\"  R: \");\nSerial.println(redColor);\nSerial.print(\"  G: \");\nSerial.println(greenColor);\nSerial.print(\"  B: \");\nSerial.println(blueColor);\n\n// The values of redColor, greenColor and blueColor can be varied during the sensing calibration of RAK12021 module\n\nif (((redColor >= 9000) && (redColor <= 65535)) && ((greenColor >= 10000) && (greenColor <= 65535)) && ((blueColor >= 12000) && (blueColor <= 65535)))\n{\nrgb.setColor(255,255,255); // WHITE\n}\n\nelse if (((redColor >= 4000) && (redColor <= 18000)) && ((greenColor >= 1300) && (greenColor <= 5000)) && ((blueColor >= 950) && (blueColor <= 2000)))\n{\nrgb.setColor(255,255,0);  // YELLOW\n}\n\nelse if (((redColor >= 600) && (redColor <= 2000)) && ((greenColor >= 1700) && (greenColor <= 10000)) && ((blueColor >= 6800) && (blueColor <= 27000)))\n{\nrgb.setColor(0,0,255);    // BLUE\n}\n\nelse if (((redColor >= 1400) && (redColor <= 4000)) && ((greenColor >= 1300) && (greenColor <= 10000)) && ((blueColor >= 950) && (blueColor <= 2700)))\n{\nrgb.setColor(0,255,0);    // GREEN\n}\n\nelse if (((redColor >= 3000) && (redColor <= 20000)) && ((greenColor >= 700) && (greenColor <= 2400)) && ((blueColor >= 950) && (blueColor <= 3000)))\n{\nrgb.setColor(255,0,0);    // RED\n}\n\nelse if ((redColor < 1500) && (greenColor < 1400) && (blueColor < 900))\n{\nrgb.setColor(0,0,0);  // OFF\n}\n\ndelay(5000);\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void) {\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void) {\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data) {\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class) {\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void) {\nif (lmh_join_status_get() != LMH_SET) {\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\n// Showing the values of red, green and blue colors from RAK12021\ndata = \" Red: \" + String(redColor) + \" Green: \" + String(greenColor) + \" Blue: \" + String(blueColor);\n\nSerial.println(data);\n\nuint16_t red_data = redColor;\nuint16_t green_data = greenColor;\nuint16_t blue_data = blueColor;\n\nm_lora_app_data.buffer[i++] = 0x01;  // byte[0]\n\n// Red data\nm_lora_app_data.buffer[i++] = (uint8_t)((red_data & 0x0000FF00) >> 8);     // byte[1]\nm_lora_app_data.buffer[i++] = (uint8_t)(red_data & 0x000000FF);            // byte[2]\n\n// Green data\nm_lora_app_data.buffer[i++] = (uint8_t)((green_data & 0x0000FF00) >> 8);   // byte[3]\nm_lora_app_data.buffer[i++] = (uint8_t)(green_data & 0x000000FF);          // byte[4]\n\n// Blue data\nm_lora_app_data.buffer[i++] = (uint8_t)((blue_data & 0x0000FF00) >> 8);    // byte[5]\nm_lora_app_data.buffer[i++] = (uint8_t)(blue_data & 0x000000FF);           // byte[6]\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS) {\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n} else {\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0x96, 0xBD, 0xC5, 0x98, 0x17, 0x69, 0x8D, 0xFA, 0x1F, 0x64, 0xFE, 0x1C, 0xF9, 0x26, 0x7F, 0x8D };\n```  \n> **Image:** OTAA device successfully registered to TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "2b8cadcb2741b14a970286bd43b9e82b", "product_family": "wisblock", "product_id": "kit6-light-and-color", "category": "How-To", "title": "WisBlock IoT Education Kit - Light & Color Quick Start Guide > WisBlock IoT Education Kit - Light & Color Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock IoT Education Kit - Light & Color using TTN and Qubitro > Light Color Recognizer LoRaWAN Application > LoRaWAN Code for Light Color Recognizer > Programming the Light Color Recognizer Device with Arduino IDE [CODE]", "content": "// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };\nuint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };", "keywords": ["Arduino IDE", "RAK4631", "Light Color Recognizer", "LoRaWAN", "programming"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **Light Color Recognizer** device. Just copy the code below for **Light Color Recognizer LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the example </summary>  \n```c\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h>  //http://librarymanager/All#SX126x\n#include <Wire.h>\n#include <NCP5623.h>//http://librarymanager/All#NCP5623 By:RAKWireless\n#include \"TCS3772.h\"  // Click here to get the library: http://librarymanager/All#TCS37725\n// It use WB_IO2 to power up and is conflicting with INT1, so better use in SlotA/SlotC/SlotD.\n\nNCP5623 rgb;\nTCS3772 tcs3772;\nTCS3772_DataScaled tcs3772_data = {0};\n\nuint16_t scale_factor;\n\nuint16_t redColor;\nuint16_t greenColor;\nuint16_t blueColor;\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define RAK4631_BOARD true\n#else\n#define RAK4631_BOARD false\n#endif\n\nbool doOTAA = true;                                               // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                                       /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                                     /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5                               /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                                        /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;                           /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;                 /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                              /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = { LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF };\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = { BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler };\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0x96, 0xBD, 0xC5, 0x98, 0x17, 0x69, 0x8D, 0xFA, 0x1F, 0x64, 0xFE, 0x1C, 0xF9, 0x26, 0x7F, 0x8D };\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };\nuint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                                            /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];               //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = { m_lora_app_data_buffer, 0, 0, 0, 0 };  //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {\n\n// Initialize Serial for debug output\npinMode(LED_BLUE, OUTPUT);\ndigitalWrite(LED_BLUE, HIGH);\n\n// Sensor Power Switch\npinMode(WB_IO2, OUTPUT);\ndigitalWrite(WB_IO2, HIGH);\n\n// enable RAK14001\npinMode(WB_IO6, OUTPUT);\ndigitalWrite(WB_IO6, HIGH);\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial) {\nif ((millis() - timeout) < 5000) {\ndelay(100);\n} else {\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA) {\nSerial.println(\"Type: OTAA\");\n} else {\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion) {\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA) {\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n} else {\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0) {\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"================================\");\nSerial.println(\"RAK12021 + RAK14001 LoRaWAN Code\");\nSerial.println(\"================================\");\n\n// If using Native I2C\nWire.begin();\nWire.setClock(100000);\n\n// Serial.println(\"RAK14001 + RAK12021\");\n\nif (!rgb.begin())\n{\nSerial.println(\"RAK14001 not found on the I2C line\");\nwhile (1);\n}\nelse\n{\nSerial.println(\"RAK14001 Found. Begining execution\");\n}\n\n// set the current output level max, the range is 1 to 31\nrgb.setCurrent(25);\n\nif(tcs3772.begin() == true)\n{\nSerial.println(\"Found sensor.\");\n}\nelse\n{\nSerial.println(\"TCS37725 not found ... check your connections.\");\nwhile(1)\n{\ndelay(10);\n}\n}\ndelay(1000);\n}\n\nvoid loop() {\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\ntcs3772_data = tcs3772.getMeasurement();\n\nscale_factor = tcs3772.autoGain(tcs3772_data.clear);\n\nredColor = tcs3772_data.red;\ngreenColor = tcs3772_data.green;\nblueColor = tcs3772_data.blue;\n\nrgb.setColor(0,0,0);     // Initially OFF\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\nSerial.print(\"  R: \");\nSerial.println(redColor);\nSerial.print(\"  G: \");\nSerial.println(greenColor);\nSerial.print(\"  B: \");\nSerial.println(blueColor);\n\n// The values of redColor, greenColor and blueColor can be varied during the sensing calibration of RAK12021 module\n\nif (((redColor >= 9000) && (redColor <= 65535)) && ((greenColor >= 10000) && (greenColor <= 65535)) && ((blueColor >= 12000) && (blueColor <= 65535)))\n{\nrgb.setColor(255,255,255); // WHITE\n}\n\nelse if (((redColor >= 4000) && (redColor <= 18000)) && ((greenColor >= 1300) && (greenColor <= 5000)) && ((blueColor >= 950) && (blueColor <= 2000)))\n{\nrgb.setColor(255,255,0);  // YELLOW\n}\n\nelse if (((redColor >= 600) && (redColor <= 2000)) && ((greenColor >= 1700) && (greenColor <= 10000)) && ((blueColor >= 6800) && (blueColor <= 27000)))\n{\nrgb.setColor(0,0,255);    // BLUE\n}\n\nelse if (((redColor >= 1400) && (redColor <= 4000)) && ((greenColor >= 1300) && (greenColor <= 10000)) && ((blueColor >= 950) && (blueColor <= 2700)))\n{\nrgb.setColor(0,255,0);    // GREEN\n}\n\nelse if (((redColor >= 3000) && (redColor <= 20000)) && ((greenColor >= 700) && (greenColor <= 2400)) && ((blueColor >= 950) && (blueColor <= 3000)))\n{\nrgb.setColor(255,0,0);    // RED\n}\n\nelse if ((redColor < 1500) && (greenColor < 1400) && (blueColor < 900))\n{\nrgb.setColor(0,0,0);  // OFF\n}\n\ndelay(5000);\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void) {\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void) {\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data) {\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class) {\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void) {\nif (lmh_join_status_get() != LMH_SET) {\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\n// Showing the values of red, green and blue colors from RAK12021\ndata = \" Red: \" + String(redColor) + \" Green: \" + String(greenColor) + \" Blue: \" + String(blueColor);\n\nSerial.println(data);\n\nuint16_t red_data = redColor;\nuint16_t green_data = greenColor;\nuint16_t blue_data = blueColor;\n\nm_lora_app_data.buffer[i++] = 0x01;  // byte[0]\n\n// Red data\nm_lora_app_data.buffer[i++] = (uint8_t)((red_data & 0x0000FF00) >> 8);     // byte[1]\nm_lora_app_data.buffer[i++] = (uint8_t)(red_data & 0x000000FF);            // byte[2]\n\n// Green data\nm_lora_app_data.buffer[i++] = (uint8_t)((green_data & 0x0000FF00) >> 8);   // byte[3]\nm_lora_app_data.buffer[i++] = (uint8_t)(green_data & 0x000000FF);          // byte[4]\n\n// Blue data\nm_lora_app_data.buffer[i++] = (uint8_t)((blue_data & 0x0000FF00) >> 8);    // byte[5]\nm_lora_app_data.buffer[i++] = (uint8_t)(blue_data & 0x000000FF);           // byte[6]\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS) {\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n} else {\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0x96, 0xBD, 0xC5, 0x98, 0x17, 0x69, 0x8D, 0xFA, 0x1F, 0x64, 0xFE, 0x1C, 0xF9, 0x26, 0x7F, 0x8D };\n```  \n> **Image:** OTAA device successfully registered to TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "5f17cb1d75dac377451adc1e9500ae46", "product_family": "wisblock", "product_id": "kit6-light-and-color", "category": "How-To", "title": "WisBlock IoT Education Kit - Light & Color Quick Start Guide > WisBlock IoT Education Kit - Light & Color Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock IoT Education Kit - Light & Color using TTN and Qubitro > Light Color Recognizer LoRaWAN Application > LoRaWAN Code for Light Color Recognizer > Programming the Light Color Recognizer Device with Arduino IDE [CODE]", "content": "// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                                            /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];               //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = { m_lora_app_data_buffer, 0, 0, 0, 0 };  //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {", "keywords": ["Arduino IDE", "RAK4631", "Light Color Recognizer", "LoRaWAN", "programming"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **Light Color Recognizer** device. Just copy the code below for **Light Color Recognizer LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the example </summary>  \n```c\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h>  //http://librarymanager/All#SX126x\n#include <Wire.h>\n#include <NCP5623.h>//http://librarymanager/All#NCP5623 By:RAKWireless\n#include \"TCS3772.h\"  // Click here to get the library: http://librarymanager/All#TCS37725\n// It use WB_IO2 to power up and is conflicting with INT1, so better use in SlotA/SlotC/SlotD.\n\nNCP5623 rgb;\nTCS3772 tcs3772;\nTCS3772_DataScaled tcs3772_data = {0};\n\nuint16_t scale_factor;\n\nuint16_t redColor;\nuint16_t greenColor;\nuint16_t blueColor;\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define RAK4631_BOARD true\n#else\n#define RAK4631_BOARD false\n#endif\n\nbool doOTAA = true;                                               // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                                       /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                                     /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5                               /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                                        /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;                           /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;                 /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                              /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = { LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF };\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = { BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler };\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0x96, 0xBD, 0xC5, 0x98, 0x17, 0x69, 0x8D, 0xFA, 0x1F, 0x64, 0xFE, 0x1C, 0xF9, 0x26, 0x7F, 0x8D };\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };\nuint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                                            /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];               //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = { m_lora_app_data_buffer, 0, 0, 0, 0 };  //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {\n\n// Initialize Serial for debug output\npinMode(LED_BLUE, OUTPUT);\ndigitalWrite(LED_BLUE, HIGH);\n\n// Sensor Power Switch\npinMode(WB_IO2, OUTPUT);\ndigitalWrite(WB_IO2, HIGH);\n\n// enable RAK14001\npinMode(WB_IO6, OUTPUT);\ndigitalWrite(WB_IO6, HIGH);\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial) {\nif ((millis() - timeout) < 5000) {\ndelay(100);\n} else {\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA) {\nSerial.println(\"Type: OTAA\");\n} else {\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion) {\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA) {\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n} else {\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0) {\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"================================\");\nSerial.println(\"RAK12021 + RAK14001 LoRaWAN Code\");\nSerial.println(\"================================\");\n\n// If using Native I2C\nWire.begin();\nWire.setClock(100000);\n\n// Serial.println(\"RAK14001 + RAK12021\");\n\nif (!rgb.begin())\n{\nSerial.println(\"RAK14001 not found on the I2C line\");\nwhile (1);\n}\nelse\n{\nSerial.println(\"RAK14001 Found. Begining execution\");\n}\n\n// set the current output level max, the range is 1 to 31\nrgb.setCurrent(25);\n\nif(tcs3772.begin() == true)\n{\nSerial.println(\"Found sensor.\");\n}\nelse\n{\nSerial.println(\"TCS37725 not found ... check your connections.\");\nwhile(1)\n{\ndelay(10);\n}\n}\ndelay(1000);\n}\n\nvoid loop() {\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\ntcs3772_data = tcs3772.getMeasurement();\n\nscale_factor = tcs3772.autoGain(tcs3772_data.clear);\n\nredColor = tcs3772_data.red;\ngreenColor = tcs3772_data.green;\nblueColor = tcs3772_data.blue;\n\nrgb.setColor(0,0,0);     // Initially OFF\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\nSerial.print(\"  R: \");\nSerial.println(redColor);\nSerial.print(\"  G: \");\nSerial.println(greenColor);\nSerial.print(\"  B: \");\nSerial.println(blueColor);\n\n// The values of redColor, greenColor and blueColor can be varied during the sensing calibration of RAK12021 module\n\nif (((redColor >= 9000) && (redColor <= 65535)) && ((greenColor >= 10000) && (greenColor <= 65535)) && ((blueColor >= 12000) && (blueColor <= 65535)))\n{\nrgb.setColor(255,255,255); // WHITE\n}\n\nelse if (((redColor >= 4000) && (redColor <= 18000)) && ((greenColor >= 1300) && (greenColor <= 5000)) && ((blueColor >= 950) && (blueColor <= 2000)))\n{\nrgb.setColor(255,255,0);  // YELLOW\n}\n\nelse if (((redColor >= 600) && (redColor <= 2000)) && ((greenColor >= 1700) && (greenColor <= 10000)) && ((blueColor >= 6800) && (blueColor <= 27000)))\n{\nrgb.setColor(0,0,255);    // BLUE\n}\n\nelse if (((redColor >= 1400) && (redColor <= 4000)) && ((greenColor >= 1300) && (greenColor <= 10000)) && ((blueColor >= 950) && (blueColor <= 2700)))\n{\nrgb.setColor(0,255,0);    // GREEN\n}\n\nelse if (((redColor >= 3000) && (redColor <= 20000)) && ((greenColor >= 700) && (greenColor <= 2400)) && ((blueColor >= 950) && (blueColor <= 3000)))\n{\nrgb.setColor(255,0,0);    // RED\n}\n\nelse if ((redColor < 1500) && (greenColor < 1400) && (blueColor < 900))\n{\nrgb.setColor(0,0,0);  // OFF\n}\n\ndelay(5000);\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void) {\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void) {\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data) {\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class) {\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void) {\nif (lmh_join_status_get() != LMH_SET) {\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\n// Showing the values of red, green and blue colors from RAK12021\ndata = \" Red: \" + String(redColor) + \" Green: \" + String(greenColor) + \" Blue: \" + String(blueColor);\n\nSerial.println(data);\n\nuint16_t red_data = redColor;\nuint16_t green_data = greenColor;\nuint16_t blue_data = blueColor;\n\nm_lora_app_data.buffer[i++] = 0x01;  // byte[0]\n\n// Red data\nm_lora_app_data.buffer[i++] = (uint8_t)((red_data & 0x0000FF00) >> 8);     // byte[1]\nm_lora_app_data.buffer[i++] = (uint8_t)(red_data & 0x000000FF);            // byte[2]\n\n// Green data\nm_lora_app_data.buffer[i++] = (uint8_t)((green_data & 0x0000FF00) >> 8);   // byte[3]\nm_lora_app_data.buffer[i++] = (uint8_t)(green_data & 0x000000FF);          // byte[4]\n\n// Blue data\nm_lora_app_data.buffer[i++] = (uint8_t)((blue_data & 0x0000FF00) >> 8);    // byte[5]\nm_lora_app_data.buffer[i++] = (uint8_t)(blue_data & 0x000000FF);           // byte[6]\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS) {\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n} else {\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0x96, 0xBD, 0xC5, 0x98, 0x17, 0x69, 0x8D, 0xFA, 0x1F, 0x64, 0xFE, 0x1C, 0xF9, 0x26, 0x7F, 0x8D };\n```  \n> **Image:** OTAA device successfully registered to TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "331c88610c8ff5b598e585f12c17a09e", "product_family": "wisblock", "product_id": "kit6-light-and-color", "category": "How-To", "title": "WisBlock IoT Education Kit - Light & Color Quick Start Guide > WisBlock IoT Education Kit - Light & Color Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock IoT Education Kit - Light & Color using TTN and Qubitro > Light Color Recognizer LoRaWAN Application > LoRaWAN Code for Light Color Recognizer > Programming the Light Color Recognizer Device with Arduino IDE [CODE]", "content": "static uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {\n\n// Initialize Serial for debug output\npinMode(LED_BLUE, OUTPUT);\ndigitalWrite(LED_BLUE, HIGH);\n\n// Sensor Power Switch\npinMode(WB_IO2, OUTPUT);\ndigitalWrite(WB_IO2, HIGH);\n\n// enable RAK14001\npinMode(WB_IO6, OUTPUT);\ndigitalWrite(WB_IO6, HIGH);\n\n// Initialize LoRa chip.\nlora_rak4630_init();", "keywords": ["Arduino IDE", "RAK4631", "Light Color Recognizer", "LoRaWAN", "programming"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **Light Color Recognizer** device. Just copy the code below for **Light Color Recognizer LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the example </summary>  \n```c\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h>  //http://librarymanager/All#SX126x\n#include <Wire.h>\n#include <NCP5623.h>//http://librarymanager/All#NCP5623 By:RAKWireless\n#include \"TCS3772.h\"  // Click here to get the library: http://librarymanager/All#TCS37725\n// It use WB_IO2 to power up and is conflicting with INT1, so better use in SlotA/SlotC/SlotD.\n\nNCP5623 rgb;\nTCS3772 tcs3772;\nTCS3772_DataScaled tcs3772_data = {0};\n\nuint16_t scale_factor;\n\nuint16_t redColor;\nuint16_t greenColor;\nuint16_t blueColor;\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define RAK4631_BOARD true\n#else\n#define RAK4631_BOARD false\n#endif\n\nbool doOTAA = true;                                               // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                                       /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                                     /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5                               /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                                        /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;                           /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;                 /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                              /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = { LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF };\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = { BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler };\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0x96, 0xBD, 0xC5, 0x98, 0x17, 0x69, 0x8D, 0xFA, 0x1F, 0x64, 0xFE, 0x1C, 0xF9, 0x26, 0x7F, 0x8D };\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };\nuint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                                            /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];               //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = { m_lora_app_data_buffer, 0, 0, 0, 0 };  //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {\n\n// Initialize Serial for debug output\npinMode(LED_BLUE, OUTPUT);\ndigitalWrite(LED_BLUE, HIGH);\n\n// Sensor Power Switch\npinMode(WB_IO2, OUTPUT);\ndigitalWrite(WB_IO2, HIGH);\n\n// enable RAK14001\npinMode(WB_IO6, OUTPUT);\ndigitalWrite(WB_IO6, HIGH);\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial) {\nif ((millis() - timeout) < 5000) {\ndelay(100);\n} else {\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA) {\nSerial.println(\"Type: OTAA\");\n} else {\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion) {\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA) {\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n} else {\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0) {\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"================================\");\nSerial.println(\"RAK12021 + RAK14001 LoRaWAN Code\");\nSerial.println(\"================================\");\n\n// If using Native I2C\nWire.begin();\nWire.setClock(100000);\n\n// Serial.println(\"RAK14001 + RAK12021\");\n\nif (!rgb.begin())\n{\nSerial.println(\"RAK14001 not found on the I2C line\");\nwhile (1);\n}\nelse\n{\nSerial.println(\"RAK14001 Found. Begining execution\");\n}\n\n// set the current output level max, the range is 1 to 31\nrgb.setCurrent(25);\n\nif(tcs3772.begin() == true)\n{\nSerial.println(\"Found sensor.\");\n}\nelse\n{\nSerial.println(\"TCS37725 not found ... check your connections.\");\nwhile(1)\n{\ndelay(10);\n}\n}\ndelay(1000);\n}\n\nvoid loop() {\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\ntcs3772_data = tcs3772.getMeasurement();\n\nscale_factor = tcs3772.autoGain(tcs3772_data.clear);\n\nredColor = tcs3772_data.red;\ngreenColor = tcs3772_data.green;\nblueColor = tcs3772_data.blue;\n\nrgb.setColor(0,0,0);     // Initially OFF\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\nSerial.print(\"  R: \");\nSerial.println(redColor);\nSerial.print(\"  G: \");\nSerial.println(greenColor);\nSerial.print(\"  B: \");\nSerial.println(blueColor);\n\n// The values of redColor, greenColor and blueColor can be varied during the sensing calibration of RAK12021 module\n\nif (((redColor >= 9000) && (redColor <= 65535)) && ((greenColor >= 10000) && (greenColor <= 65535)) && ((blueColor >= 12000) && (blueColor <= 65535)))\n{\nrgb.setColor(255,255,255); // WHITE\n}\n\nelse if (((redColor >= 4000) && (redColor <= 18000)) && ((greenColor >= 1300) && (greenColor <= 5000)) && ((blueColor >= 950) && (blueColor <= 2000)))\n{\nrgb.setColor(255,255,0);  // YELLOW\n}\n\nelse if (((redColor >= 600) && (redColor <= 2000)) && ((greenColor >= 1700) && (greenColor <= 10000)) && ((blueColor >= 6800) && (blueColor <= 27000)))\n{\nrgb.setColor(0,0,255);    // BLUE\n}\n\nelse if (((redColor >= 1400) && (redColor <= 4000)) && ((greenColor >= 1300) && (greenColor <= 10000)) && ((blueColor >= 950) && (blueColor <= 2700)))\n{\nrgb.setColor(0,255,0);    // GREEN\n}\n\nelse if (((redColor >= 3000) && (redColor <= 20000)) && ((greenColor >= 700) && (greenColor <= 2400)) && ((blueColor >= 950) && (blueColor <= 3000)))\n{\nrgb.setColor(255,0,0);    // RED\n}\n\nelse if ((redColor < 1500) && (greenColor < 1400) && (blueColor < 900))\n{\nrgb.setColor(0,0,0);  // OFF\n}\n\ndelay(5000);\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void) {\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void) {\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data) {\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class) {\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void) {\nif (lmh_join_status_get() != LMH_SET) {\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\n// Showing the values of red, green and blue colors from RAK12021\ndata = \" Red: \" + String(redColor) + \" Green: \" + String(greenColor) + \" Blue: \" + String(blueColor);\n\nSerial.println(data);\n\nuint16_t red_data = redColor;\nuint16_t green_data = greenColor;\nuint16_t blue_data = blueColor;\n\nm_lora_app_data.buffer[i++] = 0x01;  // byte[0]\n\n// Red data\nm_lora_app_data.buffer[i++] = (uint8_t)((red_data & 0x0000FF00) >> 8);     // byte[1]\nm_lora_app_data.buffer[i++] = (uint8_t)(red_data & 0x000000FF);            // byte[2]\n\n// Green data\nm_lora_app_data.buffer[i++] = (uint8_t)((green_data & 0x0000FF00) >> 8);   // byte[3]\nm_lora_app_data.buffer[i++] = (uint8_t)(green_data & 0x000000FF);          // byte[4]\n\n// Blue data\nm_lora_app_data.buffer[i++] = (uint8_t)((blue_data & 0x0000FF00) >> 8);    // byte[5]\nm_lora_app_data.buffer[i++] = (uint8_t)(blue_data & 0x000000FF);           // byte[6]\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS) {\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n} else {\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0x96, 0xBD, 0xC5, 0x98, 0x17, 0x69, 0x8D, 0xFA, 0x1F, 0x64, 0xFE, 0x1C, 0xF9, 0x26, 0x7F, 0x8D };\n```  \n> **Image:** OTAA device successfully registered to TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "0c64e2fa11016d4d96bd02ab44d2da07", "product_family": "wisblock", "product_id": "kit6-light-and-color", "category": "How-To", "title": "WisBlock IoT Education Kit - Light & Color Quick Start Guide > WisBlock IoT Education Kit - Light & Color Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock IoT Education Kit - Light & Color using TTN and Qubitro > Light Color Recognizer LoRaWAN Application > LoRaWAN Code for Light Color Recognizer > Programming the Light Color Recognizer Device with Arduino IDE [CODE]", "content": "// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial) {\nif ((millis() - timeout) < 5000) {\ndelay(100);\n} else {\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA) {\nSerial.println(\"Type: OTAA\");\n} else {\nSerial.println(\"Type: ABP\");\n}", "keywords": ["Arduino IDE", "RAK4631", "Light Color Recognizer", "LoRaWAN", "programming"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **Light Color Recognizer** device. Just copy the code below for **Light Color Recognizer LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the example </summary>  \n```c\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h>  //http://librarymanager/All#SX126x\n#include <Wire.h>\n#include <NCP5623.h>//http://librarymanager/All#NCP5623 By:RAKWireless\n#include \"TCS3772.h\"  // Click here to get the library: http://librarymanager/All#TCS37725\n// It use WB_IO2 to power up and is conflicting with INT1, so better use in SlotA/SlotC/SlotD.\n\nNCP5623 rgb;\nTCS3772 tcs3772;\nTCS3772_DataScaled tcs3772_data = {0};\n\nuint16_t scale_factor;\n\nuint16_t redColor;\nuint16_t greenColor;\nuint16_t blueColor;\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define RAK4631_BOARD true\n#else\n#define RAK4631_BOARD false\n#endif\n\nbool doOTAA = true;                                               // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                                       /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                                     /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5                               /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                                        /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;                           /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;                 /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                              /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = { LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF };\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = { BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler };\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0x96, 0xBD, 0xC5, 0x98, 0x17, 0x69, 0x8D, 0xFA, 0x1F, 0x64, 0xFE, 0x1C, 0xF9, 0x26, 0x7F, 0x8D };\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };\nuint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                                            /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];               //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = { m_lora_app_data_buffer, 0, 0, 0, 0 };  //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {\n\n// Initialize Serial for debug output\npinMode(LED_BLUE, OUTPUT);\ndigitalWrite(LED_BLUE, HIGH);\n\n// Sensor Power Switch\npinMode(WB_IO2, OUTPUT);\ndigitalWrite(WB_IO2, HIGH);\n\n// enable RAK14001\npinMode(WB_IO6, OUTPUT);\ndigitalWrite(WB_IO6, HIGH);\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial) {\nif ((millis() - timeout) < 5000) {\ndelay(100);\n} else {\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA) {\nSerial.println(\"Type: OTAA\");\n} else {\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion) {\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA) {\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n} else {\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0) {\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"================================\");\nSerial.println(\"RAK12021 + RAK14001 LoRaWAN Code\");\nSerial.println(\"================================\");\n\n// If using Native I2C\nWire.begin();\nWire.setClock(100000);\n\n// Serial.println(\"RAK14001 + RAK12021\");\n\nif (!rgb.begin())\n{\nSerial.println(\"RAK14001 not found on the I2C line\");\nwhile (1);\n}\nelse\n{\nSerial.println(\"RAK14001 Found. Begining execution\");\n}\n\n// set the current output level max, the range is 1 to 31\nrgb.setCurrent(25);\n\nif(tcs3772.begin() == true)\n{\nSerial.println(\"Found sensor.\");\n}\nelse\n{\nSerial.println(\"TCS37725 not found ... check your connections.\");\nwhile(1)\n{\ndelay(10);\n}\n}\ndelay(1000);\n}\n\nvoid loop() {\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\ntcs3772_data = tcs3772.getMeasurement();\n\nscale_factor = tcs3772.autoGain(tcs3772_data.clear);\n\nredColor = tcs3772_data.red;\ngreenColor = tcs3772_data.green;\nblueColor = tcs3772_data.blue;\n\nrgb.setColor(0,0,0);     // Initially OFF\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\nSerial.print(\"  R: \");\nSerial.println(redColor);\nSerial.print(\"  G: \");\nSerial.println(greenColor);\nSerial.print(\"  B: \");\nSerial.println(blueColor);\n\n// The values of redColor, greenColor and blueColor can be varied during the sensing calibration of RAK12021 module\n\nif (((redColor >= 9000) && (redColor <= 65535)) && ((greenColor >= 10000) && (greenColor <= 65535)) && ((blueColor >= 12000) && (blueColor <= 65535)))\n{\nrgb.setColor(255,255,255); // WHITE\n}\n\nelse if (((redColor >= 4000) && (redColor <= 18000)) && ((greenColor >= 1300) && (greenColor <= 5000)) && ((blueColor >= 950) && (blueColor <= 2000)))\n{\nrgb.setColor(255,255,0);  // YELLOW\n}\n\nelse if (((redColor >= 600) && (redColor <= 2000)) && ((greenColor >= 1700) && (greenColor <= 10000)) && ((blueColor >= 6800) && (blueColor <= 27000)))\n{\nrgb.setColor(0,0,255);    // BLUE\n}\n\nelse if (((redColor >= 1400) && (redColor <= 4000)) && ((greenColor >= 1300) && (greenColor <= 10000)) && ((blueColor >= 950) && (blueColor <= 2700)))\n{\nrgb.setColor(0,255,0);    // GREEN\n}\n\nelse if (((redColor >= 3000) && (redColor <= 20000)) && ((greenColor >= 700) && (greenColor <= 2400)) && ((blueColor >= 950) && (blueColor <= 3000)))\n{\nrgb.setColor(255,0,0);    // RED\n}\n\nelse if ((redColor < 1500) && (greenColor < 1400) && (blueColor < 900))\n{\nrgb.setColor(0,0,0);  // OFF\n}\n\ndelay(5000);\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void) {\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void) {\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data) {\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class) {\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void) {\nif (lmh_join_status_get() != LMH_SET) {\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\n// Showing the values of red, green and blue colors from RAK12021\ndata = \" Red: \" + String(redColor) + \" Green: \" + String(greenColor) + \" Blue: \" + String(blueColor);\n\nSerial.println(data);\n\nuint16_t red_data = redColor;\nuint16_t green_data = greenColor;\nuint16_t blue_data = blueColor;\n\nm_lora_app_data.buffer[i++] = 0x01;  // byte[0]\n\n// Red data\nm_lora_app_data.buffer[i++] = (uint8_t)((red_data & 0x0000FF00) >> 8);     // byte[1]\nm_lora_app_data.buffer[i++] = (uint8_t)(red_data & 0x000000FF);            // byte[2]\n\n// Green data\nm_lora_app_data.buffer[i++] = (uint8_t)((green_data & 0x0000FF00) >> 8);   // byte[3]\nm_lora_app_data.buffer[i++] = (uint8_t)(green_data & 0x000000FF);          // byte[4]\n\n// Blue data\nm_lora_app_data.buffer[i++] = (uint8_t)((blue_data & 0x0000FF00) >> 8);    // byte[5]\nm_lora_app_data.buffer[i++] = (uint8_t)(blue_data & 0x000000FF);           // byte[6]\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS) {\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n} else {\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0x96, 0xBD, 0xC5, 0x98, 0x17, 0x69, 0x8D, 0xFA, 0x1F, 0x64, 0xFE, 0x1C, 0xF9, 0x26, 0x7F, 0x8D };\n```  \n> **Image:** OTAA device successfully registered to TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "3b1011dd604a810cd70cf8786b8c0011", "product_family": "wisblock", "product_id": "kit6-light-and-color", "category": "How-To", "title": "WisBlock IoT Education Kit - Light & Color Quick Start Guide > WisBlock IoT Education Kit - Light & Color Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock IoT Education Kit - Light & Color using TTN and Qubitro > Light Color Recognizer LoRaWAN Application > LoRaWAN Code for Light Color Recognizer > Programming the Light Color Recognizer Device with Arduino IDE [CODE]", "content": "switch (g_CurrentRegion) {\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;", "keywords": ["Arduino IDE", "RAK4631", "Light Color Recognizer", "LoRaWAN", "programming"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **Light Color Recognizer** device. Just copy the code below for **Light Color Recognizer LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the example </summary>  \n```c\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h>  //http://librarymanager/All#SX126x\n#include <Wire.h>\n#include <NCP5623.h>//http://librarymanager/All#NCP5623 By:RAKWireless\n#include \"TCS3772.h\"  // Click here to get the library: http://librarymanager/All#TCS37725\n// It use WB_IO2 to power up and is conflicting with INT1, so better use in SlotA/SlotC/SlotD.\n\nNCP5623 rgb;\nTCS3772 tcs3772;\nTCS3772_DataScaled tcs3772_data = {0};\n\nuint16_t scale_factor;\n\nuint16_t redColor;\nuint16_t greenColor;\nuint16_t blueColor;\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define RAK4631_BOARD true\n#else\n#define RAK4631_BOARD false\n#endif\n\nbool doOTAA = true;                                               // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                                       /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                                     /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5                               /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                                        /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;                           /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;                 /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                              /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = { LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF };\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = { BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler };\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0x96, 0xBD, 0xC5, 0x98, 0x17, 0x69, 0x8D, 0xFA, 0x1F, 0x64, 0xFE, 0x1C, 0xF9, 0x26, 0x7F, 0x8D };\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };\nuint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                                            /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];               //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = { m_lora_app_data_buffer, 0, 0, 0, 0 };  //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {\n\n// Initialize Serial for debug output\npinMode(LED_BLUE, OUTPUT);\ndigitalWrite(LED_BLUE, HIGH);\n\n// Sensor Power Switch\npinMode(WB_IO2, OUTPUT);\ndigitalWrite(WB_IO2, HIGH);\n\n// enable RAK14001\npinMode(WB_IO6, OUTPUT);\ndigitalWrite(WB_IO6, HIGH);\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial) {\nif ((millis() - timeout) < 5000) {\ndelay(100);\n} else {\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA) {\nSerial.println(\"Type: OTAA\");\n} else {\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion) {\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA) {\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n} else {\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0) {\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"================================\");\nSerial.println(\"RAK12021 + RAK14001 LoRaWAN Code\");\nSerial.println(\"================================\");\n\n// If using Native I2C\nWire.begin();\nWire.setClock(100000);\n\n// Serial.println(\"RAK14001 + RAK12021\");\n\nif (!rgb.begin())\n{\nSerial.println(\"RAK14001 not found on the I2C line\");\nwhile (1);\n}\nelse\n{\nSerial.println(\"RAK14001 Found. Begining execution\");\n}\n\n// set the current output level max, the range is 1 to 31\nrgb.setCurrent(25);\n\nif(tcs3772.begin() == true)\n{\nSerial.println(\"Found sensor.\");\n}\nelse\n{\nSerial.println(\"TCS37725 not found ... check your connections.\");\nwhile(1)\n{\ndelay(10);\n}\n}\ndelay(1000);\n}\n\nvoid loop() {\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\ntcs3772_data = tcs3772.getMeasurement();\n\nscale_factor = tcs3772.autoGain(tcs3772_data.clear);\n\nredColor = tcs3772_data.red;\ngreenColor = tcs3772_data.green;\nblueColor = tcs3772_data.blue;\n\nrgb.setColor(0,0,0);     // Initially OFF\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\nSerial.print(\"  R: \");\nSerial.println(redColor);\nSerial.print(\"  G: \");\nSerial.println(greenColor);\nSerial.print(\"  B: \");\nSerial.println(blueColor);\n\n// The values of redColor, greenColor and blueColor can be varied during the sensing calibration of RAK12021 module\n\nif (((redColor >= 9000) && (redColor <= 65535)) && ((greenColor >= 10000) && (greenColor <= 65535)) && ((blueColor >= 12000) && (blueColor <= 65535)))\n{\nrgb.setColor(255,255,255); // WHITE\n}\n\nelse if (((redColor >= 4000) && (redColor <= 18000)) && ((greenColor >= 1300) && (greenColor <= 5000)) && ((blueColor >= 950) && (blueColor <= 2000)))\n{\nrgb.setColor(255,255,0);  // YELLOW\n}\n\nelse if (((redColor >= 600) && (redColor <= 2000)) && ((greenColor >= 1700) && (greenColor <= 10000)) && ((blueColor >= 6800) && (blueColor <= 27000)))\n{\nrgb.setColor(0,0,255);    // BLUE\n}\n\nelse if (((redColor >= 1400) && (redColor <= 4000)) && ((greenColor >= 1300) && (greenColor <= 10000)) && ((blueColor >= 950) && (blueColor <= 2700)))\n{\nrgb.setColor(0,255,0);    // GREEN\n}\n\nelse if (((redColor >= 3000) && (redColor <= 20000)) && ((greenColor >= 700) && (greenColor <= 2400)) && ((blueColor >= 950) && (blueColor <= 3000)))\n{\nrgb.setColor(255,0,0);    // RED\n}\n\nelse if ((redColor < 1500) && (greenColor < 1400) && (blueColor < 900))\n{\nrgb.setColor(0,0,0);  // OFF\n}\n\ndelay(5000);\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void) {\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void) {\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data) {\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class) {\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void) {\nif (lmh_join_status_get() != LMH_SET) {\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\n// Showing the values of red, green and blue colors from RAK12021\ndata = \" Red: \" + String(redColor) + \" Green: \" + String(greenColor) + \" Blue: \" + String(blueColor);\n\nSerial.println(data);\n\nuint16_t red_data = redColor;\nuint16_t green_data = greenColor;\nuint16_t blue_data = blueColor;\n\nm_lora_app_data.buffer[i++] = 0x01;  // byte[0]\n\n// Red data\nm_lora_app_data.buffer[i++] = (uint8_t)((red_data & 0x0000FF00) >> 8);     // byte[1]\nm_lora_app_data.buffer[i++] = (uint8_t)(red_data & 0x000000FF);            // byte[2]\n\n// Green data\nm_lora_app_data.buffer[i++] = (uint8_t)((green_data & 0x0000FF00) >> 8);   // byte[3]\nm_lora_app_data.buffer[i++] = (uint8_t)(green_data & 0x000000FF);          // byte[4]\n\n// Blue data\nm_lora_app_data.buffer[i++] = (uint8_t)((blue_data & 0x0000FF00) >> 8);    // byte[5]\nm_lora_app_data.buffer[i++] = (uint8_t)(blue_data & 0x000000FF);           // byte[6]\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS) {\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n} else {\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0x96, 0xBD, 0xC5, 0x98, 0x17, 0x69, 0x8D, 0xFA, 0x1F, 0x64, 0xFE, 0x1C, 0xF9, 0x26, 0x7F, 0x8D };\n```  \n> **Image:** OTAA device successfully registered to TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "4f71552de80e0e6c892f8b068d7d32a6", "product_family": "wisblock", "product_id": "kit6-light-and-color", "category": "How-To", "title": "WisBlock IoT Education Kit - Light & Color Quick Start Guide > WisBlock IoT Education Kit - Light & Color Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock IoT Education Kit - Light & Color using TTN and Qubitro > Light Color Recognizer LoRaWAN Application > LoRaWAN Code for Light Color Recognizer > Programming the Light Color Recognizer Device with Arduino IDE [CODE]", "content": "break;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");", "keywords": ["Arduino IDE", "RAK4631", "Light Color Recognizer", "LoRaWAN", "programming"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **Light Color Recognizer** device. Just copy the code below for **Light Color Recognizer LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the example </summary>  \n```c\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h>  //http://librarymanager/All#SX126x\n#include <Wire.h>\n#include <NCP5623.h>//http://librarymanager/All#NCP5623 By:RAKWireless\n#include \"TCS3772.h\"  // Click here to get the library: http://librarymanager/All#TCS37725\n// It use WB_IO2 to power up and is conflicting with INT1, so better use in SlotA/SlotC/SlotD.\n\nNCP5623 rgb;\nTCS3772 tcs3772;\nTCS3772_DataScaled tcs3772_data = {0};\n\nuint16_t scale_factor;\n\nuint16_t redColor;\nuint16_t greenColor;\nuint16_t blueColor;\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define RAK4631_BOARD true\n#else\n#define RAK4631_BOARD false\n#endif\n\nbool doOTAA = true;                                               // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                                       /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                                     /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5                               /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                                        /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;                           /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;                 /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                              /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = { LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF };\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = { BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler };\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0x96, 0xBD, 0xC5, 0x98, 0x17, 0x69, 0x8D, 0xFA, 0x1F, 0x64, 0xFE, 0x1C, 0xF9, 0x26, 0x7F, 0x8D };\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };\nuint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                                            /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];               //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = { m_lora_app_data_buffer, 0, 0, 0, 0 };  //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {\n\n// Initialize Serial for debug output\npinMode(LED_BLUE, OUTPUT);\ndigitalWrite(LED_BLUE, HIGH);\n\n// Sensor Power Switch\npinMode(WB_IO2, OUTPUT);\ndigitalWrite(WB_IO2, HIGH);\n\n// enable RAK14001\npinMode(WB_IO6, OUTPUT);\ndigitalWrite(WB_IO6, HIGH);\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial) {\nif ((millis() - timeout) < 5000) {\ndelay(100);\n} else {\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA) {\nSerial.println(\"Type: OTAA\");\n} else {\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion) {\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA) {\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n} else {\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0) {\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"================================\");\nSerial.println(\"RAK12021 + RAK14001 LoRaWAN Code\");\nSerial.println(\"================================\");\n\n// If using Native I2C\nWire.begin();\nWire.setClock(100000);\n\n// Serial.println(\"RAK14001 + RAK12021\");\n\nif (!rgb.begin())\n{\nSerial.println(\"RAK14001 not found on the I2C line\");\nwhile (1);\n}\nelse\n{\nSerial.println(\"RAK14001 Found. Begining execution\");\n}\n\n// set the current output level max, the range is 1 to 31\nrgb.setCurrent(25);\n\nif(tcs3772.begin() == true)\n{\nSerial.println(\"Found sensor.\");\n}\nelse\n{\nSerial.println(\"TCS37725 not found ... check your connections.\");\nwhile(1)\n{\ndelay(10);\n}\n}\ndelay(1000);\n}\n\nvoid loop() {\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\ntcs3772_data = tcs3772.getMeasurement();\n\nscale_factor = tcs3772.autoGain(tcs3772_data.clear);\n\nredColor = tcs3772_data.red;\ngreenColor = tcs3772_data.green;\nblueColor = tcs3772_data.blue;\n\nrgb.setColor(0,0,0);     // Initially OFF\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\nSerial.print(\"  R: \");\nSerial.println(redColor);\nSerial.print(\"  G: \");\nSerial.println(greenColor);\nSerial.print(\"  B: \");\nSerial.println(blueColor);\n\n// The values of redColor, greenColor and blueColor can be varied during the sensing calibration of RAK12021 module\n\nif (((redColor >= 9000) && (redColor <= 65535)) && ((greenColor >= 10000) && (greenColor <= 65535)) && ((blueColor >= 12000) && (blueColor <= 65535)))\n{\nrgb.setColor(255,255,255); // WHITE\n}\n\nelse if (((redColor >= 4000) && (redColor <= 18000)) && ((greenColor >= 1300) && (greenColor <= 5000)) && ((blueColor >= 950) && (blueColor <= 2000)))\n{\nrgb.setColor(255,255,0);  // YELLOW\n}\n\nelse if (((redColor >= 600) && (redColor <= 2000)) && ((greenColor >= 1700) && (greenColor <= 10000)) && ((blueColor >= 6800) && (blueColor <= 27000)))\n{\nrgb.setColor(0,0,255);    // BLUE\n}\n\nelse if (((redColor >= 1400) && (redColor <= 4000)) && ((greenColor >= 1300) && (greenColor <= 10000)) && ((blueColor >= 950) && (blueColor <= 2700)))\n{\nrgb.setColor(0,255,0);    // GREEN\n}\n\nelse if (((redColor >= 3000) && (redColor <= 20000)) && ((greenColor >= 700) && (greenColor <= 2400)) && ((blueColor >= 950) && (blueColor <= 3000)))\n{\nrgb.setColor(255,0,0);    // RED\n}\n\nelse if ((redColor < 1500) && (greenColor < 1400) && (blueColor < 900))\n{\nrgb.setColor(0,0,0);  // OFF\n}\n\ndelay(5000);\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void) {\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void) {\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data) {\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class) {\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void) {\nif (lmh_join_status_get() != LMH_SET) {\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\n// Showing the values of red, green and blue colors from RAK12021\ndata = \" Red: \" + String(redColor) + \" Green: \" + String(greenColor) + \" Blue: \" + String(blueColor);\n\nSerial.println(data);\n\nuint16_t red_data = redColor;\nuint16_t green_data = greenColor;\nuint16_t blue_data = blueColor;\n\nm_lora_app_data.buffer[i++] = 0x01;  // byte[0]\n\n// Red data\nm_lora_app_data.buffer[i++] = (uint8_t)((red_data & 0x0000FF00) >> 8);     // byte[1]\nm_lora_app_data.buffer[i++] = (uint8_t)(red_data & 0x000000FF);            // byte[2]\n\n// Green data\nm_lora_app_data.buffer[i++] = (uint8_t)((green_data & 0x0000FF00) >> 8);   // byte[3]\nm_lora_app_data.buffer[i++] = (uint8_t)(green_data & 0x000000FF);          // byte[4]\n\n// Blue data\nm_lora_app_data.buffer[i++] = (uint8_t)((blue_data & 0x0000FF00) >> 8);    // byte[5]\nm_lora_app_data.buffer[i++] = (uint8_t)(blue_data & 0x000000FF);           // byte[6]\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS) {\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n} else {\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0x96, 0xBD, 0xC5, 0x98, 0x17, 0x69, 0x8D, 0xFA, 0x1F, 0x64, 0xFE, 0x1C, 0xF9, 0x26, 0x7F, 0x8D };\n```  \n> **Image:** OTAA device successfully registered to TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "1dc9c6313493aea39460829b883d33be", "product_family": "wisblock", "product_id": "kit6-light-and-color", "category": "How-To", "title": "WisBlock IoT Education Kit - Light & Color Quick Start Guide > WisBlock IoT Education Kit - Light & Color Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock IoT Education Kit - Light & Color using TTN and Qubitro > Light Color Recognizer LoRaWAN Application > LoRaWAN Code for Light Color Recognizer > Programming the Light Color Recognizer Device with Arduino IDE [CODE]", "content": "// Setup the EUIs and Keys\nif (doOTAA) {\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n} else {\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0) {\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();", "keywords": ["Arduino IDE", "RAK4631", "Light Color Recognizer", "LoRaWAN", "programming"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **Light Color Recognizer** device. Just copy the code below for **Light Color Recognizer LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the example </summary>  \n```c\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h>  //http://librarymanager/All#SX126x\n#include <Wire.h>\n#include <NCP5623.h>//http://librarymanager/All#NCP5623 By:RAKWireless\n#include \"TCS3772.h\"  // Click here to get the library: http://librarymanager/All#TCS37725\n// It use WB_IO2 to power up and is conflicting with INT1, so better use in SlotA/SlotC/SlotD.\n\nNCP5623 rgb;\nTCS3772 tcs3772;\nTCS3772_DataScaled tcs3772_data = {0};\n\nuint16_t scale_factor;\n\nuint16_t redColor;\nuint16_t greenColor;\nuint16_t blueColor;\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define RAK4631_BOARD true\n#else\n#define RAK4631_BOARD false\n#endif\n\nbool doOTAA = true;                                               // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                                       /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                                     /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5                               /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                                        /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;                           /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;                 /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                              /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = { LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF };\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = { BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler };\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0x96, 0xBD, 0xC5, 0x98, 0x17, 0x69, 0x8D, 0xFA, 0x1F, 0x64, 0xFE, 0x1C, 0xF9, 0x26, 0x7F, 0x8D };\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };\nuint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                                            /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];               //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = { m_lora_app_data_buffer, 0, 0, 0, 0 };  //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {\n\n// Initialize Serial for debug output\npinMode(LED_BLUE, OUTPUT);\ndigitalWrite(LED_BLUE, HIGH);\n\n// Sensor Power Switch\npinMode(WB_IO2, OUTPUT);\ndigitalWrite(WB_IO2, HIGH);\n\n// enable RAK14001\npinMode(WB_IO6, OUTPUT);\ndigitalWrite(WB_IO6, HIGH);\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial) {\nif ((millis() - timeout) < 5000) {\ndelay(100);\n} else {\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA) {\nSerial.println(\"Type: OTAA\");\n} else {\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion) {\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA) {\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n} else {\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0) {\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"================================\");\nSerial.println(\"RAK12021 + RAK14001 LoRaWAN Code\");\nSerial.println(\"================================\");\n\n// If using Native I2C\nWire.begin();\nWire.setClock(100000);\n\n// Serial.println(\"RAK14001 + RAK12021\");\n\nif (!rgb.begin())\n{\nSerial.println(\"RAK14001 not found on the I2C line\");\nwhile (1);\n}\nelse\n{\nSerial.println(\"RAK14001 Found. Begining execution\");\n}\n\n// set the current output level max, the range is 1 to 31\nrgb.setCurrent(25);\n\nif(tcs3772.begin() == true)\n{\nSerial.println(\"Found sensor.\");\n}\nelse\n{\nSerial.println(\"TCS37725 not found ... check your connections.\");\nwhile(1)\n{\ndelay(10);\n}\n}\ndelay(1000);\n}\n\nvoid loop() {\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\ntcs3772_data = tcs3772.getMeasurement();\n\nscale_factor = tcs3772.autoGain(tcs3772_data.clear);\n\nredColor = tcs3772_data.red;\ngreenColor = tcs3772_data.green;\nblueColor = tcs3772_data.blue;\n\nrgb.setColor(0,0,0);     // Initially OFF\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\nSerial.print(\"  R: \");\nSerial.println(redColor);\nSerial.print(\"  G: \");\nSerial.println(greenColor);\nSerial.print(\"  B: \");\nSerial.println(blueColor);\n\n// The values of redColor, greenColor and blueColor can be varied during the sensing calibration of RAK12021 module\n\nif (((redColor >= 9000) && (redColor <= 65535)) && ((greenColor >= 10000) && (greenColor <= 65535)) && ((blueColor >= 12000) && (blueColor <= 65535)))\n{\nrgb.setColor(255,255,255); // WHITE\n}\n\nelse if (((redColor >= 4000) && (redColor <= 18000)) && ((greenColor >= 1300) && (greenColor <= 5000)) && ((blueColor >= 950) && (blueColor <= 2000)))\n{\nrgb.setColor(255,255,0);  // YELLOW\n}\n\nelse if (((redColor >= 600) && (redColor <= 2000)) && ((greenColor >= 1700) && (greenColor <= 10000)) && ((blueColor >= 6800) && (blueColor <= 27000)))\n{\nrgb.setColor(0,0,255);    // BLUE\n}\n\nelse if (((redColor >= 1400) && (redColor <= 4000)) && ((greenColor >= 1300) && (greenColor <= 10000)) && ((blueColor >= 950) && (blueColor <= 2700)))\n{\nrgb.setColor(0,255,0);    // GREEN\n}\n\nelse if (((redColor >= 3000) && (redColor <= 20000)) && ((greenColor >= 700) && (greenColor <= 2400)) && ((blueColor >= 950) && (blueColor <= 3000)))\n{\nrgb.setColor(255,0,0);    // RED\n}\n\nelse if ((redColor < 1500) && (greenColor < 1400) && (blueColor < 900))\n{\nrgb.setColor(0,0,0);  // OFF\n}\n\ndelay(5000);\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void) {\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void) {\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data) {\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class) {\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void) {\nif (lmh_join_status_get() != LMH_SET) {\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\n// Showing the values of red, green and blue colors from RAK12021\ndata = \" Red: \" + String(redColor) + \" Green: \" + String(greenColor) + \" Blue: \" + String(blueColor);\n\nSerial.println(data);\n\nuint16_t red_data = redColor;\nuint16_t green_data = greenColor;\nuint16_t blue_data = blueColor;\n\nm_lora_app_data.buffer[i++] = 0x01;  // byte[0]\n\n// Red data\nm_lora_app_data.buffer[i++] = (uint8_t)((red_data & 0x0000FF00) >> 8);     // byte[1]\nm_lora_app_data.buffer[i++] = (uint8_t)(red_data & 0x000000FF);            // byte[2]\n\n// Green data\nm_lora_app_data.buffer[i++] = (uint8_t)((green_data & 0x0000FF00) >> 8);   // byte[3]\nm_lora_app_data.buffer[i++] = (uint8_t)(green_data & 0x000000FF);          // byte[4]\n\n// Blue data\nm_lora_app_data.buffer[i++] = (uint8_t)((blue_data & 0x0000FF00) >> 8);    // byte[5]\nm_lora_app_data.buffer[i++] = (uint8_t)(blue_data & 0x000000FF);           // byte[6]\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS) {\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n} else {\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0x96, 0xBD, 0xC5, 0x98, 0x17, 0x69, 0x8D, 0xFA, 0x1F, 0x64, 0xFE, 0x1C, 0xF9, 0x26, 0x7F, 0x8D };\n```  \n> **Image:** OTAA device successfully registered to TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "f29734e42b930cb0b5a4637cc90a3b6a", "product_family": "wisblock", "product_id": "kit6-light-and-color", "category": "How-To", "title": "WisBlock IoT Education Kit - Light & Color Quick Start Guide > WisBlock IoT Education Kit - Light & Color Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock IoT Education Kit - Light & Color using TTN and Qubitro > Light Color Recognizer LoRaWAN Application > LoRaWAN Code for Light Color Recognizer > Programming the Light Color Recognizer Device with Arduino IDE [CODE]", "content": "// Start Join procedure\nlmh_join();\n\nSerial.println(\"================================\");\nSerial.println(\"RAK12021 + RAK14001 LoRaWAN Code\");\nSerial.println(\"================================\");\n\n// If using Native I2C\nWire.begin();\nWire.setClock(100000);\n\n// Serial.println(\"RAK14001 + RAK12021\");\n\nif (!rgb.begin())\n{\nSerial.println(\"RAK14001 not found on the I2C line\");\nwhile (1);\n}\nelse\n{\nSerial.println(\"RAK14001 Found. Begining execution\");\n}", "keywords": ["Arduino IDE", "RAK4631", "Light Color Recognizer", "LoRaWAN", "programming"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **Light Color Recognizer** device. Just copy the code below for **Light Color Recognizer LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the example </summary>  \n```c\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h>  //http://librarymanager/All#SX126x\n#include <Wire.h>\n#include <NCP5623.h>//http://librarymanager/All#NCP5623 By:RAKWireless\n#include \"TCS3772.h\"  // Click here to get the library: http://librarymanager/All#TCS37725\n// It use WB_IO2 to power up and is conflicting with INT1, so better use in SlotA/SlotC/SlotD.\n\nNCP5623 rgb;\nTCS3772 tcs3772;\nTCS3772_DataScaled tcs3772_data = {0};\n\nuint16_t scale_factor;\n\nuint16_t redColor;\nuint16_t greenColor;\nuint16_t blueColor;\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define RAK4631_BOARD true\n#else\n#define RAK4631_BOARD false\n#endif\n\nbool doOTAA = true;                                               // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                                       /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                                     /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5                               /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                                        /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;                           /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;                 /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                              /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = { LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF };\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = { BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler };\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0x96, 0xBD, 0xC5, 0x98, 0x17, 0x69, 0x8D, 0xFA, 0x1F, 0x64, 0xFE, 0x1C, 0xF9, 0x26, 0x7F, 0x8D };\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };\nuint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                                            /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];               //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = { m_lora_app_data_buffer, 0, 0, 0, 0 };  //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {\n\n// Initialize Serial for debug output\npinMode(LED_BLUE, OUTPUT);\ndigitalWrite(LED_BLUE, HIGH);\n\n// Sensor Power Switch\npinMode(WB_IO2, OUTPUT);\ndigitalWrite(WB_IO2, HIGH);\n\n// enable RAK14001\npinMode(WB_IO6, OUTPUT);\ndigitalWrite(WB_IO6, HIGH);\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial) {\nif ((millis() - timeout) < 5000) {\ndelay(100);\n} else {\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA) {\nSerial.println(\"Type: OTAA\");\n} else {\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion) {\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA) {\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n} else {\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0) {\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"================================\");\nSerial.println(\"RAK12021 + RAK14001 LoRaWAN Code\");\nSerial.println(\"================================\");\n\n// If using Native I2C\nWire.begin();\nWire.setClock(100000);\n\n// Serial.println(\"RAK14001 + RAK12021\");\n\nif (!rgb.begin())\n{\nSerial.println(\"RAK14001 not found on the I2C line\");\nwhile (1);\n}\nelse\n{\nSerial.println(\"RAK14001 Found. Begining execution\");\n}\n\n// set the current output level max, the range is 1 to 31\nrgb.setCurrent(25);\n\nif(tcs3772.begin() == true)\n{\nSerial.println(\"Found sensor.\");\n}\nelse\n{\nSerial.println(\"TCS37725 not found ... check your connections.\");\nwhile(1)\n{\ndelay(10);\n}\n}\ndelay(1000);\n}\n\nvoid loop() {\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\ntcs3772_data = tcs3772.getMeasurement();\n\nscale_factor = tcs3772.autoGain(tcs3772_data.clear);\n\nredColor = tcs3772_data.red;\ngreenColor = tcs3772_data.green;\nblueColor = tcs3772_data.blue;\n\nrgb.setColor(0,0,0);     // Initially OFF\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\nSerial.print(\"  R: \");\nSerial.println(redColor);\nSerial.print(\"  G: \");\nSerial.println(greenColor);\nSerial.print(\"  B: \");\nSerial.println(blueColor);\n\n// The values of redColor, greenColor and blueColor can be varied during the sensing calibration of RAK12021 module\n\nif (((redColor >= 9000) && (redColor <= 65535)) && ((greenColor >= 10000) && (greenColor <= 65535)) && ((blueColor >= 12000) && (blueColor <= 65535)))\n{\nrgb.setColor(255,255,255); // WHITE\n}\n\nelse if (((redColor >= 4000) && (redColor <= 18000)) && ((greenColor >= 1300) && (greenColor <= 5000)) && ((blueColor >= 950) && (blueColor <= 2000)))\n{\nrgb.setColor(255,255,0);  // YELLOW\n}\n\nelse if (((redColor >= 600) && (redColor <= 2000)) && ((greenColor >= 1700) && (greenColor <= 10000)) && ((blueColor >= 6800) && (blueColor <= 27000)))\n{\nrgb.setColor(0,0,255);    // BLUE\n}\n\nelse if (((redColor >= 1400) && (redColor <= 4000)) && ((greenColor >= 1300) && (greenColor <= 10000)) && ((blueColor >= 950) && (blueColor <= 2700)))\n{\nrgb.setColor(0,255,0);    // GREEN\n}\n\nelse if (((redColor >= 3000) && (redColor <= 20000)) && ((greenColor >= 700) && (greenColor <= 2400)) && ((blueColor >= 950) && (blueColor <= 3000)))\n{\nrgb.setColor(255,0,0);    // RED\n}\n\nelse if ((redColor < 1500) && (greenColor < 1400) && (blueColor < 900))\n{\nrgb.setColor(0,0,0);  // OFF\n}\n\ndelay(5000);\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void) {\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void) {\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data) {\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class) {\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void) {\nif (lmh_join_status_get() != LMH_SET) {\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\n// Showing the values of red, green and blue colors from RAK12021\ndata = \" Red: \" + String(redColor) + \" Green: \" + String(greenColor) + \" Blue: \" + String(blueColor);\n\nSerial.println(data);\n\nuint16_t red_data = redColor;\nuint16_t green_data = greenColor;\nuint16_t blue_data = blueColor;\n\nm_lora_app_data.buffer[i++] = 0x01;  // byte[0]\n\n// Red data\nm_lora_app_data.buffer[i++] = (uint8_t)((red_data & 0x0000FF00) >> 8);     // byte[1]\nm_lora_app_data.buffer[i++] = (uint8_t)(red_data & 0x000000FF);            // byte[2]\n\n// Green data\nm_lora_app_data.buffer[i++] = (uint8_t)((green_data & 0x0000FF00) >> 8);   // byte[3]\nm_lora_app_data.buffer[i++] = (uint8_t)(green_data & 0x000000FF);          // byte[4]\n\n// Blue data\nm_lora_app_data.buffer[i++] = (uint8_t)((blue_data & 0x0000FF00) >> 8);    // byte[5]\nm_lora_app_data.buffer[i++] = (uint8_t)(blue_data & 0x000000FF);           // byte[6]\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS) {\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n} else {\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0x96, 0xBD, 0xC5, 0x98, 0x17, 0x69, 0x8D, 0xFA, 0x1F, 0x64, 0xFE, 0x1C, 0xF9, 0x26, 0x7F, 0x8D };\n```  \n> **Image:** OTAA device successfully registered to TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "6d103cfb6d882cc0874772544c678768", "product_family": "wisblock", "product_id": "kit6-light-and-color", "category": "How-To", "title": "WisBlock IoT Education Kit - Light & Color Quick Start Guide > WisBlock IoT Education Kit - Light & Color Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock IoT Education Kit - Light & Color using TTN and Qubitro > Light Color Recognizer LoRaWAN Application > LoRaWAN Code for Light Color Recognizer > Programming the Light Color Recognizer Device with Arduino IDE [CODE]", "content": "// set the current output level max, the range is 1 to 31\nrgb.setCurrent(25);\n\nif(tcs3772.begin() == true)\n{\nSerial.println(\"Found sensor.\");\n}\nelse\n{\nSerial.println(\"TCS37725 not found ... check your connections.\");\nwhile(1)\n{\ndelay(10);\n}\n}\ndelay(1000);\n}\n\nvoid loop() {\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\ntcs3772_data = tcs3772.getMeasurement();\n\nscale_factor = tcs3772.autoGain(tcs3772_data.clear);", "keywords": ["Arduino IDE", "RAK4631", "Light Color Recognizer", "LoRaWAN", "programming"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **Light Color Recognizer** device. Just copy the code below for **Light Color Recognizer LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the example </summary>  \n```c\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h>  //http://librarymanager/All#SX126x\n#include <Wire.h>\n#include <NCP5623.h>//http://librarymanager/All#NCP5623 By:RAKWireless\n#include \"TCS3772.h\"  // Click here to get the library: http://librarymanager/All#TCS37725\n// It use WB_IO2 to power up and is conflicting with INT1, so better use in SlotA/SlotC/SlotD.\n\nNCP5623 rgb;\nTCS3772 tcs3772;\nTCS3772_DataScaled tcs3772_data = {0};\n\nuint16_t scale_factor;\n\nuint16_t redColor;\nuint16_t greenColor;\nuint16_t blueColor;\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define RAK4631_BOARD true\n#else\n#define RAK4631_BOARD false\n#endif\n\nbool doOTAA = true;                                               // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                                       /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                                     /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5                               /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                                        /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;                           /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;                 /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                              /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = { LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF };\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = { BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler };\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0x96, 0xBD, 0xC5, 0x98, 0x17, 0x69, 0x8D, 0xFA, 0x1F, 0x64, 0xFE, 0x1C, 0xF9, 0x26, 0x7F, 0x8D };\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };\nuint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                                            /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];               //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = { m_lora_app_data_buffer, 0, 0, 0, 0 };  //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {\n\n// Initialize Serial for debug output\npinMode(LED_BLUE, OUTPUT);\ndigitalWrite(LED_BLUE, HIGH);\n\n// Sensor Power Switch\npinMode(WB_IO2, OUTPUT);\ndigitalWrite(WB_IO2, HIGH);\n\n// enable RAK14001\npinMode(WB_IO6, OUTPUT);\ndigitalWrite(WB_IO6, HIGH);\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial) {\nif ((millis() - timeout) < 5000) {\ndelay(100);\n} else {\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA) {\nSerial.println(\"Type: OTAA\");\n} else {\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion) {\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA) {\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n} else {\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0) {\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"================================\");\nSerial.println(\"RAK12021 + RAK14001 LoRaWAN Code\");\nSerial.println(\"================================\");\n\n// If using Native I2C\nWire.begin();\nWire.setClock(100000);\n\n// Serial.println(\"RAK14001 + RAK12021\");\n\nif (!rgb.begin())\n{\nSerial.println(\"RAK14001 not found on the I2C line\");\nwhile (1);\n}\nelse\n{\nSerial.println(\"RAK14001 Found. Begining execution\");\n}\n\n// set the current output level max, the range is 1 to 31\nrgb.setCurrent(25);\n\nif(tcs3772.begin() == true)\n{\nSerial.println(\"Found sensor.\");\n}\nelse\n{\nSerial.println(\"TCS37725 not found ... check your connections.\");\nwhile(1)\n{\ndelay(10);\n}\n}\ndelay(1000);\n}\n\nvoid loop() {\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\ntcs3772_data = tcs3772.getMeasurement();\n\nscale_factor = tcs3772.autoGain(tcs3772_data.clear);\n\nredColor = tcs3772_data.red;\ngreenColor = tcs3772_data.green;\nblueColor = tcs3772_data.blue;\n\nrgb.setColor(0,0,0);     // Initially OFF\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\nSerial.print(\"  R: \");\nSerial.println(redColor);\nSerial.print(\"  G: \");\nSerial.println(greenColor);\nSerial.print(\"  B: \");\nSerial.println(blueColor);\n\n// The values of redColor, greenColor and blueColor can be varied during the sensing calibration of RAK12021 module\n\nif (((redColor >= 9000) && (redColor <= 65535)) && ((greenColor >= 10000) && (greenColor <= 65535)) && ((blueColor >= 12000) && (blueColor <= 65535)))\n{\nrgb.setColor(255,255,255); // WHITE\n}\n\nelse if (((redColor >= 4000) && (redColor <= 18000)) && ((greenColor >= 1300) && (greenColor <= 5000)) && ((blueColor >= 950) && (blueColor <= 2000)))\n{\nrgb.setColor(255,255,0);  // YELLOW\n}\n\nelse if (((redColor >= 600) && (redColor <= 2000)) && ((greenColor >= 1700) && (greenColor <= 10000)) && ((blueColor >= 6800) && (blueColor <= 27000)))\n{\nrgb.setColor(0,0,255);    // BLUE\n}\n\nelse if (((redColor >= 1400) && (redColor <= 4000)) && ((greenColor >= 1300) && (greenColor <= 10000)) && ((blueColor >= 950) && (blueColor <= 2700)))\n{\nrgb.setColor(0,255,0);    // GREEN\n}\n\nelse if (((redColor >= 3000) && (redColor <= 20000)) && ((greenColor >= 700) && (greenColor <= 2400)) && ((blueColor >= 950) && (blueColor <= 3000)))\n{\nrgb.setColor(255,0,0);    // RED\n}\n\nelse if ((redColor < 1500) && (greenColor < 1400) && (blueColor < 900))\n{\nrgb.setColor(0,0,0);  // OFF\n}\n\ndelay(5000);\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void) {\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void) {\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data) {\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class) {\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void) {\nif (lmh_join_status_get() != LMH_SET) {\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\n// Showing the values of red, green and blue colors from RAK12021\ndata = \" Red: \" + String(redColor) + \" Green: \" + String(greenColor) + \" Blue: \" + String(blueColor);\n\nSerial.println(data);\n\nuint16_t red_data = redColor;\nuint16_t green_data = greenColor;\nuint16_t blue_data = blueColor;\n\nm_lora_app_data.buffer[i++] = 0x01;  // byte[0]\n\n// Red data\nm_lora_app_data.buffer[i++] = (uint8_t)((red_data & 0x0000FF00) >> 8);     // byte[1]\nm_lora_app_data.buffer[i++] = (uint8_t)(red_data & 0x000000FF);            // byte[2]\n\n// Green data\nm_lora_app_data.buffer[i++] = (uint8_t)((green_data & 0x0000FF00) >> 8);   // byte[3]\nm_lora_app_data.buffer[i++] = (uint8_t)(green_data & 0x000000FF);          // byte[4]\n\n// Blue data\nm_lora_app_data.buffer[i++] = (uint8_t)((blue_data & 0x0000FF00) >> 8);    // byte[5]\nm_lora_app_data.buffer[i++] = (uint8_t)(blue_data & 0x000000FF);           // byte[6]\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS) {\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n} else {\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0x96, 0xBD, 0xC5, 0x98, 0x17, 0x69, 0x8D, 0xFA, 0x1F, 0x64, 0xFE, 0x1C, 0xF9, 0x26, 0x7F, 0x8D };\n```  \n> **Image:** OTAA device successfully registered to TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "dfc019b3cbcbe291f3f879ca2411deaf", "product_family": "wisblock", "product_id": "kit6-light-and-color", "category": "How-To", "title": "WisBlock IoT Education Kit - Light & Color Quick Start Guide > WisBlock IoT Education Kit - Light & Color Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock IoT Education Kit - Light & Color using TTN and Qubitro > Light Color Recognizer LoRaWAN Application > LoRaWAN Code for Light Color Recognizer > Programming the Light Color Recognizer Device with Arduino IDE [CODE]", "content": "tcs3772_data = tcs3772.getMeasurement();\n\nscale_factor = tcs3772.autoGain(tcs3772_data.clear);\n\nredColor = tcs3772_data.red;\ngreenColor = tcs3772_data.green;\nblueColor = tcs3772_data.blue;\n\nrgb.setColor(0,0,0);     // Initially OFF\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\nSerial.print(\"  R: \");\nSerial.println(redColor);\nSerial.print(\"  G: \");\nSerial.println(greenColor);\nSerial.print(\"  B: \");\nSerial.println(blueColor);", "keywords": ["Arduino IDE", "RAK4631", "Light Color Recognizer", "LoRaWAN", "programming"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **Light Color Recognizer** device. Just copy the code below for **Light Color Recognizer LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the example </summary>  \n```c\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h>  //http://librarymanager/All#SX126x\n#include <Wire.h>\n#include <NCP5623.h>//http://librarymanager/All#NCP5623 By:RAKWireless\n#include \"TCS3772.h\"  // Click here to get the library: http://librarymanager/All#TCS37725\n// It use WB_IO2 to power up and is conflicting with INT1, so better use in SlotA/SlotC/SlotD.\n\nNCP5623 rgb;\nTCS3772 tcs3772;\nTCS3772_DataScaled tcs3772_data = {0};\n\nuint16_t scale_factor;\n\nuint16_t redColor;\nuint16_t greenColor;\nuint16_t blueColor;\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define RAK4631_BOARD true\n#else\n#define RAK4631_BOARD false\n#endif\n\nbool doOTAA = true;                                               // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                                       /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                                     /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5                               /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                                        /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;                           /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;                 /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                              /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = { LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF };\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = { BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler };\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0x96, 0xBD, 0xC5, 0x98, 0x17, 0x69, 0x8D, 0xFA, 0x1F, 0x64, 0xFE, 0x1C, 0xF9, 0x26, 0x7F, 0x8D };\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };\nuint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                                            /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];               //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = { m_lora_app_data_buffer, 0, 0, 0, 0 };  //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {\n\n// Initialize Serial for debug output\npinMode(LED_BLUE, OUTPUT);\ndigitalWrite(LED_BLUE, HIGH);\n\n// Sensor Power Switch\npinMode(WB_IO2, OUTPUT);\ndigitalWrite(WB_IO2, HIGH);\n\n// enable RAK14001\npinMode(WB_IO6, OUTPUT);\ndigitalWrite(WB_IO6, HIGH);\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial) {\nif ((millis() - timeout) < 5000) {\ndelay(100);\n} else {\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA) {\nSerial.println(\"Type: OTAA\");\n} else {\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion) {\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA) {\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n} else {\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0) {\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"================================\");\nSerial.println(\"RAK12021 + RAK14001 LoRaWAN Code\");\nSerial.println(\"================================\");\n\n// If using Native I2C\nWire.begin();\nWire.setClock(100000);\n\n// Serial.println(\"RAK14001 + RAK12021\");\n\nif (!rgb.begin())\n{\nSerial.println(\"RAK14001 not found on the I2C line\");\nwhile (1);\n}\nelse\n{\nSerial.println(\"RAK14001 Found. Begining execution\");\n}\n\n// set the current output level max, the range is 1 to 31\nrgb.setCurrent(25);\n\nif(tcs3772.begin() == true)\n{\nSerial.println(\"Found sensor.\");\n}\nelse\n{\nSerial.println(\"TCS37725 not found ... check your connections.\");\nwhile(1)\n{\ndelay(10);\n}\n}\ndelay(1000);\n}\n\nvoid loop() {\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\ntcs3772_data = tcs3772.getMeasurement();\n\nscale_factor = tcs3772.autoGain(tcs3772_data.clear);\n\nredColor = tcs3772_data.red;\ngreenColor = tcs3772_data.green;\nblueColor = tcs3772_data.blue;\n\nrgb.setColor(0,0,0);     // Initially OFF\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\nSerial.print(\"  R: \");\nSerial.println(redColor);\nSerial.print(\"  G: \");\nSerial.println(greenColor);\nSerial.print(\"  B: \");\nSerial.println(blueColor);\n\n// The values of redColor, greenColor and blueColor can be varied during the sensing calibration of RAK12021 module\n\nif (((redColor >= 9000) && (redColor <= 65535)) && ((greenColor >= 10000) && (greenColor <= 65535)) && ((blueColor >= 12000) && (blueColor <= 65535)))\n{\nrgb.setColor(255,255,255); // WHITE\n}\n\nelse if (((redColor >= 4000) && (redColor <= 18000)) && ((greenColor >= 1300) && (greenColor <= 5000)) && ((blueColor >= 950) && (blueColor <= 2000)))\n{\nrgb.setColor(255,255,0);  // YELLOW\n}\n\nelse if (((redColor >= 600) && (redColor <= 2000)) && ((greenColor >= 1700) && (greenColor <= 10000)) && ((blueColor >= 6800) && (blueColor <= 27000)))\n{\nrgb.setColor(0,0,255);    // BLUE\n}\n\nelse if (((redColor >= 1400) && (redColor <= 4000)) && ((greenColor >= 1300) && (greenColor <= 10000)) && ((blueColor >= 950) && (blueColor <= 2700)))\n{\nrgb.setColor(0,255,0);    // GREEN\n}\n\nelse if (((redColor >= 3000) && (redColor <= 20000)) && ((greenColor >= 700) && (greenColor <= 2400)) && ((blueColor >= 950) && (blueColor <= 3000)))\n{\nrgb.setColor(255,0,0);    // RED\n}\n\nelse if ((redColor < 1500) && (greenColor < 1400) && (blueColor < 900))\n{\nrgb.setColor(0,0,0);  // OFF\n}\n\ndelay(5000);\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void) {\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void) {\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data) {\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class) {\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void) {\nif (lmh_join_status_get() != LMH_SET) {\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\n// Showing the values of red, green and blue colors from RAK12021\ndata = \" Red: \" + String(redColor) + \" Green: \" + String(greenColor) + \" Blue: \" + String(blueColor);\n\nSerial.println(data);\n\nuint16_t red_data = redColor;\nuint16_t green_data = greenColor;\nuint16_t blue_data = blueColor;\n\nm_lora_app_data.buffer[i++] = 0x01;  // byte[0]\n\n// Red data\nm_lora_app_data.buffer[i++] = (uint8_t)((red_data & 0x0000FF00) >> 8);     // byte[1]\nm_lora_app_data.buffer[i++] = (uint8_t)(red_data & 0x000000FF);            // byte[2]\n\n// Green data\nm_lora_app_data.buffer[i++] = (uint8_t)((green_data & 0x0000FF00) >> 8);   // byte[3]\nm_lora_app_data.buffer[i++] = (uint8_t)(green_data & 0x000000FF);          // byte[4]\n\n// Blue data\nm_lora_app_data.buffer[i++] = (uint8_t)((blue_data & 0x0000FF00) >> 8);    // byte[5]\nm_lora_app_data.buffer[i++] = (uint8_t)(blue_data & 0x000000FF);           // byte[6]\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS) {\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n} else {\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0x96, 0xBD, 0xC5, 0x98, 0x17, 0x69, 0x8D, 0xFA, 0x1F, 0x64, 0xFE, 0x1C, 0xF9, 0x26, 0x7F, 0x8D };\n```  \n> **Image:** OTAA device successfully registered to TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "242588676b2083dbf2ba50e45ad5dd8d", "product_family": "wisblock", "product_id": "kit6-light-and-color", "category": "How-To", "title": "WisBlock IoT Education Kit - Light & Color Quick Start Guide > WisBlock IoT Education Kit - Light & Color Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock IoT Education Kit - Light & Color using TTN and Qubitro > Light Color Recognizer LoRaWAN Application > LoRaWAN Code for Light Color Recognizer > Programming the Light Color Recognizer Device with Arduino IDE [CODE]", "content": "// The values of redColor, greenColor and blueColor can be varied during the sensing calibration of RAK12021 module\n\nif (((redColor >= 9000) && (redColor <= 65535)) && ((greenColor >= 10000) && (greenColor <= 65535)) && ((blueColor >= 12000) && (blueColor <= 65535)))\n{\nrgb.setColor(255,255,255); // WHITE\n}", "keywords": ["Arduino IDE", "RAK4631", "Light Color Recognizer", "LoRaWAN", "programming"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **Light Color Recognizer** device. Just copy the code below for **Light Color Recognizer LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the example </summary>  \n```c\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h>  //http://librarymanager/All#SX126x\n#include <Wire.h>\n#include <NCP5623.h>//http://librarymanager/All#NCP5623 By:RAKWireless\n#include \"TCS3772.h\"  // Click here to get the library: http://librarymanager/All#TCS37725\n// It use WB_IO2 to power up and is conflicting with INT1, so better use in SlotA/SlotC/SlotD.\n\nNCP5623 rgb;\nTCS3772 tcs3772;\nTCS3772_DataScaled tcs3772_data = {0};\n\nuint16_t scale_factor;\n\nuint16_t redColor;\nuint16_t greenColor;\nuint16_t blueColor;\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define RAK4631_BOARD true\n#else\n#define RAK4631_BOARD false\n#endif\n\nbool doOTAA = true;                                               // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                                       /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                                     /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5                               /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                                        /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;                           /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;                 /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                              /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = { LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF };\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = { BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler };\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0x96, 0xBD, 0xC5, 0x98, 0x17, 0x69, 0x8D, 0xFA, 0x1F, 0x64, 0xFE, 0x1C, 0xF9, 0x26, 0x7F, 0x8D };\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };\nuint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                                            /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];               //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = { m_lora_app_data_buffer, 0, 0, 0, 0 };  //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {\n\n// Initialize Serial for debug output\npinMode(LED_BLUE, OUTPUT);\ndigitalWrite(LED_BLUE, HIGH);\n\n// Sensor Power Switch\npinMode(WB_IO2, OUTPUT);\ndigitalWrite(WB_IO2, HIGH);\n\n// enable RAK14001\npinMode(WB_IO6, OUTPUT);\ndigitalWrite(WB_IO6, HIGH);\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial) {\nif ((millis() - timeout) < 5000) {\ndelay(100);\n} else {\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA) {\nSerial.println(\"Type: OTAA\");\n} else {\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion) {\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA) {\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n} else {\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0) {\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"================================\");\nSerial.println(\"RAK12021 + RAK14001 LoRaWAN Code\");\nSerial.println(\"================================\");\n\n// If using Native I2C\nWire.begin();\nWire.setClock(100000);\n\n// Serial.println(\"RAK14001 + RAK12021\");\n\nif (!rgb.begin())\n{\nSerial.println(\"RAK14001 not found on the I2C line\");\nwhile (1);\n}\nelse\n{\nSerial.println(\"RAK14001 Found. Begining execution\");\n}\n\n// set the current output level max, the range is 1 to 31\nrgb.setCurrent(25);\n\nif(tcs3772.begin() == true)\n{\nSerial.println(\"Found sensor.\");\n}\nelse\n{\nSerial.println(\"TCS37725 not found ... check your connections.\");\nwhile(1)\n{\ndelay(10);\n}\n}\ndelay(1000);\n}\n\nvoid loop() {\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\ntcs3772_data = tcs3772.getMeasurement();\n\nscale_factor = tcs3772.autoGain(tcs3772_data.clear);\n\nredColor = tcs3772_data.red;\ngreenColor = tcs3772_data.green;\nblueColor = tcs3772_data.blue;\n\nrgb.setColor(0,0,0);     // Initially OFF\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\nSerial.print(\"  R: \");\nSerial.println(redColor);\nSerial.print(\"  G: \");\nSerial.println(greenColor);\nSerial.print(\"  B: \");\nSerial.println(blueColor);\n\n// The values of redColor, greenColor and blueColor can be varied during the sensing calibration of RAK12021 module\n\nif (((redColor >= 9000) && (redColor <= 65535)) && ((greenColor >= 10000) && (greenColor <= 65535)) && ((blueColor >= 12000) && (blueColor <= 65535)))\n{\nrgb.setColor(255,255,255); // WHITE\n}\n\nelse if (((redColor >= 4000) && (redColor <= 18000)) && ((greenColor >= 1300) && (greenColor <= 5000)) && ((blueColor >= 950) && (blueColor <= 2000)))\n{\nrgb.setColor(255,255,0);  // YELLOW\n}\n\nelse if (((redColor >= 600) && (redColor <= 2000)) && ((greenColor >= 1700) && (greenColor <= 10000)) && ((blueColor >= 6800) && (blueColor <= 27000)))\n{\nrgb.setColor(0,0,255);    // BLUE\n}\n\nelse if (((redColor >= 1400) && (redColor <= 4000)) && ((greenColor >= 1300) && (greenColor <= 10000)) && ((blueColor >= 950) && (blueColor <= 2700)))\n{\nrgb.setColor(0,255,0);    // GREEN\n}\n\nelse if (((redColor >= 3000) && (redColor <= 20000)) && ((greenColor >= 700) && (greenColor <= 2400)) && ((blueColor >= 950) && (blueColor <= 3000)))\n{\nrgb.setColor(255,0,0);    // RED\n}\n\nelse if ((redColor < 1500) && (greenColor < 1400) && (blueColor < 900))\n{\nrgb.setColor(0,0,0);  // OFF\n}\n\ndelay(5000);\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void) {\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void) {\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data) {\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class) {\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void) {\nif (lmh_join_status_get() != LMH_SET) {\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\n// Showing the values of red, green and blue colors from RAK12021\ndata = \" Red: \" + String(redColor) + \" Green: \" + String(greenColor) + \" Blue: \" + String(blueColor);\n\nSerial.println(data);\n\nuint16_t red_data = redColor;\nuint16_t green_data = greenColor;\nuint16_t blue_data = blueColor;\n\nm_lora_app_data.buffer[i++] = 0x01;  // byte[0]\n\n// Red data\nm_lora_app_data.buffer[i++] = (uint8_t)((red_data & 0x0000FF00) >> 8);     // byte[1]\nm_lora_app_data.buffer[i++] = (uint8_t)(red_data & 0x000000FF);            // byte[2]\n\n// Green data\nm_lora_app_data.buffer[i++] = (uint8_t)((green_data & 0x0000FF00) >> 8);   // byte[3]\nm_lora_app_data.buffer[i++] = (uint8_t)(green_data & 0x000000FF);          // byte[4]\n\n// Blue data\nm_lora_app_data.buffer[i++] = (uint8_t)((blue_data & 0x0000FF00) >> 8);    // byte[5]\nm_lora_app_data.buffer[i++] = (uint8_t)(blue_data & 0x000000FF);           // byte[6]\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS) {\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n} else {\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0x96, 0xBD, 0xC5, 0x98, 0x17, 0x69, 0x8D, 0xFA, 0x1F, 0x64, 0xFE, 0x1C, 0xF9, 0x26, 0x7F, 0x8D };\n```  \n> **Image:** OTAA device successfully registered to TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "857307337bb7f1421f3a6ce8bf0d3aa8", "product_family": "wisblock", "product_id": "kit6-light-and-color", "category": "How-To", "title": "WisBlock IoT Education Kit - Light & Color Quick Start Guide > WisBlock IoT Education Kit - Light & Color Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock IoT Education Kit - Light & Color using TTN and Qubitro > Light Color Recognizer LoRaWAN Application > LoRaWAN Code for Light Color Recognizer > Programming the Light Color Recognizer Device with Arduino IDE [CODE]", "content": "else if (((redColor >= 4000) && (redColor <= 18000)) && ((greenColor >= 1300) && (greenColor <= 5000)) && ((blueColor >= 950) && (blueColor <= 2000)))\n{\nrgb.setColor(255,255,0);  // YELLOW\n}\n\nelse if (((redColor >= 600) && (redColor <= 2000)) && ((greenColor >= 1700) && (greenColor <= 10000)) && ((blueColor >= 6800) && (blueColor <= 27000)))\n{\nrgb.setColor(0,0,255);    // BLUE\n}", "keywords": ["Arduino IDE", "RAK4631", "Light Color Recognizer", "LoRaWAN", "programming"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **Light Color Recognizer** device. Just copy the code below for **Light Color Recognizer LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the example </summary>  \n```c\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h>  //http://librarymanager/All#SX126x\n#include <Wire.h>\n#include <NCP5623.h>//http://librarymanager/All#NCP5623 By:RAKWireless\n#include \"TCS3772.h\"  // Click here to get the library: http://librarymanager/All#TCS37725\n// It use WB_IO2 to power up and is conflicting with INT1, so better use in SlotA/SlotC/SlotD.\n\nNCP5623 rgb;\nTCS3772 tcs3772;\nTCS3772_DataScaled tcs3772_data = {0};\n\nuint16_t scale_factor;\n\nuint16_t redColor;\nuint16_t greenColor;\nuint16_t blueColor;\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define RAK4631_BOARD true\n#else\n#define RAK4631_BOARD false\n#endif\n\nbool doOTAA = true;                                               // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                                       /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                                     /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5                               /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                                        /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;                           /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;                 /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                              /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = { LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF };\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = { BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler };\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0x96, 0xBD, 0xC5, 0x98, 0x17, 0x69, 0x8D, 0xFA, 0x1F, 0x64, 0xFE, 0x1C, 0xF9, 0x26, 0x7F, 0x8D };\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };\nuint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                                            /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];               //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = { m_lora_app_data_buffer, 0, 0, 0, 0 };  //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {\n\n// Initialize Serial for debug output\npinMode(LED_BLUE, OUTPUT);\ndigitalWrite(LED_BLUE, HIGH);\n\n// Sensor Power Switch\npinMode(WB_IO2, OUTPUT);\ndigitalWrite(WB_IO2, HIGH);\n\n// enable RAK14001\npinMode(WB_IO6, OUTPUT);\ndigitalWrite(WB_IO6, HIGH);\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial) {\nif ((millis() - timeout) < 5000) {\ndelay(100);\n} else {\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA) {\nSerial.println(\"Type: OTAA\");\n} else {\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion) {\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA) {\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n} else {\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0) {\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"================================\");\nSerial.println(\"RAK12021 + RAK14001 LoRaWAN Code\");\nSerial.println(\"================================\");\n\n// If using Native I2C\nWire.begin();\nWire.setClock(100000);\n\n// Serial.println(\"RAK14001 + RAK12021\");\n\nif (!rgb.begin())\n{\nSerial.println(\"RAK14001 not found on the I2C line\");\nwhile (1);\n}\nelse\n{\nSerial.println(\"RAK14001 Found. Begining execution\");\n}\n\n// set the current output level max, the range is 1 to 31\nrgb.setCurrent(25);\n\nif(tcs3772.begin() == true)\n{\nSerial.println(\"Found sensor.\");\n}\nelse\n{\nSerial.println(\"TCS37725 not found ... check your connections.\");\nwhile(1)\n{\ndelay(10);\n}\n}\ndelay(1000);\n}\n\nvoid loop() {\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\ntcs3772_data = tcs3772.getMeasurement();\n\nscale_factor = tcs3772.autoGain(tcs3772_data.clear);\n\nredColor = tcs3772_data.red;\ngreenColor = tcs3772_data.green;\nblueColor = tcs3772_data.blue;\n\nrgb.setColor(0,0,0);     // Initially OFF\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\nSerial.print(\"  R: \");\nSerial.println(redColor);\nSerial.print(\"  G: \");\nSerial.println(greenColor);\nSerial.print(\"  B: \");\nSerial.println(blueColor);\n\n// The values of redColor, greenColor and blueColor can be varied during the sensing calibration of RAK12021 module\n\nif (((redColor >= 9000) && (redColor <= 65535)) && ((greenColor >= 10000) && (greenColor <= 65535)) && ((blueColor >= 12000) && (blueColor <= 65535)))\n{\nrgb.setColor(255,255,255); // WHITE\n}\n\nelse if (((redColor >= 4000) && (redColor <= 18000)) && ((greenColor >= 1300) && (greenColor <= 5000)) && ((blueColor >= 950) && (blueColor <= 2000)))\n{\nrgb.setColor(255,255,0);  // YELLOW\n}\n\nelse if (((redColor >= 600) && (redColor <= 2000)) && ((greenColor >= 1700) && (greenColor <= 10000)) && ((blueColor >= 6800) && (blueColor <= 27000)))\n{\nrgb.setColor(0,0,255);    // BLUE\n}\n\nelse if (((redColor >= 1400) && (redColor <= 4000)) && ((greenColor >= 1300) && (greenColor <= 10000)) && ((blueColor >= 950) && (blueColor <= 2700)))\n{\nrgb.setColor(0,255,0);    // GREEN\n}\n\nelse if (((redColor >= 3000) && (redColor <= 20000)) && ((greenColor >= 700) && (greenColor <= 2400)) && ((blueColor >= 950) && (blueColor <= 3000)))\n{\nrgb.setColor(255,0,0);    // RED\n}\n\nelse if ((redColor < 1500) && (greenColor < 1400) && (blueColor < 900))\n{\nrgb.setColor(0,0,0);  // OFF\n}\n\ndelay(5000);\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void) {\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void) {\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data) {\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class) {\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void) {\nif (lmh_join_status_get() != LMH_SET) {\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\n// Showing the values of red, green and blue colors from RAK12021\ndata = \" Red: \" + String(redColor) + \" Green: \" + String(greenColor) + \" Blue: \" + String(blueColor);\n\nSerial.println(data);\n\nuint16_t red_data = redColor;\nuint16_t green_data = greenColor;\nuint16_t blue_data = blueColor;\n\nm_lora_app_data.buffer[i++] = 0x01;  // byte[0]\n\n// Red data\nm_lora_app_data.buffer[i++] = (uint8_t)((red_data & 0x0000FF00) >> 8);     // byte[1]\nm_lora_app_data.buffer[i++] = (uint8_t)(red_data & 0x000000FF);            // byte[2]\n\n// Green data\nm_lora_app_data.buffer[i++] = (uint8_t)((green_data & 0x0000FF00) >> 8);   // byte[3]\nm_lora_app_data.buffer[i++] = (uint8_t)(green_data & 0x000000FF);          // byte[4]\n\n// Blue data\nm_lora_app_data.buffer[i++] = (uint8_t)((blue_data & 0x0000FF00) >> 8);    // byte[5]\nm_lora_app_data.buffer[i++] = (uint8_t)(blue_data & 0x000000FF);           // byte[6]\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS) {\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n} else {\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0x96, 0xBD, 0xC5, 0x98, 0x17, 0x69, 0x8D, 0xFA, 0x1F, 0x64, 0xFE, 0x1C, 0xF9, 0x26, 0x7F, 0x8D };\n```  \n> **Image:** OTAA device successfully registered to TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "603d5b823ca5bd496af62563027b20bd", "product_family": "wisblock", "product_id": "kit6-light-and-color", "category": "How-To", "title": "WisBlock IoT Education Kit - Light & Color Quick Start Guide > WisBlock IoT Education Kit - Light & Color Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock IoT Education Kit - Light & Color using TTN and Qubitro > Light Color Recognizer LoRaWAN Application > LoRaWAN Code for Light Color Recognizer > Programming the Light Color Recognizer Device with Arduino IDE [CODE]", "content": "else if (((redColor >= 1400) && (redColor <= 4000)) && ((greenColor >= 1300) && (greenColor <= 10000)) && ((blueColor >= 950) && (blueColor <= 2700)))\n{\nrgb.setColor(0,255,0);    // GREEN\n}\n\nelse if (((redColor >= 3000) && (redColor <= 20000)) && ((greenColor >= 700) && (greenColor <= 2400)) && ((blueColor >= 950) && (blueColor <= 3000)))\n{\nrgb.setColor(255,0,0);    // RED\n}\n\nelse if ((redColor < 1500) && (greenColor < 1400) && (blueColor < 900))\n{\nrgb.setColor(0,0,0);  // OFF\n}", "keywords": ["Arduino IDE", "RAK4631", "Light Color Recognizer", "LoRaWAN", "programming"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **Light Color Recognizer** device. Just copy the code below for **Light Color Recognizer LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the example </summary>  \n```c\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h>  //http://librarymanager/All#SX126x\n#include <Wire.h>\n#include <NCP5623.h>//http://librarymanager/All#NCP5623 By:RAKWireless\n#include \"TCS3772.h\"  // Click here to get the library: http://librarymanager/All#TCS37725\n// It use WB_IO2 to power up and is conflicting with INT1, so better use in SlotA/SlotC/SlotD.\n\nNCP5623 rgb;\nTCS3772 tcs3772;\nTCS3772_DataScaled tcs3772_data = {0};\n\nuint16_t scale_factor;\n\nuint16_t redColor;\nuint16_t greenColor;\nuint16_t blueColor;\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define RAK4631_BOARD true\n#else\n#define RAK4631_BOARD false\n#endif\n\nbool doOTAA = true;                                               // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                                       /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                                     /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5                               /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                                        /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;                           /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;                 /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                              /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = { LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF };\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = { BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler };\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0x96, 0xBD, 0xC5, 0x98, 0x17, 0x69, 0x8D, 0xFA, 0x1F, 0x64, 0xFE, 0x1C, 0xF9, 0x26, 0x7F, 0x8D };\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };\nuint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                                            /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];               //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = { m_lora_app_data_buffer, 0, 0, 0, 0 };  //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {\n\n// Initialize Serial for debug output\npinMode(LED_BLUE, OUTPUT);\ndigitalWrite(LED_BLUE, HIGH);\n\n// Sensor Power Switch\npinMode(WB_IO2, OUTPUT);\ndigitalWrite(WB_IO2, HIGH);\n\n// enable RAK14001\npinMode(WB_IO6, OUTPUT);\ndigitalWrite(WB_IO6, HIGH);\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial) {\nif ((millis() - timeout) < 5000) {\ndelay(100);\n} else {\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA) {\nSerial.println(\"Type: OTAA\");\n} else {\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion) {\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA) {\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n} else {\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0) {\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"================================\");\nSerial.println(\"RAK12021 + RAK14001 LoRaWAN Code\");\nSerial.println(\"================================\");\n\n// If using Native I2C\nWire.begin();\nWire.setClock(100000);\n\n// Serial.println(\"RAK14001 + RAK12021\");\n\nif (!rgb.begin())\n{\nSerial.println(\"RAK14001 not found on the I2C line\");\nwhile (1);\n}\nelse\n{\nSerial.println(\"RAK14001 Found. Begining execution\");\n}\n\n// set the current output level max, the range is 1 to 31\nrgb.setCurrent(25);\n\nif(tcs3772.begin() == true)\n{\nSerial.println(\"Found sensor.\");\n}\nelse\n{\nSerial.println(\"TCS37725 not found ... check your connections.\");\nwhile(1)\n{\ndelay(10);\n}\n}\ndelay(1000);\n}\n\nvoid loop() {\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\ntcs3772_data = tcs3772.getMeasurement();\n\nscale_factor = tcs3772.autoGain(tcs3772_data.clear);\n\nredColor = tcs3772_data.red;\ngreenColor = tcs3772_data.green;\nblueColor = tcs3772_data.blue;\n\nrgb.setColor(0,0,0);     // Initially OFF\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\nSerial.print(\"  R: \");\nSerial.println(redColor);\nSerial.print(\"  G: \");\nSerial.println(greenColor);\nSerial.print(\"  B: \");\nSerial.println(blueColor);\n\n// The values of redColor, greenColor and blueColor can be varied during the sensing calibration of RAK12021 module\n\nif (((redColor >= 9000) && (redColor <= 65535)) && ((greenColor >= 10000) && (greenColor <= 65535)) && ((blueColor >= 12000) && (blueColor <= 65535)))\n{\nrgb.setColor(255,255,255); // WHITE\n}\n\nelse if (((redColor >= 4000) && (redColor <= 18000)) && ((greenColor >= 1300) && (greenColor <= 5000)) && ((blueColor >= 950) && (blueColor <= 2000)))\n{\nrgb.setColor(255,255,0);  // YELLOW\n}\n\nelse if (((redColor >= 600) && (redColor <= 2000)) && ((greenColor >= 1700) && (greenColor <= 10000)) && ((blueColor >= 6800) && (blueColor <= 27000)))\n{\nrgb.setColor(0,0,255);    // BLUE\n}\n\nelse if (((redColor >= 1400) && (redColor <= 4000)) && ((greenColor >= 1300) && (greenColor <= 10000)) && ((blueColor >= 950) && (blueColor <= 2700)))\n{\nrgb.setColor(0,255,0);    // GREEN\n}\n\nelse if (((redColor >= 3000) && (redColor <= 20000)) && ((greenColor >= 700) && (greenColor <= 2400)) && ((blueColor >= 950) && (blueColor <= 3000)))\n{\nrgb.setColor(255,0,0);    // RED\n}\n\nelse if ((redColor < 1500) && (greenColor < 1400) && (blueColor < 900))\n{\nrgb.setColor(0,0,0);  // OFF\n}\n\ndelay(5000);\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void) {\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void) {\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data) {\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class) {\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void) {\nif (lmh_join_status_get() != LMH_SET) {\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\n// Showing the values of red, green and blue colors from RAK12021\ndata = \" Red: \" + String(redColor) + \" Green: \" + String(greenColor) + \" Blue: \" + String(blueColor);\n\nSerial.println(data);\n\nuint16_t red_data = redColor;\nuint16_t green_data = greenColor;\nuint16_t blue_data = blueColor;\n\nm_lora_app_data.buffer[i++] = 0x01;  // byte[0]\n\n// Red data\nm_lora_app_data.buffer[i++] = (uint8_t)((red_data & 0x0000FF00) >> 8);     // byte[1]\nm_lora_app_data.buffer[i++] = (uint8_t)(red_data & 0x000000FF);            // byte[2]\n\n// Green data\nm_lora_app_data.buffer[i++] = (uint8_t)((green_data & 0x0000FF00) >> 8);   // byte[3]\nm_lora_app_data.buffer[i++] = (uint8_t)(green_data & 0x000000FF);          // byte[4]\n\n// Blue data\nm_lora_app_data.buffer[i++] = (uint8_t)((blue_data & 0x0000FF00) >> 8);    // byte[5]\nm_lora_app_data.buffer[i++] = (uint8_t)(blue_data & 0x000000FF);           // byte[6]\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS) {\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n} else {\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0x96, 0xBD, 0xC5, 0x98, 0x17, 0x69, 0x8D, 0xFA, 0x1F, 0x64, 0xFE, 0x1C, 0xF9, 0x26, 0x7F, 0x8D };\n```  \n> **Image:** OTAA device successfully registered to TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "6f37e45f164a40261f15b44857c7b9f0", "product_family": "wisblock", "product_id": "kit6-light-and-color", "category": "How-To", "title": "WisBlock IoT Education Kit - Light & Color Quick Start Guide > WisBlock IoT Education Kit - Light & Color Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock IoT Education Kit - Light & Color using TTN and Qubitro > Light Color Recognizer LoRaWAN Application > LoRaWAN Code for Light Color Recognizer > Programming the Light Color Recognizer Device with Arduino IDE [CODE]", "content": "delay(5000);\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void) {\nSerial.println(\"OTAA Mode, Network Joined!\");\n}", "keywords": ["Arduino IDE", "RAK4631", "Light Color Recognizer", "LoRaWAN", "programming"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **Light Color Recognizer** device. Just copy the code below for **Light Color Recognizer LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the example </summary>  \n```c\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h>  //http://librarymanager/All#SX126x\n#include <Wire.h>\n#include <NCP5623.h>//http://librarymanager/All#NCP5623 By:RAKWireless\n#include \"TCS3772.h\"  // Click here to get the library: http://librarymanager/All#TCS37725\n// It use WB_IO2 to power up and is conflicting with INT1, so better use in SlotA/SlotC/SlotD.\n\nNCP5623 rgb;\nTCS3772 tcs3772;\nTCS3772_DataScaled tcs3772_data = {0};\n\nuint16_t scale_factor;\n\nuint16_t redColor;\nuint16_t greenColor;\nuint16_t blueColor;\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define RAK4631_BOARD true\n#else\n#define RAK4631_BOARD false\n#endif\n\nbool doOTAA = true;                                               // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                                       /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                                     /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5                               /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                                        /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;                           /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;                 /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                              /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = { LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF };\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = { BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler };\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0x96, 0xBD, 0xC5, 0x98, 0x17, 0x69, 0x8D, 0xFA, 0x1F, 0x64, 0xFE, 0x1C, 0xF9, 0x26, 0x7F, 0x8D };\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };\nuint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                                            /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];               //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = { m_lora_app_data_buffer, 0, 0, 0, 0 };  //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {\n\n// Initialize Serial for debug output\npinMode(LED_BLUE, OUTPUT);\ndigitalWrite(LED_BLUE, HIGH);\n\n// Sensor Power Switch\npinMode(WB_IO2, OUTPUT);\ndigitalWrite(WB_IO2, HIGH);\n\n// enable RAK14001\npinMode(WB_IO6, OUTPUT);\ndigitalWrite(WB_IO6, HIGH);\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial) {\nif ((millis() - timeout) < 5000) {\ndelay(100);\n} else {\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA) {\nSerial.println(\"Type: OTAA\");\n} else {\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion) {\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA) {\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n} else {\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0) {\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"================================\");\nSerial.println(\"RAK12021 + RAK14001 LoRaWAN Code\");\nSerial.println(\"================================\");\n\n// If using Native I2C\nWire.begin();\nWire.setClock(100000);\n\n// Serial.println(\"RAK14001 + RAK12021\");\n\nif (!rgb.begin())\n{\nSerial.println(\"RAK14001 not found on the I2C line\");\nwhile (1);\n}\nelse\n{\nSerial.println(\"RAK14001 Found. Begining execution\");\n}\n\n// set the current output level max, the range is 1 to 31\nrgb.setCurrent(25);\n\nif(tcs3772.begin() == true)\n{\nSerial.println(\"Found sensor.\");\n}\nelse\n{\nSerial.println(\"TCS37725 not found ... check your connections.\");\nwhile(1)\n{\ndelay(10);\n}\n}\ndelay(1000);\n}\n\nvoid loop() {\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\ntcs3772_data = tcs3772.getMeasurement();\n\nscale_factor = tcs3772.autoGain(tcs3772_data.clear);\n\nredColor = tcs3772_data.red;\ngreenColor = tcs3772_data.green;\nblueColor = tcs3772_data.blue;\n\nrgb.setColor(0,0,0);     // Initially OFF\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\nSerial.print(\"  R: \");\nSerial.println(redColor);\nSerial.print(\"  G: \");\nSerial.println(greenColor);\nSerial.print(\"  B: \");\nSerial.println(blueColor);\n\n// The values of redColor, greenColor and blueColor can be varied during the sensing calibration of RAK12021 module\n\nif (((redColor >= 9000) && (redColor <= 65535)) && ((greenColor >= 10000) && (greenColor <= 65535)) && ((blueColor >= 12000) && (blueColor <= 65535)))\n{\nrgb.setColor(255,255,255); // WHITE\n}\n\nelse if (((redColor >= 4000) && (redColor <= 18000)) && ((greenColor >= 1300) && (greenColor <= 5000)) && ((blueColor >= 950) && (blueColor <= 2000)))\n{\nrgb.setColor(255,255,0);  // YELLOW\n}\n\nelse if (((redColor >= 600) && (redColor <= 2000)) && ((greenColor >= 1700) && (greenColor <= 10000)) && ((blueColor >= 6800) && (blueColor <= 27000)))\n{\nrgb.setColor(0,0,255);    // BLUE\n}\n\nelse if (((redColor >= 1400) && (redColor <= 4000)) && ((greenColor >= 1300) && (greenColor <= 10000)) && ((blueColor >= 950) && (blueColor <= 2700)))\n{\nrgb.setColor(0,255,0);    // GREEN\n}\n\nelse if (((redColor >= 3000) && (redColor <= 20000)) && ((greenColor >= 700) && (greenColor <= 2400)) && ((blueColor >= 950) && (blueColor <= 3000)))\n{\nrgb.setColor(255,0,0);    // RED\n}\n\nelse if ((redColor < 1500) && (greenColor < 1400) && (blueColor < 900))\n{\nrgb.setColor(0,0,0);  // OFF\n}\n\ndelay(5000);\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void) {\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void) {\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data) {\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class) {\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void) {\nif (lmh_join_status_get() != LMH_SET) {\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\n// Showing the values of red, green and blue colors from RAK12021\ndata = \" Red: \" + String(redColor) + \" Green: \" + String(greenColor) + \" Blue: \" + String(blueColor);\n\nSerial.println(data);\n\nuint16_t red_data = redColor;\nuint16_t green_data = greenColor;\nuint16_t blue_data = blueColor;\n\nm_lora_app_data.buffer[i++] = 0x01;  // byte[0]\n\n// Red data\nm_lora_app_data.buffer[i++] = (uint8_t)((red_data & 0x0000FF00) >> 8);     // byte[1]\nm_lora_app_data.buffer[i++] = (uint8_t)(red_data & 0x000000FF);            // byte[2]\n\n// Green data\nm_lora_app_data.buffer[i++] = (uint8_t)((green_data & 0x0000FF00) >> 8);   // byte[3]\nm_lora_app_data.buffer[i++] = (uint8_t)(green_data & 0x000000FF);          // byte[4]\n\n// Blue data\nm_lora_app_data.buffer[i++] = (uint8_t)((blue_data & 0x0000FF00) >> 8);    // byte[5]\nm_lora_app_data.buffer[i++] = (uint8_t)(blue_data & 0x000000FF);           // byte[6]\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS) {\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n} else {\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0x96, 0xBD, 0xC5, 0x98, 0x17, 0x69, 0x8D, 0xFA, 0x1F, 0x64, 0xFE, 0x1C, 0xF9, 0x26, 0x7F, 0x8D };\n```  \n> **Image:** OTAA device successfully registered to TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "874e7cf8d64ad29662b470f68d53ca37", "product_family": "wisblock", "product_id": "kit6-light-and-color", "category": "How-To", "title": "WisBlock IoT Education Kit - Light & Color Quick Start Guide > WisBlock IoT Education Kit - Light & Color Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock IoT Education Kit - Light & Color using TTN and Qubitro > Light Color Recognizer LoRaWAN Application > LoRaWAN Code for Light Color Recognizer > Programming the Light Color Recognizer Device with Arduino IDE [CODE]", "content": "/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void) {\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data) {\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",", "keywords": ["Arduino IDE", "RAK4631", "Light Color Recognizer", "LoRaWAN", "programming"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **Light Color Recognizer** device. Just copy the code below for **Light Color Recognizer LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the example </summary>  \n```c\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h>  //http://librarymanager/All#SX126x\n#include <Wire.h>\n#include <NCP5623.h>//http://librarymanager/All#NCP5623 By:RAKWireless\n#include \"TCS3772.h\"  // Click here to get the library: http://librarymanager/All#TCS37725\n// It use WB_IO2 to power up and is conflicting with INT1, so better use in SlotA/SlotC/SlotD.\n\nNCP5623 rgb;\nTCS3772 tcs3772;\nTCS3772_DataScaled tcs3772_data = {0};\n\nuint16_t scale_factor;\n\nuint16_t redColor;\nuint16_t greenColor;\nuint16_t blueColor;\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define RAK4631_BOARD true\n#else\n#define RAK4631_BOARD false\n#endif\n\nbool doOTAA = true;                                               // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                                       /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                                     /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5                               /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                                        /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;                           /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;                 /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                              /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = { LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF };\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = { BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler };\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0x96, 0xBD, 0xC5, 0x98, 0x17, 0x69, 0x8D, 0xFA, 0x1F, 0x64, 0xFE, 0x1C, 0xF9, 0x26, 0x7F, 0x8D };\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };\nuint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                                            /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];               //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = { m_lora_app_data_buffer, 0, 0, 0, 0 };  //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {\n\n// Initialize Serial for debug output\npinMode(LED_BLUE, OUTPUT);\ndigitalWrite(LED_BLUE, HIGH);\n\n// Sensor Power Switch\npinMode(WB_IO2, OUTPUT);\ndigitalWrite(WB_IO2, HIGH);\n\n// enable RAK14001\npinMode(WB_IO6, OUTPUT);\ndigitalWrite(WB_IO6, HIGH);\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial) {\nif ((millis() - timeout) < 5000) {\ndelay(100);\n} else {\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA) {\nSerial.println(\"Type: OTAA\");\n} else {\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion) {\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA) {\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n} else {\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0) {\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"================================\");\nSerial.println(\"RAK12021 + RAK14001 LoRaWAN Code\");\nSerial.println(\"================================\");\n\n// If using Native I2C\nWire.begin();\nWire.setClock(100000);\n\n// Serial.println(\"RAK14001 + RAK12021\");\n\nif (!rgb.begin())\n{\nSerial.println(\"RAK14001 not found on the I2C line\");\nwhile (1);\n}\nelse\n{\nSerial.println(\"RAK14001 Found. Begining execution\");\n}\n\n// set the current output level max, the range is 1 to 31\nrgb.setCurrent(25);\n\nif(tcs3772.begin() == true)\n{\nSerial.println(\"Found sensor.\");\n}\nelse\n{\nSerial.println(\"TCS37725 not found ... check your connections.\");\nwhile(1)\n{\ndelay(10);\n}\n}\ndelay(1000);\n}\n\nvoid loop() {\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\ntcs3772_data = tcs3772.getMeasurement();\n\nscale_factor = tcs3772.autoGain(tcs3772_data.clear);\n\nredColor = tcs3772_data.red;\ngreenColor = tcs3772_data.green;\nblueColor = tcs3772_data.blue;\n\nrgb.setColor(0,0,0);     // Initially OFF\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\nSerial.print(\"  R: \");\nSerial.println(redColor);\nSerial.print(\"  G: \");\nSerial.println(greenColor);\nSerial.print(\"  B: \");\nSerial.println(blueColor);\n\n// The values of redColor, greenColor and blueColor can be varied during the sensing calibration of RAK12021 module\n\nif (((redColor >= 9000) && (redColor <= 65535)) && ((greenColor >= 10000) && (greenColor <= 65535)) && ((blueColor >= 12000) && (blueColor <= 65535)))\n{\nrgb.setColor(255,255,255); // WHITE\n}\n\nelse if (((redColor >= 4000) && (redColor <= 18000)) && ((greenColor >= 1300) && (greenColor <= 5000)) && ((blueColor >= 950) && (blueColor <= 2000)))\n{\nrgb.setColor(255,255,0);  // YELLOW\n}\n\nelse if (((redColor >= 600) && (redColor <= 2000)) && ((greenColor >= 1700) && (greenColor <= 10000)) && ((blueColor >= 6800) && (blueColor <= 27000)))\n{\nrgb.setColor(0,0,255);    // BLUE\n}\n\nelse if (((redColor >= 1400) && (redColor <= 4000)) && ((greenColor >= 1300) && (greenColor <= 10000)) && ((blueColor >= 950) && (blueColor <= 2700)))\n{\nrgb.setColor(0,255,0);    // GREEN\n}\n\nelse if (((redColor >= 3000) && (redColor <= 20000)) && ((greenColor >= 700) && (greenColor <= 2400)) && ((blueColor >= 950) && (blueColor <= 3000)))\n{\nrgb.setColor(255,0,0);    // RED\n}\n\nelse if ((redColor < 1500) && (greenColor < 1400) && (blueColor < 900))\n{\nrgb.setColor(0,0,0);  // OFF\n}\n\ndelay(5000);\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void) {\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void) {\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data) {\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class) {\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void) {\nif (lmh_join_status_get() != LMH_SET) {\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\n// Showing the values of red, green and blue colors from RAK12021\ndata = \" Red: \" + String(redColor) + \" Green: \" + String(greenColor) + \" Blue: \" + String(blueColor);\n\nSerial.println(data);\n\nuint16_t red_data = redColor;\nuint16_t green_data = greenColor;\nuint16_t blue_data = blueColor;\n\nm_lora_app_data.buffer[i++] = 0x01;  // byte[0]\n\n// Red data\nm_lora_app_data.buffer[i++] = (uint8_t)((red_data & 0x0000FF00) >> 8);     // byte[1]\nm_lora_app_data.buffer[i++] = (uint8_t)(red_data & 0x000000FF);            // byte[2]\n\n// Green data\nm_lora_app_data.buffer[i++] = (uint8_t)((green_data & 0x0000FF00) >> 8);   // byte[3]\nm_lora_app_data.buffer[i++] = (uint8_t)(green_data & 0x000000FF);          // byte[4]\n\n// Blue data\nm_lora_app_data.buffer[i++] = (uint8_t)((blue_data & 0x0000FF00) >> 8);    // byte[5]\nm_lora_app_data.buffer[i++] = (uint8_t)(blue_data & 0x000000FF);           // byte[6]\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS) {\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n} else {\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0x96, 0xBD, 0xC5, 0x98, 0x17, 0x69, 0x8D, 0xFA, 0x1F, 0x64, 0xFE, 0x1C, 0xF9, 0x26, 0x7F, 0x8D };\n```  \n> **Image:** OTAA device successfully registered to TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "1d23217eb742f77244c8cb15e806e9b8", "product_family": "wisblock", "product_id": "kit6-light-and-color", "category": "How-To", "title": "WisBlock IoT Education Kit - Light & Color Quick Start Guide > WisBlock IoT Education Kit - Light & Color Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock IoT Education Kit - Light & Color using TTN and Qubitro > Light Color Recognizer LoRaWAN Application > LoRaWAN Code for Light Color Recognizer > Programming the Light Color Recognizer Device with Arduino IDE [CODE]", "content": "Serial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}", "keywords": ["Arduino IDE", "RAK4631", "Light Color Recognizer", "LoRaWAN", "programming"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **Light Color Recognizer** device. Just copy the code below for **Light Color Recognizer LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the example </summary>  \n```c\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h>  //http://librarymanager/All#SX126x\n#include <Wire.h>\n#include <NCP5623.h>//http://librarymanager/All#NCP5623 By:RAKWireless\n#include \"TCS3772.h\"  // Click here to get the library: http://librarymanager/All#TCS37725\n// It use WB_IO2 to power up and is conflicting with INT1, so better use in SlotA/SlotC/SlotD.\n\nNCP5623 rgb;\nTCS3772 tcs3772;\nTCS3772_DataScaled tcs3772_data = {0};\n\nuint16_t scale_factor;\n\nuint16_t redColor;\nuint16_t greenColor;\nuint16_t blueColor;\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define RAK4631_BOARD true\n#else\n#define RAK4631_BOARD false\n#endif\n\nbool doOTAA = true;                                               // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                                       /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                                     /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5                               /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                                        /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;                           /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;                 /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                              /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = { LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF };\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = { BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler };\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0x96, 0xBD, 0xC5, 0x98, 0x17, 0x69, 0x8D, 0xFA, 0x1F, 0x64, 0xFE, 0x1C, 0xF9, 0x26, 0x7F, 0x8D };\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };\nuint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                                            /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];               //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = { m_lora_app_data_buffer, 0, 0, 0, 0 };  //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {\n\n// Initialize Serial for debug output\npinMode(LED_BLUE, OUTPUT);\ndigitalWrite(LED_BLUE, HIGH);\n\n// Sensor Power Switch\npinMode(WB_IO2, OUTPUT);\ndigitalWrite(WB_IO2, HIGH);\n\n// enable RAK14001\npinMode(WB_IO6, OUTPUT);\ndigitalWrite(WB_IO6, HIGH);\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial) {\nif ((millis() - timeout) < 5000) {\ndelay(100);\n} else {\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA) {\nSerial.println(\"Type: OTAA\");\n} else {\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion) {\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA) {\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n} else {\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0) {\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"================================\");\nSerial.println(\"RAK12021 + RAK14001 LoRaWAN Code\");\nSerial.println(\"================================\");\n\n// If using Native I2C\nWire.begin();\nWire.setClock(100000);\n\n// Serial.println(\"RAK14001 + RAK12021\");\n\nif (!rgb.begin())\n{\nSerial.println(\"RAK14001 not found on the I2C line\");\nwhile (1);\n}\nelse\n{\nSerial.println(\"RAK14001 Found. Begining execution\");\n}\n\n// set the current output level max, the range is 1 to 31\nrgb.setCurrent(25);\n\nif(tcs3772.begin() == true)\n{\nSerial.println(\"Found sensor.\");\n}\nelse\n{\nSerial.println(\"TCS37725 not found ... check your connections.\");\nwhile(1)\n{\ndelay(10);\n}\n}\ndelay(1000);\n}\n\nvoid loop() {\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\ntcs3772_data = tcs3772.getMeasurement();\n\nscale_factor = tcs3772.autoGain(tcs3772_data.clear);\n\nredColor = tcs3772_data.red;\ngreenColor = tcs3772_data.green;\nblueColor = tcs3772_data.blue;\n\nrgb.setColor(0,0,0);     // Initially OFF\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\nSerial.print(\"  R: \");\nSerial.println(redColor);\nSerial.print(\"  G: \");\nSerial.println(greenColor);\nSerial.print(\"  B: \");\nSerial.println(blueColor);\n\n// The values of redColor, greenColor and blueColor can be varied during the sensing calibration of RAK12021 module\n\nif (((redColor >= 9000) && (redColor <= 65535)) && ((greenColor >= 10000) && (greenColor <= 65535)) && ((blueColor >= 12000) && (blueColor <= 65535)))\n{\nrgb.setColor(255,255,255); // WHITE\n}\n\nelse if (((redColor >= 4000) && (redColor <= 18000)) && ((greenColor >= 1300) && (greenColor <= 5000)) && ((blueColor >= 950) && (blueColor <= 2000)))\n{\nrgb.setColor(255,255,0);  // YELLOW\n}\n\nelse if (((redColor >= 600) && (redColor <= 2000)) && ((greenColor >= 1700) && (greenColor <= 10000)) && ((blueColor >= 6800) && (blueColor <= 27000)))\n{\nrgb.setColor(0,0,255);    // BLUE\n}\n\nelse if (((redColor >= 1400) && (redColor <= 4000)) && ((greenColor >= 1300) && (greenColor <= 10000)) && ((blueColor >= 950) && (blueColor <= 2700)))\n{\nrgb.setColor(0,255,0);    // GREEN\n}\n\nelse if (((redColor >= 3000) && (redColor <= 20000)) && ((greenColor >= 700) && (greenColor <= 2400)) && ((blueColor >= 950) && (blueColor <= 3000)))\n{\nrgb.setColor(255,0,0);    // RED\n}\n\nelse if ((redColor < 1500) && (greenColor < 1400) && (blueColor < 900))\n{\nrgb.setColor(0,0,0);  // OFF\n}\n\ndelay(5000);\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void) {\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void) {\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data) {\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class) {\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void) {\nif (lmh_join_status_get() != LMH_SET) {\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\n// Showing the values of red, green and blue colors from RAK12021\ndata = \" Red: \" + String(redColor) + \" Green: \" + String(greenColor) + \" Blue: \" + String(blueColor);\n\nSerial.println(data);\n\nuint16_t red_data = redColor;\nuint16_t green_data = greenColor;\nuint16_t blue_data = blueColor;\n\nm_lora_app_data.buffer[i++] = 0x01;  // byte[0]\n\n// Red data\nm_lora_app_data.buffer[i++] = (uint8_t)((red_data & 0x0000FF00) >> 8);     // byte[1]\nm_lora_app_data.buffer[i++] = (uint8_t)(red_data & 0x000000FF);            // byte[2]\n\n// Green data\nm_lora_app_data.buffer[i++] = (uint8_t)((green_data & 0x0000FF00) >> 8);   // byte[3]\nm_lora_app_data.buffer[i++] = (uint8_t)(green_data & 0x000000FF);          // byte[4]\n\n// Blue data\nm_lora_app_data.buffer[i++] = (uint8_t)((blue_data & 0x0000FF00) >> 8);    // byte[5]\nm_lora_app_data.buffer[i++] = (uint8_t)(blue_data & 0x000000FF);           // byte[6]\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS) {\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n} else {\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0x96, 0xBD, 0xC5, 0x98, 0x17, 0x69, 0x8D, 0xFA, 0x1F, 0x64, 0xFE, 0x1C, 0xF9, 0x26, 0x7F, 0x8D };\n```  \n> **Image:** OTAA device successfully registered to TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "a947c488d1733f8b79942785a4d6e6f0", "product_family": "wisblock", "product_id": "kit6-light-and-color", "category": "How-To", "title": "WisBlock IoT Education Kit - Light & Color Quick Start Guide > WisBlock IoT Education Kit - Light & Color Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock IoT Education Kit - Light & Color using TTN and Qubitro > Light Color Recognizer LoRaWAN Application > LoRaWAN Code for Light Color Recognizer > Programming the Light Color Recognizer Device with Arduino IDE [CODE]", "content": "void lorawan_confirm_class_handler(DeviceClass_t Class) {\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void) {\nif (lmh_join_status_get() != LMH_SET) {\n//Not joined, try again later\nreturn;\n}", "keywords": ["Arduino IDE", "RAK4631", "Light Color Recognizer", "LoRaWAN", "programming"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **Light Color Recognizer** device. Just copy the code below for **Light Color Recognizer LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the example </summary>  \n```c\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h>  //http://librarymanager/All#SX126x\n#include <Wire.h>\n#include <NCP5623.h>//http://librarymanager/All#NCP5623 By:RAKWireless\n#include \"TCS3772.h\"  // Click here to get the library: http://librarymanager/All#TCS37725\n// It use WB_IO2 to power up and is conflicting with INT1, so better use in SlotA/SlotC/SlotD.\n\nNCP5623 rgb;\nTCS3772 tcs3772;\nTCS3772_DataScaled tcs3772_data = {0};\n\nuint16_t scale_factor;\n\nuint16_t redColor;\nuint16_t greenColor;\nuint16_t blueColor;\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define RAK4631_BOARD true\n#else\n#define RAK4631_BOARD false\n#endif\n\nbool doOTAA = true;                                               // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                                       /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                                     /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5                               /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                                        /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;                           /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;                 /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                              /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = { LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF };\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = { BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler };\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0x96, 0xBD, 0xC5, 0x98, 0x17, 0x69, 0x8D, 0xFA, 0x1F, 0x64, 0xFE, 0x1C, 0xF9, 0x26, 0x7F, 0x8D };\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };\nuint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                                            /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];               //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = { m_lora_app_data_buffer, 0, 0, 0, 0 };  //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {\n\n// Initialize Serial for debug output\npinMode(LED_BLUE, OUTPUT);\ndigitalWrite(LED_BLUE, HIGH);\n\n// Sensor Power Switch\npinMode(WB_IO2, OUTPUT);\ndigitalWrite(WB_IO2, HIGH);\n\n// enable RAK14001\npinMode(WB_IO6, OUTPUT);\ndigitalWrite(WB_IO6, HIGH);\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial) {\nif ((millis() - timeout) < 5000) {\ndelay(100);\n} else {\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA) {\nSerial.println(\"Type: OTAA\");\n} else {\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion) {\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA) {\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n} else {\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0) {\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"================================\");\nSerial.println(\"RAK12021 + RAK14001 LoRaWAN Code\");\nSerial.println(\"================================\");\n\n// If using Native I2C\nWire.begin();\nWire.setClock(100000);\n\n// Serial.println(\"RAK14001 + RAK12021\");\n\nif (!rgb.begin())\n{\nSerial.println(\"RAK14001 not found on the I2C line\");\nwhile (1);\n}\nelse\n{\nSerial.println(\"RAK14001 Found. Begining execution\");\n}\n\n// set the current output level max, the range is 1 to 31\nrgb.setCurrent(25);\n\nif(tcs3772.begin() == true)\n{\nSerial.println(\"Found sensor.\");\n}\nelse\n{\nSerial.println(\"TCS37725 not found ... check your connections.\");\nwhile(1)\n{\ndelay(10);\n}\n}\ndelay(1000);\n}\n\nvoid loop() {\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\ntcs3772_data = tcs3772.getMeasurement();\n\nscale_factor = tcs3772.autoGain(tcs3772_data.clear);\n\nredColor = tcs3772_data.red;\ngreenColor = tcs3772_data.green;\nblueColor = tcs3772_data.blue;\n\nrgb.setColor(0,0,0);     // Initially OFF\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\nSerial.print(\"  R: \");\nSerial.println(redColor);\nSerial.print(\"  G: \");\nSerial.println(greenColor);\nSerial.print(\"  B: \");\nSerial.println(blueColor);\n\n// The values of redColor, greenColor and blueColor can be varied during the sensing calibration of RAK12021 module\n\nif (((redColor >= 9000) && (redColor <= 65535)) && ((greenColor >= 10000) && (greenColor <= 65535)) && ((blueColor >= 12000) && (blueColor <= 65535)))\n{\nrgb.setColor(255,255,255); // WHITE\n}\n\nelse if (((redColor >= 4000) && (redColor <= 18000)) && ((greenColor >= 1300) && (greenColor <= 5000)) && ((blueColor >= 950) && (blueColor <= 2000)))\n{\nrgb.setColor(255,255,0);  // YELLOW\n}\n\nelse if (((redColor >= 600) && (redColor <= 2000)) && ((greenColor >= 1700) && (greenColor <= 10000)) && ((blueColor >= 6800) && (blueColor <= 27000)))\n{\nrgb.setColor(0,0,255);    // BLUE\n}\n\nelse if (((redColor >= 1400) && (redColor <= 4000)) && ((greenColor >= 1300) && (greenColor <= 10000)) && ((blueColor >= 950) && (blueColor <= 2700)))\n{\nrgb.setColor(0,255,0);    // GREEN\n}\n\nelse if (((redColor >= 3000) && (redColor <= 20000)) && ((greenColor >= 700) && (greenColor <= 2400)) && ((blueColor >= 950) && (blueColor <= 3000)))\n{\nrgb.setColor(255,0,0);    // RED\n}\n\nelse if ((redColor < 1500) && (greenColor < 1400) && (blueColor < 900))\n{\nrgb.setColor(0,0,0);  // OFF\n}\n\ndelay(5000);\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void) {\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void) {\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data) {\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class) {\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void) {\nif (lmh_join_status_get() != LMH_SET) {\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\n// Showing the values of red, green and blue colors from RAK12021\ndata = \" Red: \" + String(redColor) + \" Green: \" + String(greenColor) + \" Blue: \" + String(blueColor);\n\nSerial.println(data);\n\nuint16_t red_data = redColor;\nuint16_t green_data = greenColor;\nuint16_t blue_data = blueColor;\n\nm_lora_app_data.buffer[i++] = 0x01;  // byte[0]\n\n// Red data\nm_lora_app_data.buffer[i++] = (uint8_t)((red_data & 0x0000FF00) >> 8);     // byte[1]\nm_lora_app_data.buffer[i++] = (uint8_t)(red_data & 0x000000FF);            // byte[2]\n\n// Green data\nm_lora_app_data.buffer[i++] = (uint8_t)((green_data & 0x0000FF00) >> 8);   // byte[3]\nm_lora_app_data.buffer[i++] = (uint8_t)(green_data & 0x000000FF);          // byte[4]\n\n// Blue data\nm_lora_app_data.buffer[i++] = (uint8_t)((blue_data & 0x0000FF00) >> 8);    // byte[5]\nm_lora_app_data.buffer[i++] = (uint8_t)(blue_data & 0x000000FF);           // byte[6]\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS) {\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n} else {\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0x96, 0xBD, 0xC5, 0x98, 0x17, 0x69, 0x8D, 0xFA, 0x1F, 0x64, 0xFE, 0x1C, 0xF9, 0x26, 0x7F, 0x8D };\n```  \n> **Image:** OTAA device successfully registered to TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "bb48981bcc199ef47881b3b4c2f15422", "product_family": "wisblock", "product_id": "kit6-light-and-color", "category": "How-To", "title": "WisBlock IoT Education Kit - Light & Color Quick Start Guide > WisBlock IoT Education Kit - Light & Color Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock IoT Education Kit - Light & Color using TTN and Qubitro > Light Color Recognizer LoRaWAN Application > LoRaWAN Code for Light Color Recognizer > Programming the Light Color Recognizer Device with Arduino IDE [CODE]", "content": "Serial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\n// Showing the values of red, green and blue colors from RAK12021\ndata = \" Red: \" + String(redColor) + \" Green: \" + String(greenColor) + \" Blue: \" + String(blueColor);\n\nSerial.println(data);\n\nuint16_t red_data = redColor;\nuint16_t green_data = greenColor;\nuint16_t blue_data = blueColor;\n\nm_lora_app_data.buffer[i++] = 0x01;  // byte[0]", "keywords": ["Arduino IDE", "RAK4631", "Light Color Recognizer", "LoRaWAN", "programming"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **Light Color Recognizer** device. Just copy the code below for **Light Color Recognizer LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the example </summary>  \n```c\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h>  //http://librarymanager/All#SX126x\n#include <Wire.h>\n#include <NCP5623.h>//http://librarymanager/All#NCP5623 By:RAKWireless\n#include \"TCS3772.h\"  // Click here to get the library: http://librarymanager/All#TCS37725\n// It use WB_IO2 to power up and is conflicting with INT1, so better use in SlotA/SlotC/SlotD.\n\nNCP5623 rgb;\nTCS3772 tcs3772;\nTCS3772_DataScaled tcs3772_data = {0};\n\nuint16_t scale_factor;\n\nuint16_t redColor;\nuint16_t greenColor;\nuint16_t blueColor;\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define RAK4631_BOARD true\n#else\n#define RAK4631_BOARD false\n#endif\n\nbool doOTAA = true;                                               // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                                       /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                                     /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5                               /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                                        /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;                           /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;                 /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                              /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = { LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF };\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = { BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler };\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0x96, 0xBD, 0xC5, 0x98, 0x17, 0x69, 0x8D, 0xFA, 0x1F, 0x64, 0xFE, 0x1C, 0xF9, 0x26, 0x7F, 0x8D };\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };\nuint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                                            /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];               //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = { m_lora_app_data_buffer, 0, 0, 0, 0 };  //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {\n\n// Initialize Serial for debug output\npinMode(LED_BLUE, OUTPUT);\ndigitalWrite(LED_BLUE, HIGH);\n\n// Sensor Power Switch\npinMode(WB_IO2, OUTPUT);\ndigitalWrite(WB_IO2, HIGH);\n\n// enable RAK14001\npinMode(WB_IO6, OUTPUT);\ndigitalWrite(WB_IO6, HIGH);\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial) {\nif ((millis() - timeout) < 5000) {\ndelay(100);\n} else {\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA) {\nSerial.println(\"Type: OTAA\");\n} else {\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion) {\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA) {\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n} else {\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0) {\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"================================\");\nSerial.println(\"RAK12021 + RAK14001 LoRaWAN Code\");\nSerial.println(\"================================\");\n\n// If using Native I2C\nWire.begin();\nWire.setClock(100000);\n\n// Serial.println(\"RAK14001 + RAK12021\");\n\nif (!rgb.begin())\n{\nSerial.println(\"RAK14001 not found on the I2C line\");\nwhile (1);\n}\nelse\n{\nSerial.println(\"RAK14001 Found. Begining execution\");\n}\n\n// set the current output level max, the range is 1 to 31\nrgb.setCurrent(25);\n\nif(tcs3772.begin() == true)\n{\nSerial.println(\"Found sensor.\");\n}\nelse\n{\nSerial.println(\"TCS37725 not found ... check your connections.\");\nwhile(1)\n{\ndelay(10);\n}\n}\ndelay(1000);\n}\n\nvoid loop() {\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\ntcs3772_data = tcs3772.getMeasurement();\n\nscale_factor = tcs3772.autoGain(tcs3772_data.clear);\n\nredColor = tcs3772_data.red;\ngreenColor = tcs3772_data.green;\nblueColor = tcs3772_data.blue;\n\nrgb.setColor(0,0,0);     // Initially OFF\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\nSerial.print(\"  R: \");\nSerial.println(redColor);\nSerial.print(\"  G: \");\nSerial.println(greenColor);\nSerial.print(\"  B: \");\nSerial.println(blueColor);\n\n// The values of redColor, greenColor and blueColor can be varied during the sensing calibration of RAK12021 module\n\nif (((redColor >= 9000) && (redColor <= 65535)) && ((greenColor >= 10000) && (greenColor <= 65535)) && ((blueColor >= 12000) && (blueColor <= 65535)))\n{\nrgb.setColor(255,255,255); // WHITE\n}\n\nelse if (((redColor >= 4000) && (redColor <= 18000)) && ((greenColor >= 1300) && (greenColor <= 5000)) && ((blueColor >= 950) && (blueColor <= 2000)))\n{\nrgb.setColor(255,255,0);  // YELLOW\n}\n\nelse if (((redColor >= 600) && (redColor <= 2000)) && ((greenColor >= 1700) && (greenColor <= 10000)) && ((blueColor >= 6800) && (blueColor <= 27000)))\n{\nrgb.setColor(0,0,255);    // BLUE\n}\n\nelse if (((redColor >= 1400) && (redColor <= 4000)) && ((greenColor >= 1300) && (greenColor <= 10000)) && ((blueColor >= 950) && (blueColor <= 2700)))\n{\nrgb.setColor(0,255,0);    // GREEN\n}\n\nelse if (((redColor >= 3000) && (redColor <= 20000)) && ((greenColor >= 700) && (greenColor <= 2400)) && ((blueColor >= 950) && (blueColor <= 3000)))\n{\nrgb.setColor(255,0,0);    // RED\n}\n\nelse if ((redColor < 1500) && (greenColor < 1400) && (blueColor < 900))\n{\nrgb.setColor(0,0,0);  // OFF\n}\n\ndelay(5000);\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void) {\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void) {\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data) {\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class) {\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void) {\nif (lmh_join_status_get() != LMH_SET) {\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\n// Showing the values of red, green and blue colors from RAK12021\ndata = \" Red: \" + String(redColor) + \" Green: \" + String(greenColor) + \" Blue: \" + String(blueColor);\n\nSerial.println(data);\n\nuint16_t red_data = redColor;\nuint16_t green_data = greenColor;\nuint16_t blue_data = blueColor;\n\nm_lora_app_data.buffer[i++] = 0x01;  // byte[0]\n\n// Red data\nm_lora_app_data.buffer[i++] = (uint8_t)((red_data & 0x0000FF00) >> 8);     // byte[1]\nm_lora_app_data.buffer[i++] = (uint8_t)(red_data & 0x000000FF);            // byte[2]\n\n// Green data\nm_lora_app_data.buffer[i++] = (uint8_t)((green_data & 0x0000FF00) >> 8);   // byte[3]\nm_lora_app_data.buffer[i++] = (uint8_t)(green_data & 0x000000FF);          // byte[4]\n\n// Blue data\nm_lora_app_data.buffer[i++] = (uint8_t)((blue_data & 0x0000FF00) >> 8);    // byte[5]\nm_lora_app_data.buffer[i++] = (uint8_t)(blue_data & 0x000000FF);           // byte[6]\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS) {\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n} else {\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0x96, 0xBD, 0xC5, 0x98, 0x17, 0x69, 0x8D, 0xFA, 0x1F, 0x64, 0xFE, 0x1C, 0xF9, 0x26, 0x7F, 0x8D };\n```  \n> **Image:** OTAA device successfully registered to TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "e8efed62eb0d91863c974a6f837e495d", "product_family": "wisblock", "product_id": "kit6-light-and-color", "category": "How-To", "title": "WisBlock IoT Education Kit - Light & Color Quick Start Guide > WisBlock IoT Education Kit - Light & Color Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock IoT Education Kit - Light & Color using TTN and Qubitro > Light Color Recognizer LoRaWAN Application > LoRaWAN Code for Light Color Recognizer > Programming the Light Color Recognizer Device with Arduino IDE [CODE]", "content": "m_lora_app_data.buffer[i++] = 0x01;  // byte[0]\n\n// Red data\nm_lora_app_data.buffer[i++] = (uint8_t)((red_data & 0x0000FF00) >> 8);     // byte[1]\nm_lora_app_data.buffer[i++] = (uint8_t)(red_data & 0x000000FF);            // byte[2]\n\n// Green data\nm_lora_app_data.buffer[i++] = (uint8_t)((green_data & 0x0000FF00) >> 8);   // byte[3]\nm_lora_app_data.buffer[i++] = (uint8_t)(green_data & 0x000000FF);          // byte[4]", "keywords": ["Arduino IDE", "RAK4631", "Light Color Recognizer", "LoRaWAN", "programming"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **Light Color Recognizer** device. Just copy the code below for **Light Color Recognizer LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the example </summary>  \n```c\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h>  //http://librarymanager/All#SX126x\n#include <Wire.h>\n#include <NCP5623.h>//http://librarymanager/All#NCP5623 By:RAKWireless\n#include \"TCS3772.h\"  // Click here to get the library: http://librarymanager/All#TCS37725\n// It use WB_IO2 to power up and is conflicting with INT1, so better use in SlotA/SlotC/SlotD.\n\nNCP5623 rgb;\nTCS3772 tcs3772;\nTCS3772_DataScaled tcs3772_data = {0};\n\nuint16_t scale_factor;\n\nuint16_t redColor;\nuint16_t greenColor;\nuint16_t blueColor;\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define RAK4631_BOARD true\n#else\n#define RAK4631_BOARD false\n#endif\n\nbool doOTAA = true;                                               // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                                       /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                                     /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5                               /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                                        /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;                           /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;                 /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                              /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = { LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF };\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = { BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler };\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0x96, 0xBD, 0xC5, 0x98, 0x17, 0x69, 0x8D, 0xFA, 0x1F, 0x64, 0xFE, 0x1C, 0xF9, 0x26, 0x7F, 0x8D };\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };\nuint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                                            /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];               //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = { m_lora_app_data_buffer, 0, 0, 0, 0 };  //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {\n\n// Initialize Serial for debug output\npinMode(LED_BLUE, OUTPUT);\ndigitalWrite(LED_BLUE, HIGH);\n\n// Sensor Power Switch\npinMode(WB_IO2, OUTPUT);\ndigitalWrite(WB_IO2, HIGH);\n\n// enable RAK14001\npinMode(WB_IO6, OUTPUT);\ndigitalWrite(WB_IO6, HIGH);\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial) {\nif ((millis() - timeout) < 5000) {\ndelay(100);\n} else {\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA) {\nSerial.println(\"Type: OTAA\");\n} else {\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion) {\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA) {\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n} else {\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0) {\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"================================\");\nSerial.println(\"RAK12021 + RAK14001 LoRaWAN Code\");\nSerial.println(\"================================\");\n\n// If using Native I2C\nWire.begin();\nWire.setClock(100000);\n\n// Serial.println(\"RAK14001 + RAK12021\");\n\nif (!rgb.begin())\n{\nSerial.println(\"RAK14001 not found on the I2C line\");\nwhile (1);\n}\nelse\n{\nSerial.println(\"RAK14001 Found. Begining execution\");\n}\n\n// set the current output level max, the range is 1 to 31\nrgb.setCurrent(25);\n\nif(tcs3772.begin() == true)\n{\nSerial.println(\"Found sensor.\");\n}\nelse\n{\nSerial.println(\"TCS37725 not found ... check your connections.\");\nwhile(1)\n{\ndelay(10);\n}\n}\ndelay(1000);\n}\n\nvoid loop() {\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\ntcs3772_data = tcs3772.getMeasurement();\n\nscale_factor = tcs3772.autoGain(tcs3772_data.clear);\n\nredColor = tcs3772_data.red;\ngreenColor = tcs3772_data.green;\nblueColor = tcs3772_data.blue;\n\nrgb.setColor(0,0,0);     // Initially OFF\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\nSerial.print(\"  R: \");\nSerial.println(redColor);\nSerial.print(\"  G: \");\nSerial.println(greenColor);\nSerial.print(\"  B: \");\nSerial.println(blueColor);\n\n// The values of redColor, greenColor and blueColor can be varied during the sensing calibration of RAK12021 module\n\nif (((redColor >= 9000) && (redColor <= 65535)) && ((greenColor >= 10000) && (greenColor <= 65535)) && ((blueColor >= 12000) && (blueColor <= 65535)))\n{\nrgb.setColor(255,255,255); // WHITE\n}\n\nelse if (((redColor >= 4000) && (redColor <= 18000)) && ((greenColor >= 1300) && (greenColor <= 5000)) && ((blueColor >= 950) && (blueColor <= 2000)))\n{\nrgb.setColor(255,255,0);  // YELLOW\n}\n\nelse if (((redColor >= 600) && (redColor <= 2000)) && ((greenColor >= 1700) && (greenColor <= 10000)) && ((blueColor >= 6800) && (blueColor <= 27000)))\n{\nrgb.setColor(0,0,255);    // BLUE\n}\n\nelse if (((redColor >= 1400) && (redColor <= 4000)) && ((greenColor >= 1300) && (greenColor <= 10000)) && ((blueColor >= 950) && (blueColor <= 2700)))\n{\nrgb.setColor(0,255,0);    // GREEN\n}\n\nelse if (((redColor >= 3000) && (redColor <= 20000)) && ((greenColor >= 700) && (greenColor <= 2400)) && ((blueColor >= 950) && (blueColor <= 3000)))\n{\nrgb.setColor(255,0,0);    // RED\n}\n\nelse if ((redColor < 1500) && (greenColor < 1400) && (blueColor < 900))\n{\nrgb.setColor(0,0,0);  // OFF\n}\n\ndelay(5000);\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void) {\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void) {\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data) {\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class) {\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void) {\nif (lmh_join_status_get() != LMH_SET) {\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\n// Showing the values of red, green and blue colors from RAK12021\ndata = \" Red: \" + String(redColor) + \" Green: \" + String(greenColor) + \" Blue: \" + String(blueColor);\n\nSerial.println(data);\n\nuint16_t red_data = redColor;\nuint16_t green_data = greenColor;\nuint16_t blue_data = blueColor;\n\nm_lora_app_data.buffer[i++] = 0x01;  // byte[0]\n\n// Red data\nm_lora_app_data.buffer[i++] = (uint8_t)((red_data & 0x0000FF00) >> 8);     // byte[1]\nm_lora_app_data.buffer[i++] = (uint8_t)(red_data & 0x000000FF);            // byte[2]\n\n// Green data\nm_lora_app_data.buffer[i++] = (uint8_t)((green_data & 0x0000FF00) >> 8);   // byte[3]\nm_lora_app_data.buffer[i++] = (uint8_t)(green_data & 0x000000FF);          // byte[4]\n\n// Blue data\nm_lora_app_data.buffer[i++] = (uint8_t)((blue_data & 0x0000FF00) >> 8);    // byte[5]\nm_lora_app_data.buffer[i++] = (uint8_t)(blue_data & 0x000000FF);           // byte[6]\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS) {\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n} else {\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0x96, 0xBD, 0xC5, 0x98, 0x17, 0x69, 0x8D, 0xFA, 0x1F, 0x64, 0xFE, 0x1C, 0xF9, 0x26, 0x7F, 0x8D };\n```  \n> **Image:** OTAA device successfully registered to TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "3b15f01304c51c8d14b53ef5faf02273", "product_family": "wisblock", "product_id": "kit6-light-and-color", "category": "How-To", "title": "WisBlock IoT Education Kit - Light & Color Quick Start Guide > WisBlock IoT Education Kit - Light & Color Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock IoT Education Kit - Light & Color using TTN and Qubitro > Light Color Recognizer LoRaWAN Application > LoRaWAN Code for Light Color Recognizer > Programming the Light Color Recognizer Device with Arduino IDE [CODE]", "content": "// Blue data\nm_lora_app_data.buffer[i++] = (uint8_t)((blue_data & 0x0000FF00) >> 8);    // byte[5]\nm_lora_app_data.buffer[i++] = (uint8_t)(blue_data & 0x000000FF);           // byte[6]\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS) {\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n} else {\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}", "keywords": ["Arduino IDE", "RAK4631", "Light Color Recognizer", "LoRaWAN", "programming"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **Light Color Recognizer** device. Just copy the code below for **Light Color Recognizer LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the example </summary>  \n```c\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h>  //http://librarymanager/All#SX126x\n#include <Wire.h>\n#include <NCP5623.h>//http://librarymanager/All#NCP5623 By:RAKWireless\n#include \"TCS3772.h\"  // Click here to get the library: http://librarymanager/All#TCS37725\n// It use WB_IO2 to power up and is conflicting with INT1, so better use in SlotA/SlotC/SlotD.\n\nNCP5623 rgb;\nTCS3772 tcs3772;\nTCS3772_DataScaled tcs3772_data = {0};\n\nuint16_t scale_factor;\n\nuint16_t redColor;\nuint16_t greenColor;\nuint16_t blueColor;\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define RAK4631_BOARD true\n#else\n#define RAK4631_BOARD false\n#endif\n\nbool doOTAA = true;                                               // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                                       /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                                     /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5                               /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                                        /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;                           /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;                 /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                              /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = { LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF };\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = { BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler };\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0x96, 0xBD, 0xC5, 0x98, 0x17, 0x69, 0x8D, 0xFA, 0x1F, 0x64, 0xFE, 0x1C, 0xF9, 0x26, 0x7F, 0x8D };\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };\nuint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                                            /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];               //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = { m_lora_app_data_buffer, 0, 0, 0, 0 };  //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {\n\n// Initialize Serial for debug output\npinMode(LED_BLUE, OUTPUT);\ndigitalWrite(LED_BLUE, HIGH);\n\n// Sensor Power Switch\npinMode(WB_IO2, OUTPUT);\ndigitalWrite(WB_IO2, HIGH);\n\n// enable RAK14001\npinMode(WB_IO6, OUTPUT);\ndigitalWrite(WB_IO6, HIGH);\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial) {\nif ((millis() - timeout) < 5000) {\ndelay(100);\n} else {\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA) {\nSerial.println(\"Type: OTAA\");\n} else {\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion) {\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA) {\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n} else {\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0) {\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"================================\");\nSerial.println(\"RAK12021 + RAK14001 LoRaWAN Code\");\nSerial.println(\"================================\");\n\n// If using Native I2C\nWire.begin();\nWire.setClock(100000);\n\n// Serial.println(\"RAK14001 + RAK12021\");\n\nif (!rgb.begin())\n{\nSerial.println(\"RAK14001 not found on the I2C line\");\nwhile (1);\n}\nelse\n{\nSerial.println(\"RAK14001 Found. Begining execution\");\n}\n\n// set the current output level max, the range is 1 to 31\nrgb.setCurrent(25);\n\nif(tcs3772.begin() == true)\n{\nSerial.println(\"Found sensor.\");\n}\nelse\n{\nSerial.println(\"TCS37725 not found ... check your connections.\");\nwhile(1)\n{\ndelay(10);\n}\n}\ndelay(1000);\n}\n\nvoid loop() {\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\ntcs3772_data = tcs3772.getMeasurement();\n\nscale_factor = tcs3772.autoGain(tcs3772_data.clear);\n\nredColor = tcs3772_data.red;\ngreenColor = tcs3772_data.green;\nblueColor = tcs3772_data.blue;\n\nrgb.setColor(0,0,0);     // Initially OFF\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\nSerial.print(\"  R: \");\nSerial.println(redColor);\nSerial.print(\"  G: \");\nSerial.println(greenColor);\nSerial.print(\"  B: \");\nSerial.println(blueColor);\n\n// The values of redColor, greenColor and blueColor can be varied during the sensing calibration of RAK12021 module\n\nif (((redColor >= 9000) && (redColor <= 65535)) && ((greenColor >= 10000) && (greenColor <= 65535)) && ((blueColor >= 12000) && (blueColor <= 65535)))\n{\nrgb.setColor(255,255,255); // WHITE\n}\n\nelse if (((redColor >= 4000) && (redColor <= 18000)) && ((greenColor >= 1300) && (greenColor <= 5000)) && ((blueColor >= 950) && (blueColor <= 2000)))\n{\nrgb.setColor(255,255,0);  // YELLOW\n}\n\nelse if (((redColor >= 600) && (redColor <= 2000)) && ((greenColor >= 1700) && (greenColor <= 10000)) && ((blueColor >= 6800) && (blueColor <= 27000)))\n{\nrgb.setColor(0,0,255);    // BLUE\n}\n\nelse if (((redColor >= 1400) && (redColor <= 4000)) && ((greenColor >= 1300) && (greenColor <= 10000)) && ((blueColor >= 950) && (blueColor <= 2700)))\n{\nrgb.setColor(0,255,0);    // GREEN\n}\n\nelse if (((redColor >= 3000) && (redColor <= 20000)) && ((greenColor >= 700) && (greenColor <= 2400)) && ((blueColor >= 950) && (blueColor <= 3000)))\n{\nrgb.setColor(255,0,0);    // RED\n}\n\nelse if ((redColor < 1500) && (greenColor < 1400) && (blueColor < 900))\n{\nrgb.setColor(0,0,0);  // OFF\n}\n\ndelay(5000);\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void) {\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void) {\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data) {\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class) {\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void) {\nif (lmh_join_status_get() != LMH_SET) {\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\n// Showing the values of red, green and blue colors from RAK12021\ndata = \" Red: \" + String(redColor) + \" Green: \" + String(greenColor) + \" Blue: \" + String(blueColor);\n\nSerial.println(data);\n\nuint16_t red_data = redColor;\nuint16_t green_data = greenColor;\nuint16_t blue_data = blueColor;\n\nm_lora_app_data.buffer[i++] = 0x01;  // byte[0]\n\n// Red data\nm_lora_app_data.buffer[i++] = (uint8_t)((red_data & 0x0000FF00) >> 8);     // byte[1]\nm_lora_app_data.buffer[i++] = (uint8_t)(red_data & 0x000000FF);            // byte[2]\n\n// Green data\nm_lora_app_data.buffer[i++] = (uint8_t)((green_data & 0x0000FF00) >> 8);   // byte[3]\nm_lora_app_data.buffer[i++] = (uint8_t)(green_data & 0x000000FF);          // byte[4]\n\n// Blue data\nm_lora_app_data.buffer[i++] = (uint8_t)((blue_data & 0x0000FF00) >> 8);    // byte[5]\nm_lora_app_data.buffer[i++] = (uint8_t)(blue_data & 0x000000FF);           // byte[6]\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS) {\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n} else {\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0x96, 0xBD, 0xC5, 0x98, 0x17, 0x69, 0x8D, 0xFA, 0x1F, 0x64, 0xFE, 0x1C, 0xF9, 0x26, 0x7F, 0x8D };\n```  \n> **Image:** OTAA device successfully registered to TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "e073bf4fbd24f4caafbaf82bc2e83297", "product_family": "wisblock", "product_id": "kit6-light-and-color", "category": "How-To", "title": "WisBlock IoT Education Kit - Light & Color Quick Start Guide > WisBlock IoT Education Kit - Light & Color Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock IoT Education Kit - Light & Color using TTN and Qubitro > Light Color Recognizer LoRaWAN Application > LoRaWAN Code for Light Color Recognizer > Programming the Light Color Recognizer Device with Arduino IDE [CODE]", "content": "```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.", "keywords": ["Arduino IDE", "RAK4631", "Light Color Recognizer", "LoRaWAN", "programming"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **Light Color Recognizer** device. Just copy the code below for **Light Color Recognizer LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the example </summary>  \n```c\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h>  //http://librarymanager/All#SX126x\n#include <Wire.h>\n#include <NCP5623.h>//http://librarymanager/All#NCP5623 By:RAKWireless\n#include \"TCS3772.h\"  // Click here to get the library: http://librarymanager/All#TCS37725\n// It use WB_IO2 to power up and is conflicting with INT1, so better use in SlotA/SlotC/SlotD.\n\nNCP5623 rgb;\nTCS3772 tcs3772;\nTCS3772_DataScaled tcs3772_data = {0};\n\nuint16_t scale_factor;\n\nuint16_t redColor;\nuint16_t greenColor;\nuint16_t blueColor;\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define RAK4631_BOARD true\n#else\n#define RAK4631_BOARD false\n#endif\n\nbool doOTAA = true;                                               // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                                       /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                                     /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5                               /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                                        /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;                           /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;                 /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                              /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = { LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF };\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = { BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler };\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0x96, 0xBD, 0xC5, 0x98, 0x17, 0x69, 0x8D, 0xFA, 0x1F, 0x64, 0xFE, 0x1C, 0xF9, 0x26, 0x7F, 0x8D };\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };\nuint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                                            /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];               //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = { m_lora_app_data_buffer, 0, 0, 0, 0 };  //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {\n\n// Initialize Serial for debug output\npinMode(LED_BLUE, OUTPUT);\ndigitalWrite(LED_BLUE, HIGH);\n\n// Sensor Power Switch\npinMode(WB_IO2, OUTPUT);\ndigitalWrite(WB_IO2, HIGH);\n\n// enable RAK14001\npinMode(WB_IO6, OUTPUT);\ndigitalWrite(WB_IO6, HIGH);\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial) {\nif ((millis() - timeout) < 5000) {\ndelay(100);\n} else {\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA) {\nSerial.println(\"Type: OTAA\");\n} else {\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion) {\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA) {\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n} else {\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0) {\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"================================\");\nSerial.println(\"RAK12021 + RAK14001 LoRaWAN Code\");\nSerial.println(\"================================\");\n\n// If using Native I2C\nWire.begin();\nWire.setClock(100000);\n\n// Serial.println(\"RAK14001 + RAK12021\");\n\nif (!rgb.begin())\n{\nSerial.println(\"RAK14001 not found on the I2C line\");\nwhile (1);\n}\nelse\n{\nSerial.println(\"RAK14001 Found. Begining execution\");\n}\n\n// set the current output level max, the range is 1 to 31\nrgb.setCurrent(25);\n\nif(tcs3772.begin() == true)\n{\nSerial.println(\"Found sensor.\");\n}\nelse\n{\nSerial.println(\"TCS37725 not found ... check your connections.\");\nwhile(1)\n{\ndelay(10);\n}\n}\ndelay(1000);\n}\n\nvoid loop() {\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\ntcs3772_data = tcs3772.getMeasurement();\n\nscale_factor = tcs3772.autoGain(tcs3772_data.clear);\n\nredColor = tcs3772_data.red;\ngreenColor = tcs3772_data.green;\nblueColor = tcs3772_data.blue;\n\nrgb.setColor(0,0,0);     // Initially OFF\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\nSerial.print(\"  R: \");\nSerial.println(redColor);\nSerial.print(\"  G: \");\nSerial.println(greenColor);\nSerial.print(\"  B: \");\nSerial.println(blueColor);\n\n// The values of redColor, greenColor and blueColor can be varied during the sensing calibration of RAK12021 module\n\nif (((redColor >= 9000) && (redColor <= 65535)) && ((greenColor >= 10000) && (greenColor <= 65535)) && ((blueColor >= 12000) && (blueColor <= 65535)))\n{\nrgb.setColor(255,255,255); // WHITE\n}\n\nelse if (((redColor >= 4000) && (redColor <= 18000)) && ((greenColor >= 1300) && (greenColor <= 5000)) && ((blueColor >= 950) && (blueColor <= 2000)))\n{\nrgb.setColor(255,255,0);  // YELLOW\n}\n\nelse if (((redColor >= 600) && (redColor <= 2000)) && ((greenColor >= 1700) && (greenColor <= 10000)) && ((blueColor >= 6800) && (blueColor <= 27000)))\n{\nrgb.setColor(0,0,255);    // BLUE\n}\n\nelse if (((redColor >= 1400) && (redColor <= 4000)) && ((greenColor >= 1300) && (greenColor <= 10000)) && ((blueColor >= 950) && (blueColor <= 2700)))\n{\nrgb.setColor(0,255,0);    // GREEN\n}\n\nelse if (((redColor >= 3000) && (redColor <= 20000)) && ((greenColor >= 700) && (greenColor <= 2400)) && ((blueColor >= 950) && (blueColor <= 3000)))\n{\nrgb.setColor(255,0,0);    // RED\n}\n\nelse if ((redColor < 1500) && (greenColor < 1400) && (blueColor < 900))\n{\nrgb.setColor(0,0,0);  // OFF\n}\n\ndelay(5000);\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void) {\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void) {\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data) {\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class) {\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void) {\nif (lmh_join_status_get() != LMH_SET) {\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\n// Showing the values of red, green and blue colors from RAK12021\ndata = \" Red: \" + String(redColor) + \" Green: \" + String(greenColor) + \" Blue: \" + String(blueColor);\n\nSerial.println(data);\n\nuint16_t red_data = redColor;\nuint16_t green_data = greenColor;\nuint16_t blue_data = blueColor;\n\nm_lora_app_data.buffer[i++] = 0x01;  // byte[0]\n\n// Red data\nm_lora_app_data.buffer[i++] = (uint8_t)((red_data & 0x0000FF00) >> 8);     // byte[1]\nm_lora_app_data.buffer[i++] = (uint8_t)(red_data & 0x000000FF);            // byte[2]\n\n// Green data\nm_lora_app_data.buffer[i++] = (uint8_t)((green_data & 0x0000FF00) >> 8);   // byte[3]\nm_lora_app_data.buffer[i++] = (uint8_t)(green_data & 0x000000FF);          // byte[4]\n\n// Blue data\nm_lora_app_data.buffer[i++] = (uint8_t)((blue_data & 0x0000FF00) >> 8);    // byte[5]\nm_lora_app_data.buffer[i++] = (uint8_t)(blue_data & 0x000000FF);           // byte[6]\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS) {\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n} else {\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0x96, 0xBD, 0xC5, 0x98, 0x17, 0x69, 0x8D, 0xFA, 0x1F, 0x64, 0xFE, 0x1C, 0xF9, 0x26, 0x7F, 0x8D };\n```  \n> **Image:** OTAA device successfully registered to TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "bd941d73de6f9799c4342a236e5a2c21", "product_family": "wisblock", "product_id": "kit6-light-and-color", "category": "How-To", "title": "WisBlock IoT Education Kit - Light & Color Quick Start Guide > WisBlock IoT Education Kit - Light & Color Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock IoT Education Kit - Light & Color using TTN and Qubitro > Light Color Recognizer LoRaWAN Application > LoRaWAN Code for Light Color Recognizer > Programming the Light Color Recognizer Device with Arduino IDE [CODE]", "content": "- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |", "keywords": ["Arduino IDE", "RAK4631", "Light Color Recognizer", "LoRaWAN", "programming"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **Light Color Recognizer** device. Just copy the code below for **Light Color Recognizer LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the example </summary>  \n```c\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h>  //http://librarymanager/All#SX126x\n#include <Wire.h>\n#include <NCP5623.h>//http://librarymanager/All#NCP5623 By:RAKWireless\n#include \"TCS3772.h\"  // Click here to get the library: http://librarymanager/All#TCS37725\n// It use WB_IO2 to power up and is conflicting with INT1, so better use in SlotA/SlotC/SlotD.\n\nNCP5623 rgb;\nTCS3772 tcs3772;\nTCS3772_DataScaled tcs3772_data = {0};\n\nuint16_t scale_factor;\n\nuint16_t redColor;\nuint16_t greenColor;\nuint16_t blueColor;\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define RAK4631_BOARD true\n#else\n#define RAK4631_BOARD false\n#endif\n\nbool doOTAA = true;                                               // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                                       /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                                     /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5                               /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                                        /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;                           /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;                 /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                              /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = { LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF };\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = { BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler };\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0x96, 0xBD, 0xC5, 0x98, 0x17, 0x69, 0x8D, 0xFA, 0x1F, 0x64, 0xFE, 0x1C, 0xF9, 0x26, 0x7F, 0x8D };\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };\nuint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                                            /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];               //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = { m_lora_app_data_buffer, 0, 0, 0, 0 };  //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {\n\n// Initialize Serial for debug output\npinMode(LED_BLUE, OUTPUT);\ndigitalWrite(LED_BLUE, HIGH);\n\n// Sensor Power Switch\npinMode(WB_IO2, OUTPUT);\ndigitalWrite(WB_IO2, HIGH);\n\n// enable RAK14001\npinMode(WB_IO6, OUTPUT);\ndigitalWrite(WB_IO6, HIGH);\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial) {\nif ((millis() - timeout) < 5000) {\ndelay(100);\n} else {\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA) {\nSerial.println(\"Type: OTAA\");\n} else {\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion) {\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA) {\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n} else {\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0) {\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"================================\");\nSerial.println(\"RAK12021 + RAK14001 LoRaWAN Code\");\nSerial.println(\"================================\");\n\n// If using Native I2C\nWire.begin();\nWire.setClock(100000);\n\n// Serial.println(\"RAK14001 + RAK12021\");\n\nif (!rgb.begin())\n{\nSerial.println(\"RAK14001 not found on the I2C line\");\nwhile (1);\n}\nelse\n{\nSerial.println(\"RAK14001 Found. Begining execution\");\n}\n\n// set the current output level max, the range is 1 to 31\nrgb.setCurrent(25);\n\nif(tcs3772.begin() == true)\n{\nSerial.println(\"Found sensor.\");\n}\nelse\n{\nSerial.println(\"TCS37725 not found ... check your connections.\");\nwhile(1)\n{\ndelay(10);\n}\n}\ndelay(1000);\n}\n\nvoid loop() {\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\ntcs3772_data = tcs3772.getMeasurement();\n\nscale_factor = tcs3772.autoGain(tcs3772_data.clear);\n\nredColor = tcs3772_data.red;\ngreenColor = tcs3772_data.green;\nblueColor = tcs3772_data.blue;\n\nrgb.setColor(0,0,0);     // Initially OFF\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\nSerial.print(\"  R: \");\nSerial.println(redColor);\nSerial.print(\"  G: \");\nSerial.println(greenColor);\nSerial.print(\"  B: \");\nSerial.println(blueColor);\n\n// The values of redColor, greenColor and blueColor can be varied during the sensing calibration of RAK12021 module\n\nif (((redColor >= 9000) && (redColor <= 65535)) && ((greenColor >= 10000) && (greenColor <= 65535)) && ((blueColor >= 12000) && (blueColor <= 65535)))\n{\nrgb.setColor(255,255,255); // WHITE\n}\n\nelse if (((redColor >= 4000) && (redColor <= 18000)) && ((greenColor >= 1300) && (greenColor <= 5000)) && ((blueColor >= 950) && (blueColor <= 2000)))\n{\nrgb.setColor(255,255,0);  // YELLOW\n}\n\nelse if (((redColor >= 600) && (redColor <= 2000)) && ((greenColor >= 1700) && (greenColor <= 10000)) && ((blueColor >= 6800) && (blueColor <= 27000)))\n{\nrgb.setColor(0,0,255);    // BLUE\n}\n\nelse if (((redColor >= 1400) && (redColor <= 4000)) && ((greenColor >= 1300) && (greenColor <= 10000)) && ((blueColor >= 950) && (blueColor <= 2700)))\n{\nrgb.setColor(0,255,0);    // GREEN\n}\n\nelse if (((redColor >= 3000) && (redColor <= 20000)) && ((greenColor >= 700) && (greenColor <= 2400)) && ((blueColor >= 950) && (blueColor <= 3000)))\n{\nrgb.setColor(255,0,0);    // RED\n}\n\nelse if ((redColor < 1500) && (greenColor < 1400) && (blueColor < 900))\n{\nrgb.setColor(0,0,0);  // OFF\n}\n\ndelay(5000);\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void) {\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void) {\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data) {\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class) {\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void) {\nif (lmh_join_status_get() != LMH_SET) {\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\n// Showing the values of red, green and blue colors from RAK12021\ndata = \" Red: \" + String(redColor) + \" Green: \" + String(greenColor) + \" Blue: \" + String(blueColor);\n\nSerial.println(data);\n\nuint16_t red_data = redColor;\nuint16_t green_data = greenColor;\nuint16_t blue_data = blueColor;\n\nm_lora_app_data.buffer[i++] = 0x01;  // byte[0]\n\n// Red data\nm_lora_app_data.buffer[i++] = (uint8_t)((red_data & 0x0000FF00) >> 8);     // byte[1]\nm_lora_app_data.buffer[i++] = (uint8_t)(red_data & 0x000000FF);            // byte[2]\n\n// Green data\nm_lora_app_data.buffer[i++] = (uint8_t)((green_data & 0x0000FF00) >> 8);   // byte[3]\nm_lora_app_data.buffer[i++] = (uint8_t)(green_data & 0x000000FF);          // byte[4]\n\n// Blue data\nm_lora_app_data.buffer[i++] = (uint8_t)((blue_data & 0x0000FF00) >> 8);    // byte[5]\nm_lora_app_data.buffer[i++] = (uint8_t)(blue_data & 0x000000FF);           // byte[6]\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS) {\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n} else {\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0x96, 0xBD, 0xC5, 0x98, 0x17, 0x69, 0x8D, 0xFA, 0x1F, 0x64, 0xFE, 0x1C, 0xF9, 0x26, 0x7F, 0x8D };\n```  \n> **Image:** OTAA device successfully registered to TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "b062ef0eb2ed2232c95527500ff2e11c", "product_family": "wisblock", "product_id": "kit6-light-and-color", "category": "How-To", "title": "WisBlock IoT Education Kit - Light & Color Quick Start Guide > WisBlock IoT Education Kit - Light & Color Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock IoT Education Kit - Light & Color using TTN and Qubitro > Light Color Recognizer LoRaWAN Application > LoRaWAN Code for Light Color Recognizer > Programming the Light Color Recognizer Device with Arduino IDE [CODE]", "content": "|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |", "keywords": ["Arduino IDE", "RAK4631", "Light Color Recognizer", "LoRaWAN", "programming"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **Light Color Recognizer** device. Just copy the code below for **Light Color Recognizer LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the example </summary>  \n```c\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h>  //http://librarymanager/All#SX126x\n#include <Wire.h>\n#include <NCP5623.h>//http://librarymanager/All#NCP5623 By:RAKWireless\n#include \"TCS3772.h\"  // Click here to get the library: http://librarymanager/All#TCS37725\n// It use WB_IO2 to power up and is conflicting with INT1, so better use in SlotA/SlotC/SlotD.\n\nNCP5623 rgb;\nTCS3772 tcs3772;\nTCS3772_DataScaled tcs3772_data = {0};\n\nuint16_t scale_factor;\n\nuint16_t redColor;\nuint16_t greenColor;\nuint16_t blueColor;\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define RAK4631_BOARD true\n#else\n#define RAK4631_BOARD false\n#endif\n\nbool doOTAA = true;                                               // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                                       /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                                     /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5                               /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                                        /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;                           /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;                 /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                              /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = { LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF };\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = { BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler };\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0x96, 0xBD, 0xC5, 0x98, 0x17, 0x69, 0x8D, 0xFA, 0x1F, 0x64, 0xFE, 0x1C, 0xF9, 0x26, 0x7F, 0x8D };\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };\nuint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                                            /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];               //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = { m_lora_app_data_buffer, 0, 0, 0, 0 };  //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {\n\n// Initialize Serial for debug output\npinMode(LED_BLUE, OUTPUT);\ndigitalWrite(LED_BLUE, HIGH);\n\n// Sensor Power Switch\npinMode(WB_IO2, OUTPUT);\ndigitalWrite(WB_IO2, HIGH);\n\n// enable RAK14001\npinMode(WB_IO6, OUTPUT);\ndigitalWrite(WB_IO6, HIGH);\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial) {\nif ((millis() - timeout) < 5000) {\ndelay(100);\n} else {\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA) {\nSerial.println(\"Type: OTAA\");\n} else {\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion) {\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA) {\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n} else {\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0) {\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"================================\");\nSerial.println(\"RAK12021 + RAK14001 LoRaWAN Code\");\nSerial.println(\"================================\");\n\n// If using Native I2C\nWire.begin();\nWire.setClock(100000);\n\n// Serial.println(\"RAK14001 + RAK12021\");\n\nif (!rgb.begin())\n{\nSerial.println(\"RAK14001 not found on the I2C line\");\nwhile (1);\n}\nelse\n{\nSerial.println(\"RAK14001 Found. Begining execution\");\n}\n\n// set the current output level max, the range is 1 to 31\nrgb.setCurrent(25);\n\nif(tcs3772.begin() == true)\n{\nSerial.println(\"Found sensor.\");\n}\nelse\n{\nSerial.println(\"TCS37725 not found ... check your connections.\");\nwhile(1)\n{\ndelay(10);\n}\n}\ndelay(1000);\n}\n\nvoid loop() {\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\ntcs3772_data = tcs3772.getMeasurement();\n\nscale_factor = tcs3772.autoGain(tcs3772_data.clear);\n\nredColor = tcs3772_data.red;\ngreenColor = tcs3772_data.green;\nblueColor = tcs3772_data.blue;\n\nrgb.setColor(0,0,0);     // Initially OFF\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\nSerial.print(\"  R: \");\nSerial.println(redColor);\nSerial.print(\"  G: \");\nSerial.println(greenColor);\nSerial.print(\"  B: \");\nSerial.println(blueColor);\n\n// The values of redColor, greenColor and blueColor can be varied during the sensing calibration of RAK12021 module\n\nif (((redColor >= 9000) && (redColor <= 65535)) && ((greenColor >= 10000) && (greenColor <= 65535)) && ((blueColor >= 12000) && (blueColor <= 65535)))\n{\nrgb.setColor(255,255,255); // WHITE\n}\n\nelse if (((redColor >= 4000) && (redColor <= 18000)) && ((greenColor >= 1300) && (greenColor <= 5000)) && ((blueColor >= 950) && (blueColor <= 2000)))\n{\nrgb.setColor(255,255,0);  // YELLOW\n}\n\nelse if (((redColor >= 600) && (redColor <= 2000)) && ((greenColor >= 1700) && (greenColor <= 10000)) && ((blueColor >= 6800) && (blueColor <= 27000)))\n{\nrgb.setColor(0,0,255);    // BLUE\n}\n\nelse if (((redColor >= 1400) && (redColor <= 4000)) && ((greenColor >= 1300) && (greenColor <= 10000)) && ((blueColor >= 950) && (blueColor <= 2700)))\n{\nrgb.setColor(0,255,0);    // GREEN\n}\n\nelse if (((redColor >= 3000) && (redColor <= 20000)) && ((greenColor >= 700) && (greenColor <= 2400)) && ((blueColor >= 950) && (blueColor <= 3000)))\n{\nrgb.setColor(255,0,0);    // RED\n}\n\nelse if ((redColor < 1500) && (greenColor < 1400) && (blueColor < 900))\n{\nrgb.setColor(0,0,0);  // OFF\n}\n\ndelay(5000);\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void) {\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void) {\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data) {\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class) {\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void) {\nif (lmh_join_status_get() != LMH_SET) {\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\n// Showing the values of red, green and blue colors from RAK12021\ndata = \" Red: \" + String(redColor) + \" Green: \" + String(greenColor) + \" Blue: \" + String(blueColor);\n\nSerial.println(data);\n\nuint16_t red_data = redColor;\nuint16_t green_data = greenColor;\nuint16_t blue_data = blueColor;\n\nm_lora_app_data.buffer[i++] = 0x01;  // byte[0]\n\n// Red data\nm_lora_app_data.buffer[i++] = (uint8_t)((red_data & 0x0000FF00) >> 8);     // byte[1]\nm_lora_app_data.buffer[i++] = (uint8_t)(red_data & 0x000000FF);            // byte[2]\n\n// Green data\nm_lora_app_data.buffer[i++] = (uint8_t)((green_data & 0x0000FF00) >> 8);   // byte[3]\nm_lora_app_data.buffer[i++] = (uint8_t)(green_data & 0x000000FF);          // byte[4]\n\n// Blue data\nm_lora_app_data.buffer[i++] = (uint8_t)((blue_data & 0x0000FF00) >> 8);    // byte[5]\nm_lora_app_data.buffer[i++] = (uint8_t)(blue_data & 0x000000FF);           // byte[6]\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS) {\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n} else {\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0x96, 0xBD, 0xC5, 0x98, 0x17, 0x69, 0x8D, 0xFA, 0x1F, 0x64, 0xFE, 0x1C, 0xF9, 0x26, 0x7F, 0x8D };\n```  \n> **Image:** OTAA device successfully registered to TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "57dcf863e9d99dbb4263e7f6300d45bd", "product_family": "wisblock", "product_id": "kit6-light-and-color", "category": "How-To", "title": "WisBlock IoT Education Kit - Light & Color Quick Start Guide > WisBlock IoT Education Kit - Light & Color Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock IoT Education Kit - Light & Color using TTN and Qubitro > Light Color Recognizer LoRaWAN Application > LoRaWAN Code for Light Color Recognizer > Programming the Light Color Recognizer Device with Arduino IDE [CODE]", "content": "|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |", "keywords": ["Arduino IDE", "RAK4631", "Light Color Recognizer", "LoRaWAN", "programming"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **Light Color Recognizer** device. Just copy the code below for **Light Color Recognizer LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the example </summary>  \n```c\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h>  //http://librarymanager/All#SX126x\n#include <Wire.h>\n#include <NCP5623.h>//http://librarymanager/All#NCP5623 By:RAKWireless\n#include \"TCS3772.h\"  // Click here to get the library: http://librarymanager/All#TCS37725\n// It use WB_IO2 to power up and is conflicting with INT1, so better use in SlotA/SlotC/SlotD.\n\nNCP5623 rgb;\nTCS3772 tcs3772;\nTCS3772_DataScaled tcs3772_data = {0};\n\nuint16_t scale_factor;\n\nuint16_t redColor;\nuint16_t greenColor;\nuint16_t blueColor;\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define RAK4631_BOARD true\n#else\n#define RAK4631_BOARD false\n#endif\n\nbool doOTAA = true;                                               // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                                       /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                                     /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5                               /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                                        /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;                           /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;                 /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                              /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = { LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF };\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = { BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler };\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0x96, 0xBD, 0xC5, 0x98, 0x17, 0x69, 0x8D, 0xFA, 0x1F, 0x64, 0xFE, 0x1C, 0xF9, 0x26, 0x7F, 0x8D };\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };\nuint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                                            /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];               //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = { m_lora_app_data_buffer, 0, 0, 0, 0 };  //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {\n\n// Initialize Serial for debug output\npinMode(LED_BLUE, OUTPUT);\ndigitalWrite(LED_BLUE, HIGH);\n\n// Sensor Power Switch\npinMode(WB_IO2, OUTPUT);\ndigitalWrite(WB_IO2, HIGH);\n\n// enable RAK14001\npinMode(WB_IO6, OUTPUT);\ndigitalWrite(WB_IO6, HIGH);\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial) {\nif ((millis() - timeout) < 5000) {\ndelay(100);\n} else {\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA) {\nSerial.println(\"Type: OTAA\");\n} else {\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion) {\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA) {\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n} else {\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0) {\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"================================\");\nSerial.println(\"RAK12021 + RAK14001 LoRaWAN Code\");\nSerial.println(\"================================\");\n\n// If using Native I2C\nWire.begin();\nWire.setClock(100000);\n\n// Serial.println(\"RAK14001 + RAK12021\");\n\nif (!rgb.begin())\n{\nSerial.println(\"RAK14001 not found on the I2C line\");\nwhile (1);\n}\nelse\n{\nSerial.println(\"RAK14001 Found. Begining execution\");\n}\n\n// set the current output level max, the range is 1 to 31\nrgb.setCurrent(25);\n\nif(tcs3772.begin() == true)\n{\nSerial.println(\"Found sensor.\");\n}\nelse\n{\nSerial.println(\"TCS37725 not found ... check your connections.\");\nwhile(1)\n{\ndelay(10);\n}\n}\ndelay(1000);\n}\n\nvoid loop() {\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\ntcs3772_data = tcs3772.getMeasurement();\n\nscale_factor = tcs3772.autoGain(tcs3772_data.clear);\n\nredColor = tcs3772_data.red;\ngreenColor = tcs3772_data.green;\nblueColor = tcs3772_data.blue;\n\nrgb.setColor(0,0,0);     // Initially OFF\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\nSerial.print(\"  R: \");\nSerial.println(redColor);\nSerial.print(\"  G: \");\nSerial.println(greenColor);\nSerial.print(\"  B: \");\nSerial.println(blueColor);\n\n// The values of redColor, greenColor and blueColor can be varied during the sensing calibration of RAK12021 module\n\nif (((redColor >= 9000) && (redColor <= 65535)) && ((greenColor >= 10000) && (greenColor <= 65535)) && ((blueColor >= 12000) && (blueColor <= 65535)))\n{\nrgb.setColor(255,255,255); // WHITE\n}\n\nelse if (((redColor >= 4000) && (redColor <= 18000)) && ((greenColor >= 1300) && (greenColor <= 5000)) && ((blueColor >= 950) && (blueColor <= 2000)))\n{\nrgb.setColor(255,255,0);  // YELLOW\n}\n\nelse if (((redColor >= 600) && (redColor <= 2000)) && ((greenColor >= 1700) && (greenColor <= 10000)) && ((blueColor >= 6800) && (blueColor <= 27000)))\n{\nrgb.setColor(0,0,255);    // BLUE\n}\n\nelse if (((redColor >= 1400) && (redColor <= 4000)) && ((greenColor >= 1300) && (greenColor <= 10000)) && ((blueColor >= 950) && (blueColor <= 2700)))\n{\nrgb.setColor(0,255,0);    // GREEN\n}\n\nelse if (((redColor >= 3000) && (redColor <= 20000)) && ((greenColor >= 700) && (greenColor <= 2400)) && ((blueColor >= 950) && (blueColor <= 3000)))\n{\nrgb.setColor(255,0,0);    // RED\n}\n\nelse if ((redColor < 1500) && (greenColor < 1400) && (blueColor < 900))\n{\nrgb.setColor(0,0,0);  // OFF\n}\n\ndelay(5000);\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void) {\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void) {\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data) {\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class) {\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void) {\nif (lmh_join_status_get() != LMH_SET) {\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\n// Showing the values of red, green and blue colors from RAK12021\ndata = \" Red: \" + String(redColor) + \" Green: \" + String(greenColor) + \" Blue: \" + String(blueColor);\n\nSerial.println(data);\n\nuint16_t red_data = redColor;\nuint16_t green_data = greenColor;\nuint16_t blue_data = blueColor;\n\nm_lora_app_data.buffer[i++] = 0x01;  // byte[0]\n\n// Red data\nm_lora_app_data.buffer[i++] = (uint8_t)((red_data & 0x0000FF00) >> 8);     // byte[1]\nm_lora_app_data.buffer[i++] = (uint8_t)(red_data & 0x000000FF);            // byte[2]\n\n// Green data\nm_lora_app_data.buffer[i++] = (uint8_t)((green_data & 0x0000FF00) >> 8);   // byte[3]\nm_lora_app_data.buffer[i++] = (uint8_t)(green_data & 0x000000FF);          // byte[4]\n\n// Blue data\nm_lora_app_data.buffer[i++] = (uint8_t)((blue_data & 0x0000FF00) >> 8);    // byte[5]\nm_lora_app_data.buffer[i++] = (uint8_t)(blue_data & 0x000000FF);           // byte[6]\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS) {\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n} else {\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0x96, 0xBD, 0xC5, 0x98, 0x17, 0x69, 0x8D, 0xFA, 0x1F, 0x64, 0xFE, 0x1C, 0xF9, 0x26, 0x7F, 0x8D };\n```  \n> **Image:** OTAA device successfully registered to TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "0afb8679f88584df95602033e1157060", "product_family": "wisblock", "product_id": "kit6-light-and-color", "category": "How-To", "title": "WisBlock IoT Education Kit - Light & Color Quick Start Guide > WisBlock IoT Education Kit - Light & Color Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock IoT Education Kit - Light & Color using TTN and Qubitro > Light Color Recognizer LoRaWAN Application > LoRaWAN Code for Light Color Recognizer > Programming the Light Color Recognizer Device with Arduino IDE [CODE]", "content": "|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |", "keywords": ["Arduino IDE", "RAK4631", "Light Color Recognizer", "LoRaWAN", "programming"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **Light Color Recognizer** device. Just copy the code below for **Light Color Recognizer LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the example </summary>  \n```c\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h>  //http://librarymanager/All#SX126x\n#include <Wire.h>\n#include <NCP5623.h>//http://librarymanager/All#NCP5623 By:RAKWireless\n#include \"TCS3772.h\"  // Click here to get the library: http://librarymanager/All#TCS37725\n// It use WB_IO2 to power up and is conflicting with INT1, so better use in SlotA/SlotC/SlotD.\n\nNCP5623 rgb;\nTCS3772 tcs3772;\nTCS3772_DataScaled tcs3772_data = {0};\n\nuint16_t scale_factor;\n\nuint16_t redColor;\nuint16_t greenColor;\nuint16_t blueColor;\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define RAK4631_BOARD true\n#else\n#define RAK4631_BOARD false\n#endif\n\nbool doOTAA = true;                                               // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                                       /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                                     /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5                               /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                                        /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;                           /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;                 /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                              /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = { LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF };\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = { BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler };\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0x96, 0xBD, 0xC5, 0x98, 0x17, 0x69, 0x8D, 0xFA, 0x1F, 0x64, 0xFE, 0x1C, 0xF9, 0x26, 0x7F, 0x8D };\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };\nuint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                                            /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];               //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = { m_lora_app_data_buffer, 0, 0, 0, 0 };  //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {\n\n// Initialize Serial for debug output\npinMode(LED_BLUE, OUTPUT);\ndigitalWrite(LED_BLUE, HIGH);\n\n// Sensor Power Switch\npinMode(WB_IO2, OUTPUT);\ndigitalWrite(WB_IO2, HIGH);\n\n// enable RAK14001\npinMode(WB_IO6, OUTPUT);\ndigitalWrite(WB_IO6, HIGH);\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial) {\nif ((millis() - timeout) < 5000) {\ndelay(100);\n} else {\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA) {\nSerial.println(\"Type: OTAA\");\n} else {\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion) {\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA) {\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n} else {\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0) {\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"================================\");\nSerial.println(\"RAK12021 + RAK14001 LoRaWAN Code\");\nSerial.println(\"================================\");\n\n// If using Native I2C\nWire.begin();\nWire.setClock(100000);\n\n// Serial.println(\"RAK14001 + RAK12021\");\n\nif (!rgb.begin())\n{\nSerial.println(\"RAK14001 not found on the I2C line\");\nwhile (1);\n}\nelse\n{\nSerial.println(\"RAK14001 Found. Begining execution\");\n}\n\n// set the current output level max, the range is 1 to 31\nrgb.setCurrent(25);\n\nif(tcs3772.begin() == true)\n{\nSerial.println(\"Found sensor.\");\n}\nelse\n{\nSerial.println(\"TCS37725 not found ... check your connections.\");\nwhile(1)\n{\ndelay(10);\n}\n}\ndelay(1000);\n}\n\nvoid loop() {\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\ntcs3772_data = tcs3772.getMeasurement();\n\nscale_factor = tcs3772.autoGain(tcs3772_data.clear);\n\nredColor = tcs3772_data.red;\ngreenColor = tcs3772_data.green;\nblueColor = tcs3772_data.blue;\n\nrgb.setColor(0,0,0);     // Initially OFF\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\nSerial.print(\"  R: \");\nSerial.println(redColor);\nSerial.print(\"  G: \");\nSerial.println(greenColor);\nSerial.print(\"  B: \");\nSerial.println(blueColor);\n\n// The values of redColor, greenColor and blueColor can be varied during the sensing calibration of RAK12021 module\n\nif (((redColor >= 9000) && (redColor <= 65535)) && ((greenColor >= 10000) && (greenColor <= 65535)) && ((blueColor >= 12000) && (blueColor <= 65535)))\n{\nrgb.setColor(255,255,255); // WHITE\n}\n\nelse if (((redColor >= 4000) && (redColor <= 18000)) && ((greenColor >= 1300) && (greenColor <= 5000)) && ((blueColor >= 950) && (blueColor <= 2000)))\n{\nrgb.setColor(255,255,0);  // YELLOW\n}\n\nelse if (((redColor >= 600) && (redColor <= 2000)) && ((greenColor >= 1700) && (greenColor <= 10000)) && ((blueColor >= 6800) && (blueColor <= 27000)))\n{\nrgb.setColor(0,0,255);    // BLUE\n}\n\nelse if (((redColor >= 1400) && (redColor <= 4000)) && ((greenColor >= 1300) && (greenColor <= 10000)) && ((blueColor >= 950) && (blueColor <= 2700)))\n{\nrgb.setColor(0,255,0);    // GREEN\n}\n\nelse if (((redColor >= 3000) && (redColor <= 20000)) && ((greenColor >= 700) && (greenColor <= 2400)) && ((blueColor >= 950) && (blueColor <= 3000)))\n{\nrgb.setColor(255,0,0);    // RED\n}\n\nelse if ((redColor < 1500) && (greenColor < 1400) && (blueColor < 900))\n{\nrgb.setColor(0,0,0);  // OFF\n}\n\ndelay(5000);\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void) {\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void) {\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data) {\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class) {\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void) {\nif (lmh_join_status_get() != LMH_SET) {\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\n// Showing the values of red, green and blue colors from RAK12021\ndata = \" Red: \" + String(redColor) + \" Green: \" + String(greenColor) + \" Blue: \" + String(blueColor);\n\nSerial.println(data);\n\nuint16_t red_data = redColor;\nuint16_t green_data = greenColor;\nuint16_t blue_data = blueColor;\n\nm_lora_app_data.buffer[i++] = 0x01;  // byte[0]\n\n// Red data\nm_lora_app_data.buffer[i++] = (uint8_t)((red_data & 0x0000FF00) >> 8);     // byte[1]\nm_lora_app_data.buffer[i++] = (uint8_t)(red_data & 0x000000FF);            // byte[2]\n\n// Green data\nm_lora_app_data.buffer[i++] = (uint8_t)((green_data & 0x0000FF00) >> 8);   // byte[3]\nm_lora_app_data.buffer[i++] = (uint8_t)(green_data & 0x000000FF);          // byte[4]\n\n// Blue data\nm_lora_app_data.buffer[i++] = (uint8_t)((blue_data & 0x0000FF00) >> 8);    // byte[5]\nm_lora_app_data.buffer[i++] = (uint8_t)(blue_data & 0x000000FF);           // byte[6]\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS) {\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n} else {\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0x96, 0xBD, 0xC5, 0x98, 0x17, 0x69, 0x8D, 0xFA, 0x1F, 0x64, 0xFE, 0x1C, 0xF9, 0x26, 0x7F, 0x8D };\n```  \n> **Image:** OTAA device successfully registered to TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "13247d0abf66fa80ff567e7a12bd0a2c", "product_family": "wisblock", "product_id": "kit6-light-and-color", "category": "How-To", "title": "WisBlock IoT Education Kit - Light & Color Quick Start Guide > WisBlock IoT Education Kit - Light & Color Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock IoT Education Kit - Light & Color using TTN and Qubitro > Light Color Recognizer LoRaWAN Application > LoRaWAN Code for Light Color Recognizer > Programming the Light Color Recognizer Device with Arduino IDE [CODE]", "content": "|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```", "keywords": ["Arduino IDE", "RAK4631", "Light Color Recognizer", "LoRaWAN", "programming"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **Light Color Recognizer** device. Just copy the code below for **Light Color Recognizer LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the example </summary>  \n```c\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h>  //http://librarymanager/All#SX126x\n#include <Wire.h>\n#include <NCP5623.h>//http://librarymanager/All#NCP5623 By:RAKWireless\n#include \"TCS3772.h\"  // Click here to get the library: http://librarymanager/All#TCS37725\n// It use WB_IO2 to power up and is conflicting with INT1, so better use in SlotA/SlotC/SlotD.\n\nNCP5623 rgb;\nTCS3772 tcs3772;\nTCS3772_DataScaled tcs3772_data = {0};\n\nuint16_t scale_factor;\n\nuint16_t redColor;\nuint16_t greenColor;\nuint16_t blueColor;\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define RAK4631_BOARD true\n#else\n#define RAK4631_BOARD false\n#endif\n\nbool doOTAA = true;                                               // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                                       /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                                     /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5                               /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                                        /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;                           /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;                 /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                              /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = { LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF };\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = { BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler };\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0x96, 0xBD, 0xC5, 0x98, 0x17, 0x69, 0x8D, 0xFA, 0x1F, 0x64, 0xFE, 0x1C, 0xF9, 0x26, 0x7F, 0x8D };\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };\nuint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                                            /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];               //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = { m_lora_app_data_buffer, 0, 0, 0, 0 };  //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {\n\n// Initialize Serial for debug output\npinMode(LED_BLUE, OUTPUT);\ndigitalWrite(LED_BLUE, HIGH);\n\n// Sensor Power Switch\npinMode(WB_IO2, OUTPUT);\ndigitalWrite(WB_IO2, HIGH);\n\n// enable RAK14001\npinMode(WB_IO6, OUTPUT);\ndigitalWrite(WB_IO6, HIGH);\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial) {\nif ((millis() - timeout) < 5000) {\ndelay(100);\n} else {\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA) {\nSerial.println(\"Type: OTAA\");\n} else {\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion) {\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA) {\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n} else {\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0) {\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"================================\");\nSerial.println(\"RAK12021 + RAK14001 LoRaWAN Code\");\nSerial.println(\"================================\");\n\n// If using Native I2C\nWire.begin();\nWire.setClock(100000);\n\n// Serial.println(\"RAK14001 + RAK12021\");\n\nif (!rgb.begin())\n{\nSerial.println(\"RAK14001 not found on the I2C line\");\nwhile (1);\n}\nelse\n{\nSerial.println(\"RAK14001 Found. Begining execution\");\n}\n\n// set the current output level max, the range is 1 to 31\nrgb.setCurrent(25);\n\nif(tcs3772.begin() == true)\n{\nSerial.println(\"Found sensor.\");\n}\nelse\n{\nSerial.println(\"TCS37725 not found ... check your connections.\");\nwhile(1)\n{\ndelay(10);\n}\n}\ndelay(1000);\n}\n\nvoid loop() {\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\ntcs3772_data = tcs3772.getMeasurement();\n\nscale_factor = tcs3772.autoGain(tcs3772_data.clear);\n\nredColor = tcs3772_data.red;\ngreenColor = tcs3772_data.green;\nblueColor = tcs3772_data.blue;\n\nrgb.setColor(0,0,0);     // Initially OFF\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\nSerial.print(\"  R: \");\nSerial.println(redColor);\nSerial.print(\"  G: \");\nSerial.println(greenColor);\nSerial.print(\"  B: \");\nSerial.println(blueColor);\n\n// The values of redColor, greenColor and blueColor can be varied during the sensing calibration of RAK12021 module\n\nif (((redColor >= 9000) && (redColor <= 65535)) && ((greenColor >= 10000) && (greenColor <= 65535)) && ((blueColor >= 12000) && (blueColor <= 65535)))\n{\nrgb.setColor(255,255,255); // WHITE\n}\n\nelse if (((redColor >= 4000) && (redColor <= 18000)) && ((greenColor >= 1300) && (greenColor <= 5000)) && ((blueColor >= 950) && (blueColor <= 2000)))\n{\nrgb.setColor(255,255,0);  // YELLOW\n}\n\nelse if (((redColor >= 600) && (redColor <= 2000)) && ((greenColor >= 1700) && (greenColor <= 10000)) && ((blueColor >= 6800) && (blueColor <= 27000)))\n{\nrgb.setColor(0,0,255);    // BLUE\n}\n\nelse if (((redColor >= 1400) && (redColor <= 4000)) && ((greenColor >= 1300) && (greenColor <= 10000)) && ((blueColor >= 950) && (blueColor <= 2700)))\n{\nrgb.setColor(0,255,0);    // GREEN\n}\n\nelse if (((redColor >= 3000) && (redColor <= 20000)) && ((greenColor >= 700) && (greenColor <= 2400)) && ((blueColor >= 950) && (blueColor <= 3000)))\n{\nrgb.setColor(255,0,0);    // RED\n}\n\nelse if ((redColor < 1500) && (greenColor < 1400) && (blueColor < 900))\n{\nrgb.setColor(0,0,0);  // OFF\n}\n\ndelay(5000);\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void) {\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void) {\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data) {\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class) {\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void) {\nif (lmh_join_status_get() != LMH_SET) {\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\n// Showing the values of red, green and blue colors from RAK12021\ndata = \" Red: \" + String(redColor) + \" Green: \" + String(greenColor) + \" Blue: \" + String(blueColor);\n\nSerial.println(data);\n\nuint16_t red_data = redColor;\nuint16_t green_data = greenColor;\nuint16_t blue_data = blueColor;\n\nm_lora_app_data.buffer[i++] = 0x01;  // byte[0]\n\n// Red data\nm_lora_app_data.buffer[i++] = (uint8_t)((red_data & 0x0000FF00) >> 8);     // byte[1]\nm_lora_app_data.buffer[i++] = (uint8_t)(red_data & 0x000000FF);            // byte[2]\n\n// Green data\nm_lora_app_data.buffer[i++] = (uint8_t)((green_data & 0x0000FF00) >> 8);   // byte[3]\nm_lora_app_data.buffer[i++] = (uint8_t)(green_data & 0x000000FF);          // byte[4]\n\n// Blue data\nm_lora_app_data.buffer[i++] = (uint8_t)((blue_data & 0x0000FF00) >> 8);    // byte[5]\nm_lora_app_data.buffer[i++] = (uint8_t)(blue_data & 0x000000FF);           // byte[6]\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS) {\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n} else {\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0x96, 0xBD, 0xC5, 0x98, 0x17, 0x69, 0x8D, 0xFA, 0x1F, 0x64, 0xFE, 0x1C, 0xF9, 0x26, 0x7F, 0x8D };\n```  \n> **Image:** OTAA device successfully registered to TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "4b545d8f88240bf7a73c78b30022f8f3", "product_family": "wisblock", "product_id": "kit6-light-and-color", "category": "How-To", "title": "WisBlock IoT Education Kit - Light & Color Quick Start Guide > WisBlock IoT Education Kit - Light & Color Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock IoT Education Kit - Light & Color using TTN and Qubitro > Light Color Recognizer LoRaWAN Application > LoRaWAN Code for Light Color Recognizer > Programming the Light Color Recognizer Device with Arduino IDE [CODE]", "content": "```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```", "keywords": ["Arduino IDE", "RAK4631", "Light Color Recognizer", "LoRaWAN", "programming"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **Light Color Recognizer** device. Just copy the code below for **Light Color Recognizer LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the example </summary>  \n```c\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h>  //http://librarymanager/All#SX126x\n#include <Wire.h>\n#include <NCP5623.h>//http://librarymanager/All#NCP5623 By:RAKWireless\n#include \"TCS3772.h\"  // Click here to get the library: http://librarymanager/All#TCS37725\n// It use WB_IO2 to power up and is conflicting with INT1, so better use in SlotA/SlotC/SlotD.\n\nNCP5623 rgb;\nTCS3772 tcs3772;\nTCS3772_DataScaled tcs3772_data = {0};\n\nuint16_t scale_factor;\n\nuint16_t redColor;\nuint16_t greenColor;\nuint16_t blueColor;\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define RAK4631_BOARD true\n#else\n#define RAK4631_BOARD false\n#endif\n\nbool doOTAA = true;                                               // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                                       /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                                     /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5                               /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                                        /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;                           /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;                 /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                              /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = { LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF };\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = { BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler };\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0x96, 0xBD, 0xC5, 0x98, 0x17, 0x69, 0x8D, 0xFA, 0x1F, 0x64, 0xFE, 0x1C, 0xF9, 0x26, 0x7F, 0x8D };\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };\nuint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                                            /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];               //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = { m_lora_app_data_buffer, 0, 0, 0, 0 };  //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {\n\n// Initialize Serial for debug output\npinMode(LED_BLUE, OUTPUT);\ndigitalWrite(LED_BLUE, HIGH);\n\n// Sensor Power Switch\npinMode(WB_IO2, OUTPUT);\ndigitalWrite(WB_IO2, HIGH);\n\n// enable RAK14001\npinMode(WB_IO6, OUTPUT);\ndigitalWrite(WB_IO6, HIGH);\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial) {\nif ((millis() - timeout) < 5000) {\ndelay(100);\n} else {\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA) {\nSerial.println(\"Type: OTAA\");\n} else {\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion) {\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA) {\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n} else {\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0) {\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"================================\");\nSerial.println(\"RAK12021 + RAK14001 LoRaWAN Code\");\nSerial.println(\"================================\");\n\n// If using Native I2C\nWire.begin();\nWire.setClock(100000);\n\n// Serial.println(\"RAK14001 + RAK12021\");\n\nif (!rgb.begin())\n{\nSerial.println(\"RAK14001 not found on the I2C line\");\nwhile (1);\n}\nelse\n{\nSerial.println(\"RAK14001 Found. Begining execution\");\n}\n\n// set the current output level max, the range is 1 to 31\nrgb.setCurrent(25);\n\nif(tcs3772.begin() == true)\n{\nSerial.println(\"Found sensor.\");\n}\nelse\n{\nSerial.println(\"TCS37725 not found ... check your connections.\");\nwhile(1)\n{\ndelay(10);\n}\n}\ndelay(1000);\n}\n\nvoid loop() {\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\ntcs3772_data = tcs3772.getMeasurement();\n\nscale_factor = tcs3772.autoGain(tcs3772_data.clear);\n\nredColor = tcs3772_data.red;\ngreenColor = tcs3772_data.green;\nblueColor = tcs3772_data.blue;\n\nrgb.setColor(0,0,0);     // Initially OFF\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\nSerial.print(\"  R: \");\nSerial.println(redColor);\nSerial.print(\"  G: \");\nSerial.println(greenColor);\nSerial.print(\"  B: \");\nSerial.println(blueColor);\n\n// The values of redColor, greenColor and blueColor can be varied during the sensing calibration of RAK12021 module\n\nif (((redColor >= 9000) && (redColor <= 65535)) && ((greenColor >= 10000) && (greenColor <= 65535)) && ((blueColor >= 12000) && (blueColor <= 65535)))\n{\nrgb.setColor(255,255,255); // WHITE\n}\n\nelse if (((redColor >= 4000) && (redColor <= 18000)) && ((greenColor >= 1300) && (greenColor <= 5000)) && ((blueColor >= 950) && (blueColor <= 2000)))\n{\nrgb.setColor(255,255,0);  // YELLOW\n}\n\nelse if (((redColor >= 600) && (redColor <= 2000)) && ((greenColor >= 1700) && (greenColor <= 10000)) && ((blueColor >= 6800) && (blueColor <= 27000)))\n{\nrgb.setColor(0,0,255);    // BLUE\n}\n\nelse if (((redColor >= 1400) && (redColor <= 4000)) && ((greenColor >= 1300) && (greenColor <= 10000)) && ((blueColor >= 950) && (blueColor <= 2700)))\n{\nrgb.setColor(0,255,0);    // GREEN\n}\n\nelse if (((redColor >= 3000) && (redColor <= 20000)) && ((greenColor >= 700) && (greenColor <= 2400)) && ((blueColor >= 950) && (blueColor <= 3000)))\n{\nrgb.setColor(255,0,0);    // RED\n}\n\nelse if ((redColor < 1500) && (greenColor < 1400) && (blueColor < 900))\n{\nrgb.setColor(0,0,0);  // OFF\n}\n\ndelay(5000);\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void) {\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void) {\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data) {\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class) {\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void) {\nif (lmh_join_status_get() != LMH_SET) {\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\n// Showing the values of red, green and blue colors from RAK12021\ndata = \" Red: \" + String(redColor) + \" Green: \" + String(greenColor) + \" Blue: \" + String(blueColor);\n\nSerial.println(data);\n\nuint16_t red_data = redColor;\nuint16_t green_data = greenColor;\nuint16_t blue_data = blueColor;\n\nm_lora_app_data.buffer[i++] = 0x01;  // byte[0]\n\n// Red data\nm_lora_app_data.buffer[i++] = (uint8_t)((red_data & 0x0000FF00) >> 8);     // byte[1]\nm_lora_app_data.buffer[i++] = (uint8_t)(red_data & 0x000000FF);            // byte[2]\n\n// Green data\nm_lora_app_data.buffer[i++] = (uint8_t)((green_data & 0x0000FF00) >> 8);   // byte[3]\nm_lora_app_data.buffer[i++] = (uint8_t)(green_data & 0x000000FF);          // byte[4]\n\n// Blue data\nm_lora_app_data.buffer[i++] = (uint8_t)((blue_data & 0x0000FF00) >> 8);    // byte[5]\nm_lora_app_data.buffer[i++] = (uint8_t)(blue_data & 0x000000FF);           // byte[6]\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS) {\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n} else {\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0x96, 0xBD, 0xC5, 0x98, 0x17, 0x69, 0x8D, 0xFA, 0x1F, 0x64, 0xFE, 0x1C, 0xF9, 0x26, 0x7F, 0x8D };\n```  \n> **Image:** OTAA device successfully registered to TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "20f43f00efb1d6a5390c578cfdb7f21b", "product_family": "wisblock", "product_id": "kit6-light-and-color", "category": "How-To", "title": "WisBlock IoT Education Kit - Light & Color Quick Start Guide > WisBlock IoT Education Kit - Light & Color Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock IoT Education Kit - Light & Color using TTN and Qubitro > Light Color Recognizer LoRaWAN Application > LoRaWAN Code for Light Color Recognizer > Programming the Light Color Recognizer Device with Arduino IDE [CODE]", "content": "```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E };", "keywords": ["Arduino IDE", "RAK4631", "Light Color Recognizer", "LoRaWAN", "programming"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **Light Color Recognizer** device. Just copy the code below for **Light Color Recognizer LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the example </summary>  \n```c\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h>  //http://librarymanager/All#SX126x\n#include <Wire.h>\n#include <NCP5623.h>//http://librarymanager/All#NCP5623 By:RAKWireless\n#include \"TCS3772.h\"  // Click here to get the library: http://librarymanager/All#TCS37725\n// It use WB_IO2 to power up and is conflicting with INT1, so better use in SlotA/SlotC/SlotD.\n\nNCP5623 rgb;\nTCS3772 tcs3772;\nTCS3772_DataScaled tcs3772_data = {0};\n\nuint16_t scale_factor;\n\nuint16_t redColor;\nuint16_t greenColor;\nuint16_t blueColor;\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define RAK4631_BOARD true\n#else\n#define RAK4631_BOARD false\n#endif\n\nbool doOTAA = true;                                               // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                                       /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                                     /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5                               /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                                        /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;                           /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;                 /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                              /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = { LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF };\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = { BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler };\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0x96, 0xBD, 0xC5, 0x98, 0x17, 0x69, 0x8D, 0xFA, 0x1F, 0x64, 0xFE, 0x1C, 0xF9, 0x26, 0x7F, 0x8D };\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };\nuint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                                            /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];               //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = { m_lora_app_data_buffer, 0, 0, 0, 0 };  //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {\n\n// Initialize Serial for debug output\npinMode(LED_BLUE, OUTPUT);\ndigitalWrite(LED_BLUE, HIGH);\n\n// Sensor Power Switch\npinMode(WB_IO2, OUTPUT);\ndigitalWrite(WB_IO2, HIGH);\n\n// enable RAK14001\npinMode(WB_IO6, OUTPUT);\ndigitalWrite(WB_IO6, HIGH);\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial) {\nif ((millis() - timeout) < 5000) {\ndelay(100);\n} else {\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA) {\nSerial.println(\"Type: OTAA\");\n} else {\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion) {\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA) {\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n} else {\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0) {\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"================================\");\nSerial.println(\"RAK12021 + RAK14001 LoRaWAN Code\");\nSerial.println(\"================================\");\n\n// If using Native I2C\nWire.begin();\nWire.setClock(100000);\n\n// Serial.println(\"RAK14001 + RAK12021\");\n\nif (!rgb.begin())\n{\nSerial.println(\"RAK14001 not found on the I2C line\");\nwhile (1);\n}\nelse\n{\nSerial.println(\"RAK14001 Found. Begining execution\");\n}\n\n// set the current output level max, the range is 1 to 31\nrgb.setCurrent(25);\n\nif(tcs3772.begin() == true)\n{\nSerial.println(\"Found sensor.\");\n}\nelse\n{\nSerial.println(\"TCS37725 not found ... check your connections.\");\nwhile(1)\n{\ndelay(10);\n}\n}\ndelay(1000);\n}\n\nvoid loop() {\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\ntcs3772_data = tcs3772.getMeasurement();\n\nscale_factor = tcs3772.autoGain(tcs3772_data.clear);\n\nredColor = tcs3772_data.red;\ngreenColor = tcs3772_data.green;\nblueColor = tcs3772_data.blue;\n\nrgb.setColor(0,0,0);     // Initially OFF\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\nSerial.print(\"  R: \");\nSerial.println(redColor);\nSerial.print(\"  G: \");\nSerial.println(greenColor);\nSerial.print(\"  B: \");\nSerial.println(blueColor);\n\n// The values of redColor, greenColor and blueColor can be varied during the sensing calibration of RAK12021 module\n\nif (((redColor >= 9000) && (redColor <= 65535)) && ((greenColor >= 10000) && (greenColor <= 65535)) && ((blueColor >= 12000) && (blueColor <= 65535)))\n{\nrgb.setColor(255,255,255); // WHITE\n}\n\nelse if (((redColor >= 4000) && (redColor <= 18000)) && ((greenColor >= 1300) && (greenColor <= 5000)) && ((blueColor >= 950) && (blueColor <= 2000)))\n{\nrgb.setColor(255,255,0);  // YELLOW\n}\n\nelse if (((redColor >= 600) && (redColor <= 2000)) && ((greenColor >= 1700) && (greenColor <= 10000)) && ((blueColor >= 6800) && (blueColor <= 27000)))\n{\nrgb.setColor(0,0,255);    // BLUE\n}\n\nelse if (((redColor >= 1400) && (redColor <= 4000)) && ((greenColor >= 1300) && (greenColor <= 10000)) && ((blueColor >= 950) && (blueColor <= 2700)))\n{\nrgb.setColor(0,255,0);    // GREEN\n}\n\nelse if (((redColor >= 3000) && (redColor <= 20000)) && ((greenColor >= 700) && (greenColor <= 2400)) && ((blueColor >= 950) && (blueColor <= 3000)))\n{\nrgb.setColor(255,0,0);    // RED\n}\n\nelse if ((redColor < 1500) && (greenColor < 1400) && (blueColor < 900))\n{\nrgb.setColor(0,0,0);  // OFF\n}\n\ndelay(5000);\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void) {\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void) {\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data) {\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class) {\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void) {\nif (lmh_join_status_get() != LMH_SET) {\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\n// Showing the values of red, green and blue colors from RAK12021\ndata = \" Red: \" + String(redColor) + \" Green: \" + String(greenColor) + \" Blue: \" + String(blueColor);\n\nSerial.println(data);\n\nuint16_t red_data = redColor;\nuint16_t green_data = greenColor;\nuint16_t blue_data = blueColor;\n\nm_lora_app_data.buffer[i++] = 0x01;  // byte[0]\n\n// Red data\nm_lora_app_data.buffer[i++] = (uint8_t)((red_data & 0x0000FF00) >> 8);     // byte[1]\nm_lora_app_data.buffer[i++] = (uint8_t)(red_data & 0x000000FF);            // byte[2]\n\n// Green data\nm_lora_app_data.buffer[i++] = (uint8_t)((green_data & 0x0000FF00) >> 8);   // byte[3]\nm_lora_app_data.buffer[i++] = (uint8_t)(green_data & 0x000000FF);          // byte[4]\n\n// Blue data\nm_lora_app_data.buffer[i++] = (uint8_t)((blue_data & 0x0000FF00) >> 8);    // byte[5]\nm_lora_app_data.buffer[i++] = (uint8_t)(blue_data & 0x000000FF);           // byte[6]\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS) {\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n} else {\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0x96, 0xBD, 0xC5, 0x98, 0x17, 0x69, 0x8D, 0xFA, 0x1F, 0x64, 0xFE, 0x1C, 0xF9, 0x26, 0x7F, 0x8D };\n```  \n> **Image:** OTAA device successfully registered to TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "a4dc71bfcf6e215b483166b7f414762c", "product_family": "wisblock", "product_id": "kit6-light-and-color", "category": "How-To", "title": "WisBlock IoT Education Kit - Light & Color Quick Start Guide > WisBlock IoT Education Kit - Light & Color Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock IoT Education Kit - Light & Color using TTN and Qubitro > Light Color Recognizer LoRaWAN Application > LoRaWAN Code for Light Color Recognizer > Programming the Light Color Recognizer Device with Arduino IDE [CODE]", "content": "uint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0x96, 0xBD, 0xC5, 0x98, 0x17, 0x69, 0x8D, 0xFA, 0x1F, 0x64, 0xFE, 0x1C, 0xF9, 0x26, 0x7F, 0x8D };\n```  \n> **Image:** OTAA device successfully registered to TTN", "keywords": ["Arduino IDE", "RAK4631", "Light Color Recognizer", "LoRaWAN", "programming"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **Light Color Recognizer** device. Just copy the code below for **Light Color Recognizer LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the example </summary>  \n```c\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h>  //http://librarymanager/All#SX126x\n#include <Wire.h>\n#include <NCP5623.h>//http://librarymanager/All#NCP5623 By:RAKWireless\n#include \"TCS3772.h\"  // Click here to get the library: http://librarymanager/All#TCS37725\n// It use WB_IO2 to power up and is conflicting with INT1, so better use in SlotA/SlotC/SlotD.\n\nNCP5623 rgb;\nTCS3772 tcs3772;\nTCS3772_DataScaled tcs3772_data = {0};\n\nuint16_t scale_factor;\n\nuint16_t redColor;\nuint16_t greenColor;\nuint16_t blueColor;\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define RAK4631_BOARD true\n#else\n#define RAK4631_BOARD false\n#endif\n\nbool doOTAA = true;                                               // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                                       /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                                     /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5                               /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                                        /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;                           /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;                 /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                              /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = { LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF };\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = { BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler };\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0x96, 0xBD, 0xC5, 0x98, 0x17, 0x69, 0x8D, 0xFA, 0x1F, 0x64, 0xFE, 0x1C, 0xF9, 0x26, 0x7F, 0x8D };\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };\nuint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                                            /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];               //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = { m_lora_app_data_buffer, 0, 0, 0, 0 };  //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {\n\n// Initialize Serial for debug output\npinMode(LED_BLUE, OUTPUT);\ndigitalWrite(LED_BLUE, HIGH);\n\n// Sensor Power Switch\npinMode(WB_IO2, OUTPUT);\ndigitalWrite(WB_IO2, HIGH);\n\n// enable RAK14001\npinMode(WB_IO6, OUTPUT);\ndigitalWrite(WB_IO6, HIGH);\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial) {\nif ((millis() - timeout) < 5000) {\ndelay(100);\n} else {\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA) {\nSerial.println(\"Type: OTAA\");\n} else {\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion) {\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA) {\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n} else {\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0) {\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"================================\");\nSerial.println(\"RAK12021 + RAK14001 LoRaWAN Code\");\nSerial.println(\"================================\");\n\n// If using Native I2C\nWire.begin();\nWire.setClock(100000);\n\n// Serial.println(\"RAK14001 + RAK12021\");\n\nif (!rgb.begin())\n{\nSerial.println(\"RAK14001 not found on the I2C line\");\nwhile (1);\n}\nelse\n{\nSerial.println(\"RAK14001 Found. Begining execution\");\n}\n\n// set the current output level max, the range is 1 to 31\nrgb.setCurrent(25);\n\nif(tcs3772.begin() == true)\n{\nSerial.println(\"Found sensor.\");\n}\nelse\n{\nSerial.println(\"TCS37725 not found ... check your connections.\");\nwhile(1)\n{\ndelay(10);\n}\n}\ndelay(1000);\n}\n\nvoid loop() {\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\ntcs3772_data = tcs3772.getMeasurement();\n\nscale_factor = tcs3772.autoGain(tcs3772_data.clear);\n\nredColor = tcs3772_data.red;\ngreenColor = tcs3772_data.green;\nblueColor = tcs3772_data.blue;\n\nrgb.setColor(0,0,0);     // Initially OFF\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\nSerial.print(\"  R: \");\nSerial.println(redColor);\nSerial.print(\"  G: \");\nSerial.println(greenColor);\nSerial.print(\"  B: \");\nSerial.println(blueColor);\n\n// The values of redColor, greenColor and blueColor can be varied during the sensing calibration of RAK12021 module\n\nif (((redColor >= 9000) && (redColor <= 65535)) && ((greenColor >= 10000) && (greenColor <= 65535)) && ((blueColor >= 12000) && (blueColor <= 65535)))\n{\nrgb.setColor(255,255,255); // WHITE\n}\n\nelse if (((redColor >= 4000) && (redColor <= 18000)) && ((greenColor >= 1300) && (greenColor <= 5000)) && ((blueColor >= 950) && (blueColor <= 2000)))\n{\nrgb.setColor(255,255,0);  // YELLOW\n}\n\nelse if (((redColor >= 600) && (redColor <= 2000)) && ((greenColor >= 1700) && (greenColor <= 10000)) && ((blueColor >= 6800) && (blueColor <= 27000)))\n{\nrgb.setColor(0,0,255);    // BLUE\n}\n\nelse if (((redColor >= 1400) && (redColor <= 4000)) && ((greenColor >= 1300) && (greenColor <= 10000)) && ((blueColor >= 950) && (blueColor <= 2700)))\n{\nrgb.setColor(0,255,0);    // GREEN\n}\n\nelse if (((redColor >= 3000) && (redColor <= 20000)) && ((greenColor >= 700) && (greenColor <= 2400)) && ((blueColor >= 950) && (blueColor <= 3000)))\n{\nrgb.setColor(255,0,0);    // RED\n}\n\nelse if ((redColor < 1500) && (greenColor < 1400) && (blueColor < 900))\n{\nrgb.setColor(0,0,0);  // OFF\n}\n\ndelay(5000);\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void) {\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void) {\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data) {\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class) {\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void) {\nif (lmh_join_status_get() != LMH_SET) {\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\n// Showing the values of red, green and blue colors from RAK12021\ndata = \" Red: \" + String(redColor) + \" Green: \" + String(greenColor) + \" Blue: \" + String(blueColor);\n\nSerial.println(data);\n\nuint16_t red_data = redColor;\nuint16_t green_data = greenColor;\nuint16_t blue_data = blueColor;\n\nm_lora_app_data.buffer[i++] = 0x01;  // byte[0]\n\n// Red data\nm_lora_app_data.buffer[i++] = (uint8_t)((red_data & 0x0000FF00) >> 8);     // byte[1]\nm_lora_app_data.buffer[i++] = (uint8_t)(red_data & 0x000000FF);            // byte[2]\n\n// Green data\nm_lora_app_data.buffer[i++] = (uint8_t)((green_data & 0x0000FF00) >> 8);   // byte[3]\nm_lora_app_data.buffer[i++] = (uint8_t)(green_data & 0x000000FF);          // byte[4]\n\n// Blue data\nm_lora_app_data.buffer[i++] = (uint8_t)((blue_data & 0x0000FF00) >> 8);    // byte[5]\nm_lora_app_data.buffer[i++] = (uint8_t)(blue_data & 0x000000FF);           // byte[6]\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS) {\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n} else {\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0x96, 0xBD, 0xC5, 0x98, 0x17, 0x69, 0x8D, 0xFA, 0x1F, 0x64, 0xFE, 0x1C, 0xF9, 0x26, 0x7F, 0x8D };\n```  \n> **Image:** OTAA device successfully registered to TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "03ddfb046bbfd1d774c4e27131c66442", "product_family": "wisblock", "product_id": "kit6-light-and-color", "category": "How-To", "title": "WisBlock IoT Education Kit - Light & Color Quick Start Guide > WisBlock IoT Education Kit - Light & Color Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock IoT Education Kit - Light & Color using TTN and Qubitro > Light Color Recognizer LoRaWAN Application > LoRaWAN Code for Light Color Recognizer > Programming the Light Color Recognizer Device with Arduino IDE [CODE]", "content": "```  \n> **Image:** OTAA device successfully registered to TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.", "keywords": ["Arduino IDE", "RAK4631", "Light Color Recognizer", "LoRaWAN", "programming"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **Light Color Recognizer** device. Just copy the code below for **Light Color Recognizer LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the example </summary>  \n```c\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h>  //http://librarymanager/All#SX126x\n#include <Wire.h>\n#include <NCP5623.h>//http://librarymanager/All#NCP5623 By:RAKWireless\n#include \"TCS3772.h\"  // Click here to get the library: http://librarymanager/All#TCS37725\n// It use WB_IO2 to power up and is conflicting with INT1, so better use in SlotA/SlotC/SlotD.\n\nNCP5623 rgb;\nTCS3772 tcs3772;\nTCS3772_DataScaled tcs3772_data = {0};\n\nuint16_t scale_factor;\n\nuint16_t redColor;\nuint16_t greenColor;\nuint16_t blueColor;\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define RAK4631_BOARD true\n#else\n#define RAK4631_BOARD false\n#endif\n\nbool doOTAA = true;                                               // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                                       /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                                     /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5                               /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                                        /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;                           /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;                 /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                              /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = { LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF };\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = { BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler };\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0x96, 0xBD, 0xC5, 0x98, 0x17, 0x69, 0x8D, 0xFA, 0x1F, 0x64, 0xFE, 0x1C, 0xF9, 0x26, 0x7F, 0x8D };\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };\nuint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                                            /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];               //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = { m_lora_app_data_buffer, 0, 0, 0, 0 };  //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {\n\n// Initialize Serial for debug output\npinMode(LED_BLUE, OUTPUT);\ndigitalWrite(LED_BLUE, HIGH);\n\n// Sensor Power Switch\npinMode(WB_IO2, OUTPUT);\ndigitalWrite(WB_IO2, HIGH);\n\n// enable RAK14001\npinMode(WB_IO6, OUTPUT);\ndigitalWrite(WB_IO6, HIGH);\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial) {\nif ((millis() - timeout) < 5000) {\ndelay(100);\n} else {\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA) {\nSerial.println(\"Type: OTAA\");\n} else {\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion) {\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA) {\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n} else {\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0) {\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"================================\");\nSerial.println(\"RAK12021 + RAK14001 LoRaWAN Code\");\nSerial.println(\"================================\");\n\n// If using Native I2C\nWire.begin();\nWire.setClock(100000);\n\n// Serial.println(\"RAK14001 + RAK12021\");\n\nif (!rgb.begin())\n{\nSerial.println(\"RAK14001 not found on the I2C line\");\nwhile (1);\n}\nelse\n{\nSerial.println(\"RAK14001 Found. Begining execution\");\n}\n\n// set the current output level max, the range is 1 to 31\nrgb.setCurrent(25);\n\nif(tcs3772.begin() == true)\n{\nSerial.println(\"Found sensor.\");\n}\nelse\n{\nSerial.println(\"TCS37725 not found ... check your connections.\");\nwhile(1)\n{\ndelay(10);\n}\n}\ndelay(1000);\n}\n\nvoid loop() {\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\ntcs3772_data = tcs3772.getMeasurement();\n\nscale_factor = tcs3772.autoGain(tcs3772_data.clear);\n\nredColor = tcs3772_data.red;\ngreenColor = tcs3772_data.green;\nblueColor = tcs3772_data.blue;\n\nrgb.setColor(0,0,0);     // Initially OFF\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\nSerial.print(\"  R: \");\nSerial.println(redColor);\nSerial.print(\"  G: \");\nSerial.println(greenColor);\nSerial.print(\"  B: \");\nSerial.println(blueColor);\n\n// The values of redColor, greenColor and blueColor can be varied during the sensing calibration of RAK12021 module\n\nif (((redColor >= 9000) && (redColor <= 65535)) && ((greenColor >= 10000) && (greenColor <= 65535)) && ((blueColor >= 12000) && (blueColor <= 65535)))\n{\nrgb.setColor(255,255,255); // WHITE\n}\n\nelse if (((redColor >= 4000) && (redColor <= 18000)) && ((greenColor >= 1300) && (greenColor <= 5000)) && ((blueColor >= 950) && (blueColor <= 2000)))\n{\nrgb.setColor(255,255,0);  // YELLOW\n}\n\nelse if (((redColor >= 600) && (redColor <= 2000)) && ((greenColor >= 1700) && (greenColor <= 10000)) && ((blueColor >= 6800) && (blueColor <= 27000)))\n{\nrgb.setColor(0,0,255);    // BLUE\n}\n\nelse if (((redColor >= 1400) && (redColor <= 4000)) && ((greenColor >= 1300) && (greenColor <= 10000)) && ((blueColor >= 950) && (blueColor <= 2700)))\n{\nrgb.setColor(0,255,0);    // GREEN\n}\n\nelse if (((redColor >= 3000) && (redColor <= 20000)) && ((greenColor >= 700) && (greenColor <= 2400)) && ((blueColor >= 950) && (blueColor <= 3000)))\n{\nrgb.setColor(255,0,0);    // RED\n}\n\nelse if ((redColor < 1500) && (greenColor < 1400) && (blueColor < 900))\n{\nrgb.setColor(0,0,0);  // OFF\n}\n\ndelay(5000);\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void) {\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void) {\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data) {\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class) {\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void) {\nif (lmh_join_status_get() != LMH_SET) {\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\n// Showing the values of red, green and blue colors from RAK12021\ndata = \" Red: \" + String(redColor) + \" Green: \" + String(greenColor) + \" Blue: \" + String(blueColor);\n\nSerial.println(data);\n\nuint16_t red_data = redColor;\nuint16_t green_data = greenColor;\nuint16_t blue_data = blueColor;\n\nm_lora_app_data.buffer[i++] = 0x01;  // byte[0]\n\n// Red data\nm_lora_app_data.buffer[i++] = (uint8_t)((red_data & 0x0000FF00) >> 8);     // byte[1]\nm_lora_app_data.buffer[i++] = (uint8_t)(red_data & 0x000000FF);            // byte[2]\n\n// Green data\nm_lora_app_data.buffer[i++] = (uint8_t)((green_data & 0x0000FF00) >> 8);   // byte[3]\nm_lora_app_data.buffer[i++] = (uint8_t)(green_data & 0x000000FF);          // byte[4]\n\n// Blue data\nm_lora_app_data.buffer[i++] = (uint8_t)((blue_data & 0x0000FF00) >> 8);    // byte[5]\nm_lora_app_data.buffer[i++] = (uint8_t)(blue_data & 0x000000FF);           // byte[6]\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS) {\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n} else {\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0x96, 0xBD, 0xC5, 0x98, 0x17, 0x69, 0x8D, 0xFA, 0x1F, 0x64, 0xFE, 0x1C, 0xF9, 0x26, 0x7F, 0x8D };\n```  \n> **Image:** OTAA device successfully registered to TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "e39d55a654db86504db052829ba1f339", "product_family": "wisblock", "product_id": "kit6-light-and-color", "category": "How-To", "title": "WisBlock IoT Education Kit - Light & Color Quick Start Guide > WisBlock IoT Education Kit - Light & Color Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock IoT Education Kit - Light & Color using TTN and Qubitro > Light Color Recognizer LoRaWAN Application > LoRaWAN Code for Light Color Recognizer > Programming the Light Color Recognizer Device with Arduino IDE [CODE]", "content": "> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board", "keywords": ["Arduino IDE", "RAK4631", "Light Color Recognizer", "LoRaWAN", "programming"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **Light Color Recognizer** device. Just copy the code below for **Light Color Recognizer LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the example </summary>  \n```c\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h>  //http://librarymanager/All#SX126x\n#include <Wire.h>\n#include <NCP5623.h>//http://librarymanager/All#NCP5623 By:RAKWireless\n#include \"TCS3772.h\"  // Click here to get the library: http://librarymanager/All#TCS37725\n// It use WB_IO2 to power up and is conflicting with INT1, so better use in SlotA/SlotC/SlotD.\n\nNCP5623 rgb;\nTCS3772 tcs3772;\nTCS3772_DataScaled tcs3772_data = {0};\n\nuint16_t scale_factor;\n\nuint16_t redColor;\nuint16_t greenColor;\nuint16_t blueColor;\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define RAK4631_BOARD true\n#else\n#define RAK4631_BOARD false\n#endif\n\nbool doOTAA = true;                                               // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                                       /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                                     /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5                               /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                                        /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;                           /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;                 /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                              /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = { LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF };\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = { BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler };\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0x96, 0xBD, 0xC5, 0x98, 0x17, 0x69, 0x8D, 0xFA, 0x1F, 0x64, 0xFE, 0x1C, 0xF9, 0x26, 0x7F, 0x8D };\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };\nuint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                                            /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];               //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = { m_lora_app_data_buffer, 0, 0, 0, 0 };  //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {\n\n// Initialize Serial for debug output\npinMode(LED_BLUE, OUTPUT);\ndigitalWrite(LED_BLUE, HIGH);\n\n// Sensor Power Switch\npinMode(WB_IO2, OUTPUT);\ndigitalWrite(WB_IO2, HIGH);\n\n// enable RAK14001\npinMode(WB_IO6, OUTPUT);\ndigitalWrite(WB_IO6, HIGH);\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial) {\nif ((millis() - timeout) < 5000) {\ndelay(100);\n} else {\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA) {\nSerial.println(\"Type: OTAA\");\n} else {\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion) {\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA) {\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n} else {\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0) {\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"================================\");\nSerial.println(\"RAK12021 + RAK14001 LoRaWAN Code\");\nSerial.println(\"================================\");\n\n// If using Native I2C\nWire.begin();\nWire.setClock(100000);\n\n// Serial.println(\"RAK14001 + RAK12021\");\n\nif (!rgb.begin())\n{\nSerial.println(\"RAK14001 not found on the I2C line\");\nwhile (1);\n}\nelse\n{\nSerial.println(\"RAK14001 Found. Begining execution\");\n}\n\n// set the current output level max, the range is 1 to 31\nrgb.setCurrent(25);\n\nif(tcs3772.begin() == true)\n{\nSerial.println(\"Found sensor.\");\n}\nelse\n{\nSerial.println(\"TCS37725 not found ... check your connections.\");\nwhile(1)\n{\ndelay(10);\n}\n}\ndelay(1000);\n}\n\nvoid loop() {\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\ntcs3772_data = tcs3772.getMeasurement();\n\nscale_factor = tcs3772.autoGain(tcs3772_data.clear);\n\nredColor = tcs3772_data.red;\ngreenColor = tcs3772_data.green;\nblueColor = tcs3772_data.blue;\n\nrgb.setColor(0,0,0);     // Initially OFF\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\nSerial.print(\"  R: \");\nSerial.println(redColor);\nSerial.print(\"  G: \");\nSerial.println(greenColor);\nSerial.print(\"  B: \");\nSerial.println(blueColor);\n\n// The values of redColor, greenColor and blueColor can be varied during the sensing calibration of RAK12021 module\n\nif (((redColor >= 9000) && (redColor <= 65535)) && ((greenColor >= 10000) && (greenColor <= 65535)) && ((blueColor >= 12000) && (blueColor <= 65535)))\n{\nrgb.setColor(255,255,255); // WHITE\n}\n\nelse if (((redColor >= 4000) && (redColor <= 18000)) && ((greenColor >= 1300) && (greenColor <= 5000)) && ((blueColor >= 950) && (blueColor <= 2000)))\n{\nrgb.setColor(255,255,0);  // YELLOW\n}\n\nelse if (((redColor >= 600) && (redColor <= 2000)) && ((greenColor >= 1700) && (greenColor <= 10000)) && ((blueColor >= 6800) && (blueColor <= 27000)))\n{\nrgb.setColor(0,0,255);    // BLUE\n}\n\nelse if (((redColor >= 1400) && (redColor <= 4000)) && ((greenColor >= 1300) && (greenColor <= 10000)) && ((blueColor >= 950) && (blueColor <= 2700)))\n{\nrgb.setColor(0,255,0);    // GREEN\n}\n\nelse if (((redColor >= 3000) && (redColor <= 20000)) && ((greenColor >= 700) && (greenColor <= 2400)) && ((blueColor >= 950) && (blueColor <= 3000)))\n{\nrgb.setColor(255,0,0);    // RED\n}\n\nelse if ((redColor < 1500) && (greenColor < 1400) && (blueColor < 900))\n{\nrgb.setColor(0,0,0);  // OFF\n}\n\ndelay(5000);\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void) {\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void) {\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data) {\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class) {\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void) {\nif (lmh_join_status_get() != LMH_SET) {\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\n// Showing the values of red, green and blue colors from RAK12021\ndata = \" Red: \" + String(redColor) + \" Green: \" + String(greenColor) + \" Blue: \" + String(blueColor);\n\nSerial.println(data);\n\nuint16_t red_data = redColor;\nuint16_t green_data = greenColor;\nuint16_t blue_data = blueColor;\n\nm_lora_app_data.buffer[i++] = 0x01;  // byte[0]\n\n// Red data\nm_lora_app_data.buffer[i++] = (uint8_t)((red_data & 0x0000FF00) >> 8);     // byte[1]\nm_lora_app_data.buffer[i++] = (uint8_t)(red_data & 0x000000FF);            // byte[2]\n\n// Green data\nm_lora_app_data.buffer[i++] = (uint8_t)((green_data & 0x0000FF00) >> 8);   // byte[3]\nm_lora_app_data.buffer[i++] = (uint8_t)(green_data & 0x000000FF);          // byte[4]\n\n// Blue data\nm_lora_app_data.buffer[i++] = (uint8_t)((blue_data & 0x0000FF00) >> 8);    // byte[5]\nm_lora_app_data.buffer[i++] = (uint8_t)(blue_data & 0x000000FF);           // byte[6]\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS) {\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n} else {\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0x96, 0xBD, 0xC5, 0x98, 0x17, 0x69, 0x8D, 0xFA, 0x1F, 0x64, 0xFE, 0x1C, 0xF9, 0x26, 0x7F, 0x8D };\n```  \n> **Image:** OTAA device successfully registered to TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "a18d94736f73d919ed8f4098418bc489", "product_family": "wisblock", "product_id": "kit6-light-and-color", "category": "How-To", "title": "WisBlock IoT Education Kit - Light & Color Quick Start Guide > WisBlock IoT Education Kit - Light & Color Quick Start Guide > Miscellaneous > TTN Account Creation > How to Register a Device on The Things Network (TTN) for kit6-light-and-color", "content": "1. The first step is to go to [The Things Network](https://www.thethingsnetwork.org/) and sign up an account shown in the figure below. Then select a cluster as shown in the figure below.  \n> **Image:** Signing up an account in TTN  \n> **Image:** Signing up an account in TTN  \n> **Image:** Selecting Cluster in TTN  \n> **Image:** Signing up through the Things ID  \n> **Image:** Creation of an account through the Things ID  \n> **Image:** Creation of an account through the Things ID", "keywords": ["The Things Network", "TTN", "device registration", "LoRaWAN", "application creation"], "source_file": "quickstart.md", "token_count": 250, "parent_content": "1. The first step is to go to [The Things Network](https://www.thethingsnetwork.org/) and sign up an account shown in the figure below. Then select a cluster as shown in the figure below.  \n> **Image:** Signing up an account in TTN  \n> **Image:** Signing up an account in TTN  \n> **Image:** Selecting Cluster in TTN  \n> **Image:** Signing up through the Things ID  \n> **Image:** Creation of an account through the Things ID  \n> **Image:** Creation of an account through the Things ID  \nYou can use the same login credentials on the TTN V2 if you have one. If you have no account yet, you need to create one.  \n2. Now that you are logged in to the platform, the next step is to create an application. Click **Create an application**.  \n> **Image:** The Things Stack Platform  \n> **Image:** Creating TTN Application of your LoRaWAN devices  \n3. To have an application registered, input first the specific details and necessary information about your application then click **Create application**.  \n> **Image:** Details of the TTN application  \n> **TIP:** NOTE  \nThe details and information are dependent to what device you are using (e.g. **RAK12019**, etc.).  \n4. If you have no error on the previous step, you should now be on the application console page.  \n> **TIP:** NOTE  \nAbove procedures are applicable to all applications you will be using.  \n- For **UV Index & UV Intensity Monitoring**, go to this [link](#uv-index-uv-intensity-monitoring-ttn-registration-section-and-device-registration) once done with the TTN account creation.\n- For **Light Color Recognizer**, go to this [link](#light-color-recognizer-ttn-registration-section-and-device-registration) once done with the TTN account creation."}
{"id": "5e9fa0da43c881685c5728cb2bac5909", "product_family": "wisblock", "product_id": "kit6-light-and-color", "category": "How-To", "title": "WisBlock IoT Education Kit - Light & Color Quick Start Guide > WisBlock IoT Education Kit - Light & Color Quick Start Guide > Miscellaneous > TTN Account Creation > How to Register a Device on The Things Network (TTN) for kit6-light-and-color", "content": "> **Image:** Creation of an account through the Things ID  \nYou can use the same login credentials on the TTN V2 if you have one. If you have no account yet, you need to create one.  \n2. Now that you are logged in to the platform, the next step is to create an application. Click **Create an application**.  \n> **Image:** The Things Stack Platform  \n> **Image:** Creating TTN Application of your LoRaWAN devices", "keywords": ["The Things Network", "TTN", "device registration", "LoRaWAN", "application creation"], "source_file": "quickstart.md", "token_count": 250, "parent_content": "1. The first step is to go to [The Things Network](https://www.thethingsnetwork.org/) and sign up an account shown in the figure below. Then select a cluster as shown in the figure below.  \n> **Image:** Signing up an account in TTN  \n> **Image:** Signing up an account in TTN  \n> **Image:** Selecting Cluster in TTN  \n> **Image:** Signing up through the Things ID  \n> **Image:** Creation of an account through the Things ID  \n> **Image:** Creation of an account through the Things ID  \nYou can use the same login credentials on the TTN V2 if you have one. If you have no account yet, you need to create one.  \n2. Now that you are logged in to the platform, the next step is to create an application. Click **Create an application**.  \n> **Image:** The Things Stack Platform  \n> **Image:** Creating TTN Application of your LoRaWAN devices  \n3. To have an application registered, input first the specific details and necessary information about your application then click **Create application**.  \n> **Image:** Details of the TTN application  \n> **TIP:** NOTE  \nThe details and information are dependent to what device you are using (e.g. **RAK12019**, etc.).  \n4. If you have no error on the previous step, you should now be on the application console page.  \n> **TIP:** NOTE  \nAbove procedures are applicable to all applications you will be using.  \n- For **UV Index & UV Intensity Monitoring**, go to this [link](#uv-index-uv-intensity-monitoring-ttn-registration-section-and-device-registration) once done with the TTN account creation.\n- For **Light Color Recognizer**, go to this [link](#light-color-recognizer-ttn-registration-section-and-device-registration) once done with the TTN account creation."}
{"id": "f956a441efdf9b7abc05065f6508fb51", "product_family": "wisblock", "product_id": "kit6-light-and-color", "category": "How-To", "title": "WisBlock IoT Education Kit - Light & Color Quick Start Guide > WisBlock IoT Education Kit - Light & Color Quick Start Guide > Miscellaneous > TTN Account Creation > How to Register a Device on The Things Network (TTN) for kit6-light-and-color", "content": "> **Image:** Creating TTN Application of your LoRaWAN devices  \n3. To have an application registered, input first the specific details and necessary information about your application then click **Create application**.  \n> **Image:** Details of the TTN application  \n> **TIP:** NOTE  \nThe details and information are dependent to what device you are using (e.g. **RAK12019**, etc.).  \n4. If you have no error on the previous step, you should now be on the application console page.", "keywords": ["The Things Network", "TTN", "device registration", "LoRaWAN", "application creation"], "source_file": "quickstart.md", "token_count": 250, "parent_content": "1. The first step is to go to [The Things Network](https://www.thethingsnetwork.org/) and sign up an account shown in the figure below. Then select a cluster as shown in the figure below.  \n> **Image:** Signing up an account in TTN  \n> **Image:** Signing up an account in TTN  \n> **Image:** Selecting Cluster in TTN  \n> **Image:** Signing up through the Things ID  \n> **Image:** Creation of an account through the Things ID  \n> **Image:** Creation of an account through the Things ID  \nYou can use the same login credentials on the TTN V2 if you have one. If you have no account yet, you need to create one.  \n2. Now that you are logged in to the platform, the next step is to create an application. Click **Create an application**.  \n> **Image:** The Things Stack Platform  \n> **Image:** Creating TTN Application of your LoRaWAN devices  \n3. To have an application registered, input first the specific details and necessary information about your application then click **Create application**.  \n> **Image:** Details of the TTN application  \n> **TIP:** NOTE  \nThe details and information are dependent to what device you are using (e.g. **RAK12019**, etc.).  \n4. If you have no error on the previous step, you should now be on the application console page.  \n> **TIP:** NOTE  \nAbove procedures are applicable to all applications you will be using.  \n- For **UV Index & UV Intensity Monitoring**, go to this [link](#uv-index-uv-intensity-monitoring-ttn-registration-section-and-device-registration) once done with the TTN account creation.\n- For **Light Color Recognizer**, go to this [link](#light-color-recognizer-ttn-registration-section-and-device-registration) once done with the TTN account creation."}
{"id": "da0c6a5d6cbe8cdd8c1e6970305e85b7", "product_family": "wisblock", "product_id": "kit6-light-and-color", "category": "How-To", "title": "WisBlock IoT Education Kit - Light & Color Quick Start Guide > WisBlock IoT Education Kit - Light & Color Quick Start Guide > Miscellaneous > TTN Account Creation > How to Register a Device on The Things Network (TTN) for kit6-light-and-color", "content": "4. If you have no error on the previous step, you should now be on the application console page.  \n> **TIP:** NOTE  \nAbove procedures are applicable to all applications you will be using.  \n- For **UV Index & UV Intensity Monitoring**, go to this [link](#uv-index-uv-intensity-monitoring-ttn-registration-section-and-device-registration) once done with the TTN account creation.", "keywords": ["The Things Network", "TTN", "device registration", "LoRaWAN", "application creation"], "source_file": "quickstart.md", "token_count": 250, "parent_content": "1. The first step is to go to [The Things Network](https://www.thethingsnetwork.org/) and sign up an account shown in the figure below. Then select a cluster as shown in the figure below.  \n> **Image:** Signing up an account in TTN  \n> **Image:** Signing up an account in TTN  \n> **Image:** Selecting Cluster in TTN  \n> **Image:** Signing up through the Things ID  \n> **Image:** Creation of an account through the Things ID  \n> **Image:** Creation of an account through the Things ID  \nYou can use the same login credentials on the TTN V2 if you have one. If you have no account yet, you need to create one.  \n2. Now that you are logged in to the platform, the next step is to create an application. Click **Create an application**.  \n> **Image:** The Things Stack Platform  \n> **Image:** Creating TTN Application of your LoRaWAN devices  \n3. To have an application registered, input first the specific details and necessary information about your application then click **Create application**.  \n> **Image:** Details of the TTN application  \n> **TIP:** NOTE  \nThe details and information are dependent to what device you are using (e.g. **RAK12019**, etc.).  \n4. If you have no error on the previous step, you should now be on the application console page.  \n> **TIP:** NOTE  \nAbove procedures are applicable to all applications you will be using.  \n- For **UV Index & UV Intensity Monitoring**, go to this [link](#uv-index-uv-intensity-monitoring-ttn-registration-section-and-device-registration) once done with the TTN account creation.\n- For **Light Color Recognizer**, go to this [link](#light-color-recognizer-ttn-registration-section-and-device-registration) once done with the TTN account creation."}
{"id": "5780548deadc872348e97a2c94cd0087", "product_family": "wisblock", "product_id": "kit6-light-and-color", "category": "How-To", "title": "WisBlock IoT Education Kit - Light & Color Quick Start Guide > WisBlock IoT Education Kit - Light & Color Quick Start Guide > Miscellaneous > TTN Account Creation > How to Register a Device on The Things Network (TTN) for kit6-light-and-color", "content": "- For **Light Color Recognizer**, go to this [link](#light-color-recognizer-ttn-registration-section-and-device-registration) once done with the TTN account creation.", "keywords": ["The Things Network", "TTN", "device registration", "LoRaWAN", "application creation"], "source_file": "quickstart.md", "token_count": 250, "parent_content": "1. The first step is to go to [The Things Network](https://www.thethingsnetwork.org/) and sign up an account shown in the figure below. Then select a cluster as shown in the figure below.  \n> **Image:** Signing up an account in TTN  \n> **Image:** Signing up an account in TTN  \n> **Image:** Selecting Cluster in TTN  \n> **Image:** Signing up through the Things ID  \n> **Image:** Creation of an account through the Things ID  \n> **Image:** Creation of an account through the Things ID  \nYou can use the same login credentials on the TTN V2 if you have one. If you have no account yet, you need to create one.  \n2. Now that you are logged in to the platform, the next step is to create an application. Click **Create an application**.  \n> **Image:** The Things Stack Platform  \n> **Image:** Creating TTN Application of your LoRaWAN devices  \n3. To have an application registered, input first the specific details and necessary information about your application then click **Create application**.  \n> **Image:** Details of the TTN application  \n> **TIP:** NOTE  \nThe details and information are dependent to what device you are using (e.g. **RAK12019**, etc.).  \n4. If you have no error on the previous step, you should now be on the application console page.  \n> **TIP:** NOTE  \nAbove procedures are applicable to all applications you will be using.  \n- For **UV Index & UV Intensity Monitoring**, go to this [link](#uv-index-uv-intensity-monitoring-ttn-registration-section-and-device-registration) once done with the TTN account creation.\n- For **Light Color Recognizer**, go to this [link](#light-color-recognizer-ttn-registration-section-and-device-registration) once done with the TTN account creation."}
{"id": "3bc43c4949edbe552b41ea825e0dcfc8", "product_family": "wisblock", "product_id": "kit6-light-and-color", "category": "How-To", "title": "WisBlock IoT Education Kit - Light & Color Quick Start Guide > WisBlock IoT Education Kit - Light & Color Quick Start Guide > Miscellaneous > Device Registration > Registering an OTAA End-Device on TTN Console", "content": "1. Go to your application console to register a device. To start adding an OTAA end-device, click **+ Register end device**, as shown below.  \n> **Image:** Register End Device  \n2. To register the board, click the **Enter end device specifics manually**.  \n> **Image:** Enter end device specifics manually", "keywords": ["OTAA", "TTN", "end-device", "registration", "LoRaWAN"], "source_file": "quickstart.md", "token_count": 0, "parent_content": "1. Go to your application console to register a device. To start adding an OTAA end-device, click **+ Register end device**, as shown below.  \n> **Image:** Register End Device  \n2. To register the board, click the **Enter end device specifics manually**.  \n> **Image:** Enter end device specifics manually  \n3. Next step is to set up **Frequency plan**, compatible **LoRaWAN version**, and **Regional Parameters version** supported. Then provide the **JoinEUI** credentials by entering zeroes into it.  \n> **Image:** Setting up your device  \n> **Image:** Setting up your device  \n4. Then click **Show advanced activation, LoRaWAN class and cluster settings**. Configure the activation mode by selecting **Over the air activation (OTAA)** and Additional LoRaWAN class capabilities to **class A only**. Then click **Confirm**.  \n> **Image:** Setting up your device  \n> **Image:** Setting up your device  \n5. Once done, provide the DevEUI credentials of your device into the **DevEUI** portion. This will automatically generate the specific End\ndevice ID of your board. Then click **Generate** under **AppKey** under Provisioning information section. Once done, you need to change the **End device ID** since it is automatically prefilled using the **DevEUI** of your device. Then click **Register end device**.  \n> **TIP:** NOTE  \n- The **AppEUI**, **DevEUI**, and **AppKey** are hidden in this section as these are unique from a specific device. The **DevEUI** credential is unique to every **RAK4631** device. Also, you should generate your own **AppEUI** and **AppKey** credentials for your specific device and application.  \n- The **AppEUI** is the same as **JoinEUI**.  \n- The details under **End device ID** are dependent to what device you are using (e.g. **uv-intensity-meter**, etc.).  \n> **Image:** Setting up your device  \n> **Image:** Setting up your device  \n> **Image:** Changing the End device ID  \n> **Image:** Register End Device  \n6. You should now be able to see the device on the TTN console after you fully register your device, as shown below.  \n> **TIP:** NOTE  \n- The **AppEUI**, **DevEUI**, and **AppKey** are the parameters that you will need to activate your LoRaWAN end-device via OTAA. The **AppKey** is hidden by default for security reasons, but you can easily show it by clicking the show button. You can also copy the parameters quickly using the copy button.  \n- These parameters are always accessible on the device console page, as highlighted in the figure below.  \n> **Image:** OTAA device successfully registered to TTN  \n> **TIP:** NOTE  \nAbove procedures are applicable to all applications you will be using.  \n- For **UV Index & UV Intensity Monitoring**, go to this [link](#lorawan-code-for-uv-index-uv-intensity-monitoring) once done with the device registration.\n- For **Light Color Recognizer**, go to this [link](#lorawan-code-for-light-color-recognizer) once done with the device registration."}
{"id": "0f7b1271b4fa38812d450fbf503012b1", "product_family": "wisblock", "product_id": "kit6-light-and-color", "category": "How-To", "title": "WisBlock IoT Education Kit - Light & Color Quick Start Guide > WisBlock IoT Education Kit - Light & Color Quick Start Guide > Miscellaneous > Device Registration > Registering an OTAA End-Device on TTN Console", "content": "> **Image:** Enter end device specifics manually  \n3. Next step is to set up **Frequency plan**, compatible **LoRaWAN version**, and **Regional Parameters version** supported. Then provide the **JoinEUI** credentials by entering zeroes into it.  \n> **Image:** Setting up your device  \n> **Image:** Setting up your device", "keywords": ["OTAA", "TTN", "end-device", "registration", "LoRaWAN"], "source_file": "quickstart.md", "token_count": 0, "parent_content": "1. Go to your application console to register a device. To start adding an OTAA end-device, click **+ Register end device**, as shown below.  \n> **Image:** Register End Device  \n2. To register the board, click the **Enter end device specifics manually**.  \n> **Image:** Enter end device specifics manually  \n3. Next step is to set up **Frequency plan**, compatible **LoRaWAN version**, and **Regional Parameters version** supported. Then provide the **JoinEUI** credentials by entering zeroes into it.  \n> **Image:** Setting up your device  \n> **Image:** Setting up your device  \n4. Then click **Show advanced activation, LoRaWAN class and cluster settings**. Configure the activation mode by selecting **Over the air activation (OTAA)** and Additional LoRaWAN class capabilities to **class A only**. Then click **Confirm**.  \n> **Image:** Setting up your device  \n> **Image:** Setting up your device  \n5. Once done, provide the DevEUI credentials of your device into the **DevEUI** portion. This will automatically generate the specific End\ndevice ID of your board. Then click **Generate** under **AppKey** under Provisioning information section. Once done, you need to change the **End device ID** since it is automatically prefilled using the **DevEUI** of your device. Then click **Register end device**.  \n> **TIP:** NOTE  \n- The **AppEUI**, **DevEUI**, and **AppKey** are hidden in this section as these are unique from a specific device. The **DevEUI** credential is unique to every **RAK4631** device. Also, you should generate your own **AppEUI** and **AppKey** credentials for your specific device and application.  \n- The **AppEUI** is the same as **JoinEUI**.  \n- The details under **End device ID** are dependent to what device you are using (e.g. **uv-intensity-meter**, etc.).  \n> **Image:** Setting up your device  \n> **Image:** Setting up your device  \n> **Image:** Changing the End device ID  \n> **Image:** Register End Device  \n6. You should now be able to see the device on the TTN console after you fully register your device, as shown below.  \n> **TIP:** NOTE  \n- The **AppEUI**, **DevEUI**, and **AppKey** are the parameters that you will need to activate your LoRaWAN end-device via OTAA. The **AppKey** is hidden by default for security reasons, but you can easily show it by clicking the show button. You can also copy the parameters quickly using the copy button.  \n- These parameters are always accessible on the device console page, as highlighted in the figure below.  \n> **Image:** OTAA device successfully registered to TTN  \n> **TIP:** NOTE  \nAbove procedures are applicable to all applications you will be using.  \n- For **UV Index & UV Intensity Monitoring**, go to this [link](#lorawan-code-for-uv-index-uv-intensity-monitoring) once done with the device registration.\n- For **Light Color Recognizer**, go to this [link](#lorawan-code-for-light-color-recognizer) once done with the device registration."}
{"id": "df2775b4409797b3d5c9ac479426913c", "product_family": "wisblock", "product_id": "kit6-light-and-color", "category": "How-To", "title": "WisBlock IoT Education Kit - Light & Color Quick Start Guide > WisBlock IoT Education Kit - Light & Color Quick Start Guide > Miscellaneous > Device Registration > Registering an OTAA End-Device on TTN Console", "content": "> **Image:** Setting up your device  \n> **Image:** Setting up your device  \n4. Then click **Show advanced activation, LoRaWAN class and cluster settings**. Configure the activation mode by selecting **Over the air activation (OTAA)** and Additional LoRaWAN class capabilities to **class A only**. Then click **Confirm**.  \n> **Image:** Setting up your device  \n> **Image:** Setting up your device", "keywords": ["OTAA", "TTN", "end-device", "registration", "LoRaWAN"], "source_file": "quickstart.md", "token_count": 0, "parent_content": "1. Go to your application console to register a device. To start adding an OTAA end-device, click **+ Register end device**, as shown below.  \n> **Image:** Register End Device  \n2. To register the board, click the **Enter end device specifics manually**.  \n> **Image:** Enter end device specifics manually  \n3. Next step is to set up **Frequency plan**, compatible **LoRaWAN version**, and **Regional Parameters version** supported. Then provide the **JoinEUI** credentials by entering zeroes into it.  \n> **Image:** Setting up your device  \n> **Image:** Setting up your device  \n4. Then click **Show advanced activation, LoRaWAN class and cluster settings**. Configure the activation mode by selecting **Over the air activation (OTAA)** and Additional LoRaWAN class capabilities to **class A only**. Then click **Confirm**.  \n> **Image:** Setting up your device  \n> **Image:** Setting up your device  \n5. Once done, provide the DevEUI credentials of your device into the **DevEUI** portion. This will automatically generate the specific End\ndevice ID of your board. Then click **Generate** under **AppKey** under Provisioning information section. Once done, you need to change the **End device ID** since it is automatically prefilled using the **DevEUI** of your device. Then click **Register end device**.  \n> **TIP:** NOTE  \n- The **AppEUI**, **DevEUI**, and **AppKey** are hidden in this section as these are unique from a specific device. The **DevEUI** credential is unique to every **RAK4631** device. Also, you should generate your own **AppEUI** and **AppKey** credentials for your specific device and application.  \n- The **AppEUI** is the same as **JoinEUI**.  \n- The details under **End device ID** are dependent to what device you are using (e.g. **uv-intensity-meter**, etc.).  \n> **Image:** Setting up your device  \n> **Image:** Setting up your device  \n> **Image:** Changing the End device ID  \n> **Image:** Register End Device  \n6. You should now be able to see the device on the TTN console after you fully register your device, as shown below.  \n> **TIP:** NOTE  \n- The **AppEUI**, **DevEUI**, and **AppKey** are the parameters that you will need to activate your LoRaWAN end-device via OTAA. The **AppKey** is hidden by default for security reasons, but you can easily show it by clicking the show button. You can also copy the parameters quickly using the copy button.  \n- These parameters are always accessible on the device console page, as highlighted in the figure below.  \n> **Image:** OTAA device successfully registered to TTN  \n> **TIP:** NOTE  \nAbove procedures are applicable to all applications you will be using.  \n- For **UV Index & UV Intensity Monitoring**, go to this [link](#lorawan-code-for-uv-index-uv-intensity-monitoring) once done with the device registration.\n- For **Light Color Recognizer**, go to this [link](#lorawan-code-for-light-color-recognizer) once done with the device registration."}
{"id": "7fd129255190197b3719894990604044", "product_family": "wisblock", "product_id": "kit6-light-and-color", "category": "How-To", "title": "WisBlock IoT Education Kit - Light & Color Quick Start Guide > WisBlock IoT Education Kit - Light & Color Quick Start Guide > Miscellaneous > Device Registration > Registering an OTAA End-Device on TTN Console", "content": "> **Image:** Setting up your device  \n> **Image:** Setting up your device  \n5. Once done, provide the DevEUI credentials of your device into the **DevEUI** portion. This will automatically generate the specific End\ndevice ID of your board. Then click **Generate** under **AppKey** under Provisioning information section. Once done, you need to change the **End device ID** since it is automatically prefilled using the **DevEUI** of your device. Then click **Register end device**.", "keywords": ["OTAA", "TTN", "end-device", "registration", "LoRaWAN"], "source_file": "quickstart.md", "token_count": 0, "parent_content": "1. Go to your application console to register a device. To start adding an OTAA end-device, click **+ Register end device**, as shown below.  \n> **Image:** Register End Device  \n2. To register the board, click the **Enter end device specifics manually**.  \n> **Image:** Enter end device specifics manually  \n3. Next step is to set up **Frequency plan**, compatible **LoRaWAN version**, and **Regional Parameters version** supported. Then provide the **JoinEUI** credentials by entering zeroes into it.  \n> **Image:** Setting up your device  \n> **Image:** Setting up your device  \n4. Then click **Show advanced activation, LoRaWAN class and cluster settings**. Configure the activation mode by selecting **Over the air activation (OTAA)** and Additional LoRaWAN class capabilities to **class A only**. Then click **Confirm**.  \n> **Image:** Setting up your device  \n> **Image:** Setting up your device  \n5. Once done, provide the DevEUI credentials of your device into the **DevEUI** portion. This will automatically generate the specific End\ndevice ID of your board. Then click **Generate** under **AppKey** under Provisioning information section. Once done, you need to change the **End device ID** since it is automatically prefilled using the **DevEUI** of your device. Then click **Register end device**.  \n> **TIP:** NOTE  \n- The **AppEUI**, **DevEUI**, and **AppKey** are hidden in this section as these are unique from a specific device. The **DevEUI** credential is unique to every **RAK4631** device. Also, you should generate your own **AppEUI** and **AppKey** credentials for your specific device and application.  \n- The **AppEUI** is the same as **JoinEUI**.  \n- The details under **End device ID** are dependent to what device you are using (e.g. **uv-intensity-meter**, etc.).  \n> **Image:** Setting up your device  \n> **Image:** Setting up your device  \n> **Image:** Changing the End device ID  \n> **Image:** Register End Device  \n6. You should now be able to see the device on the TTN console after you fully register your device, as shown below.  \n> **TIP:** NOTE  \n- The **AppEUI**, **DevEUI**, and **AppKey** are the parameters that you will need to activate your LoRaWAN end-device via OTAA. The **AppKey** is hidden by default for security reasons, but you can easily show it by clicking the show button. You can also copy the parameters quickly using the copy button.  \n- These parameters are always accessible on the device console page, as highlighted in the figure below.  \n> **Image:** OTAA device successfully registered to TTN  \n> **TIP:** NOTE  \nAbove procedures are applicable to all applications you will be using.  \n- For **UV Index & UV Intensity Monitoring**, go to this [link](#lorawan-code-for-uv-index-uv-intensity-monitoring) once done with the device registration.\n- For **Light Color Recognizer**, go to this [link](#lorawan-code-for-light-color-recognizer) once done with the device registration."}
{"id": "881a34976daf69408b2264a4bef2e18a", "product_family": "wisblock", "product_id": "kit6-light-and-color", "category": "How-To", "title": "WisBlock IoT Education Kit - Light & Color Quick Start Guide > WisBlock IoT Education Kit - Light & Color Quick Start Guide > Miscellaneous > Device Registration > Registering an OTAA End-Device on TTN Console", "content": "> **TIP:** NOTE  \n- The **AppEUI**, **DevEUI**, and **AppKey** are hidden in this section as these are unique from a specific device. The **DevEUI** credential is unique to every **RAK4631** device. Also, you should generate your own **AppEUI** and **AppKey** credentials for your specific device and application.  \n- The **AppEUI** is the same as **JoinEUI**.  \n- The details under **End device ID** are dependent to what device you are using (e.g. **uv-intensity-meter**, etc.).", "keywords": ["OTAA", "TTN", "end-device", "registration", "LoRaWAN"], "source_file": "quickstart.md", "token_count": 0, "parent_content": "1. Go to your application console to register a device. To start adding an OTAA end-device, click **+ Register end device**, as shown below.  \n> **Image:** Register End Device  \n2. To register the board, click the **Enter end device specifics manually**.  \n> **Image:** Enter end device specifics manually  \n3. Next step is to set up **Frequency plan**, compatible **LoRaWAN version**, and **Regional Parameters version** supported. Then provide the **JoinEUI** credentials by entering zeroes into it.  \n> **Image:** Setting up your device  \n> **Image:** Setting up your device  \n4. Then click **Show advanced activation, LoRaWAN class and cluster settings**. Configure the activation mode by selecting **Over the air activation (OTAA)** and Additional LoRaWAN class capabilities to **class A only**. Then click **Confirm**.  \n> **Image:** Setting up your device  \n> **Image:** Setting up your device  \n5. Once done, provide the DevEUI credentials of your device into the **DevEUI** portion. This will automatically generate the specific End\ndevice ID of your board. Then click **Generate** under **AppKey** under Provisioning information section. Once done, you need to change the **End device ID** since it is automatically prefilled using the **DevEUI** of your device. Then click **Register end device**.  \n> **TIP:** NOTE  \n- The **AppEUI**, **DevEUI**, and **AppKey** are hidden in this section as these are unique from a specific device. The **DevEUI** credential is unique to every **RAK4631** device. Also, you should generate your own **AppEUI** and **AppKey** credentials for your specific device and application.  \n- The **AppEUI** is the same as **JoinEUI**.  \n- The details under **End device ID** are dependent to what device you are using (e.g. **uv-intensity-meter**, etc.).  \n> **Image:** Setting up your device  \n> **Image:** Setting up your device  \n> **Image:** Changing the End device ID  \n> **Image:** Register End Device  \n6. You should now be able to see the device on the TTN console after you fully register your device, as shown below.  \n> **TIP:** NOTE  \n- The **AppEUI**, **DevEUI**, and **AppKey** are the parameters that you will need to activate your LoRaWAN end-device via OTAA. The **AppKey** is hidden by default for security reasons, but you can easily show it by clicking the show button. You can also copy the parameters quickly using the copy button.  \n- These parameters are always accessible on the device console page, as highlighted in the figure below.  \n> **Image:** OTAA device successfully registered to TTN  \n> **TIP:** NOTE  \nAbove procedures are applicable to all applications you will be using.  \n- For **UV Index & UV Intensity Monitoring**, go to this [link](#lorawan-code-for-uv-index-uv-intensity-monitoring) once done with the device registration.\n- For **Light Color Recognizer**, go to this [link](#lorawan-code-for-light-color-recognizer) once done with the device registration."}
{"id": "529eff742bf5ce9486794442476ecf7b", "product_family": "wisblock", "product_id": "kit6-light-and-color", "category": "How-To", "title": "WisBlock IoT Education Kit - Light & Color Quick Start Guide > WisBlock IoT Education Kit - Light & Color Quick Start Guide > Miscellaneous > Device Registration > Registering an OTAA End-Device on TTN Console", "content": "> **Image:** Setting up your device  \n> **Image:** Setting up your device  \n> **Image:** Changing the End device ID  \n> **Image:** Register End Device  \n6. You should now be able to see the device on the TTN console after you fully register your device, as shown below.  \n> **TIP:** NOTE", "keywords": ["OTAA", "TTN", "end-device", "registration", "LoRaWAN"], "source_file": "quickstart.md", "token_count": 0, "parent_content": "1. Go to your application console to register a device. To start adding an OTAA end-device, click **+ Register end device**, as shown below.  \n> **Image:** Register End Device  \n2. To register the board, click the **Enter end device specifics manually**.  \n> **Image:** Enter end device specifics manually  \n3. Next step is to set up **Frequency plan**, compatible **LoRaWAN version**, and **Regional Parameters version** supported. Then provide the **JoinEUI** credentials by entering zeroes into it.  \n> **Image:** Setting up your device  \n> **Image:** Setting up your device  \n4. Then click **Show advanced activation, LoRaWAN class and cluster settings**. Configure the activation mode by selecting **Over the air activation (OTAA)** and Additional LoRaWAN class capabilities to **class A only**. Then click **Confirm**.  \n> **Image:** Setting up your device  \n> **Image:** Setting up your device  \n5. Once done, provide the DevEUI credentials of your device into the **DevEUI** portion. This will automatically generate the specific End\ndevice ID of your board. Then click **Generate** under **AppKey** under Provisioning information section. Once done, you need to change the **End device ID** since it is automatically prefilled using the **DevEUI** of your device. Then click **Register end device**.  \n> **TIP:** NOTE  \n- The **AppEUI**, **DevEUI**, and **AppKey** are hidden in this section as these are unique from a specific device. The **DevEUI** credential is unique to every **RAK4631** device. Also, you should generate your own **AppEUI** and **AppKey** credentials for your specific device and application.  \n- The **AppEUI** is the same as **JoinEUI**.  \n- The details under **End device ID** are dependent to what device you are using (e.g. **uv-intensity-meter**, etc.).  \n> **Image:** Setting up your device  \n> **Image:** Setting up your device  \n> **Image:** Changing the End device ID  \n> **Image:** Register End Device  \n6. You should now be able to see the device on the TTN console after you fully register your device, as shown below.  \n> **TIP:** NOTE  \n- The **AppEUI**, **DevEUI**, and **AppKey** are the parameters that you will need to activate your LoRaWAN end-device via OTAA. The **AppKey** is hidden by default for security reasons, but you can easily show it by clicking the show button. You can also copy the parameters quickly using the copy button.  \n- These parameters are always accessible on the device console page, as highlighted in the figure below.  \n> **Image:** OTAA device successfully registered to TTN  \n> **TIP:** NOTE  \nAbove procedures are applicable to all applications you will be using.  \n- For **UV Index & UV Intensity Monitoring**, go to this [link](#lorawan-code-for-uv-index-uv-intensity-monitoring) once done with the device registration.\n- For **Light Color Recognizer**, go to this [link](#lorawan-code-for-light-color-recognizer) once done with the device registration."}
{"id": "8509436eaa77fc09d532d5dec7e206f7", "product_family": "wisblock", "product_id": "kit6-light-and-color", "category": "How-To", "title": "WisBlock IoT Education Kit - Light & Color Quick Start Guide > WisBlock IoT Education Kit - Light & Color Quick Start Guide > Miscellaneous > Device Registration > Registering an OTAA End-Device on TTN Console", "content": "> **TIP:** NOTE  \n- The **AppEUI**, **DevEUI**, and **AppKey** are the parameters that you will need to activate your LoRaWAN end-device via OTAA. The **AppKey** is hidden by default for security reasons, but you can easily show it by clicking the show button. You can also copy the parameters quickly using the copy button.  \n- These parameters are always accessible on the device console page, as highlighted in the figure below.  \n> **Image:** OTAA device successfully registered to TTN", "keywords": ["OTAA", "TTN", "end-device", "registration", "LoRaWAN"], "source_file": "quickstart.md", "token_count": 0, "parent_content": "1. Go to your application console to register a device. To start adding an OTAA end-device, click **+ Register end device**, as shown below.  \n> **Image:** Register End Device  \n2. To register the board, click the **Enter end device specifics manually**.  \n> **Image:** Enter end device specifics manually  \n3. Next step is to set up **Frequency plan**, compatible **LoRaWAN version**, and **Regional Parameters version** supported. Then provide the **JoinEUI** credentials by entering zeroes into it.  \n> **Image:** Setting up your device  \n> **Image:** Setting up your device  \n4. Then click **Show advanced activation, LoRaWAN class and cluster settings**. Configure the activation mode by selecting **Over the air activation (OTAA)** and Additional LoRaWAN class capabilities to **class A only**. Then click **Confirm**.  \n> **Image:** Setting up your device  \n> **Image:** Setting up your device  \n5. Once done, provide the DevEUI credentials of your device into the **DevEUI** portion. This will automatically generate the specific End\ndevice ID of your board. Then click **Generate** under **AppKey** under Provisioning information section. Once done, you need to change the **End device ID** since it is automatically prefilled using the **DevEUI** of your device. Then click **Register end device**.  \n> **TIP:** NOTE  \n- The **AppEUI**, **DevEUI**, and **AppKey** are hidden in this section as these are unique from a specific device. The **DevEUI** credential is unique to every **RAK4631** device. Also, you should generate your own **AppEUI** and **AppKey** credentials for your specific device and application.  \n- The **AppEUI** is the same as **JoinEUI**.  \n- The details under **End device ID** are dependent to what device you are using (e.g. **uv-intensity-meter**, etc.).  \n> **Image:** Setting up your device  \n> **Image:** Setting up your device  \n> **Image:** Changing the End device ID  \n> **Image:** Register End Device  \n6. You should now be able to see the device on the TTN console after you fully register your device, as shown below.  \n> **TIP:** NOTE  \n- The **AppEUI**, **DevEUI**, and **AppKey** are the parameters that you will need to activate your LoRaWAN end-device via OTAA. The **AppKey** is hidden by default for security reasons, but you can easily show it by clicking the show button. You can also copy the parameters quickly using the copy button.  \n- These parameters are always accessible on the device console page, as highlighted in the figure below.  \n> **Image:** OTAA device successfully registered to TTN  \n> **TIP:** NOTE  \nAbove procedures are applicable to all applications you will be using.  \n- For **UV Index & UV Intensity Monitoring**, go to this [link](#lorawan-code-for-uv-index-uv-intensity-monitoring) once done with the device registration.\n- For **Light Color Recognizer**, go to this [link](#lorawan-code-for-light-color-recognizer) once done with the device registration."}
{"id": "6fed6bfc6f8c4b108985683da890121b", "product_family": "wisblock", "product_id": "kit6-light-and-color", "category": "How-To", "title": "WisBlock IoT Education Kit - Light & Color Quick Start Guide > WisBlock IoT Education Kit - Light & Color Quick Start Guide > Miscellaneous > Device Registration > Registering an OTAA End-Device on TTN Console", "content": "> **Image:** OTAA device successfully registered to TTN  \n> **TIP:** NOTE  \nAbove procedures are applicable to all applications you will be using.  \n- For **UV Index & UV Intensity Monitoring**, go to this [link](#lorawan-code-for-uv-index-uv-intensity-monitoring) once done with the device registration.\n- For **Light Color Recognizer**, go to this [link](#lorawan-code-for-light-color-recognizer) once done with the device registration.", "keywords": ["OTAA", "TTN", "end-device", "registration", "LoRaWAN"], "source_file": "quickstart.md", "token_count": 0, "parent_content": "1. Go to your application console to register a device. To start adding an OTAA end-device, click **+ Register end device**, as shown below.  \n> **Image:** Register End Device  \n2. To register the board, click the **Enter end device specifics manually**.  \n> **Image:** Enter end device specifics manually  \n3. Next step is to set up **Frequency plan**, compatible **LoRaWAN version**, and **Regional Parameters version** supported. Then provide the **JoinEUI** credentials by entering zeroes into it.  \n> **Image:** Setting up your device  \n> **Image:** Setting up your device  \n4. Then click **Show advanced activation, LoRaWAN class and cluster settings**. Configure the activation mode by selecting **Over the air activation (OTAA)** and Additional LoRaWAN class capabilities to **class A only**. Then click **Confirm**.  \n> **Image:** Setting up your device  \n> **Image:** Setting up your device  \n5. Once done, provide the DevEUI credentials of your device into the **DevEUI** portion. This will automatically generate the specific End\ndevice ID of your board. Then click **Generate** under **AppKey** under Provisioning information section. Once done, you need to change the **End device ID** since it is automatically prefilled using the **DevEUI** of your device. Then click **Register end device**.  \n> **TIP:** NOTE  \n- The **AppEUI**, **DevEUI**, and **AppKey** are hidden in this section as these are unique from a specific device. The **DevEUI** credential is unique to every **RAK4631** device. Also, you should generate your own **AppEUI** and **AppKey** credentials for your specific device and application.  \n- The **AppEUI** is the same as **JoinEUI**.  \n- The details under **End device ID** are dependent to what device you are using (e.g. **uv-intensity-meter**, etc.).  \n> **Image:** Setting up your device  \n> **Image:** Setting up your device  \n> **Image:** Changing the End device ID  \n> **Image:** Register End Device  \n6. You should now be able to see the device on the TTN console after you fully register your device, as shown below.  \n> **TIP:** NOTE  \n- The **AppEUI**, **DevEUI**, and **AppKey** are the parameters that you will need to activate your LoRaWAN end-device via OTAA. The **AppKey** is hidden by default for security reasons, but you can easily show it by clicking the show button. You can also copy the parameters quickly using the copy button.  \n- These parameters are always accessible on the device console page, as highlighted in the figure below.  \n> **Image:** OTAA device successfully registered to TTN  \n> **TIP:** NOTE  \nAbove procedures are applicable to all applications you will be using.  \n- For **UV Index & UV Intensity Monitoring**, go to this [link](#lorawan-code-for-uv-index-uv-intensity-monitoring) once done with the device registration.\n- For **Light Color Recognizer**, go to this [link](#lorawan-code-for-light-color-recognizer) once done with the device registration."}
{"id": "e6178a5c1b1bc84e257ad6c45023157a", "product_family": "wisblock", "product_id": "kit6-light-and-color", "category": "How-To", "title": "WisBlock IoT Education Kit - Light & Color Quick Start Guide > WisBlock IoT Education Kit - Light & Color Quick Start Guide > Miscellaneous > Arduino IDE Installation + RAK4631 > Installing Arduino IDE and RAKwireless BSP for WisBlock", "content": "1. Download the [Arduino IDE](https://www.arduino.cc/en/software) and install it on your PC or laptop. You must choose the appropriate **Arduino IDE** depending on your operating system.  \n> **Image:** Download Options for the Arduino IDE", "keywords": ["Arduino IDE", "RAKwireless BSP", "WisBlock", "RAK4631", "Installation"], "source_file": "quickstart.md", "token_count": 250, "parent_content": "1. Download the [Arduino IDE](https://www.arduino.cc/en/software) and install it on your PC or laptop. You must choose the appropriate **Arduino IDE** depending on your operating system.  \n> **Image:** Download Options for the Arduino IDE  \n2. Open the **Arduino IDE** then install the [RAKwireless Arduino BSP](https://github.com/RAKWireless/RAKwireless-Arduino-BSP-Index) for WisBlock by using the `package_rakwireless_index.json` board installation package. The WisBlock Core should now be available on the Arduino IDE. Click on **File** > **Preference**. In the **Preference** window, look for **Additional Boards Manager URLs** then click the icon on the right side. Paste the link into it then click **OK** > **OK**.  \n> **Image:** Preference Set-Up  \n> **Image:** Preference Window  \n> **Image:** RAKwireless Arduino BSP  \n> **Image:** Completing the setup of the RAKwireless BSP support for the Arduino Board Manager  \n3. Then to your **Arduino IDE**, go to **Tools** > **Board:XXXXX** > **Boards Manager**. Then look for **RAKwireless Boards by RAKwireless** since we will be working on with the **RAK4631 WisBlock Core**. Choose the latest version then install it. Once done, close the **Board Manager**.  \n> **Image:** Opening the Boards Manager  \n> **Image:** Installing the RAKwireless nRF Boards  \n> **Image:** Successfully installed the RAKwireless nRF Boards  \n> **TIP:** NOTE  \nAbove procedures are applicable to all applications you will be using.  \n- For **UV Index & UV Intensity Monitoring**, go to this [link](#lorawan-code-for-uv-index-uv-intensity-monitoring) once done with the device registration.\n- For **Light Color Recognizer**, go to this [link](#lorawan-code-for-light-color-recognizer) once done with the device registration."}
{"id": "ea146be6d55aa97d06d70e25fcc337c5", "product_family": "wisblock", "product_id": "kit6-light-and-color", "category": "How-To", "title": "WisBlock IoT Education Kit - Light & Color Quick Start Guide > WisBlock IoT Education Kit - Light & Color Quick Start Guide > Miscellaneous > Arduino IDE Installation + RAK4631 > Installing Arduino IDE and RAKwireless BSP for WisBlock", "content": "2. Open the **Arduino IDE** then install the [RAKwireless Arduino BSP](https://github.com/RAKWireless/RAKwireless-Arduino-BSP-Index) for WisBlock by using the `package_rakwireless_index.json` board installation package. The WisBlock Core should now be available on the Arduino IDE. Click on **File** > **Preference**. In the **Preference** window, look for **Additional Boards Manager URLs** then click the icon on the right side. Paste the link into it then click **OK** > **OK**.", "keywords": ["Arduino IDE", "RAKwireless BSP", "WisBlock", "RAK4631", "Installation"], "source_file": "quickstart.md", "token_count": 250, "parent_content": "1. Download the [Arduino IDE](https://www.arduino.cc/en/software) and install it on your PC or laptop. You must choose the appropriate **Arduino IDE** depending on your operating system.  \n> **Image:** Download Options for the Arduino IDE  \n2. Open the **Arduino IDE** then install the [RAKwireless Arduino BSP](https://github.com/RAKWireless/RAKwireless-Arduino-BSP-Index) for WisBlock by using the `package_rakwireless_index.json` board installation package. The WisBlock Core should now be available on the Arduino IDE. Click on **File** > **Preference**. In the **Preference** window, look for **Additional Boards Manager URLs** then click the icon on the right side. Paste the link into it then click **OK** > **OK**.  \n> **Image:** Preference Set-Up  \n> **Image:** Preference Window  \n> **Image:** RAKwireless Arduino BSP  \n> **Image:** Completing the setup of the RAKwireless BSP support for the Arduino Board Manager  \n3. Then to your **Arduino IDE**, go to **Tools** > **Board:XXXXX** > **Boards Manager**. Then look for **RAKwireless Boards by RAKwireless** since we will be working on with the **RAK4631 WisBlock Core**. Choose the latest version then install it. Once done, close the **Board Manager**.  \n> **Image:** Opening the Boards Manager  \n> **Image:** Installing the RAKwireless nRF Boards  \n> **Image:** Successfully installed the RAKwireless nRF Boards  \n> **TIP:** NOTE  \nAbove procedures are applicable to all applications you will be using.  \n- For **UV Index & UV Intensity Monitoring**, go to this [link](#lorawan-code-for-uv-index-uv-intensity-monitoring) once done with the device registration.\n- For **Light Color Recognizer**, go to this [link](#lorawan-code-for-light-color-recognizer) once done with the device registration."}
{"id": "dce0e7aec1dd3768ec151726efa00255", "product_family": "wisblock", "product_id": "kit6-light-and-color", "category": "How-To", "title": "WisBlock IoT Education Kit - Light & Color Quick Start Guide > WisBlock IoT Education Kit - Light & Color Quick Start Guide > Miscellaneous > Arduino IDE Installation + RAK4631 > Installing Arduino IDE and RAKwireless BSP for WisBlock", "content": "> **Image:** Preference Set-Up  \n> **Image:** Preference Window  \n> **Image:** RAKwireless Arduino BSP  \n> **Image:** Completing the setup of the RAKwireless BSP support for the Arduino Board Manager  \n3. Then to your **Arduino IDE**, go to **Tools** > **Board:XXXXX** > **Boards Manager**. Then look for **RAKwireless Boards by RAKwireless** since we will be working on with the **RAK4631 WisBlock Core**. Choose the latest version then install it. Once done, close the **Board Manager**.", "keywords": ["Arduino IDE", "RAKwireless BSP", "WisBlock", "RAK4631", "Installation"], "source_file": "quickstart.md", "token_count": 250, "parent_content": "1. Download the [Arduino IDE](https://www.arduino.cc/en/software) and install it on your PC or laptop. You must choose the appropriate **Arduino IDE** depending on your operating system.  \n> **Image:** Download Options for the Arduino IDE  \n2. Open the **Arduino IDE** then install the [RAKwireless Arduino BSP](https://github.com/RAKWireless/RAKwireless-Arduino-BSP-Index) for WisBlock by using the `package_rakwireless_index.json` board installation package. The WisBlock Core should now be available on the Arduino IDE. Click on **File** > **Preference**. In the **Preference** window, look for **Additional Boards Manager URLs** then click the icon on the right side. Paste the link into it then click **OK** > **OK**.  \n> **Image:** Preference Set-Up  \n> **Image:** Preference Window  \n> **Image:** RAKwireless Arduino BSP  \n> **Image:** Completing the setup of the RAKwireless BSP support for the Arduino Board Manager  \n3. Then to your **Arduino IDE**, go to **Tools** > **Board:XXXXX** > **Boards Manager**. Then look for **RAKwireless Boards by RAKwireless** since we will be working on with the **RAK4631 WisBlock Core**. Choose the latest version then install it. Once done, close the **Board Manager**.  \n> **Image:** Opening the Boards Manager  \n> **Image:** Installing the RAKwireless nRF Boards  \n> **Image:** Successfully installed the RAKwireless nRF Boards  \n> **TIP:** NOTE  \nAbove procedures are applicable to all applications you will be using.  \n- For **UV Index & UV Intensity Monitoring**, go to this [link](#lorawan-code-for-uv-index-uv-intensity-monitoring) once done with the device registration.\n- For **Light Color Recognizer**, go to this [link](#lorawan-code-for-light-color-recognizer) once done with the device registration."}
{"id": "b90515ed996be36ccdb131c8335c8635", "product_family": "wisblock", "product_id": "kit6-light-and-color", "category": "How-To", "title": "WisBlock IoT Education Kit - Light & Color Quick Start Guide > WisBlock IoT Education Kit - Light & Color Quick Start Guide > Miscellaneous > Arduino IDE Installation + RAK4631 > Installing Arduino IDE and RAKwireless BSP for WisBlock", "content": "> **Image:** Opening the Boards Manager  \n> **Image:** Installing the RAKwireless nRF Boards  \n> **Image:** Successfully installed the RAKwireless nRF Boards  \n> **TIP:** NOTE  \nAbove procedures are applicable to all applications you will be using.  \n- For **UV Index & UV Intensity Monitoring**, go to this [link](#lorawan-code-for-uv-index-uv-intensity-monitoring) once done with the device registration.", "keywords": ["Arduino IDE", "RAKwireless BSP", "WisBlock", "RAK4631", "Installation"], "source_file": "quickstart.md", "token_count": 250, "parent_content": "1. Download the [Arduino IDE](https://www.arduino.cc/en/software) and install it on your PC or laptop. You must choose the appropriate **Arduino IDE** depending on your operating system.  \n> **Image:** Download Options for the Arduino IDE  \n2. Open the **Arduino IDE** then install the [RAKwireless Arduino BSP](https://github.com/RAKWireless/RAKwireless-Arduino-BSP-Index) for WisBlock by using the `package_rakwireless_index.json` board installation package. The WisBlock Core should now be available on the Arduino IDE. Click on **File** > **Preference**. In the **Preference** window, look for **Additional Boards Manager URLs** then click the icon on the right side. Paste the link into it then click **OK** > **OK**.  \n> **Image:** Preference Set-Up  \n> **Image:** Preference Window  \n> **Image:** RAKwireless Arduino BSP  \n> **Image:** Completing the setup of the RAKwireless BSP support for the Arduino Board Manager  \n3. Then to your **Arduino IDE**, go to **Tools** > **Board:XXXXX** > **Boards Manager**. Then look for **RAKwireless Boards by RAKwireless** since we will be working on with the **RAK4631 WisBlock Core**. Choose the latest version then install it. Once done, close the **Board Manager**.  \n> **Image:** Opening the Boards Manager  \n> **Image:** Installing the RAKwireless nRF Boards  \n> **Image:** Successfully installed the RAKwireless nRF Boards  \n> **TIP:** NOTE  \nAbove procedures are applicable to all applications you will be using.  \n- For **UV Index & UV Intensity Monitoring**, go to this [link](#lorawan-code-for-uv-index-uv-intensity-monitoring) once done with the device registration.\n- For **Light Color Recognizer**, go to this [link](#lorawan-code-for-light-color-recognizer) once done with the device registration."}
{"id": "0bb81e48f56c6a96abd490ba461755d4", "product_family": "wisblock", "product_id": "kit6-light-and-color", "category": "How-To", "title": "WisBlock IoT Education Kit - Light & Color Quick Start Guide > WisBlock IoT Education Kit - Light & Color Quick Start Guide > Miscellaneous > Arduino IDE Installation + RAK4631 > Installing Arduino IDE and RAKwireless BSP for WisBlock", "content": "- For **Light Color Recognizer**, go to this [link](#lorawan-code-for-light-color-recognizer) once done with the device registration.", "keywords": ["Arduino IDE", "RAKwireless BSP", "WisBlock", "RAK4631", "Installation"], "source_file": "quickstart.md", "token_count": 250, "parent_content": "1. Download the [Arduino IDE](https://www.arduino.cc/en/software) and install it on your PC or laptop. You must choose the appropriate **Arduino IDE** depending on your operating system.  \n> **Image:** Download Options for the Arduino IDE  \n2. Open the **Arduino IDE** then install the [RAKwireless Arduino BSP](https://github.com/RAKWireless/RAKwireless-Arduino-BSP-Index) for WisBlock by using the `package_rakwireless_index.json` board installation package. The WisBlock Core should now be available on the Arduino IDE. Click on **File** > **Preference**. In the **Preference** window, look for **Additional Boards Manager URLs** then click the icon on the right side. Paste the link into it then click **OK** > **OK**.  \n> **Image:** Preference Set-Up  \n> **Image:** Preference Window  \n> **Image:** RAKwireless Arduino BSP  \n> **Image:** Completing the setup of the RAKwireless BSP support for the Arduino Board Manager  \n3. Then to your **Arduino IDE**, go to **Tools** > **Board:XXXXX** > **Boards Manager**. Then look for **RAKwireless Boards by RAKwireless** since we will be working on with the **RAK4631 WisBlock Core**. Choose the latest version then install it. Once done, close the **Board Manager**.  \n> **Image:** Opening the Boards Manager  \n> **Image:** Installing the RAKwireless nRF Boards  \n> **Image:** Successfully installed the RAKwireless nRF Boards  \n> **TIP:** NOTE  \nAbove procedures are applicable to all applications you will be using.  \n- For **UV Index & UV Intensity Monitoring**, go to this [link](#lorawan-code-for-uv-index-uv-intensity-monitoring) once done with the device registration.\n- For **Light Color Recognizer**, go to this [link](#lorawan-code-for-light-color-recognizer) once done with the device registration."}
