{"id":"94ec52224f21144559cf9095eb9d11df","product_family":"wisgate","product_id":"rak10701-p","category":"Reference","title":"RAK10701-P Field Tester for LoRaWAN Pro Datasheet","content":"# RAK10701-P Field Tester for LoRaWAN Pro Datasheet\n","keywords":[],"source_file":"wisgate\\rak10701-p\\datasheet.md","token_count":8}
{"id":"6859d352fc8c048042f33715351a6f98","product_family":"wisgate","product_id":"rak10701-p","category":"Concept","title":"RAK10701-P Field Tester for LoRaWAN Overview","content":"## Overview\n\n### Description\n\nThe **RAK10701-P Field Tester for LoRaWAN** is a ready-to-use WisNode for evaluating deployed LoRaWAN network, which comes in a hard case and two different antenna types. It has a GNSS and a touchscreen LCD for the user interface, which displays the number of gateways the device can reach and other parameters like approximate distance, RSSI, and SNR. It is powered by a rechargeable battery and can be charged via USB Type-C interface.\n\n\n> **WARNING:** The latest RAK10701 Field Tester firmware only works on the following LoRaWAN Network Servers: **Helium**, **The Things Network**, and **Chirpstack**.\n\n\n\n> **TIP:** NOTE\nThe [source code of RAK10701](https://github.com/RAKWireless/RAK10701-Field-Tester) is open-sourced (except the RUI3 APIs).\n\nThe device has to be charged first if it comes fresh from shipping. There is a possibility that the battery was drained during its transport.\n\n\n### Features\n\n- Supports LoRaWAN regions: RU864, IN865, EU868, US915, AU915, KR920, & AS923-1/2/3/4\n- Compatible with LoRaWAN 1.0.3\n- Works with Helium Network, TheThingsNetwork, and with custom end-points with other LoRaWAN networks\n- Protected by a hard case which is ideal for fieldwork\n- Includes two different antenna types\n- Shows the number of gateways/hotspots in the range\n- Shows min and max RSSI levels\n- Shows min and max distance to gateways/hotspots in range\n- Compatible with WisToolBox and allows wireless configuration via BLE\n- Powered by 3200¬†mAh battery\n- Rechargeable over a USB Type-C connector\n- 320x240 TFT touchscreen\n- 2.3¬†dBi external antenna via RP-SMA connector\n- Operating Temperature: -10¬∞¬†C ~ 60¬∞¬†C\n- Storage Temperature: -40¬∞¬†C ~ 80¬∞¬†C\n","keywords":[],"source_file":"wisgate\\rak10701-p\\datasheet.md","token_count":0}
{"id":"3944a4e741d4d0c041024172a900115c","product_family":"wisgate","product_id":"rak10701-p","category":"Reference","title":"RAK10701-P Field Tester for LoRaWAN Hardware Specifications","content":"## Specifications\n\n### Overview\n\nRAK10701-P Field Tester for LoRaWAN with the external antenna.\n\n> **Image:** RAK10701-P Field Tester for LoRaWAN\n\n### Hardware\n\nThe hardware specification is categorized into five (5) parts. It shows the interfacing of the tracker. It also covers the rf, antennas, electrical, environmental, and mechanical parameters that include the tabular data of the functionalities and standard values of the RAK10701-P Field Tester for LoRaWAN.\n\n#### Interfaces\n\nThe RAK10701-P Field Tester for LoRaWAN has four interfaces which are the touch screen LCD, external button, antenna port, and USB connector.\n\n##### Touchscreen TFT LCD\n\nThe touchscreen LCD is the main interface of the device. Most of the user interaction is done via the touchscreen LCD.\n\n> **Image:** RAK10701-L front view with an LCD screen\n\nYou can interact with the device and check the data needed on your LoRaWAN network field testing. The icons highlighted in the red box are the areas responsive to touch. Other parts of the screen will not be responsive to any touch input.\n\n> **Image:** RAK10701-L home display\n\n\n> **TIP:** NOTE\nThe complete details on different pages of the screens are discussed in the [RAK10701-L Quick Start Guide](https://docs.rakwireless.com/product-categories/wisgate/rak10701-l/quickstart/).\n\n\n##### External Button\n\nThere is one external button on RAK10701 which can be used in various scenarios.\n\n1. Turning on and off (holding for five seconds)\n2. Forced uplink (double-click)\n3. Sleep and wake-up (single click)\n\n> **Image:** RAK10701-L useable button\n\n##### Antenna RP-SMA Connector\n\nOn top of the RAK10701-P Field Tester for LoRaWAN is an RP-SMA port for the external antenna.\n\n> **Image:** RAK10701-P RP-SMA antenna port\n\nThere are two antennas included in the RAK10701-P, one with 2.0¬†dBi gain:\n\n> **Image:** 2.0 dBi antenna\n\nThen, another one with 2.3¬†dBi gain.\n\n> **Image:** 2.3 dBi antenna\n\n\n> **TIP:** NOTE\nDetailed information about the LoRa antenna can be found on the datasheet:\n\n- [9xx MHz Antenna](https://docs.rakwireless.com/product-categories/accessories/rakarj16/overview/)\n- [8xx MHz Antenna](https://docs.rakwireless.com/product-categories/accessories/rakarj17/overview/)\n\n\n##### USB Type-C for Charging and WisToolBox Configuration\n\nThere is also a USB interface on RAK10701. You can use [WisToolBox](https://docs.rakwireless.com/product-categories/software-tools/wistoolbox/overview/) software to configure the devices via USB connection. You also have the option to configure the device wirelessly via BLE connection using the [WisToolBox Mobile App](https://docs.rakwireless.com/product-categories/software-tools/wistoolbox/wistoolbox-mobile/) compatible with iOS and Android.\n\n> **Image:** USB Type-C connector access\n\n#### RF Characteristics\n\n##### LoRaWAN Operating Frequencies\n\nThe RAK10701-L Field Tester for LoRaWAN supports the regional bands shown in the table below. When purchasing a RAK10701, pay attention to specifying the correct variant for your region.\n\n| Region        | Frequency (MHz) | RAK10701-P Field Tester for LoRaWAN |\n| ------------- | --------------- | ----------------------------------- |\n| Russia        | RU864           | 8xx MHz version                     |\n| India         | IN865           | 8xx MHz version                     |\n| Europe        | EU868           | 8xx MHz version                     |\n| North America | US915           | 9xx MHz version                     |\n| Canada        | US915           | 9xx MHz version                     |\n| Australia     | AU915           | 9xx MHz version                     |\n| Korea         | KR920           | 9xx MHz version                     |\n| Asia          | AS923-1/2/3/4   | 9xx MHz version                     |\n\n##### GPS Antenna\n\n| Items     | Parameter        |\n| --------- | ---------------- |\n| Frequency | 1575.42¬†MHz |\n\n#### Electrical Characteristics\n\n##### Working Mode\n\n| Mode      | Condition | Power Consumption |\n| --------- | --------- | ----------------- |\n| Idle Mode | LCD On    | 120¬†mA       |\n|           | LCD Off   | 60¬†mA        |\n\n##### Battery Supply\n\nThe RAK10701-P Field Tester for LoRaWAN is equipped with a built-in rechargeable 3.7¬†V Li-ion battery with 3200¬†mAh capacity. This can be charged via a USB Type-C connector interface.\n\n#### Environmental Characteristics\n\nThe table below lists the operation and storage temperature requirements.\n\n| Parameter             | Min.        | Typical     | Max.        |\n| --------------------- | ----------- | ----------- | ----------- |\n| Storage Temp. Range   | -40¬∞¬†C | +25¬∞¬†C | +80¬∞¬†C |\n| Operation Temp. Range | -10¬∞¬†C | +25¬∞¬†C | +60¬∞¬†C |\n\n#### Mechanical Characteristics\n\n- Dimensions: 100¬†mm x 75¬†mm x 38¬†mm\n- Weight: approximately 8.6¬†oz (243.8¬†g) without battery\n\n### Firmware\n\nDownload the latest firmware version of RAK10701-P via the [ WisToolBox](https://docs.rakwireless.com/product-categories/software-tools/wistoolbox/overview).\n\n","keywords":[],"source_file":"wisgate\\rak10701-p\\datasheet.md","token_count":0}
{"id":"0e49caf43eb10be15e607b2d892e9bcd","product_family":"wisgate","product_id":"rak10701-p","category":"Concept","title":"Introduction to RAK10701-P Field Tester for LoRaWAN Pro","content":"# RAK10701-P Field Tester for LoRaWAN Pro\n\nThank you for choosing **RAK10701-P Field Tester for LoRaWAN Pro** in your awesome IoT project! üéâ To help you get started, we have provided you with all the necessary documentation for your product.\n\n* Quick Start Guide\n* Datasheet\n\n\n> **WARNING:** The latest RAK10701 Field Tester firmware only works on the following LoRaWAN Network Servers: **Helium**, **The Things Network**, and **Chirpstack**.\n\n\n\n> **TIP:** NOTE\nThe [source code of RAK10701](https://github.com/RAKWireless/RAK10701-Field-Tester) is open-sourced (except the RUI3 APIs).\n\nThe device has to be charged first if it comes fresh from shipping. There is a possibility that the battery was drained during its transport.\n\n","keywords":[],"source_file":"wisgate\\rak10701-p\\overview.md","token_count":100}
{"id":"d728aca5570c4089bdf093fb81f0fca8","product_family":"wisgate","product_id":"rak10701-p","category":"Concept","title":"RAK10701-P Field Tester for LoRaWAN Overview","content":"## Product Description\n\nThe **RAK10701-P Field Tester for LoRaWAN** is a ready-to-use WisNode for evaluating deployed LoRaWAN network, which comes in a hard case and two different antenna types. It has a GNSS and a touchscreen LCD for the user interface, which displays the number of gateways the device can reach and other parameters like approximate distance, RSSI, and SNR. It is powered by a rechargeable battery and can be charged via USB Type-C interface.\n","keywords":[],"source_file":"wisgate\\rak10701-p\\overview.md","token_count":0}
{"id":"74804d6bf8242acc49f39c0e636206a8","product_family":"wisgate","product_id":"rak10701-p","category":"Concept","title":"RAK10701-P Product Features Overview","content":"## Product Features\n\n- Supports LoRaWAN regions: RU864, IN865, EU868, US915, AU915, KR920, & AS923-1/2/3/4\n- Compatible with LoRaWAN 1.0.3\n- Works with Helium Network, TheThingsNetwork, and with custom end-points with other LoRaWAN networks\n- Protected by a hard case which is ideal for fieldwork\n- Includes two different antenna types\n- Shows the number of gateways/hotspots in the range\n- Shows min and max RSSI levels\n- Shows min and max distance to gateways/hotspots in range\n- Compatible with WisToolBox and allows wireless configuration via BLE\n- Powered by 3,200¬†mAh battery\n- Rechargeable over a USB Type-C connector\n- 320x240 TFT touchscreen\n- 2.3¬†dBi external antenna via RP-SMA connector\n- Operating Temperature: -10¬∞¬†C ~ 60¬∞¬†C\n- Storage Temperature: -40¬∞¬†C ~ 80¬∞¬†C\n","keywords":[],"source_file":"wisgate\\rak10701-p\\overview.md","token_count":0}
{"id":"6612d4ce14a5a3c236f32bcbd6faeb62","product_family":"wisgate","product_id":"rak10701-p","category":"Concept","title":"Prerequisites for Using RAK10701-P","content":"## Prerequisites\n\nTo use a **RAK10701-P**, you need the following:\n\n- To be in a coverage of a LoRaWAN gateway registered to a supported LoRaWAN Network Server. \n- The LoRaWAN Gateway receiving the uplinks must have a GPS coordinates.\n- RAK10701-P must registered as a device on the LoRaWAN Network Server.\n- RAK10701-P must be sufficiently charged.\n- RAK10701-P must have access to sky to get a GPS location fix.\n\n","keywords":[],"source_file":"wisgate\\rak10701-p\\overview.md","token_count":70}
{"id":"3ea9a12702561766c8d86e8037f9c62b","product_family":"wisgate","product_id":"rak10701-p","category":"How-To","title":"RAK10701-P Field Tester Pro for LoRaWAN Quick Start Guide","content":"# RAK10701-P Field Tester Pro for LoRaWAN Quick Start Guide\n","keywords":[],"source_file":"wisgate\\rak10701-p\\quickstart.md","token_count":10}
{"id":"4ce9c8a2ac87b6c63f075c4248863056","product_family":"wisgate","product_id":"rak10701-p","category":"How-To","title":"Prerequisites for RAK10701-P Field Tester Pro Installation","content":"## Prerequisites\n\nBefore going through each and every step in the installation guide of the RAK10701-P Field Tester Pro for LoRaWAN, make sure to prepare the necessary items listed below:\n\n### Hardware Tools\n\n1. [ RAK10701-P Field Tester Pro for LoRaWAN ](https://store.rakwireless.com/products/field-tester-for-lorawan-rak10701?variant=42437595726022?utm_source=RAK10701P&utm_medium=Document&utm_campaign=BuyFromStore)\n2. LoRa SubGHz Antenna with RP-SMA connector\n3. USB Type-C Cable\n4. Windows/Linux/macOS for PC or iOS/Android for mobile\n\n### Software Tools\n\n[ WisToolBox ](https://docs.rakwireless.com/product-categories/software-tools/wistoolbox/overview) for configuration and firmware update.\n\n\n> **TIP:** NOTE\nIt is mandatory that you are within the coverage of the LoRaWAN Gateway of the network you are trying to join. Without the coverage, the Field Tester will not be useable.\n\n","keywords":[],"source_file":"wisgate\\rak10701-p\\quickstart.md","token_count":150}
{"id":"6b0ddd6b3ddfbe11814a13da48c92948","product_family":"wisgate","product_id":"rak10701-p","category":"How-To","title":"RAK10701-P Field Tester Pro Physical Interface and Network Server Configuration","content":"## Product Configuration\n\n### RAK10701-P Field Tester Pro Physical Interface\n\nThe user interface of the RAK10701-P Field Tester Pro for LoRaWAN is via TFT Touchscreen LCD and one pushbutton at the side. There is also an external LoRA antenna port via RP-SMA connector and USB-C port for charging and configuration if connected to a PC.\n\n> **Image:** RAK10701-L front view with an LCD screen\n\n\n> **TIP:** NOTE\nYou have to ensure that the LoRa antenna is attached before turning on the device.\n\n\n1. To turn on the device, you have to press and hold the button for at least five seconds.\n\n> **Image:** RAK10701-P button to turn on\n\n\n> **TIP:** NOTE\nThe same button can be used to power off. You have to hold it as well for at least five seconds.\n\n> **Image:** RAK10701-P power off\n\n\n2. When the device initializes, it will show the RAK logo on the screen. If there is any initialization error, it will be shown on the upper right section of the screen as well. A properly working device should not have any errors shown.\n\n> **Image:** RAK10701-P power up successful\n\n> **Image:** GPS error on boot up sequence\n\n3. After the successful boot-up, the main home screen will be shown. Take note, that there will be no data at the first start of the device.\n\n\n> **TIP:** NOTE\nThe field tester must be outside and has a clear view of the sky to get GPS coordinates. The GPS antenna is located on top of the device beside the RP-SMA connector of the LoRa Antenna.\n\nIf you are indoors, there will be no reception of the GPS signal. The latitude and longitude data will be empty.\n\n\n> **Image:** RAK10701-P Main Page waiting for valid data\n\n4. Once fully powered on, the external button at the side can sleep or wake up the display on the LCD screen via a single press on it.\n\n5. If the device is connected via USB-C to a computer, then the button is pressed, it will not remove the display but will lock the screen (touch screen behavior is disabled).\n\n> **Image:** RAK10701-P locked screen\n\n### LoRaWAN Network Servers Guide for RAK10701-P Field Tester Pro\n\nThe field tester supports different network servers and can be used as well on others not listed in this guide as long as the uplink and downlink packets are configured correctly.\n\nYou can check each guide on how to use the RAK10701-P Field Tester Pro for LoRaWAN in the following network servers.\n\n- [Helium](https://docs.rakwireless.com/product-categories/wisgate/rak10701-p/quickstart/#rak10701-p-field-tester-pro-guide-for-the-helium-network)\n- [The Things Network](https://docs.rakwireless.com/product-categories/wisgate/rak10701-p/quickstart/#rak10701-p-field-tester-pro-guide-for-the-things-network)\n- [Chirpstack (with Datacake)](https://docs.rakwireless.com/product-categories/wisgate/rak10701-p/quickstart/#rak10701-p-field-tester-pro-guide-for-chirpstack)\n- [Loriot (with Datacake)](https://docs.rakwireless.com/product-categories/wisgate/rak10701-p/quickstart/#rak10701-p-field-tester-pro-guide-for-loriot-and-datacake) \n- [Chirpstack (with NodeRED)](https://docs.rakwireless.com/product-categories/wisgate/rak10701-p/quickstart/#rak10701-p-field-tester-pro-guide-for-chirpstack-and-nodered)\n\nAdditional information:\n\n- [Packet Frame Format](https://docs.rakwireless.com/product-categories/wisgate/rak10701-p/quickstart/#packet-frame-format)\n\n\n> **TIP:** NOTE\nThis section will focus on the configuration of each network server. The procedure of [Device Configuration of RAK10701-P via WisToolBox](https://docs.rakwireless.com/product-categories/wisgate/rak10701-p/quickstart/#configuration-of-rak10701-p-using-wistoolbox) is the same for all network server and will be covered in a separate section of the guide.\n\n\n#### RAK10701-P Field Tester Pro Guide for the Helium Network\n\nRAK10701-P can be manually registered to [Helium Console](https://console.helium.com/). This is a public LoRaWAN network server that you can use for your LoRaWAN end-devices powered by community-driven Helium Hotspots. This guide will show every detail of how to prepare the Helium Console for your RAK10701-P Field Tester Pro.\n\n\n> **TIP:** NOTE\nThis guide is based on [disk19 guide for the Field Tester](https://github.com/disk91/WioLoRaWANFieldTester/blob/master/doc/ConfigureHelium.md) configuration for the Helium Console.\n\n\n1. You need to register an account and then purchase data credits (DC) to use the network. If you are a new user, there are free data credits (DC) included in your new account to get you started quickly.\n\n> **Image:** Helium Console\n\n> **Image:** Console Home Page\n\n2. Once you are logged in, you can start adding your device. You have two ways to add a device as shown in the image.\n\n> **Image:** Adding Device\n\n3. The newly added device parameters will be shown. You have to put a device name and click save.\n\n\n> **TIP:** NOTE\nThe DEVEUI, APPEUI, and APPKEY are important in this step. These values must be configured on your RAK10701-P device using WisToolBox which will be covered later in this guide.\n\n\n> **Image:** Configuring Device Name\n\n4. The device will be added to the blockchain and it will show pending beside its name.\n\n> **Image:** Pending Device Status\n\n5. While waiting for the device to be added to the blockchain, you can create a `Label`. This will allow you to group your device to have a common setting. This will be needed to attach the needed integrations to the backend server of `dev.disk91.com`. You have to click the folder with the + icon and add a `Label` name then click `Save Label`. The newly created label should now be shown in the `Devices` console.\n\n> **Image:** Add Label icon\n\n> **Image:** Add Label Name\n\n> **Image:** Label created successfully\n\n6. Once the `Label` is created you have to associate it on the RAK10701 device. You can attach the `Label` on the device by clicking the **Add Label** button.\n\n> **Image:** Attach a label to the device\n\n7. A pop-up will be shown and you have to select the correct `Label` created for RAK10701 then click **Add Label**.\n\n> **Image:** Drop-down on label selection\n\n8. After successful attachment of `Label` on the devices, it should show one (1) device is under that `Label`. The device is properly labeled which is needed for the next steps - `Integrations` and `Flow`.\n\n> **Image:** Label added on the RAK10701 device\n\n9. To connect the backend server, you have to create an `Integration`.\n\n> **Image:** Add integration\n\n> **Image:** HTTP integration\n\n10. Then you must proceed to steps 2 and 3 sections of the `Integration` settings. You have to select `POST` then on the Endpoint URL, you must put `https://dev.disk91.com/fieldtester/helium/v3`. It is also needed to put the integration name before the clicking Add integration button.\n\n> **Image:** Details of HTTP Integration\n\n11. After preparing the device and the integration, you can now proceed with creating the flow to connect them. You have to click `Flows` and then the `+` icon on `NODES`.\n\n> **Image:** Setting up the Flows\n\n12. You must select `Labels` and `Integrations` and then drag the correct blocks on the flows canvas.\n\n> **Image:** Drag the rak10701-devices label\n\n> **Image:** Drag the RAK1070x_Integration\n\n13. You then have to connect the `Label` block to the `Integration` block via the tiny connector indicated by the red arrows by using your mouse cursor and dragging the line connector.\n\n\n> **TIP:** NOTE\nThere is no need to save the changes created on the flows canvas since it is automatically saved as you do changes.\n\n\n> **Image:** Connecting Labels to Integrations\n\n14. The final step in the setting up of the Helium Console for RAK10701 is the setting up of packets. You have to click on `Packets` and then the `Add New Packet Config` icon.\n\n> **Image:** Creating Packets\n\n15. You must also input a name on the `Packet Config Name`, select `Multiple Packets` and drag the slider so it will show `All Available Packets`. Once done, you can now click on `+ Create Packet Config`.\n\n> **Image:** Multiple packets configuration\n\n> **Image:** Successful packets creation\n\n16. You must associate the multiple packet setup with the `rak10701-devices` label. To do this, you have to go back on `Flows`, double-click on the `rak10701-devices` label, choose the `Packets` tab under rak10701-devices settings then enable `ALL Packets`. After this, you can now proceed with the configuration of RAK10701 using WisToolBox.\n\n> **Image:** Attaching multiple packets to the rak10701-devices label\n\n17. You can now proceed on [device configuration](https://docs.rakwireless.com/product-categories/wisgate/rak10701-p/quickstart/#configuration-of-rak10701-p-using-wistoolbox) so that the proper EUIs and KEY will match the one in the Helium network.\n\n#### RAK10701-P Field Tester Pro Guide for The Things Network\n\nThis section shows how to use the RAK10701-P Field Tester Pro for LoRaWAN to The Things Stack.\n\n1. Log in to TTNv3. To do so, head to the TTNv3 [site](https://console.cloud.thethings.network/) and select your cluster. If you already have a TTN account, you can use your The Things ID credentials to log in.\n\n> **Image:** The Things Stack home page\n\n> **Image:** Console page after a successful login\n\n\n> **TIP:** NOTE\nTo connect RAK10701-P Field Tester Pro to TTNv3, you should already have connected a gateway in range to TTNv3. Or, you have to be sure that you are in the range of a public gateway.\n\n\n2. Now that you are logged in to the platform, the next step is to create an application. In your console, click **Create an application**.\n\n> **Image:** Create an application\n\n3. To have an application registered, you need to input first the specific details and necessary information about your application then click **Create application**.\n\n> **Image:** Creating an Application\n\n4. If you had no error during the previous step, you should now be on the application console page. The next step is to **add end-devices to your TTN application**.\n\n> **Image:** Add end-devices to your TTN application\n\n5. To register the RAK10701-P Field Tester Pro, you need to click **Manually** first.\n\n> **Image:** Adding end devices manually\n\n6. Choose the following configurations in adding the end devices. You must choose the correct Frequency Plan and the LoRaWAN version must be 1.0.3.\n\n> **Image:** Configurations for adding end devices\n\n7.  Click **Show advanced activation, LoRaWAN class, and cluster settings**, then select **Over the air action** (OTAA).\n\n> **Image:** OTAA settings\n\n8. Then input the LoRaWAN OTAA parameters. For **AppEUI**, you may click **Fill with Zeros**. For **AppKey** and **DevEUI**, you can click **Generate**. Then the parameters will be automatically filled by the TTS platform. Finally, click **Register End Device**.\n\n> **Image:** Registering the end device\n\n9. You should now be able to see the device on the TTN console after you fully register your device. Take note of these OTAA parameters, such as the `AppEUI`, `DevEUI`, and the `AppKey`, as they are needed in the configuration of the RAK10701-P Field Tester Pro hardware later on in this guide.\n\n> **Image:** OTAA device successfully registered to TTN\n\n10. After adding the device to the LoRaWAN application, link it to the backend server. The first step is to create an **API key**.\n\n> **Image:** Creating API key\n\n> **Image:** Creating API key\n\n11. Configure the API key parameters. You can put any names that will easily track your API. You have to set the expiration date as well. Then you must check `Write downlink application traffic`. After the configuration, you can now click `Create API key`.\n\n> **Image:** API key parameters\n\n12. This step is critical. You need to copy the API key because this will be used on Webhook integration.\n\n> **Image:** Copy API key\n\n13. With the API key created, you can proceed with creating the Webhook integration.\n\n> **Image:** Webhook Integration\n\n14. Select **Custom Webhook**.\n\n> **Image:** Custom Webhook\n\n15. Configure the necessary parameters on the Webhook. You can select any name for the webhook. You then need to set the base URL going to disk19 server `https://dev.disk91.com/fieldtester/ttn/v3`, add the API key from the previous step and lastly put a check on the `Uplink message` under **Enabled event types**.\n\n> **Image:** Webhook parameters\n\n16. After setting all the configurations, you can now add the webhook.\n\n> **Image:** Add Webhook\n\n17. You should see now the newly created webhook.\n\n> **Image:** Add Webhook\n\n18. After adding the application, device, and webhook integration to the console, you have to configure the parameters in your device to match the parameters on the TTN console. You can use [WisToolBox](https://docs.rakwireless.com/product-categories/software-tools/wistoolbox/overview/) via USB connection or wirelessly via BLE. You can now proceed on the [RAK10701-P Configuration using WisToolBox](https://docs.rakwireless.com/product-categories/wisgate/rak10701-p/quickstart/#configuration-of-rak10701-p-using-wistoolbox). You also have the option to update device parameters directly via [RUI3 AT Commands](https://docs.rakwireless.com/product-categories/software-apis-and-libraries/rui3/at-command-manual/#lorawan-keys-and-ids) (if you prefer AT commands instead of WisToolBox).\n\n19. Once you configured the RAK10701-P with the correct Frequency Band and EUIs/Key by following the guide on the [RAK10701-P Configuration using WisToolBox](https://docs.rakwireless.com/product-categories/wisgate/rak10701-p/quickstart/#configuration-of-rak10701-p-using-wistoolbox), you should see the join request/accept, uplinks and downlinks to The Things Stack console. These uplinks contains the coordinates of the field tester and the downlinks contains the data calculated by the disk91 server. The uplink uses fport 1 and the downlink uses fport 2. To view the actual coordinates on the console, you need to add a payload decoder on your uplink data.\n\n> **Image:** Adding Uplink Payload Decoder\n\nUplink payload decoder script.\n\n<details>\n<summary> Click to view the code</summary>\n\n```js\nfunction Decoder(bytes, port) {\n\tvar decoded = {};\n\t// avoid sending Downlink ACK to integration (Cargo)\n\tif (port === 1) {\n\t\tvar lonSign = (bytes[0] >> 7) & 0x01 ? -1 : 1;\n\t\tvar latSign = (bytes[0] >> 6) & 0x01 ? -1 : 1;\n\n\t\tvar encLat = ((bytes[0] & 0x3f) << 17) +\n\t\t\t(bytes[1] << 9) +\n\t\t\t(bytes[2] << 1) +\n\t\t\t(bytes[3] >> 7);\n\n\t\tvar encLon = ((bytes[3] & 0x7f) << 16) +\n\t\t\t(bytes[4] << 8) +\n\t\t\tbytes[5];\n\n\t\tvar hdop = bytes[8] / 10;\n\t\tvar sats = bytes[9];\n\n\t\tconst maxHdop = 2;\n\t\tconst minSats = 5;\n\n\t\tif ((hdop < maxHdop) && (sats >= minSats)) {\n\t\t\t// Send only acceptable quality of position to mappers\n\t\t\tdecoded.latitude = latSign * (encLat * 108 + 53) / 10000000;\n\t\t\tdecoded.longitude = lonSign * (encLon * 215 + 107) / 10000000;\n\t\t\tdecoded.altitude = ((bytes[6] << 8) + bytes[7]) - 1000;\n\t\t\tdecoded.accuracy = (hdop * 5 + 5) / 10\n\t\t\tdecoded.hdop = hdop;\n\t\t\tdecoded.sats = sats;\n\t\t} else {\n\t\t\tdecoded.error = \"Need more GPS precision (hdop must be <\" + maxHdop +\n\t\t\t\t\" & sats must be >= \" + minSats + \") current hdop: \" + hdop + \" & sats:\" + sats;\n\t\t}\n\t\treturn decoded;\n\t}\n\treturn null;\n}\n```\n\n</details>\n\n20. With the correct payload decoder, you should now see GPS coordinates data which you can also use to other integration.\n\n> **Image:** Decoded payload and TTS console\n\n#### RAK10701-P Field Tester Pro Guide for Chirpstack\n\n##### How Does It Work?\n\nThere are two steps under the hood of the Field Tester. In step one, the Field Tester is sending out data packets over LoRaWAN. These packets are received by one or multiple gateways. These packets are forwarded from the LoRaWAN network server to another backend server. When the packets are forwarded, they include information about signal strength and the number of gateways that have received the packet.\n\n> **Image:** Step 1 - Field Tester Sending Uplink Payload\n\nIn the second step, the backend server is calculating the minimum and maximum distance between the Field Tester Pro and the gateways that received the data. Together with the minimum and maximum RSSI levels, this information is then sent back to the Field Tester Pro as a LoRaWAN downlink.\n\n> **Image:** Step 2 - Backend Server Sending Useful Information as Downlink\n\nTo use Chirpstack for RAK10701-P, you must have a working installation of the Chirpstack LoRaWAN network server. It can be on a dedicated machine, Raspberry Pi, or in a cloud VPS instance. It should have a fixed IP address and port to where `Datacake.co` will connect to.\n\n1. To start with Chirpstack, you must create a device profile for your RAK10701-P Field Tester Pro device. You must select `LoRaWAN MAC version 1.0.3` which is the LoRaWAN specification version that the RAK10701 Field Tester supports.\n\n> **Image:** Creating Device Profile in Chirpstack\n\n2. You must enable `Device supports OTAA` as the network join method as well.\n\n> **Image:** Enable support for OTAA\n\n3. You can also include a custom javascript decoder under the `CODEC` tab. This will allow you to see the specific information transmitted by the device.\n\n> **Image:** Custom Javascript Decoder for RAK10701 Field Mapper\n\nHere's the complete decoder script:\n\n<details>\n<summary> Click to view the code</summary>\n\n```js\nfunction Decode(fPort, bytes, variables) {\n    var decoded = {};\n    // avoid sending Downlink ACK to integration (Cargo)\n    if ((fPort === 1) || (fPort === 2)){\n        var lonSign = (bytes[0] >> 7) & 0x01 ? -1 : 1;\n        var latSign = (bytes[0] >> 6) & 0x01 ? -1 : 1;\n\n        var encLat = ((bytes[0] & 0x3f) << 17) +\n            (bytes[1] << 9) +\n            (bytes[2] << 1) +\n            (bytes[3] >> 7);\n\n        var encLon = ((bytes[3] & 0x7f) << 16) +\n            (bytes[4] << 8) +\n            bytes[5];\n\n        var hdop = bytes[8] / 10;\n        var sats = bytes[9];\n\n        var maxHdop = 2;\n        var minSats = 5;\n\n        if ((hdop < maxHdop) && (sats >= minSats)) {\n            // Send only acceptable quality of position to mappers\n            decoded.latitude = latSign * (encLat * 108 + 53) / 10000000;\n            decoded.longitude = lonSign * (encLon * 215 + 107) / 10000000;\n            decoded.altitude = ((bytes[6] << 8) + bytes[7]) - 1000;\n            decoded.accuracy = (hdop * 5 + 5) / 10\n            decoded.hdop = hdop;\n            decoded.sats = sats;\n        } else {\n            decoded.error = \"Need more GPS precision (hdop must be <\" + maxHdop +\n                \" & sats must be >= \" + minSats + \") current hdop: \" + hdop + \" & sats:\" + sats;\n            decoded.latitude = latSign * (encLat * 108 + 53) / 10000000;\n            decoded.longitude = lonSign * (encLon * 215 + 107) / 10000000;\n            decoded.altitude = ((bytes[6] << 8) + bytes[7]) - 1000;\n            decoded.accuracy = (hdop * 5 + 5) / 10\n            decoded.hdop = hdop;\n            decoded.sats = sats;\n        }\n        return decoded;\n    }\n    return null;\n\n```\n\n</details>\n\n\n> **TIP:** NOTE\nThis decoder script can be found on [RAKwireless Standardize Payload repository](https://github.com/RAKWireless/RAKwireless_Standardized_Payload) which also includes a custom decoder script for TTN and Helium.\n\n\n4. After creating the device profile, you can now create an application and add the RAK10701 device. And then attached the `Device-profile` you created. You have to take note of the DEVEUI and APPKEY in this section. These parameters must match the ones in our RAK10701 Field Tester.\n\n> **Image:** Create application in Chirpstack\n\n> **Image:** Create device in Chirpstack.\n\n> **Image:** Device APPKEY\n\n5. You also need to secure that you have a Gateway registered in Chirpstack and with the correct Network Server profile.\n\n> **Image:** Gateways registered in Chripstack\n\n6. The next step after setting up the network server, devices, and gateway, is the integration of the Chirpstack application to Datacake. You must choose HTTP, then click `Edit`. Then you have to use this endpoint going to datacake `https://api.datacake.co/integrations/lorawan/chirpstack/`.\n\n> **Image:** Creating integration\n\n> **Image:** Creating endpoint for Datacake.co  \n\n7. The last step on the Chirpstack side, is the creation of the API key. This is needed to allow Datacake in sending downlink packets to the RAK10701 Field Tester. Make sure the key is copied and saved somewhere, it is only retrievable during the key creation. Copy the Token and save it in a text editor.\n\n> **Image:** Creation of API Key\n\n> **Image:** Creation of API Key\n\n8. You can now proceed on [Datacake](https://datacake.co/) and add a LoRaWAN device that will be linked to your RAK10701 created in ChirpStack. You have to create an account if you do not have one yet.\n\n> **Image:** Device list dashboard\n\n> **Image:** Selecting LoRaWAN\n\n> **Image:** Add new product\n\n> **Image:** Selecting chirpstack\n\n> **Image:** Adding device name\n\n9. Next step is to enable the downlink. This is the step where you'll be needing the previously created API key in step 7 of this guide. Take note that the `ChirpStack URL` should be based on your deployed Chirpstack network server. After doing all configurations, click update and save.\n\n> **Image:** Configuration settings\n\n> **Image:** Chirpstack downlink configuration\n\n> **Image:** Chirpstack URL and API key\n\n10. Just below the `LoRaWAN` section in datacake.co, you'll see the `Payload Decoder`. This is a very critical step to ensure that all important data will be covered.\n\n<details>\n<summary> Click to view the code</summary>\n\n```js\nfunction distance(lat1, lon1, lat2, lon2) {\n    if ((lat1 == lat2) && (lon1 == lon2)) {\n        return 0;\n    }\n    else {\n        var radlat1 = Math.PI * lat1 / 180;\n        var radlat2 = Math.PI * lat2 / 180;\n        var theta = lon1 - lon2;\n        var radtheta = Math.PI * theta / 180;\n        var dist = Math.sin(radlat1) * Math.sin(radlat2) + Math.cos(radlat1) * Math.cos(radlat2) * Math.cos(radtheta);\n        if (dist > 1) {\n            dist = 1;\n        }\n        dist = Math.acos(dist);\n        dist = dist * 180 / Math.PI;\n        dist = dist * 60 * 1.1515;\n        dist = dist * 1.609344;\n        return dist;\n    }\n}\n\nfunction Decoder(bytes, fPort) {\n    var decoded = {};\n    // avoid sending Downlink ACK to integration (Cargo)\n    if (fPort === 1) {\n        var lonSign = (bytes[0] >> 7) & 0x01 ? -1 : 1;\n        var latSign = (bytes[0] >> 6) & 0x01 ? -1 : 1;\n\n        var encLat = ((bytes[0] & 0x3f) << 17) +\n            (bytes[1] << 9) +\n            (bytes[2] << 1) +\n            (bytes[3] >> 7);\n\n        var encLon = ((bytes[3] & 0x7f) << 16) +\n            (bytes[4] << 8) +\n            bytes[5];\n\n        var hdop = bytes[8] / 10;\n        var sats = bytes[9];\n\n        var maxHdop = 2;\n        var minSats = 5;\n\n        if ((hdop < maxHdop) && (sats >= minSats)) {\n            // Send only acceptable quality of position to mappers\n            decoded.latitude = latSign * (encLat * 108 + 53) / 10000000;\n            decoded.longitude = lonSign * (encLon * 215 + 107) / 10000000;\n            decoded.altitude = ((bytes[6] << 8) + bytes[7]) - 1000;\n            decoded.accuracy = (hdop * 5 + 5) / 10\n            decoded.hdop = hdop;\n            decoded.sats = sats;\n            decoded.location = \"(\" + decoded.latitude + \",\" + decoded.longitude + \")\";\n        } else {\n            decoded.error = \"Need more GPS precision (hdop must be <\" + maxHdop +\n                \" & sats must be >= \" + minSats + \") current hdop: \" + hdop + \" & sats:\" + sats;\n            decoded.latitude = latSign * (encLat * 108 + 53) / 10000000;\n            decoded.longitude = lonSign * (encLon * 215 + 107) / 10000000;\n            decoded.altitude = ((bytes[6] << 8) + bytes[7]) - 1000;\n            decoded.accuracy = (hdop * 5 + 5) / 10\n            decoded.hdop = hdop;\n            decoded.sats = sats;\n            decoded.location = \"(\" + decoded.latitude + \",\" + decoded.longitude + \")\";\n        }\n        //      decoded.raw = rawPayload.uplink_message.rx_metadata[0].location;\n        decoded.num_gw = normalizedPayload.gateways.length;\n        decoded.minRSSI = 0;\n        decoded.maxRSSI = 0;\n        decoded.minSNR = 0;\n        decoded.maxSNR = 0;\n        decoded.minDistance = 0;\n        decoded.maxDistance = 0;\n\n        var server_type = 0;\n        // Check if payload comes from TTN\n        if (typeof (rawPayload.uplink_message) != \"undefined\") {\n            console.log(\"Found TTN format\");\n            server_type = 1;\n        }\n        // Check if payload comes from Helium\n        else if (typeof (rawPayload.hotspots) != \"undefined\") {\n            console.log(\"Found Helium format\");\n            server_type = 2;\n        }\n        // Check if payload comes from Chirpstack\n        else if (typeof (rawPayload.rxInfo) != \"undefined\") {\n            console.log(\"Found Chirpstack format\");\n            server_type = 3;\n            decoded.is_chirpstack = 1;\n        }\n        else {\n            console.log(\"Unknown raw format\");\n        }\n\n        var gw_lat = {};\n        var gw_long = {};\n\n        decoded.num_gw = 0;\n        for (idx_tst = 0; idx_tst < 10; idx_tst++)\n        {\n            if (typeof (normalizedPayload.gateways[idx_tst]) != \"undefined\")\n            {\n                console.log(\"Found gateway with IDX \" + idx_tst);\n                decoded.num_gw += 1;\n            }\n        }\n\n        for (idx = 0; idx < decoded.num_gw; idx++) {\n            var new_rssi = (!!normalizedPayload.gateways && !!normalizedPayload.gateways[idx] && normalizedPayload.gateways[idx].rssi) || 0;\n            var new_snr = (!!normalizedPayload.gateways && !!normalizedPayload.gateways[idx] && normalizedPayload.gateways[idx].snr) || 0;\n            if ((new_rssi < decoded.minRSSI) || (decoded.minRSSI == 0)) {\n                decoded.minRSSI = new_rssi;\n            }\n            if ((new_rssi > decoded.maxRSSI) || (decoded.maxRSSI == 0)) {\n                decoded.maxRSSI = new_rssi;\n            }\n            if ((new_snr < decoded.minSNR) || (decoded.minSNR == 0)) {\n                decoded.minSNR = new_snr;\n            }\n            if ((new_snr > decoded.maxSNR) || (decoded.maxSNR == 0)) {\n                decoded.maxSNR = new_snr;\n            }\n\n            // var gw_lat = 0.0;\n            // var gw_long = 0.0;\n            switch (server_type) {\n                //TTN\n                case 1:\n                    gw_lat[idx] = rawPayload.uplink_message.rx_metadata[idx].location.latitude;\n                    gw_long[idx] = rawPayload.uplink_message.rx_metadata[idx].location.longitude;\n                    break;\n                // Helium\n                case 2:\n                    gw_lat[idx] = rawPayload.hotspots[idx].lat;\n                    gw_long[idx] = rawPayload.hotspots[idx].long;\n                    break;\n                // Chirpstack\n                case 3:\n                    gw_lat[idx] = rawPayload.rxInfo[idx].location.latitude;\n                    gw_long[idx] = rawPayload.rxInfo[idx].location.longitude;\n                    break;\n                default:\n                    console.log(\"Unknown LNS\");\n                    break;\n            }\n\n            console.log(\"IDX \" + idx + \" lat \" + gw_lat[idx] + \" long \" + gw_long[idx]);\n            // decoded.gw_lat[idx] = gw_lat;\n            // decoded.gw_long[idx] = gw_long;\n\n            // Calculate distance\n            var new_distance = distance(gw_lat[idx], gw_long[idx], decoded.latitude, decoded.longitude);\n            if ((new_distance < decoded.minDistance) || (decoded.minDistance == 0)) {\n                decoded.minDistance = new_distance * 1000;\n            }\n            if ((new_distance > decoded.maxDistance) || (decoded.maxDistance == 0)) {\n                decoded.maxDistance = new_distance * 1000;\n            }\n        }\n\n        switch (decoded.num_gw) {\n            case 20:\n                decoded.hotspot_10 = \"(\" + gw_lat[19] + \",\" + gw_long[19] + \")\";\n            case 19:\n                decoded.hotspot_09 = \"(\" + gw_lat[18] + \",\" + gw_long[18] + \")\";\n            case 18:\n                decoded.hotspot_08 = \"(\" + gw_lat[17] + \",\" + gw_long[17] + \")\";\n            case 17:\n                decoded.hotspot_07 = \"(\" + gw_lat[16] + \",\" + gw_long[16] + \")\";\n            case 16:\n                decoded.hotspot_06 = \"(\" + gw_lat[15] + \",\" + gw_long[15] + \")\";\n            case 15:\n                decoded.hotspot_05 = \"(\" + gw_lat[14] + \",\" + gw_long[14] + \")\";\n            case 14:\n                decoded.hotspot_04 = \"(\" + gw_lat[13] + \",\" + gw_long[13] + \")\";\n            case 13:\n                decoded.hotspot_03 = \"(\" + gw_lat[12] + \",\" + gw_long[12] + \")\";\n            case 12:\n                decoded.hotspot_02 = \"(\" + gw_lat[11] + \",\" + gw_long[11] + \")\";\n            case 11:\n                decoded.hotspot_01 = \"(\" + gw_lat[10] + \",\" + gw_long[10] + \")\";\n            case 10:\n                decoded.hotspot_10 = \"(\" + gw_lat[9] + \",\" + gw_long[9] + \")\";\n            case 9:\n                decoded.hotspot_09 = \"(\" + gw_lat[8] + \",\" + gw_long[8] + \")\";\n            case 8:\n                decoded.hotspot_08 = \"(\" + gw_lat[7] + \",\" + gw_long[7] + \")\";\n            case 7:\n                decoded.hotspot_07 = \"(\" + gw_lat[6] + \",\" + gw_long[6] + \")\";\n            case 6:\n                decoded.hotspot_06 = \"(\" + gw_lat[5] + \",\" + gw_long[5] + \")\";\n            case 5:\n                decoded.hotspot_05 = \"(\" + gw_lat[4] + \",\" + gw_long[4] + \")\";\n            case 4:\n                decoded.hotspot_04 = \"(\" + gw_lat[3] + \",\" + gw_long[3] + \")\";\n            case 3:\n                decoded.hotspot_03 = \"(\" + gw_lat[2] + \",\" + gw_long[2] + \")\";\n            case 2:\n                decoded.hotspot_02 = \"(\" + gw_lat[1] + \",\" + gw_long[1] + \")\";\n            case 1:\n                decoded.hotspot_01 = \"(\" + gw_lat[0] + \",\" + gw_long[0] + \")\";\n            default:\n                break;\n        }\n\n        decoded.maxMod = parseInt((decoded.maxDistance / 250), 10);\n        decoded.minMod = parseInt((decoded.minDistance / 250), 10);\n        decoded.maxDistance = parseInt((decoded.maxMod * 250), 10);\n        decoded.minDistance = parseInt((decoded.minMod * 250), 10);\n        if (decoded.maxDistance <= 1) {\n            decoded.maxDistance = parseInt(250, 10);\n        }\n        if (decoded.minDistance <= 1) {\n            decoded.minDistance = parseInt(250, 10);\n        }\n        return decoded;\n    }\n    return null;\n\n}\n```\n\n</details>\n\nThis decoder is not only decoding data from the LoRaWAN packet but is as well reading gateway information from the additional data that the LoRaWAN server added to the data it forwarded to Datacake.\n\nEach LoRaWAN server uses a different format for this additional information, so there is a code section that tries to detect whether the data came from a Chirpstack LSN, from TTN, or from a Helium Console:\n\n<details>\n<summary> Click to view the code</summary>\n\n```js\nvar server_type = 0;\n        // Check if payload comes from TTN\n        if (typeof (rawPayload.uplink_message) != \"undefined\") {\n            console.log(\"Found TTN format\");\n            server_type = 1;\n        }\n        // Check if payload comes from Helium\n        else if (typeof (rawPayload.hotspots) != \"undefined\") {\n            console.log(\"Found Helium format\");\n            server_type = 2;\n        }\n        // Check if payload comes from Chirpstack\n        else if (typeof (rawPayload.rxInfo) != \"undefined\") {\n            console.log(\"Found Chirpstack format\");\n            server_type = 3;\n            decoded.is_chirpstack = 1;\n        }\n        else {\n            console.log(\"Unknown raw format\");\n        }\n```\n\n</details>\n\nOnce the data is extracted, it calculates the distance between the RAK10701 Field Tester location and the different gateways that received the LoRaWAN packet. This version of the decoder can handle up to 10 gateways, but it can be extended.\n\n<details>\n<summary> Click to view the code</summary>\n\n```js\nfunction distance(lat1, lon1, lat2, lon2) {\n    if ((lat1 == lat2) && (lon1 == lon2)) {\n        return 0;\n    }\n    else {\n        var radlat1 = Math.PI * lat1 / 180;\n        var radlat2 = Math.PI * lat2 / 180;\n        var theta = lon1 - lon2;\n        var radtheta = Math.PI * theta / 180;\n        var dist = Math.sin(radlat1) * Math.sin(radlat2) + Math.cos(radlat1) * Math.cos(radlat2) * Math.cos(radtheta);\n        if (dist > 1) {\n            dist = 1;\n        }\n        dist = Math.acos(dist);\n        dist = dist * 180 / Math.PI;\n        dist = dist * 60 * 1.1515;\n        dist = dist * 1.609344;\n        return dist;\n    }\n}\n```\n\n</details>\n\nIn the next step, it analyzes the different distances and RSSI levels to find the closest and farthest gateway and the lowest and highest RSSI and SNR levels.\n\nThe result of the decoding is then put into different data fields that are used by Chirpstack for the visualization and by the rule, we will define to create the downlink to the RAK10701 Field Tester.\n\n11. The next step is to create the different data fields that are filled by the data decoder. This is done in the Fields section of the device configuration, just below the data encoder section.\n\n> **Image:** Creation of data field\n\nThe following fields are required:\n\n| Field Name    | Identifier (returned value from the decoder) | Field Type |\n| ------------- | -------------------------------------------- | ---------- |\n| Field Tester  | LOCATION                                     | Location   |\n| MinDistance   | MINDISTANCE                                  | Integer    |\n| MaxDistance   | MAXDISTANCE                                  | Integer    |\n| MinRSSI       | MINRSSI                                      | Float      |\n| MaxRSSI       | MAXRSSI                                      | Float      |\n| MinSNR        | MINSNR                                       | Float      |\n| MaxSNR        | MAXSNR                                       | Float      |\n| minMod        | MINMOD                                       | Integer    |\n| maxMod        | MAXMAD                                       | Integer    |\n| hotspot_01    | HOTSPOT_01                                   | Location   |\n| hotspot_02    | HOTSPOT_01                                   | Location   |\n| hotspot_0‚Ä¶    | HOTSPOT_...                                  | Location   |\n| hotspot_09    | HOTSPOT_09                                   | Location   |\n| hotspot_10    | HOTSPOT_10                                   | Location   |\n| is_chirpstack | IS_CHIRPSTACK                                | Boolean    |\n\nThere are more variables created by the decoder, but this is the minimum set required for the dashboard and to configure the download.\n\n12. This is the most critical step so that the RAK10701 will be able to display the necessary details helpful in Field Testing the LoRaWAN network. This section is responsible for the \"backend-server functions\". In this step, we create the automatic downlink to the device that is executed every time a data packet from the RAK10701 Field Tester arrives. Take note that port number 2 is used by RAK10701 for downlinks and `Trigger on measurements` should be checked.\n\n> **Image:** Chirpstack downlink configuration\n\n> **Image:** Chirpstack downlink configuration\n\nIn this guide, the downlink is only created when the Field Tester is connected through a Chirpstack server. When TTN or Helium is used, the downlink would be created by the original backend server.\n\nThis is controlled by the ‚ÄúFields used‚Äù where you can see the IS_CHIRPSTACK.\n\nThe Payload Encoder is preparing a downlink packet that will be sent back to the RAK10701 Field Tester. The downlink packet is only 6¬†bytes large to avoid problems in LoRaWAN regions with limited downlink packet sizes.\n\nThis is the complete decoder script. The first byte is usually a counter, but it works well if the counter is ignored and always set to 1.\n\n<details>\n<summary> Click to view the code</summary>\n\n```js\nfunction Encoder(measurements, port) {\n    var buf = [];\n    buf[0] = 1;\n    buf[1] = measurements.MINRSSI.value + 200;\n    buf[2] = measurements.MAXRSSI.value + 200;\n    // var temp = parseInt(measurements.MINMOD.value,10);\n    if (measurements.MINMOD.value == 0) {\n        measurements.MINMOD.value = 1;\n    }\n    console.log(measurements.MINMOD.value);\n    buf[3] = measurements.MINMOD.value;\n    if (measurements.MAXMOD.value == 0) {\n        measurements.MAXMOD.value = 1;\n    }\n    buf[4] = measurements.MAXMOD.value;\n    buf[5] = measurements.NUM_GW.value;\n    return buf;\n}\n```\n\n</details>\n\n13. You can now proceed on [device configuration](https://docs.rakwireless.com/product-categories/wisgate/rak10701-p/quickstart/#configuration-of-rak10701-p-using-wistoolbox) so that the proper EUIs and KEY will match the one in the network server.\n\n#### RAK10701-P Field Tester Pro Guide for LORIOT and Datacake\n\nIn this document, you will find a step-by-step guide for performing a field mapping test using LORIOT network management system and Datacake's platform to visualize your results. This solution will help you in your network planning ventures and ensure your decisions are data-driven and adequate to your surroundings.\n\n##### Prerequisites\n\n- [RAK10701 WisNode Field Tester for LoRaWAN](https://store.rakwireless.com/products/field-tester-for-lorawan-rak10701?variant=42437595726022)\n- [LORIOT account](https://www.loriot.io/login.html)\n- [Datacake account](https://datacake.co/pricing)\n- Gateway\n\n##### Setting LORIOT as the LNS\n\n1. Forward a gateway to LORIOT, which will be the LNS (LoRa Network Server) for this use case. For registration of the gateway to LORIOT, you will need the gateway‚Äôs MAC and EUI, which can be found on the Overview page of WisGateOS 2.\n\n> **Image:** WisGate Edges web UI\n\n2. Go to your LORIOT profile. From the menu on the left, navigate through **Networks** > **your_network** > **+Add Gateway**.\n\n> **Image:** LORIOT console\n\n\n> **TIP:** NOTE\nThe LORIOT platform provides you with a **Sample Network** at the point of your profile creation. You can use it for free. If you wish to create a new one, or delete the provided one, you will need a paid plan to continue.\n\n\n3. For the base platform select **Basics Station Semtech**. You will be asked to provide eth0 MAC address and EUI, which you obtained in step 1. After filling in these values, press the **Register Basics Station Semtech gateway** at the bottom of the page.\n\n> **Image:** Registering The Gateway To LORIOT\n\n4. The last thing you need to do to connect your gateway with LORIOT LNS is to provide the Basics Station configuration to the gateway. This can be done by going to the gateway's **web UI** > **LoRa** > **Configuration** and doing a Basics station server setup.\n\n> **Image:** Gateway Configuration Page\n\nYou can find the Trust (CA Certificate), the Server URL, and the Server port in LORIOT by navigating to the newly registered **Gateway** > **Certificate**. Use the configuration provided by LORIOT as it may differ from the guide depending on your region.\n\n> **Image:** Certificate\n\n5. If the steps are followed correctly, the gateway should show a **Connected** status.\n\n##### Adding the Device and LORIOT to Datacake Integration\n\n1. Add the device to LORIOT. In the LORIOT platform, navigate to **Applications** > **your_application** and use the **Enroll Device** utility from the menu on the left. Fill out your Device EUI, Join (APP) EUI, and Application Key.\n\n> **Image:** Adding The Device To The LORIOT Platform\n\n\n> **TIP:** NOTE\nThe LORIOT platform provides you with a **Sample Application** at the point of your profile creation. You can use it for free. If you wish to create a new one or delete the provided one, you will need a paid plan to continue.\n\n\n2. Use the Output utility to set up the Datacake integration. For now, just give it a name. The Authorization requires additional settings that will not be covered by this guide. For more information regarding this process, refer to [Datacake's guide](https://docs.datacake.de/lorawan/lns/loriot).\n\n> **Image:** Add Output\n\n3. Now, you need to add the device in Datacake. To register a new device, navigate to the **Devices** tab in your Datacake account. Click the **+Add Device** button.\n\n> **Image:** Datacake Platform\n\n4. Choose **New Product** under **Datacake Product**. Enter the device name in the **Product name** input box, and proceed by clicking **Next**.\n\n> **Image:** Add Lorawan Device 1\n\n5. Select **LORIOT** as the Network Server and click **Next**.\n\n> **Image:** Add Lorawan Device 2\n\n6. On the next page, you will have to enter the name and DEVEUI of the device. Select the plan for Datacake according to your needs and finish the device-adding procedure.\n\n7. Now, navigate to **Configuration** in the newly created device at Datacake and scroll down to the **Network Server** configuration. Click **Change**.\n\n> **Image:** Device Network Server Configuration\n\n8. You will need the LORIOT Access Token, which is generated from the LORIOT console. Navigate to **LORIOT** > **Access Tokens** and copy the token to put it in Datacake.\n\n> **Image:** LORIOT Access Token\n\n> **Image:** Access Token Field In Datacake\n\nYou can generate a new access token or use the existing one.\n\n9. If everything is done correctly, you should see a trickle of RAW data in the Debug window of Datacake.\n\n##### Setting up the Uplink Payload Decoder and the Downlink Encoder\n\n1. In the Datacake console, navigate to the **Configuration** tab of your RAK10701 device. At the bottom of the page, you will find the **Payload Decoder** field. Copy the decoder provided below and paste it in that field. This decoder will calculate the values displayed on the screen of the Field Tester.\n\n<details>\n<summary> Click to view the code</summary>\n\n```js\n\nfunction distance(lat1, lon1, lat2, lon2) {\n\tif ((lat1 == lat2) && (lon1 == lon2)) {\n\t\treturn 0;\n\t}\n\telse {\n\t\tvar radlat1 = Math.PI * lat1 / 180;\n\t\tvar radlat2 = Math.PI * lat2 / 180;\n\t\tvar theta = lon1 - lon2;\n\t\tvar radtheta = Math.PI * theta / 180;\n\t\tvar dist = Math.sin(radlat1) * Math.sin(radlat2) + Math.cos(radlat1) * Math.cos(radlat2) * Math.cos(radtheta);\n\t\tif (dist > 1) {\n\t\t\tdist = 1;\n\t\t}\n\t\tdist = Math.acos(dist);\n\t\tdist = dist * 180 / Math.PI;\n\t\tdist = dist * 60 * 1.1515;\n\t\tdist = dist * 1.609344;\n\t\treturn dist;\n\t}\n}\n\nfunction Decoder(bytes, fPort) {\n\tvar decoded = {};\n\t// avoid sending Downlink ACK to integration (Cargo)\n\tif (fPort === 1) {\n\t\tvar lonSign = (bytes[0] >> 7) & 0x01 ? -1 : 1;\n\t\tvar latSign = (bytes[0] >> 6) & 0x01 ? -1 : 1;\n\n\t\tvar encLat = ((bytes[0] & 0x3f) << 17) +\n\t\t\t(bytes[1] << 9) +\n\t\t\t(bytes[2] << 1) +\n\t\t\t(bytes[3] >> 7);\n\n\t\tvar encLon = ((bytes[3] & 0x7f) << 16) +\n\t\t\t(bytes[4] << 8) +\n\t\t\tbytes[5];\n\n\t\tvar hdop = bytes[8] / 10;\n\t\tvar sats = bytes[9];\n\n\t\tvar maxHdop = 2;\n\t\tvar minSats = 5;\n\n\t\tif ((hdop < maxHdop) && (sats >= minSats)) {\n\t\t\t// Send only acceptable quality of position to mappers\n\t\t\tdecoded.latitude = latSign * (encLat * 108 + 53) / 10000000;\n\t\t\tdecoded.longitude = lonSign * (encLon * 215 + 107) / 10000000;\n\t\t\tdecoded.altitude = ((bytes[6] << 8) + bytes[7]) - 1000;\n\t\t\tdecoded.accuracy = (hdop * 5 + 5) / 10\n\t\t\tdecoded.hdop = hdop;\n\t\t\tdecoded.sats = sats;\n\t\t\tdecoded.location = \"(\" + decoded.latitude + \",\" + decoded.longitude + \")\";\n\t\t} else {\n\t\t\tdecoded.error = \"Need more GPS precision (hdop must be <\" + maxHdop +\n\t\t\t\t\" & sats must be >= \" + minSats + \") current hdop: \" + hdop + \" & sats:\" + sats;\n\t\t\tdecoded.latitude = latSign * (encLat * 108 + 53) / 10000000;\n\t\t\tdecoded.longitude = lonSign * (encLon * 215 + 107) / 10000000;\n\t\t\tdecoded.altitude = ((bytes[6] << 8) + bytes[7]) - 1000;\n\t\t\tdecoded.accuracy = (hdop * 5 + 5) / 10\n\t\t\tdecoded.hdop = hdop;\n\t\t\tdecoded.sats = sats;\n\t\t\tdecoded.location = \"(\" + decoded.latitude + \",\" + decoded.longitude + \")\";\n\t\t}\n\t\t// \t\tdecoded.raw = rawPayload.uplink_message.rx_metadata[0].location;\n\t\tdecoded.num_gw = normalizedPayload.gateways.length;\n\t\tdecoded.minRSSI = 0;\n\t\tdecoded.maxRSSI = 0;\n\t\tdecoded.minSNR = 0;\n\t\tdecoded.maxSNR = 0;\n\t\tdecoded.minDistance = 0;\n\t\tdecoded.maxDistance = 0;\n\t\tvar server_type = 0;\n\t\t// Check if payload comes from TTN\n\t\tif (typeof (rawPayload.uplink_message) != \"undefined\") {\n\t\t\tconsole.log(\"Found TTN format\");\n\t\t\tserver_type = 1;\n\t\t\tdecoded.is_chirpstack = 1;\n\t\t}\n\t\t// Check if payload comes from Helium\n\t\telse if (typeof (rawPayload.hotspots) != \"undefined\") {\n\t\t\tconsole.log(\"Found Helium format\");\n\t\t\tserver_type = 2;\n\t\t}\n\t\t// Check if payload comes from Chirpstack\n\t\telse if (typeof (rawPayload.rxInfo) != \"undefined\") {\n\t\t\tconsole.log(\"Found Chirpstack format\");\n\t\t\tserver_type = 3;\n\t\t\tdecoded.is_chirpstack = 1;\n\t\t}\n\t\t// Check if payload comes from LORIOT\n\t\telse if (typeof (rawPayload.cmd) != \"undefined\") {\n\t\t\tconsole.log(\"Found LORIOT format\");\n\t\t\tserver_type = 4;\n\t\t\tdecoded.is_chirpstack = 1;\n\t\t}\n\t\telse {\n\t\t\tconsole.log(\"Unknown raw format\");\n\t\t}\n\n\t\tvar gw_lat = {};\n\t\tvar gw_long = {};\n\n\t\tdecoded.num_gw = 0;\n\t\tfor (idx_tst = 0; idx_tst < 10; idx_tst++)\n\t\t{\n\t\t\tif (typeof (normalizedPayload.gateways[idx_tst]) != \"undefined\")\n\t\t\t{\n\t\t\t\tconsole.log(\"Found gateway with IDX \" + idx_tst);\n\t\t\t\tdecoded.num_gw += 1;\n\t\t\t}\n\t\t}\n\n\t\tfor (idx = 0; idx < decoded.num_gw; idx++) {\n\t\t\tvar new_rssi = (!!normalizedPayload.gateways && !!normalizedPayload.gateways[idx] && normalizedPayload.gateways[idx].rssi) || 0;\n\t\t\tvar new_snr = (!!normalizedPayload.gateways && !!normalizedPayload.gateways[idx] && normalizedPayload.gateways[idx].snr) || 0;\n\t\t\tif ((new_rssi < decoded.minRSSI) || (decoded.minRSSI == 0)) {\n\t\t\t\tdecoded.minRSSI = new_rssi;\n\t\t\t}\n\t\t\tif ((new_rssi > decoded.maxRSSI) || (decoded.maxRSSI == 0)) {\n\t\t\t\tdecoded.maxRSSI = new_rssi;\n\t\t\t}\n\t\t\tif ((new_snr < decoded.minSNR) || (decoded.minSNR == 0)) {\n\t\t\t\tdecoded.minSNR = new_snr;\n\t\t\t}\n\t\t\tif ((new_snr > decoded.maxSNR) || (decoded.maxSNR == 0)) {\n\t\t\t\tdecoded.maxSNR = new_snr;\n\t\t\t}\n\t\t\tswitch (server_type) {\n\t\t\t\t//TTN\n\t\t\t\tcase 1:\n\t\t\t\t\tgw_lat[idx] = rawPayload.uplink_message.rx_metadata[idx].location.latitude;\n\t\t\t\t\tgw_long[idx] = rawPayload.uplink_message.rx_metadata[idx].location.longitude;\n\t\t\t\t\tbreak;\n\t\t\t\t// Helium\n\t\t\t\tcase 2:\n\t\t\t\t\tgw_lat[idx] = rawPayload.hotspots[idx].lat;\n\t\t\t\t\tgw_long[idx] = rawPayload.hotspots[idx].long;\n\t\t\t\t\tbreak;\n\t\t\t\t// Chirpstack\n\t\t\t\tcase 3:\n\t\t\t\t\tgw_lat[idx] = rawPayload.rxInfo[idx].location.latitude;\n\t\t\t\t\tgw_long[idx] = rawPayload.rxInfo[idx].location.longitude;\n\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\t//LORIOT\n\t\t\t\tcase 4:\n\t\t\t\t\tgw_lat[idx] = rawPayload.gws[0].lat;\n\t\t\t\t\tgw_long[idx] = rawPayload.gws[0].lon;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tconsole.log(\"Unknown LNS\");\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tconsole.log(\"IDX \" + idx + \" lat \" + gw_lat[idx] + \" long \" + gw_long[idx]);\n\n\t\t\t// Calculate distance\n\t\t\tvar new_distance = distance(gw_lat[idx], gw_long[idx], decoded.latitude, decoded.longitude);\n\t\t\tif ((new_distance * 1000 < decoded.minDistance) || (decoded.minDistance == 0)) {\n\t\t\t\tdecoded.minDistance = new_distance * 1000;\n\t\t\t}\n\t\t\tif ((new_distance * 1000 > decoded.maxDistance) || (decoded.maxDistance == 0)) {\n\t\t\t\tdecoded.maxDistance = new_distance * 1000;\n\t\t\t}\n\t\t}\n\n\t\tvar hotspot_name = \"\"\n\t\tfor (idx = 0; idx < decoded.num_gw; idx++) {\n\t\t\tvar index = idx + 1;\n\t\t\tif (index < 9) {\n\t\t\t\thotspot_name = \"hotspot_0\" + index.toString();\n\t\t\t} else {\n\t\t\t\thotspot_name = \"hotspot_\" + index.toString();\n\t\t\t}\n\t\t\tconsole.log(hotspot_name);\n\t\t\tdecoded[hotspot_name] = \"(\" + gw_lat[idx] + \",\" + gw_long[idx] + \")\";\n\t\t}\n\n\t\tdecoded.maxMod = 1 + parseInt((Math.round(decoded.maxDistance / 250.0)), 10);\n\t\tdecoded.minMod = 1 + parseInt((Math.round(decoded.minDistance / 250.0)), 10);\n\t\t\n\t\treturn decoded;\n\t}\n\treturn null;\n\n}\n```\n\n</details>\n\n> **Image:** Datacake Payload Decoder Field\n\n2. After saving the payload decoder it is time to set the downlink payload encoder. Navigate to **Downlinks** and copy-paste the provided encoder in the field. Set the port to **2** and use the **IS_CHIRPSTACK** field to trigger the downlink.\n\n<details>\n<summary> Click to view the code</summary>\n\n```js\nfunction Encoder(measurements, port) {\n    var buf = [];\n    buf[0] = 1;\n    buf[1] = measurements.MINRSSI.value + 200;\n    buf[2] = measurements.MAXRSSI.value + 200;\n    // var temp = parseInt(measurements.MINMOD.value,10);\n    if (measurements.MINMOD.value == 0) {\n        measurements.MINMOD.value = 1;\n    }\n    console.log(measurements.MINMOD.value);\n    buf[3] = measurements.MINMOD.value;\n    if (measurements.MAXMOD.value == 0) {\n        measurements.MAXMOD.value = 1;\n    }\n    buf[4] = measurements.MAXMOD.value;\n    buf[5] = measurements.NUM_GW.value;\n    return buf;\n}\n```\n\n</details>\n\n> **Image:** Downlink Configuration\n\n3. You should now be able to see the data from the downlink on your Field Tester's screen.\n\n#### RAK10701-P Field Tester Pro Guide for Chirpstack and NodeRED\n\n##### How Does It Work?\n\nThe Field Tester performs two steps:\n\n- In the first step, it sends data packets over LoRaWAN, which are then received by one or multiple gateways. These packets are forwarded by the LoRaWAN network server to a backend server, including information about signal strength and the number of gateways that received the packet.\n\n> **Image:** Step 1 - Field Tester Sending Uplink Payload\n\n- In the second step, the backend server calculates the minimum and maximum distances from the Field Tester Pro to the gateways, along with the minimum and maximum RSSI levels, and sends information back to the Field Tester Pro as a LoRaWAN downlink.\n\n> **Image:** Step 2 - Backend Server Sending Useful Information as Downlink\n\nTo use Chirpstack and NodeRED for RAK10701-P, you need a working Chirpstack LoRaWAN network server. This can be on a dedicated machine, a Raspberry Pi, or a cloud VPS. You also need NodeRED installed and connected to the Chirpstack MQTT broker.\n\n1. To start with Chirpstack, you must create a device profile for your RAK10701-P Field Tester Pro device. You must select `LoRaWAN MAC version 1.0.3` which is the LoRaWAN specification version that the RAK10701 Field Tester supports.\n\n> **Image:** Creating Device Profile in Chirpstack\n\n2. You must enable `Device supports OTAA` as the network join method as well.\n\n> **Image:** Enable support for OTAA\n\n3. Once done with the device profile, you can now create an application and add the RAK10701 device. And then attached the `Device-profile` you created. \n\n> **Image:** Create application in Chirpstack\n\n\n> **TIP:** NOTE  \nTake note of the DEVEUI and APPKEY in this section. These parameters must match the ones in our RAK10701 Field Tester.\n\n\n> **Image:** Create device in Chirpstack.\n\n> **Image:** Device APPKEY\n\n4. Make sure your Gateway is registered in Chirpstack with the correct Network Server profile.\n\n> **Image:** Gateways registered in Chripstack\n\n5. After setting up the network server, devices, and gateway, install the NodeRED. This is required to run the backend server, which is in this case a NodeRED flow.\n\n\n> **TIP:** NOTE        \n  Check the [NodeRED documentation](https://nodered.org/#get-started) about installation options.\n\n\n  - Once the NodeRED is installed, start it and select a flow to add the required nodes.\n\n6. Install the Field Tester Service node     \n\n  a. Before starting to set up the flow, the Field Tester Service node needs to be added to the NodeRED palette.    \n  Use the top-right icon in NodeRED and select **Manage Palette** from the new menu:    \n\n> **Image:** Manage Palette\n\n  b. In the new window, select the **Install** tab and type ***`rakwireless/field-tester-server`*** in the search box. The node will show up in the search result. Install the node by clicking the **Install** button.    \n\n> **Image:** Install Palette\n\n  c. Once the node is installed, we can start to setup the NodeRED flow.\n\n7. Setup the input Node    \n  \n  a. For Chirpstack V4 we need first an input node that can receive information from Chirpstacks MQTT broker. Pull the _**`mqtt in`**_ node from the left side bar to your flow:\n\n> **Image:** Prepare input node\n\n  b. Then set up the MQTT connection, double click the ***`mqtt in`*** node to open the setup window. Then click on the Server ***Edit*** icon.    \n\n> **Image:** Setup input node\n\n  c. In the setup window, add your server connection in the **Connection** tab:\n\n> **Image:** Add MQTT Broker\n\n  d. Server can be an URL or an IP address where your Chirpstack MQTT broker can be reached. This and the port number depends on your Chirpstack installation and MQTT settings.\n\n  e. Next go to the **Security** tab and enter the required username and password. Again, this depends on your MQTT settings:    \n\n> **Image:** Add credentials\n\n  f. To receive the data from the MQTT broker, we need to set up the topic we want to listen to. The first step is to get the ID of the application in Chirpstack:    \n\n> **Image:** Get Chirpstack application ID\n\n  g. Copy the application ID, to use it in the MQTT input node to set up the topic.\n\n  h. Open the MQTT input settings in the NodeRED flow by double clicking on the icon in the flow.\n\n  Then edit the topic field. The syntax is:    \n  `application` = fixed        \n  `application ID` = from the Chirpstack LNS application        \n  `#` = get all messages        \n\n  In this example the topic is:\n  ```\n  application/57184973-d64d-4656-be1d-84d4427bcb1a/#\n  ```\n\n  i. Select as **Output** the option **`a parsed JSON object`**.    \n\n> **Image:** Setup MQTT topic\n\n8. Set up the output node\n\n  a. We need an output node as well to be able to send downlinks to the Chirpstack MQTT Broker.    \n\n  b. Pull the _**`mqtt out`**_ node from the left side bar to your flow:\n\n> **Image:** Prepare output node\n\n  c. The only setup required is to select the same server that is used in the ***`mqtt in`*** node.\n\n9. Setup the Field Tester Backend Node\n\n  a. Now we can add and setup the Field Tester Server node.\n\n  b. Pull the ***`field tester service`*** node from the left side bar to your flow:\n\n> **Image:** Add Field Tester Service node\n\n  c. Double click on the new node to setup the parser:\n\n> **Image:** Set up the parser\n\n  For this example, the required parser is **Chirpstack v3 and v4**.\n\n\n> **TIP:** NOTE        \nThe Field Tester Service node can be used with other LoRaWAN servers as well. Depending on the server and the options to receive uplinks and create downlinks, additional nodes might be required to convert this data into **Raw data** before sending it to the Field Tester Service.    \nHowever, guides on how to use it with other LNS are not available at this time.\n\n\n10. Connect the nodes\n\n  - The last step is to connect the nodes:\n\n> **Image:** Connect the node\n\n  \n> **TIP:** NOTE\n  - For debugging, it will be helpful to add a debug output node to the flow. This helps to check whether the output of the parser is correct:\n\n> **Image:** Device\n\n\n  - Select **complete msg object** as output.\n\n  The result of parser can then be checked on the right side in the debug window:\n\n> **Image:** Device\n\n  That's all, a simple implementation of a backend server for the RAK10701 Field Tester with NodeRED.    \n\n  On the other hand, the uplink packets from the Field Tester can be sent in parallel to Datacake for a visualization of the locations, but in this case, there is no need to set up the downlink procedure in Datacake.\n\n\n> **TIP:** NOTE\n  _**All credits for the Field Tester Service node go to Xose from RAKwireless.**_\n\n\n### Configuration of RAK10701-P Using WisToolBox\n\nThe Field Mapper should have the correct credentials to connect to the Helium Console. This can be done using WisToolBox and also with the help of the touchscreen LCD user interface.\n\n1. Connect the RAK10701-P to the PC via USB Type-C cable and open the WisToolBox application. You can find more info on how to install and use the [WisToolbox from its documentation](https://docs.rakwireless.com/product-categories/software-tools/wistoolbox/overview/).\n\n2. Click the **CONNECT DEVICE** button to launch WisToolBox Dashboard.\n\n> **Image:** WisToolBox Desktop splash screen\n\n3. Review the **Connection settings** parameters on the dashboard, then click on the **CONNECT** button.\n\n> **Image:** WisToolBox Desktop connection settings\n\n4. On the WisToolBox Dashboard screen, select the RAK4630 module. This is the module inside the RAK10701-P Field Tester device.\n\n> **Image:** Detected module by WisToolBox\n\n5. You can now update the APPEUI, DEVEUI, and APPKEY. It must be the same as the parameters you have in the [Setting up of Network Server](https://docs.rakwireless.com/product-categories/wisgate/rak10701-p/quickstart/#lorawan-network-servers-guide-for-rak10701-p-field-tester-pro). Then you can click **APPLY COMMANDS**.\n\n> **Image:** Changing device parameters\n\n\n> **TIP:** NOTE\nThese are the only parameters that you need to change via WisToolBox. Other configurations like frequency plan, the interval of uplinks, TX power, and data rate can be done on the touchscreen of RAK10701.\n\nFor the frequency plan change, the device must be restarted to activate this newly configured frequency band. There will be a notification on the UI touchscreen LCD. If you use WisToolBox to configure the band, you have to restart the device manually, and there will be no notification from the UI of the LCD.\n\n\n6. You will see the summary of commands that were applied successfully. If the update is unsuccessful, just resend the needed changes. After the successful update, click the **CLOSE** button to return to Dashboard.\n\n> **Image:** Successful update of parameters\n\n7. You can now remove the USB Type-C cable and proceed to the screen of RAK10701. You can click the settings icon and then update the frequency plan, the interval of uplinks, TX power, and data rate as needed. You can use the arrows for navigation and click `OK` to save changes.\n\n> **Image:** RAK10701-P settings button\n\n> **Image:** Configurable parameters\n\n### Miscellaneous\n\nThis part of the guide shows the Field Tester interface and how to update the firmware.\n\n- [User Interface](https://docs.rakwireless.com/product-categories/wisgate/rak10701-p/quickstart/#field-tester-display-interface)\n- [Firmware Update](https://docs.rakwireless.com/product-categories/wisgate/rak10701-p/quickstart/#upgrading-the-firmware)\n\n#### Field Tester Display Interface\n\nThis section discusses the interfaces on the device's LCD and its pages.\n\n##### Display Status and Indicator\n\nThe RAK10701-P WisNode Field Tester has status indicators that show the current state of the device.\n\n> **Image:** Device status and indicator\n\n> **Image:** Different device status\n\n**Status:**\n\n- **IDLE**: RAK10701-P Field Tester Pro state is in between the previous uplink and the next uplink. The duration of IDLE depends on the interval configured on the device.\n- **JOINING**: RAK10701-P Field Tester Pro is trying to join the network. This status is triggered when a Join request is sent.\n- **JOINED**: RAK10701-P Field Tester Pro successfully received the Join accept the packet. This status will be displayed until refreshed when new data is sent.\n- **FAILED**: RAK10701-P Field Tester Pro failed to join the network. Triggered by receive timeout. There might be no available gateway reachable by the Field Tester.\n- **SENDING**: RAK10701-P Field Tester Pro's data such as GPS is being uploaded via an uplink. It will be displayed until the reception is completed or timed out.\n\n##### Settings\n\nThe field tester has configurable parameters: Band, TX power, TX interval, backlight intensity, and DR. You can navigate the settings using the arrow widgets plus the back and ok buttons.\nThe OTAA parameters APPEUI, DEVEUI, and APPKEY are also displayed but can't be changed on the touchscreen. WisToolBox or another Serial Port terminal tool is needed to send the AT commands to update the EUIs and key.\n\n> **Image:** Settings button\n\n> **Image:** Settings page\n\n##### Data Plots\n\nThere are four different data plots on the field tester: **number of gateways**, **RSSI**, **SNR**, and **approximate distance**. These graphs are accessible by touching the respective icons assigned to the parameter.\n\n> **Image:** Accessing different data plots\n\n> **Image:** Distance plot\n\n> **Image:** RSSI plot\n\n> **Image:** SNR plot\n\n##### GPS Data\n\nThe main page shows the last GPS data captured by the device.\n\n> **Image:** GPS display\n\n> **Image:** GPS data\n\n#### Packet Frame Format\n\nThe Uplink packet format send on Fport 1:\n| Byte  | Usage                                                  |\n| ----- | ------------------------------------------------------ |\n| 0 - 5 | GSP position see here for details. Decoding see below  |\n| 6 - 7 | Altitude in meters + 1000¬†m ( 1100 = 100¬†m ) |\n| 8     | HDOP * 10 (11 = 1.1)                                   |\n| 9     | Sats in view                                           |\n\nWhen the GPS position is invalid of GPS is disable, the frame is fill with 0's.\n\nThe downlink response format send on Fport 2:\n| Byte | Usage                               |\n| ---- | ----------------------------------- |\n| 0    | Sequence ID % 255                   |\n| 1    | Min Rssi + 200 (160 = -40¬†dBm) |\n| 2    | Max Rssi + 200 (160 = -40¬†dBm) |\n| 3    | Min Distance step 250¬†m        |\n| 4    | Max Distance step 250¬†m        |\n| 5    | Seen hotspot                        |\n\nThe distance is calculated from the GPS position and the gateways position returned by LoRaWAN server meta-data. Under 250¬†m value is 250¬†m, over 32¬†km value is 32¬†km. 0 is considered as an invalid response.\n\nThe following integration and payload transformation allows to decode the gps position and report is to mapper.\n\nDiscovery uplink format send on Fport 3 (no ack):\n| Byte  | Usage                                                                                              |\n| ----- | -------------------------------------------------------------------------------------------------- |\n| 0 - 5 | [GPS position](https://www.disk91.com/2015/technology/sigfox/telecom-design-sdk-decode-gps-frame/) |\n\nDiscovery is sending 10 messages SF10 every 40 seconds. All the other information comes from the metadata provided by the network server.\n\n#### Upgrading the Firmware\n\nIt is recommended to update to the latest version of the firmware. To do this, download the latest [RAK10701-P WisNode Field Tester firmware](https://docs.rakwireless.com/product-categories/wisgate/rak10701-p/datasheet/#software) and use the WisToolBox to update the custom firmware.\n\n1. Drag the downloaded firmware to the WisToolBox custom firmware section.\n\n> **Image:** WisToolBox firmware\n\n2. After the firmware file is uploaded to the application, you can now select **UPGRADE DEVICE**.\n\n> **Image:** Upload the latest firmware\n\n> **Image:** Confirm upgrading of firmware\n\n3. If all proceed with no error, you should see `Firmware update successful` notification, and the RAK10701-P will restart automatically.\n\n> **Image:** Ongoing upgrading of firmware\n\n> **Image:** Successful upload of latest firmware\n\n","keywords":[],"source_file":"wisgate\\rak10701-p\\quickstart.md","token_count":0}
