{"id": "c1a06d4060a6f4b092f037deb77c4e16", "product_family": "wisblock", "product_id": "kit4-industrial", "category": "Concept", "title": "WisBlock IoT Education Kit - Smart Industry Quick Start Guide > WisBlock IoT Education Kit - Smart Industry Quick Start Guide > Prerequisite > What Do You Need? > Overview of WisBlock IoT Education Kit - Smart Industry Components", "content": "The **WisBlock IoT Education Kit - Smart Industry** comes with **RAK19007** and **RAK19001** **WisBlock Base boards**, two **RAK4631** **WisBlock Core modules**, and set of sensor modules to explore with. Before going through each and every step on using the **WisBlock IoT Education Kit - Smart Industry**, make sure to prepare the necessary items listed below:", "keywords": ["WisBlock", "IoT Education Kit", "Smart Industry", "RAK19007", "RAK19001", "RAK4631", "sensor modules"], "source_file": "quickstart.md", "token_count": 70, "parent_content": "The **WisBlock IoT Education Kit - Smart Industry** comes with **RAK19007** and **RAK19001** **WisBlock Base boards**, two **RAK4631** **WisBlock Core modules**, and set of sensor modules to explore with. Before going through each and every step on using the **WisBlock IoT Education Kit - Smart Industry**, make sure to prepare the necessary items listed below:"}
{"id": "1360f9dfc16295395a0e879d7a58a806", "product_family": "wisblock", "product_id": "kit4-industrial", "category": "Reference", "title": "WisBlock IoT Education Kit - Smart Industry Quick Start Guide > WisBlock IoT Education Kit - Smart Industry Quick Start Guide > Prerequisite > What Do You Need? > Hardware > Kit4-Industrial Components List [TABLE]", "content": "- [RAK4631 WisBlock Core](https://store.rakwireless.com/products/nordic-nrf52840-ble-core-module-for-lorawan-with-lora-sx1262-rak4631-rak4631-c?variant=42576992436422)\n- [RAK19007 WisBlock Base Board](https://store.rakwireless.com/products/rak19007-wisblock-base-board-2nd-gen)\n- [RAK19001 WisBlock Base Board](https://store.rakwireless.com/products/rak19001-wisblock-dual-io-base-board)\n- [RAK16002 Coulomb Sensor](https://store.rakwireless.com/products/rak16002-coulomb-sensor)", "keywords": ["kit4-industrial", "components", "list", "reference"], "source_file": "quickstart.md", "token_count": 150, "parent_content": "- [RAK4631 WisBlock Core](https://store.rakwireless.com/products/nordic-nrf52840-ble-core-module-for-lorawan-with-lora-sx1262-rak4631-rak4631-c?variant=42576992436422)\n- [RAK19007 WisBlock Base Board](https://store.rakwireless.com/products/rak19007-wisblock-base-board-2nd-gen)\n- [RAK19001 WisBlock Base Board](https://store.rakwireless.com/products/rak19001-wisblock-dual-io-base-board)\n- [RAK16002 Coulomb Sensor](https://store.rakwireless.com/products/rak16002-coulomb-sensor)\n- [RAK12014 IR ToF Sensor](https://store.rakwireless.com/products/rak12014-wisblock-tof-sensor)\n- [RAK12029 Inductive Sensor](https://store.rakwireless.com/products/rak12029-inductive-proximity-sensor)\n- [RAK13001 Relay Module](https://store.rakwireless.com/products/relay-io-rak13001)\n- USB C Cable\n- [RAK19005 Sensor Extension Cable (optional)](https://store.rakwireless.com/products/fpc-extension-cable-for-slot-a-to-d-rak19005)\n- [RAK19008 IO Extension Cable (optional)](https://store.rakwireless.com/products/wisblock-io-extension-cable-rak19008)\n- [Li-Ion/LiPo battery](https://store.rakwireless.com/collections/wisblock-accessory/products/battery-connector-cable?utm_source=BatteryConnector&utm_medium=Document&utm_campaign=BuyFromStore)\n- [Solar charger (optional)](https://store.rakwireless.com/collections/wisblock-accessory/products/solar-panel-connector-cable?utm_source=SolarPanelConnector&utm_medium=Document&utm_campaign=BuyFromStore)"}
{"id": "cb7f7622e29bba8e9417ab5d34296c5d", "product_family": "wisblock", "product_id": "kit4-industrial", "category": "Reference", "title": "WisBlock IoT Education Kit - Smart Industry Quick Start Guide > WisBlock IoT Education Kit - Smart Industry Quick Start Guide > Prerequisite > What Do You Need? > Hardware > Kit4-Industrial Components List [TABLE]", "content": "- [RAK16002 Coulomb Sensor](https://store.rakwireless.com/products/rak16002-coulomb-sensor)\n- [RAK12014 IR ToF Sensor](https://store.rakwireless.com/products/rak12014-wisblock-tof-sensor)\n- [RAK12029 Inductive Sensor](https://store.rakwireless.com/products/rak12029-inductive-proximity-sensor)\n- [RAK13001 Relay Module](https://store.rakwireless.com/products/relay-io-rak13001)\n- USB C Cable", "keywords": ["kit4-industrial", "components", "list", "reference"], "source_file": "quickstart.md", "token_count": 150, "parent_content": "- [RAK4631 WisBlock Core](https://store.rakwireless.com/products/nordic-nrf52840-ble-core-module-for-lorawan-with-lora-sx1262-rak4631-rak4631-c?variant=42576992436422)\n- [RAK19007 WisBlock Base Board](https://store.rakwireless.com/products/rak19007-wisblock-base-board-2nd-gen)\n- [RAK19001 WisBlock Base Board](https://store.rakwireless.com/products/rak19001-wisblock-dual-io-base-board)\n- [RAK16002 Coulomb Sensor](https://store.rakwireless.com/products/rak16002-coulomb-sensor)\n- [RAK12014 IR ToF Sensor](https://store.rakwireless.com/products/rak12014-wisblock-tof-sensor)\n- [RAK12029 Inductive Sensor](https://store.rakwireless.com/products/rak12029-inductive-proximity-sensor)\n- [RAK13001 Relay Module](https://store.rakwireless.com/products/relay-io-rak13001)\n- USB C Cable\n- [RAK19005 Sensor Extension Cable (optional)](https://store.rakwireless.com/products/fpc-extension-cable-for-slot-a-to-d-rak19005)\n- [RAK19008 IO Extension Cable (optional)](https://store.rakwireless.com/products/wisblock-io-extension-cable-rak19008)\n- [Li-Ion/LiPo battery](https://store.rakwireless.com/collections/wisblock-accessory/products/battery-connector-cable?utm_source=BatteryConnector&utm_medium=Document&utm_campaign=BuyFromStore)\n- [Solar charger (optional)](https://store.rakwireless.com/collections/wisblock-accessory/products/solar-panel-connector-cable?utm_source=SolarPanelConnector&utm_medium=Document&utm_campaign=BuyFromStore)"}
{"id": "5f996531c54a5015342086b8292bc7ea", "product_family": "wisblock", "product_id": "kit4-industrial", "category": "Reference", "title": "WisBlock IoT Education Kit - Smart Industry Quick Start Guide > WisBlock IoT Education Kit - Smart Industry Quick Start Guide > Prerequisite > What Do You Need? > Hardware > Kit4-Industrial Components List [TABLE]", "content": "- [RAK13001 Relay Module](https://store.rakwireless.com/products/relay-io-rak13001)\n- USB C Cable\n- [RAK19005 Sensor Extension Cable (optional)](https://store.rakwireless.com/products/fpc-extension-cable-for-slot-a-to-d-rak19005)\n- [RAK19008 IO Extension Cable (optional)](https://store.rakwireless.com/products/wisblock-io-extension-cable-rak19008)", "keywords": ["kit4-industrial", "components", "list", "reference"], "source_file": "quickstart.md", "token_count": 150, "parent_content": "- [RAK4631 WisBlock Core](https://store.rakwireless.com/products/nordic-nrf52840-ble-core-module-for-lorawan-with-lora-sx1262-rak4631-rak4631-c?variant=42576992436422)\n- [RAK19007 WisBlock Base Board](https://store.rakwireless.com/products/rak19007-wisblock-base-board-2nd-gen)\n- [RAK19001 WisBlock Base Board](https://store.rakwireless.com/products/rak19001-wisblock-dual-io-base-board)\n- [RAK16002 Coulomb Sensor](https://store.rakwireless.com/products/rak16002-coulomb-sensor)\n- [RAK12014 IR ToF Sensor](https://store.rakwireless.com/products/rak12014-wisblock-tof-sensor)\n- [RAK12029 Inductive Sensor](https://store.rakwireless.com/products/rak12029-inductive-proximity-sensor)\n- [RAK13001 Relay Module](https://store.rakwireless.com/products/relay-io-rak13001)\n- USB C Cable\n- [RAK19005 Sensor Extension Cable (optional)](https://store.rakwireless.com/products/fpc-extension-cable-for-slot-a-to-d-rak19005)\n- [RAK19008 IO Extension Cable (optional)](https://store.rakwireless.com/products/wisblock-io-extension-cable-rak19008)\n- [Li-Ion/LiPo battery](https://store.rakwireless.com/collections/wisblock-accessory/products/battery-connector-cable?utm_source=BatteryConnector&utm_medium=Document&utm_campaign=BuyFromStore)\n- [Solar charger (optional)](https://store.rakwireless.com/collections/wisblock-accessory/products/solar-panel-connector-cable?utm_source=SolarPanelConnector&utm_medium=Document&utm_campaign=BuyFromStore)"}
{"id": "ff101f17a49105b60d1069ff5218e124", "product_family": "wisblock", "product_id": "kit4-industrial", "category": "Reference", "title": "WisBlock IoT Education Kit - Smart Industry Quick Start Guide > WisBlock IoT Education Kit - Smart Industry Quick Start Guide > Prerequisite > What Do You Need? > Hardware > Kit4-Industrial Components List [TABLE]", "content": "- [Li-Ion/LiPo battery](https://store.rakwireless.com/collections/wisblock-accessory/products/battery-connector-cable?utm_source=BatteryConnector&utm_medium=Document&utm_campaign=BuyFromStore)\n- [Solar charger (optional)](https://store.rakwireless.com/collections/wisblock-accessory/products/solar-panel-connector-cable?utm_source=SolarPanelConnector&utm_medium=Document&utm_campaign=BuyFromStore)", "keywords": ["kit4-industrial", "components", "list", "reference"], "source_file": "quickstart.md", "token_count": 150, "parent_content": "- [RAK4631 WisBlock Core](https://store.rakwireless.com/products/nordic-nrf52840-ble-core-module-for-lorawan-with-lora-sx1262-rak4631-rak4631-c?variant=42576992436422)\n- [RAK19007 WisBlock Base Board](https://store.rakwireless.com/products/rak19007-wisblock-base-board-2nd-gen)\n- [RAK19001 WisBlock Base Board](https://store.rakwireless.com/products/rak19001-wisblock-dual-io-base-board)\n- [RAK16002 Coulomb Sensor](https://store.rakwireless.com/products/rak16002-coulomb-sensor)\n- [RAK12014 IR ToF Sensor](https://store.rakwireless.com/products/rak12014-wisblock-tof-sensor)\n- [RAK12029 Inductive Sensor](https://store.rakwireless.com/products/rak12029-inductive-proximity-sensor)\n- [RAK13001 Relay Module](https://store.rakwireless.com/products/relay-io-rak13001)\n- USB C Cable\n- [RAK19005 Sensor Extension Cable (optional)](https://store.rakwireless.com/products/fpc-extension-cable-for-slot-a-to-d-rak19005)\n- [RAK19008 IO Extension Cable (optional)](https://store.rakwireless.com/products/wisblock-io-extension-cable-rak19008)\n- [Li-Ion/LiPo battery](https://store.rakwireless.com/collections/wisblock-accessory/products/battery-connector-cable?utm_source=BatteryConnector&utm_medium=Document&utm_campaign=BuyFromStore)\n- [Solar charger (optional)](https://store.rakwireless.com/collections/wisblock-accessory/products/solar-panel-connector-cable?utm_source=SolarPanelConnector&utm_medium=Document&utm_campaign=BuyFromStore)"}
{"id": "dcd0a80dac7071597efb5ef4b5d481e8", "product_family": "wisblock", "product_id": "kit4-industrial", "category": "How-To", "title": "WisBlock IoT Education Kit - Smart Industry Quick Start Guide > WisBlock IoT Education Kit - Smart Industry Quick Start Guide > Prerequisite > What Do You Need? > Software > Arduino > Install ArduinoIDE and RAKwireless Arduino BSP", "content": "- Download and install [ArduinoIDE](https://www.arduino.cc/en/Main/Software).\n- To add the RAKwireless Core boards on your Arduino Boards Manager, install the [RAKwireless Arduino BSP](https://github.com/RAKWireless/RAKwireless-Arduino-BSP-Index).", "keywords": ["ArduinoIDE", "RAKwireless Arduino BSP", "installation"], "source_file": "quickstart.md", "token_count": 30, "parent_content": "- Download and install [ArduinoIDE](https://www.arduino.cc/en/Main/Software).\n- To add the RAKwireless Core boards on your Arduino Boards Manager, install the [RAKwireless Arduino BSP](https://github.com/RAKWireless/RAKwireless-Arduino-BSP-Index)."}
{"id": "28d94a420029d774300b6f9a6b65b508", "product_family": "wisblock", "product_id": "kit4-industrial", "category": "Concept", "title": "WisBlock IoT Education Kit - Smart Industry Quick Start Guide > WisBlock IoT Education Kit - Smart Industry Quick Start Guide > Product Configuration > Hardware Setup & Sample Applications > WisBlock IoT Education Kit - Smart Industry Overview", "content": "**WisBlock IoT Education Kit - Smart Industry** comprises of position and distance sensors, UI devices and actuators that can be used with **RAK19007** and **RAK19001** **WisBlock Base boards** which you can choose from. They are used in industrial environments that can be useful to different IoT applications. You can choose from these devices for your desired applications.  \n- **Battery Monitoring Application - RAK4631 + RAK16002 Board**  \n> **Image:** RAK4631 + RAK16002 Board", "keywords": ["WisBlock", "IoT Education Kit", "Smart Industry", "RAK19007", "RAK19001", "RAK4631", "RAK16002", "RAK12014", "RAK12029", "RAK13001"], "source_file": "quickstart.md", "token_count": 150, "parent_content": "**WisBlock IoT Education Kit - Smart Industry** comprises of position and distance sensors, UI devices and actuators that can be used with **RAK19007** and **RAK19001** **WisBlock Base boards** which you can choose from. They are used in industrial environments that can be useful to different IoT applications. You can choose from these devices for your desired applications.  \n- **Battery Monitoring Application - RAK4631 + RAK16002 Board**  \n> **Image:** RAK4631 + RAK16002 Board  \n- **Material Classifier Application - RAK4631 + RAK12014 + RAK12029 + RAK13001 Board**  \n> **Image:** RAK4631 + RAK12014 + RAK12029 + RAK13001 Board  \n> **Image:** RAK12014 connected at RAK19001 board  \n> **Image:** RAK4631 + RAK12014 + RAK12029 + RAK13001 Board"}
{"id": "ae22fa36cc49c8c4d7dff67ef2ac693f", "product_family": "wisblock", "product_id": "kit4-industrial", "category": "Concept", "title": "WisBlock IoT Education Kit - Smart Industry Quick Start Guide > WisBlock IoT Education Kit - Smart Industry Quick Start Guide > Product Configuration > Hardware Setup & Sample Applications > WisBlock IoT Education Kit - Smart Industry Overview", "content": "> **Image:** RAK4631 + RAK16002 Board  \n- **Material Classifier Application - RAK4631 + RAK12014 + RAK12029 + RAK13001 Board**  \n> **Image:** RAK4631 + RAK12014 + RAK12029 + RAK13001 Board  \n> **Image:** RAK12014 connected at RAK19001 board  \n> **Image:** RAK4631 + RAK12014 + RAK12029 + RAK13001 Board", "keywords": ["WisBlock", "IoT Education Kit", "Smart Industry", "RAK19007", "RAK19001", "RAK4631", "RAK16002", "RAK12014", "RAK12029", "RAK13001"], "source_file": "quickstart.md", "token_count": 150, "parent_content": "**WisBlock IoT Education Kit - Smart Industry** comprises of position and distance sensors, UI devices and actuators that can be used with **RAK19007** and **RAK19001** **WisBlock Base boards** which you can choose from. They are used in industrial environments that can be useful to different IoT applications. You can choose from these devices for your desired applications.  \n- **Battery Monitoring Application - RAK4631 + RAK16002 Board**  \n> **Image:** RAK4631 + RAK16002 Board  \n- **Material Classifier Application - RAK4631 + RAK12014 + RAK12029 + RAK13001 Board**  \n> **Image:** RAK4631 + RAK12014 + RAK12029 + RAK13001 Board  \n> **Image:** RAK12014 connected at RAK19001 board  \n> **Image:** RAK4631 + RAK12014 + RAK12029 + RAK13001 Board"}
{"id": "cf574ee8c971fb9a64456a97b7f3aa80", "product_family": "wisblock", "product_id": "kit4-industrial", "category": "Reference", "title": "WisBlock IoT Education Kit - Smart Industry Quick Start Guide > WisBlock IoT Education Kit - Smart Industry Quick Start Guide > Product Configuration > Hardware Setup & Sample Applications > Assembly and Functionality Tests of WisBlock Smart Industry Modules > WisBlock Smart Industry Modules Reference", "content": "The following WisBlock Smart Industry modules listed below are used in this kit. To check for their asssemblies and functionalities, please refer to the links below for further information:  \n- [RAK16002 Coulomb Sensor](https://docs.rakwireless.com/product-categories/wisblock/rak16002/quickstart/#prerequisite)\n- [RAK12014 IR ToF Sensor](https://docs.rakwireless.com/product-categories/wisblock/rak12014/quickstart/)", "keywords": ["WisBlock", "Smart Industry", "Modules", "RAK16002", "RAK12014", "RAK12029", "RAK13001"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "The following WisBlock Smart Industry modules listed below are used in this kit. To check for their asssemblies and functionalities, please refer to the links below for further information:  \n- [RAK16002 Coulomb Sensor](https://docs.rakwireless.com/product-categories/wisblock/rak16002/quickstart/#prerequisite)\n- [RAK12014 IR ToF Sensor](https://docs.rakwireless.com/product-categories/wisblock/rak12014/quickstart/)\n- [RAK12029 Inductive Sensor](https://docs.rakwireless.com/product-categories/wisblock/rak12029/quickstart/)\n- [RAK13001 Relay Module](https://docs.rakwireless.com/product-categories/wisblock/rak13001/quickstart/)"}
{"id": "d09dd5027ce825a61a8243ff29084ec5", "product_family": "wisblock", "product_id": "kit4-industrial", "category": "Reference", "title": "WisBlock IoT Education Kit - Smart Industry Quick Start Guide > WisBlock IoT Education Kit - Smart Industry Quick Start Guide > Product Configuration > Hardware Setup & Sample Applications > Assembly and Functionality Tests of WisBlock Smart Industry Modules > WisBlock Smart Industry Modules Reference", "content": "- [RAK12029 Inductive Sensor](https://docs.rakwireless.com/product-categories/wisblock/rak12029/quickstart/)\n- [RAK13001 Relay Module](https://docs.rakwireless.com/product-categories/wisblock/rak13001/quickstart/)", "keywords": ["WisBlock", "Smart Industry", "Modules", "RAK16002", "RAK12014", "RAK12029", "RAK13001"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "The following WisBlock Smart Industry modules listed below are used in this kit. To check for their asssemblies and functionalities, please refer to the links below for further information:  \n- [RAK16002 Coulomb Sensor](https://docs.rakwireless.com/product-categories/wisblock/rak16002/quickstart/#prerequisite)\n- [RAK12014 IR ToF Sensor](https://docs.rakwireless.com/product-categories/wisblock/rak12014/quickstart/)\n- [RAK12029 Inductive Sensor](https://docs.rakwireless.com/product-categories/wisblock/rak12029/quickstart/)\n- [RAK13001 Relay Module](https://docs.rakwireless.com/product-categories/wisblock/rak13001/quickstart/)"}
{"id": "b84c2ca620a54b87bd6217efdea4de31", "product_family": "wisblock", "product_id": "kit4-industrial", "category": "Concept", "title": "WisBlock IoT Education Kit - Smart Industry Quick Start Guide > WisBlock IoT Education Kit - Smart Industry Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock Smart Industry Kit using TTN and Quibitro > LoRaWAN Applications Overview", "content": "- [Battery Monitoring LoRaWAN Application](#battery-monitoring-lorawan-application)\n- [Material Classifier LoRaWAN Application](#material-classifier-lorawan-application)", "keywords": ["LoRaWAN", "Battery Monitoring", "Material Classifier"], "source_file": "quickstart.md", "token_count": 20, "parent_content": "- [Battery Monitoring LoRaWAN Application](#battery-monitoring-lorawan-application)\n- [Material Classifier LoRaWAN Application](#material-classifier-lorawan-application)"}
{"id": "46b96235c4902364f04469f071658159", "product_family": "wisblock", "product_id": "kit4-industrial", "category": "Concept", "title": "WisBlock IoT Education Kit - Smart Industry Quick Start Guide > WisBlock IoT Education Kit - Smart Industry Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock Smart Industry Kit using TTN and Quibitro > Battery Monitoring LoRaWAN Application > Battery Monitoring LoRaWAN Application Overview", "content": "The **Battery Monitoring LoRaWAN Application** is used to monitor the state-of-charge (SoC) of the battery used in RAKwireless devices via **TTN** or **Qubitro**. It uses **RAK16002** coulomb sensor module which is based on **LTC2941IDCB**.  \n> **Image:** Battery Monitoring device", "keywords": ["Battery Monitoring", "LoRaWAN", "RAK16002", "LTC2941IDCB", "TTN", "Qubitro"], "source_file": "quickstart.md", "token_count": 50, "parent_content": "The **Battery Monitoring LoRaWAN Application** is used to monitor the state-of-charge (SoC) of the battery used in RAKwireless devices via **TTN** or **Qubitro**. It uses **RAK16002** coulomb sensor module which is based on **LTC2941IDCB**.  \n> **Image:** Battery Monitoring device"}
{"id": "a6f29d82539800c0cc7e3eef6d5a5a1b", "product_family": "wisblock", "product_id": "kit4-industrial", "category": "How-To", "title": "WisBlock IoT Education Kit - Smart Industry Quick Start Guide > WisBlock IoT Education Kit - Smart Industry Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock Smart Industry Kit using TTN and Quibitro > Battery Monitoring LoRaWAN Application > Battery Monitoring - TTN Registration Section and Device Registration > Steps for TTN Account Creation and Device Registration", "content": "1. If you already have an existing TTN account, you may proceed to the next steps. If you haven't created any TTN account, please refer to this [link](#ttn-account-creation) to create one.  \n2. Once done with the TTN account creation, you may now proceed with the device registration. Please refer to this [guide](#device-registration) for your reference. After creating the application and adding the device in TTN, you can proceed on the LoRaWAN Code uploading steps.", "keywords": ["TTN", "account creation", "device registration", "LoRaWAN"], "source_file": "quickstart.md", "token_count": 0, "parent_content": "1. If you already have an existing TTN account, you may proceed to the next steps. If you haven't created any TTN account, please refer to this [link](#ttn-account-creation) to create one.  \n2. Once done with the TTN account creation, you may now proceed with the device registration. Please refer to this [guide](#device-registration) for your reference. After creating the application and adding the device in TTN, you can proceed on the LoRaWAN Code uploading steps."}
{"id": "07a6f91ee44e5ed5ff05b9b7be003338", "product_family": "wisblock", "product_id": "kit4-industrial", "category": "How-To", "title": "WisBlock IoT Education Kit - Smart Industry Quick Start Guide > WisBlock IoT Education Kit - Smart Industry Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock Smart Industry Kit using TTN and Quibitro > Battery Monitoring LoRaWAN Application > LoRaWAN Code for Battery Monitoring > Battery Monitoring LoRaWAN Application Setup [CODE]", "content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **Battery Monitoring** device. Just copy the code below for **Battery Monitoring LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE", "keywords": ["Arduino IDE", "RAK4631", "Battery Monitoring", "LoRaWAN", "SX126x-Arduino"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **Battery Monitoring** device. Just copy the code below for **Battery Monitoring LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the code</summary>  \n```c\n\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h> //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n#include \"LTC2941.h\"               // Click here to get the library: http://librarymanager/All#GROVE-Coulomb_Counter\n#define BATTERY_CAPACITY2200     // unit:mAh.\n#define CURRENT_CAPACITY  42352    // Set the current battery level to 1800 mAh.\n#define Enable            WB_IO2   // Sensor Power Switch\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define  RAK4631_BOARD true\n#else\n#define  RAK4631_BOARD false\n#endif\n\nlong int coulomb, mAh, percent;\n\nbool doOTAA = true;   // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                     /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                   /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5             /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                      /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                      /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = {LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF};\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = {BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler\n};\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x64, 0xF6, 0xCB, 0x00, 0x35, 0x2D, 0x3B, 0x99, 0x6C, 0xFB, 0x36, 0xE4, 0xCE, 0x1A, 0x08, 0x91};\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = {0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23};\nuint8_t nodeAppsKey[16] = {0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C};\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                     /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];            //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = {m_lora_app_data_buffer, 0, 0, 0, 0}; //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup()\n{\n// Sensor Power Switch\npinMode(Enable, OUTPUT);\ndigitalWrite(Enable, HIGH);\n\npinMode(LED_GREEN, OUTPUT);  // Output LED\npinMode(LED_BLUE, OUTPUT);   // Output LED\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial)\n{\nif ((millis() - timeout) < 5000)\n{\ndelay(100);\n}\nelse\n{\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA)\n{\nSerial.println(\"Type: OTAA\");\n}\nelse\n{\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion)\n{\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA)\n{\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n}\nelse\n{\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0)\n{\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"========================\");\nSerial.println(\"RAK16002 LoRaWAN example\");\nSerial.println(\"========================\");\n\nWire.begin();\n\nltc2941.initialize();\nltc2941.setBatteryFullMAh(BATTERY_CAPACITY , false);\nltc2941.setAccumulatedCharge(CURRENT_CAPACITY); // Set the current battery level to 1800 mAh.\n\n}\n\nvoid loop()\n{\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\ndigitalWrite(LED_BLUE,HIGH);\ndigitalWrite(LED_GREEN, HIGH);\n\n// Measures Coulomb, Charge and Percentage\ncoulomb = ltc2941.getCoulombs();\nmAh = ltc2941.getmAh();\npercent = ltc2941.getPercent();\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\nSerial.print(coulomb);\nSerial.print(\"C   \");\nSerial.print(mAh);\nSerial.print(\"mAh   \");\nSerial.print(percent);\nSerial.println(\"%\");\ndelay(5000);\n\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void)\n{\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void)\n{\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data)\n{\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class)\n{\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void)\n{\nif (lmh_join_status_get() != LMH_SET)\n{\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\ndata = \" Coulomb: \" + String(coulomb) + \" C \" + \" Charge: \" + String(mAh) + \" mAh \" + \" Percentage: \" + String(percent) + \" % \";\nSerial.println(data);\n\nuint32_t coulomb_data = coulomb;\nuint32_t mAh_data = mAh;\nuint16_t percent_data = percent;\n\nm_lora_app_data.buffer[i++] = 0x01;\n\nm_lora_app_data.buffer[i++] = (uint8_t)((coulomb_data  & 0xFF000000) >> 24);\nm_lora_app_data.buffer[i++] = (uint8_t)((coulomb_data  & 0x00FF0000) >> 16);\nm_lora_app_data.buffer[i++] = (uint8_t)((coulomb_data  & 0x0000FF00) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(coulomb_data  & 0x000000FF);\n\nm_lora_app_data.buffer[i++] = (uint8_t)((mAh_data & 0xFF000000) >> 24);\nm_lora_app_data.buffer[i++] = (uint8_t)((mAh_data & 0x00FF0000) >> 16);\nm_lora_app_data.buffer[i++] = (uint8_t)((mAh_data & 0x0000FF00) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(mAh_data & 0x000000FF);\n\nm_lora_app_data.buffer[i++] = (uint8_t)((percent_data) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(percent_data);\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS)\n{\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n}\nelse\n{\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x64, 0xF6, 0xCB, 0x00, 0x35, 0x2D, 0x3B, 0x99, 0x6C, 0xFB, 0x36, 0xE4, 0xCE, 0x1A, 0x08, 0x91};\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "1541c1dd0c7be2680e954ea0bdd3015d", "product_family": "wisblock", "product_id": "kit4-industrial", "category": "How-To", "title": "WisBlock IoT Education Kit - Smart Industry Quick Start Guide > WisBlock IoT Education Kit - Smart Industry Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock Smart Industry Kit using TTN and Quibitro > Battery Monitoring LoRaWAN Application > LoRaWAN Code for Battery Monitoring > Battery Monitoring LoRaWAN Application Setup [CODE]", "content": "> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the code</summary>  \n```c", "keywords": ["Arduino IDE", "RAK4631", "Battery Monitoring", "LoRaWAN", "SX126x-Arduino"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **Battery Monitoring** device. Just copy the code below for **Battery Monitoring LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the code</summary>  \n```c\n\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h> //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n#include \"LTC2941.h\"               // Click here to get the library: http://librarymanager/All#GROVE-Coulomb_Counter\n#define BATTERY_CAPACITY2200     // unit:mAh.\n#define CURRENT_CAPACITY  42352    // Set the current battery level to 1800 mAh.\n#define Enable            WB_IO2   // Sensor Power Switch\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define  RAK4631_BOARD true\n#else\n#define  RAK4631_BOARD false\n#endif\n\nlong int coulomb, mAh, percent;\n\nbool doOTAA = true;   // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                     /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                   /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5             /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                      /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                      /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = {LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF};\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = {BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler\n};\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x64, 0xF6, 0xCB, 0x00, 0x35, 0x2D, 0x3B, 0x99, 0x6C, 0xFB, 0x36, 0xE4, 0xCE, 0x1A, 0x08, 0x91};\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = {0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23};\nuint8_t nodeAppsKey[16] = {0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C};\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                     /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];            //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = {m_lora_app_data_buffer, 0, 0, 0, 0}; //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup()\n{\n// Sensor Power Switch\npinMode(Enable, OUTPUT);\ndigitalWrite(Enable, HIGH);\n\npinMode(LED_GREEN, OUTPUT);  // Output LED\npinMode(LED_BLUE, OUTPUT);   // Output LED\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial)\n{\nif ((millis() - timeout) < 5000)\n{\ndelay(100);\n}\nelse\n{\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA)\n{\nSerial.println(\"Type: OTAA\");\n}\nelse\n{\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion)\n{\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA)\n{\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n}\nelse\n{\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0)\n{\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"========================\");\nSerial.println(\"RAK16002 LoRaWAN example\");\nSerial.println(\"========================\");\n\nWire.begin();\n\nltc2941.initialize();\nltc2941.setBatteryFullMAh(BATTERY_CAPACITY , false);\nltc2941.setAccumulatedCharge(CURRENT_CAPACITY); // Set the current battery level to 1800 mAh.\n\n}\n\nvoid loop()\n{\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\ndigitalWrite(LED_BLUE,HIGH);\ndigitalWrite(LED_GREEN, HIGH);\n\n// Measures Coulomb, Charge and Percentage\ncoulomb = ltc2941.getCoulombs();\nmAh = ltc2941.getmAh();\npercent = ltc2941.getPercent();\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\nSerial.print(coulomb);\nSerial.print(\"C   \");\nSerial.print(mAh);\nSerial.print(\"mAh   \");\nSerial.print(percent);\nSerial.println(\"%\");\ndelay(5000);\n\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void)\n{\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void)\n{\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data)\n{\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class)\n{\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void)\n{\nif (lmh_join_status_get() != LMH_SET)\n{\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\ndata = \" Coulomb: \" + String(coulomb) + \" C \" + \" Charge: \" + String(mAh) + \" mAh \" + \" Percentage: \" + String(percent) + \" % \";\nSerial.println(data);\n\nuint32_t coulomb_data = coulomb;\nuint32_t mAh_data = mAh;\nuint16_t percent_data = percent;\n\nm_lora_app_data.buffer[i++] = 0x01;\n\nm_lora_app_data.buffer[i++] = (uint8_t)((coulomb_data  & 0xFF000000) >> 24);\nm_lora_app_data.buffer[i++] = (uint8_t)((coulomb_data  & 0x00FF0000) >> 16);\nm_lora_app_data.buffer[i++] = (uint8_t)((coulomb_data  & 0x0000FF00) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(coulomb_data  & 0x000000FF);\n\nm_lora_app_data.buffer[i++] = (uint8_t)((mAh_data & 0xFF000000) >> 24);\nm_lora_app_data.buffer[i++] = (uint8_t)((mAh_data & 0x00FF0000) >> 16);\nm_lora_app_data.buffer[i++] = (uint8_t)((mAh_data & 0x0000FF00) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(mAh_data & 0x000000FF);\n\nm_lora_app_data.buffer[i++] = (uint8_t)((percent_data) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(percent_data);\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS)\n{\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n}\nelse\n{\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x64, 0xF6, 0xCB, 0x00, 0x35, 0x2D, 0x3B, 0x99, 0x6C, 0xFB, 0x36, 0xE4, 0xCE, 0x1A, 0x08, 0x91};\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "4899ad56f5c8b25788245f95a007a45f", "product_family": "wisblock", "product_id": "kit4-industrial", "category": "How-To", "title": "WisBlock IoT Education Kit - Smart Industry Quick Start Guide > WisBlock IoT Education Kit - Smart Industry Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock Smart Industry Kit using TTN and Quibitro > Battery Monitoring LoRaWAN Application > LoRaWAN Code for Battery Monitoring > Battery Monitoring LoRaWAN Application Setup [CODE]", "content": "#include <Arduino.h>\n#include <LoRaWan-RAK4630.h> //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n#include \"LTC2941.h\"               // Click here to get the library: http://librarymanager/All#GROVE-Coulomb_Counter\n#define BATTERY_CAPACITY2200     // unit:mAh.\n#define CURRENT_CAPACITY  42352    // Set the current battery level to 1800 mAh.\n#define Enable            WB_IO2   // Sensor Power Switch", "keywords": ["Arduino IDE", "RAK4631", "Battery Monitoring", "LoRaWAN", "SX126x-Arduino"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **Battery Monitoring** device. Just copy the code below for **Battery Monitoring LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the code</summary>  \n```c\n\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h> //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n#include \"LTC2941.h\"               // Click here to get the library: http://librarymanager/All#GROVE-Coulomb_Counter\n#define BATTERY_CAPACITY2200     // unit:mAh.\n#define CURRENT_CAPACITY  42352    // Set the current battery level to 1800 mAh.\n#define Enable            WB_IO2   // Sensor Power Switch\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define  RAK4631_BOARD true\n#else\n#define  RAK4631_BOARD false\n#endif\n\nlong int coulomb, mAh, percent;\n\nbool doOTAA = true;   // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                     /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                   /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5             /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                      /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                      /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = {LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF};\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = {BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler\n};\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x64, 0xF6, 0xCB, 0x00, 0x35, 0x2D, 0x3B, 0x99, 0x6C, 0xFB, 0x36, 0xE4, 0xCE, 0x1A, 0x08, 0x91};\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = {0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23};\nuint8_t nodeAppsKey[16] = {0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C};\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                     /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];            //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = {m_lora_app_data_buffer, 0, 0, 0, 0}; //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup()\n{\n// Sensor Power Switch\npinMode(Enable, OUTPUT);\ndigitalWrite(Enable, HIGH);\n\npinMode(LED_GREEN, OUTPUT);  // Output LED\npinMode(LED_BLUE, OUTPUT);   // Output LED\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial)\n{\nif ((millis() - timeout) < 5000)\n{\ndelay(100);\n}\nelse\n{\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA)\n{\nSerial.println(\"Type: OTAA\");\n}\nelse\n{\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion)\n{\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA)\n{\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n}\nelse\n{\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0)\n{\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"========================\");\nSerial.println(\"RAK16002 LoRaWAN example\");\nSerial.println(\"========================\");\n\nWire.begin();\n\nltc2941.initialize();\nltc2941.setBatteryFullMAh(BATTERY_CAPACITY , false);\nltc2941.setAccumulatedCharge(CURRENT_CAPACITY); // Set the current battery level to 1800 mAh.\n\n}\n\nvoid loop()\n{\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\ndigitalWrite(LED_BLUE,HIGH);\ndigitalWrite(LED_GREEN, HIGH);\n\n// Measures Coulomb, Charge and Percentage\ncoulomb = ltc2941.getCoulombs();\nmAh = ltc2941.getmAh();\npercent = ltc2941.getPercent();\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\nSerial.print(coulomb);\nSerial.print(\"C   \");\nSerial.print(mAh);\nSerial.print(\"mAh   \");\nSerial.print(percent);\nSerial.println(\"%\");\ndelay(5000);\n\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void)\n{\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void)\n{\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data)\n{\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class)\n{\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void)\n{\nif (lmh_join_status_get() != LMH_SET)\n{\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\ndata = \" Coulomb: \" + String(coulomb) + \" C \" + \" Charge: \" + String(mAh) + \" mAh \" + \" Percentage: \" + String(percent) + \" % \";\nSerial.println(data);\n\nuint32_t coulomb_data = coulomb;\nuint32_t mAh_data = mAh;\nuint16_t percent_data = percent;\n\nm_lora_app_data.buffer[i++] = 0x01;\n\nm_lora_app_data.buffer[i++] = (uint8_t)((coulomb_data  & 0xFF000000) >> 24);\nm_lora_app_data.buffer[i++] = (uint8_t)((coulomb_data  & 0x00FF0000) >> 16);\nm_lora_app_data.buffer[i++] = (uint8_t)((coulomb_data  & 0x0000FF00) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(coulomb_data  & 0x000000FF);\n\nm_lora_app_data.buffer[i++] = (uint8_t)((mAh_data & 0xFF000000) >> 24);\nm_lora_app_data.buffer[i++] = (uint8_t)((mAh_data & 0x00FF0000) >> 16);\nm_lora_app_data.buffer[i++] = (uint8_t)((mAh_data & 0x0000FF00) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(mAh_data & 0x000000FF);\n\nm_lora_app_data.buffer[i++] = (uint8_t)((percent_data) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(percent_data);\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS)\n{\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n}\nelse\n{\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x64, 0xF6, 0xCB, 0x00, 0x35, 0x2D, 0x3B, 0x99, 0x6C, 0xFB, 0x36, 0xE4, 0xCE, 0x1A, 0x08, 0x91};\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "6d03a314a1eedf361b791d75da424a04", "product_family": "wisblock", "product_id": "kit4-industrial", "category": "How-To", "title": "WisBlock IoT Education Kit - Smart Industry Quick Start Guide > WisBlock IoT Education Kit - Smart Industry Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock Smart Industry Kit using TTN and Quibitro > Battery Monitoring LoRaWAN Application > LoRaWAN Code for Battery Monitoring > Battery Monitoring LoRaWAN Application Setup [CODE]", "content": "#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define  RAK4631_BOARD true\n#else\n#define  RAK4631_BOARD false\n#endif\n\nlong int coulomb, mAh, percent;", "keywords": ["Arduino IDE", "RAK4631", "Battery Monitoring", "LoRaWAN", "SX126x-Arduino"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **Battery Monitoring** device. Just copy the code below for **Battery Monitoring LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the code</summary>  \n```c\n\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h> //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n#include \"LTC2941.h\"               // Click here to get the library: http://librarymanager/All#GROVE-Coulomb_Counter\n#define BATTERY_CAPACITY2200     // unit:mAh.\n#define CURRENT_CAPACITY  42352    // Set the current battery level to 1800 mAh.\n#define Enable            WB_IO2   // Sensor Power Switch\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define  RAK4631_BOARD true\n#else\n#define  RAK4631_BOARD false\n#endif\n\nlong int coulomb, mAh, percent;\n\nbool doOTAA = true;   // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                     /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                   /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5             /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                      /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                      /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = {LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF};\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = {BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler\n};\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x64, 0xF6, 0xCB, 0x00, 0x35, 0x2D, 0x3B, 0x99, 0x6C, 0xFB, 0x36, 0xE4, 0xCE, 0x1A, 0x08, 0x91};\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = {0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23};\nuint8_t nodeAppsKey[16] = {0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C};\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                     /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];            //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = {m_lora_app_data_buffer, 0, 0, 0, 0}; //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup()\n{\n// Sensor Power Switch\npinMode(Enable, OUTPUT);\ndigitalWrite(Enable, HIGH);\n\npinMode(LED_GREEN, OUTPUT);  // Output LED\npinMode(LED_BLUE, OUTPUT);   // Output LED\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial)\n{\nif ((millis() - timeout) < 5000)\n{\ndelay(100);\n}\nelse\n{\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA)\n{\nSerial.println(\"Type: OTAA\");\n}\nelse\n{\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion)\n{\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA)\n{\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n}\nelse\n{\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0)\n{\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"========================\");\nSerial.println(\"RAK16002 LoRaWAN example\");\nSerial.println(\"========================\");\n\nWire.begin();\n\nltc2941.initialize();\nltc2941.setBatteryFullMAh(BATTERY_CAPACITY , false);\nltc2941.setAccumulatedCharge(CURRENT_CAPACITY); // Set the current battery level to 1800 mAh.\n\n}\n\nvoid loop()\n{\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\ndigitalWrite(LED_BLUE,HIGH);\ndigitalWrite(LED_GREEN, HIGH);\n\n// Measures Coulomb, Charge and Percentage\ncoulomb = ltc2941.getCoulombs();\nmAh = ltc2941.getmAh();\npercent = ltc2941.getPercent();\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\nSerial.print(coulomb);\nSerial.print(\"C   \");\nSerial.print(mAh);\nSerial.print(\"mAh   \");\nSerial.print(percent);\nSerial.println(\"%\");\ndelay(5000);\n\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void)\n{\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void)\n{\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data)\n{\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class)\n{\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void)\n{\nif (lmh_join_status_get() != LMH_SET)\n{\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\ndata = \" Coulomb: \" + String(coulomb) + \" C \" + \" Charge: \" + String(mAh) + \" mAh \" + \" Percentage: \" + String(percent) + \" % \";\nSerial.println(data);\n\nuint32_t coulomb_data = coulomb;\nuint32_t mAh_data = mAh;\nuint16_t percent_data = percent;\n\nm_lora_app_data.buffer[i++] = 0x01;\n\nm_lora_app_data.buffer[i++] = (uint8_t)((coulomb_data  & 0xFF000000) >> 24);\nm_lora_app_data.buffer[i++] = (uint8_t)((coulomb_data  & 0x00FF0000) >> 16);\nm_lora_app_data.buffer[i++] = (uint8_t)((coulomb_data  & 0x0000FF00) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(coulomb_data  & 0x000000FF);\n\nm_lora_app_data.buffer[i++] = (uint8_t)((mAh_data & 0xFF000000) >> 24);\nm_lora_app_data.buffer[i++] = (uint8_t)((mAh_data & 0x00FF0000) >> 16);\nm_lora_app_data.buffer[i++] = (uint8_t)((mAh_data & 0x0000FF00) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(mAh_data & 0x000000FF);\n\nm_lora_app_data.buffer[i++] = (uint8_t)((percent_data) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(percent_data);\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS)\n{\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n}\nelse\n{\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x64, 0xF6, 0xCB, 0x00, 0x35, 0x2D, 0x3B, 0x99, 0x6C, 0xFB, 0x36, 0xE4, 0xCE, 0x1A, 0x08, 0x91};\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "fce6e46add49087e62ef1e4718ce8ea4", "product_family": "wisblock", "product_id": "kit4-industrial", "category": "How-To", "title": "WisBlock IoT Education Kit - Smart Industry Quick Start Guide > WisBlock IoT Education Kit - Smart Industry Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock Smart Industry Kit using TTN and Quibitro > Battery Monitoring LoRaWAN Application > LoRaWAN Code for Battery Monitoring > Battery Monitoring LoRaWAN Application Setup [CODE]", "content": "bool doOTAA = true;   // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                     /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                   /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5             /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/", "keywords": ["Arduino IDE", "RAK4631", "Battery Monitoring", "LoRaWAN", "SX126x-Arduino"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **Battery Monitoring** device. Just copy the code below for **Battery Monitoring LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the code</summary>  \n```c\n\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h> //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n#include \"LTC2941.h\"               // Click here to get the library: http://librarymanager/All#GROVE-Coulomb_Counter\n#define BATTERY_CAPACITY2200     // unit:mAh.\n#define CURRENT_CAPACITY  42352    // Set the current battery level to 1800 mAh.\n#define Enable            WB_IO2   // Sensor Power Switch\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define  RAK4631_BOARD true\n#else\n#define  RAK4631_BOARD false\n#endif\n\nlong int coulomb, mAh, percent;\n\nbool doOTAA = true;   // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                     /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                   /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5             /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                      /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                      /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = {LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF};\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = {BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler\n};\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x64, 0xF6, 0xCB, 0x00, 0x35, 0x2D, 0x3B, 0x99, 0x6C, 0xFB, 0x36, 0xE4, 0xCE, 0x1A, 0x08, 0x91};\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = {0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23};\nuint8_t nodeAppsKey[16] = {0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C};\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                     /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];            //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = {m_lora_app_data_buffer, 0, 0, 0, 0}; //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup()\n{\n// Sensor Power Switch\npinMode(Enable, OUTPUT);\ndigitalWrite(Enable, HIGH);\n\npinMode(LED_GREEN, OUTPUT);  // Output LED\npinMode(LED_BLUE, OUTPUT);   // Output LED\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial)\n{\nif ((millis() - timeout) < 5000)\n{\ndelay(100);\n}\nelse\n{\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA)\n{\nSerial.println(\"Type: OTAA\");\n}\nelse\n{\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion)\n{\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA)\n{\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n}\nelse\n{\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0)\n{\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"========================\");\nSerial.println(\"RAK16002 LoRaWAN example\");\nSerial.println(\"========================\");\n\nWire.begin();\n\nltc2941.initialize();\nltc2941.setBatteryFullMAh(BATTERY_CAPACITY , false);\nltc2941.setAccumulatedCharge(CURRENT_CAPACITY); // Set the current battery level to 1800 mAh.\n\n}\n\nvoid loop()\n{\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\ndigitalWrite(LED_BLUE,HIGH);\ndigitalWrite(LED_GREEN, HIGH);\n\n// Measures Coulomb, Charge and Percentage\ncoulomb = ltc2941.getCoulombs();\nmAh = ltc2941.getmAh();\npercent = ltc2941.getPercent();\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\nSerial.print(coulomb);\nSerial.print(\"C   \");\nSerial.print(mAh);\nSerial.print(\"mAh   \");\nSerial.print(percent);\nSerial.println(\"%\");\ndelay(5000);\n\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void)\n{\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void)\n{\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data)\n{\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class)\n{\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void)\n{\nif (lmh_join_status_get() != LMH_SET)\n{\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\ndata = \" Coulomb: \" + String(coulomb) + \" C \" + \" Charge: \" + String(mAh) + \" mAh \" + \" Percentage: \" + String(percent) + \" % \";\nSerial.println(data);\n\nuint32_t coulomb_data = coulomb;\nuint32_t mAh_data = mAh;\nuint16_t percent_data = percent;\n\nm_lora_app_data.buffer[i++] = 0x01;\n\nm_lora_app_data.buffer[i++] = (uint8_t)((coulomb_data  & 0xFF000000) >> 24);\nm_lora_app_data.buffer[i++] = (uint8_t)((coulomb_data  & 0x00FF0000) >> 16);\nm_lora_app_data.buffer[i++] = (uint8_t)((coulomb_data  & 0x0000FF00) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(coulomb_data  & 0x000000FF);\n\nm_lora_app_data.buffer[i++] = (uint8_t)((mAh_data & 0xFF000000) >> 24);\nm_lora_app_data.buffer[i++] = (uint8_t)((mAh_data & 0x00FF0000) >> 16);\nm_lora_app_data.buffer[i++] = (uint8_t)((mAh_data & 0x0000FF00) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(mAh_data & 0x000000FF);\n\nm_lora_app_data.buffer[i++] = (uint8_t)((percent_data) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(percent_data);\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS)\n{\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n}\nelse\n{\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x64, 0xF6, 0xCB, 0x00, 0x35, 0x2D, 0x3B, 0x99, 0x6C, 0xFB, 0x36, 0xE4, 0xCE, 0x1A, 0x08, 0x91};\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "f73f86471073ff95503425a07fab3d1c", "product_family": "wisblock", "product_id": "kit4-industrial", "category": "How-To", "title": "WisBlock IoT Education Kit - Smart Industry Quick Start Guide > WisBlock IoT Education Kit - Smart Industry Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock Smart Industry Kit using TTN and Quibitro > Battery Monitoring LoRaWAN Application > LoRaWAN Code for Battery Monitoring > Battery Monitoring LoRaWAN Application Setup [CODE]", "content": "#define JOINREQ_NBTRIALS 3                      /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                      /* data port*/", "keywords": ["Arduino IDE", "RAK4631", "Battery Monitoring", "LoRaWAN", "SX126x-Arduino"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **Battery Monitoring** device. Just copy the code below for **Battery Monitoring LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the code</summary>  \n```c\n\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h> //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n#include \"LTC2941.h\"               // Click here to get the library: http://librarymanager/All#GROVE-Coulomb_Counter\n#define BATTERY_CAPACITY2200     // unit:mAh.\n#define CURRENT_CAPACITY  42352    // Set the current battery level to 1800 mAh.\n#define Enable            WB_IO2   // Sensor Power Switch\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define  RAK4631_BOARD true\n#else\n#define  RAK4631_BOARD false\n#endif\n\nlong int coulomb, mAh, percent;\n\nbool doOTAA = true;   // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                     /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                   /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5             /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                      /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                      /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = {LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF};\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = {BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler\n};\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x64, 0xF6, 0xCB, 0x00, 0x35, 0x2D, 0x3B, 0x99, 0x6C, 0xFB, 0x36, 0xE4, 0xCE, 0x1A, 0x08, 0x91};\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = {0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23};\nuint8_t nodeAppsKey[16] = {0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C};\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                     /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];            //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = {m_lora_app_data_buffer, 0, 0, 0, 0}; //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup()\n{\n// Sensor Power Switch\npinMode(Enable, OUTPUT);\ndigitalWrite(Enable, HIGH);\n\npinMode(LED_GREEN, OUTPUT);  // Output LED\npinMode(LED_BLUE, OUTPUT);   // Output LED\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial)\n{\nif ((millis() - timeout) < 5000)\n{\ndelay(100);\n}\nelse\n{\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA)\n{\nSerial.println(\"Type: OTAA\");\n}\nelse\n{\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion)\n{\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA)\n{\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n}\nelse\n{\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0)\n{\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"========================\");\nSerial.println(\"RAK16002 LoRaWAN example\");\nSerial.println(\"========================\");\n\nWire.begin();\n\nltc2941.initialize();\nltc2941.setBatteryFullMAh(BATTERY_CAPACITY , false);\nltc2941.setAccumulatedCharge(CURRENT_CAPACITY); // Set the current battery level to 1800 mAh.\n\n}\n\nvoid loop()\n{\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\ndigitalWrite(LED_BLUE,HIGH);\ndigitalWrite(LED_GREEN, HIGH);\n\n// Measures Coulomb, Charge and Percentage\ncoulomb = ltc2941.getCoulombs();\nmAh = ltc2941.getmAh();\npercent = ltc2941.getPercent();\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\nSerial.print(coulomb);\nSerial.print(\"C   \");\nSerial.print(mAh);\nSerial.print(\"mAh   \");\nSerial.print(percent);\nSerial.println(\"%\");\ndelay(5000);\n\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void)\n{\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void)\n{\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data)\n{\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class)\n{\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void)\n{\nif (lmh_join_status_get() != LMH_SET)\n{\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\ndata = \" Coulomb: \" + String(coulomb) + \" C \" + \" Charge: \" + String(mAh) + \" mAh \" + \" Percentage: \" + String(percent) + \" % \";\nSerial.println(data);\n\nuint32_t coulomb_data = coulomb;\nuint32_t mAh_data = mAh;\nuint16_t percent_data = percent;\n\nm_lora_app_data.buffer[i++] = 0x01;\n\nm_lora_app_data.buffer[i++] = (uint8_t)((coulomb_data  & 0xFF000000) >> 24);\nm_lora_app_data.buffer[i++] = (uint8_t)((coulomb_data  & 0x00FF0000) >> 16);\nm_lora_app_data.buffer[i++] = (uint8_t)((coulomb_data  & 0x0000FF00) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(coulomb_data  & 0x000000FF);\n\nm_lora_app_data.buffer[i++] = (uint8_t)((mAh_data & 0xFF000000) >> 24);\nm_lora_app_data.buffer[i++] = (uint8_t)((mAh_data & 0x00FF0000) >> 16);\nm_lora_app_data.buffer[i++] = (uint8_t)((mAh_data & 0x0000FF00) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(mAh_data & 0x000000FF);\n\nm_lora_app_data.buffer[i++] = (uint8_t)((percent_data) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(percent_data);\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS)\n{\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n}\nelse\n{\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x64, 0xF6, 0xCB, 0x00, 0x35, 0x2D, 0x3B, 0x99, 0x6C, 0xFB, 0x36, 0xE4, 0xCE, 0x1A, 0x08, 0x91};\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "c5b6583afa709e601f4bf9072d9681a0", "product_family": "wisblock", "product_id": "kit4-industrial", "category": "How-To", "title": "WisBlock IoT Education Kit - Smart Industry Quick Start Guide > WisBlock IoT Education Kit - Smart Industry Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock Smart Industry Kit using TTN and Quibitro > Battery Monitoring LoRaWAN Application > LoRaWAN Code for Battery Monitoring > Battery Monitoring LoRaWAN Application Setup [CODE]", "content": "/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = {LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF};", "keywords": ["Arduino IDE", "RAK4631", "Battery Monitoring", "LoRaWAN", "SX126x-Arduino"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **Battery Monitoring** device. Just copy the code below for **Battery Monitoring LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the code</summary>  \n```c\n\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h> //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n#include \"LTC2941.h\"               // Click here to get the library: http://librarymanager/All#GROVE-Coulomb_Counter\n#define BATTERY_CAPACITY2200     // unit:mAh.\n#define CURRENT_CAPACITY  42352    // Set the current battery level to 1800 mAh.\n#define Enable            WB_IO2   // Sensor Power Switch\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define  RAK4631_BOARD true\n#else\n#define  RAK4631_BOARD false\n#endif\n\nlong int coulomb, mAh, percent;\n\nbool doOTAA = true;   // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                     /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                   /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5             /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                      /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                      /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = {LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF};\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = {BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler\n};\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x64, 0xF6, 0xCB, 0x00, 0x35, 0x2D, 0x3B, 0x99, 0x6C, 0xFB, 0x36, 0xE4, 0xCE, 0x1A, 0x08, 0x91};\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = {0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23};\nuint8_t nodeAppsKey[16] = {0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C};\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                     /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];            //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = {m_lora_app_data_buffer, 0, 0, 0, 0}; //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup()\n{\n// Sensor Power Switch\npinMode(Enable, OUTPUT);\ndigitalWrite(Enable, HIGH);\n\npinMode(LED_GREEN, OUTPUT);  // Output LED\npinMode(LED_BLUE, OUTPUT);   // Output LED\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial)\n{\nif ((millis() - timeout) < 5000)\n{\ndelay(100);\n}\nelse\n{\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA)\n{\nSerial.println(\"Type: OTAA\");\n}\nelse\n{\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion)\n{\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA)\n{\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n}\nelse\n{\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0)\n{\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"========================\");\nSerial.println(\"RAK16002 LoRaWAN example\");\nSerial.println(\"========================\");\n\nWire.begin();\n\nltc2941.initialize();\nltc2941.setBatteryFullMAh(BATTERY_CAPACITY , false);\nltc2941.setAccumulatedCharge(CURRENT_CAPACITY); // Set the current battery level to 1800 mAh.\n\n}\n\nvoid loop()\n{\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\ndigitalWrite(LED_BLUE,HIGH);\ndigitalWrite(LED_GREEN, HIGH);\n\n// Measures Coulomb, Charge and Percentage\ncoulomb = ltc2941.getCoulombs();\nmAh = ltc2941.getmAh();\npercent = ltc2941.getPercent();\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\nSerial.print(coulomb);\nSerial.print(\"C   \");\nSerial.print(mAh);\nSerial.print(\"mAh   \");\nSerial.print(percent);\nSerial.println(\"%\");\ndelay(5000);\n\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void)\n{\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void)\n{\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data)\n{\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class)\n{\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void)\n{\nif (lmh_join_status_get() != LMH_SET)\n{\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\ndata = \" Coulomb: \" + String(coulomb) + \" C \" + \" Charge: \" + String(mAh) + \" mAh \" + \" Percentage: \" + String(percent) + \" % \";\nSerial.println(data);\n\nuint32_t coulomb_data = coulomb;\nuint32_t mAh_data = mAh;\nuint16_t percent_data = percent;\n\nm_lora_app_data.buffer[i++] = 0x01;\n\nm_lora_app_data.buffer[i++] = (uint8_t)((coulomb_data  & 0xFF000000) >> 24);\nm_lora_app_data.buffer[i++] = (uint8_t)((coulomb_data  & 0x00FF0000) >> 16);\nm_lora_app_data.buffer[i++] = (uint8_t)((coulomb_data  & 0x0000FF00) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(coulomb_data  & 0x000000FF);\n\nm_lora_app_data.buffer[i++] = (uint8_t)((mAh_data & 0xFF000000) >> 24);\nm_lora_app_data.buffer[i++] = (uint8_t)((mAh_data & 0x00FF0000) >> 16);\nm_lora_app_data.buffer[i++] = (uint8_t)((mAh_data & 0x0000FF00) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(mAh_data & 0x000000FF);\n\nm_lora_app_data.buffer[i++] = (uint8_t)((percent_data) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(percent_data);\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS)\n{\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n}\nelse\n{\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x64, 0xF6, 0xCB, 0x00, 0x35, 0x2D, 0x3B, 0x99, 0x6C, 0xFB, 0x36, 0xE4, 0xCE, 0x1A, 0x08, 0x91};\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "11cc1f9455f56d6d506019adf2b989d9", "product_family": "wisblock", "product_id": "kit4-industrial", "category": "How-To", "title": "WisBlock IoT Education Kit - Smart Industry Quick Start Guide > WisBlock IoT Education Kit - Smart Industry Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock Smart Industry Kit using TTN and Quibitro > Battery Monitoring LoRaWAN Application > LoRaWAN Code for Battery Monitoring > Battery Monitoring LoRaWAN Application Setup [CODE]", "content": "// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);", "keywords": ["Arduino IDE", "RAK4631", "Battery Monitoring", "LoRaWAN", "SX126x-Arduino"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **Battery Monitoring** device. Just copy the code below for **Battery Monitoring LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the code</summary>  \n```c\n\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h> //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n#include \"LTC2941.h\"               // Click here to get the library: http://librarymanager/All#GROVE-Coulomb_Counter\n#define BATTERY_CAPACITY2200     // unit:mAh.\n#define CURRENT_CAPACITY  42352    // Set the current battery level to 1800 mAh.\n#define Enable            WB_IO2   // Sensor Power Switch\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define  RAK4631_BOARD true\n#else\n#define  RAK4631_BOARD false\n#endif\n\nlong int coulomb, mAh, percent;\n\nbool doOTAA = true;   // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                     /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                   /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5             /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                      /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                      /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = {LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF};\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = {BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler\n};\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x64, 0xF6, 0xCB, 0x00, 0x35, 0x2D, 0x3B, 0x99, 0x6C, 0xFB, 0x36, 0xE4, 0xCE, 0x1A, 0x08, 0x91};\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = {0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23};\nuint8_t nodeAppsKey[16] = {0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C};\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                     /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];            //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = {m_lora_app_data_buffer, 0, 0, 0, 0}; //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup()\n{\n// Sensor Power Switch\npinMode(Enable, OUTPUT);\ndigitalWrite(Enable, HIGH);\n\npinMode(LED_GREEN, OUTPUT);  // Output LED\npinMode(LED_BLUE, OUTPUT);   // Output LED\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial)\n{\nif ((millis() - timeout) < 5000)\n{\ndelay(100);\n}\nelse\n{\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA)\n{\nSerial.println(\"Type: OTAA\");\n}\nelse\n{\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion)\n{\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA)\n{\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n}\nelse\n{\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0)\n{\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"========================\");\nSerial.println(\"RAK16002 LoRaWAN example\");\nSerial.println(\"========================\");\n\nWire.begin();\n\nltc2941.initialize();\nltc2941.setBatteryFullMAh(BATTERY_CAPACITY , false);\nltc2941.setAccumulatedCharge(CURRENT_CAPACITY); // Set the current battery level to 1800 mAh.\n\n}\n\nvoid loop()\n{\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\ndigitalWrite(LED_BLUE,HIGH);\ndigitalWrite(LED_GREEN, HIGH);\n\n// Measures Coulomb, Charge and Percentage\ncoulomb = ltc2941.getCoulombs();\nmAh = ltc2941.getmAh();\npercent = ltc2941.getPercent();\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\nSerial.print(coulomb);\nSerial.print(\"C   \");\nSerial.print(mAh);\nSerial.print(\"mAh   \");\nSerial.print(percent);\nSerial.println(\"%\");\ndelay(5000);\n\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void)\n{\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void)\n{\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data)\n{\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class)\n{\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void)\n{\nif (lmh_join_status_get() != LMH_SET)\n{\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\ndata = \" Coulomb: \" + String(coulomb) + \" C \" + \" Charge: \" + String(mAh) + \" mAh \" + \" Percentage: \" + String(percent) + \" % \";\nSerial.println(data);\n\nuint32_t coulomb_data = coulomb;\nuint32_t mAh_data = mAh;\nuint16_t percent_data = percent;\n\nm_lora_app_data.buffer[i++] = 0x01;\n\nm_lora_app_data.buffer[i++] = (uint8_t)((coulomb_data  & 0xFF000000) >> 24);\nm_lora_app_data.buffer[i++] = (uint8_t)((coulomb_data  & 0x00FF0000) >> 16);\nm_lora_app_data.buffer[i++] = (uint8_t)((coulomb_data  & 0x0000FF00) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(coulomb_data  & 0x000000FF);\n\nm_lora_app_data.buffer[i++] = (uint8_t)((mAh_data & 0xFF000000) >> 24);\nm_lora_app_data.buffer[i++] = (uint8_t)((mAh_data & 0x00FF0000) >> 16);\nm_lora_app_data.buffer[i++] = (uint8_t)((mAh_data & 0x0000FF00) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(mAh_data & 0x000000FF);\n\nm_lora_app_data.buffer[i++] = (uint8_t)((percent_data) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(percent_data);\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS)\n{\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n}\nelse\n{\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x64, 0xF6, 0xCB, 0x00, 0x35, 0x2D, 0x3B, 0x99, 0x6C, 0xFB, 0x36, 0xE4, 0xCE, 0x1A, 0x08, 0x91};\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "9ae7d99c6df2395599ab4132d45771c3", "product_family": "wisblock", "product_id": "kit4-industrial", "category": "How-To", "title": "WisBlock IoT Education Kit - Smart Industry Quick Start Guide > WisBlock IoT Education Kit - Smart Industry Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock Smart Industry Kit using TTN and Quibitro > Battery Monitoring LoRaWAN Application > LoRaWAN Code for Battery Monitoring > Battery Monitoring LoRaWAN Application Setup [CODE]", "content": "/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = {BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler\n};\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};", "keywords": ["Arduino IDE", "RAK4631", "Battery Monitoring", "LoRaWAN", "SX126x-Arduino"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **Battery Monitoring** device. Just copy the code below for **Battery Monitoring LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the code</summary>  \n```c\n\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h> //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n#include \"LTC2941.h\"               // Click here to get the library: http://librarymanager/All#GROVE-Coulomb_Counter\n#define BATTERY_CAPACITY2200     // unit:mAh.\n#define CURRENT_CAPACITY  42352    // Set the current battery level to 1800 mAh.\n#define Enable            WB_IO2   // Sensor Power Switch\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define  RAK4631_BOARD true\n#else\n#define  RAK4631_BOARD false\n#endif\n\nlong int coulomb, mAh, percent;\n\nbool doOTAA = true;   // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                     /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                   /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5             /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                      /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                      /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = {LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF};\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = {BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler\n};\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x64, 0xF6, 0xCB, 0x00, 0x35, 0x2D, 0x3B, 0x99, 0x6C, 0xFB, 0x36, 0xE4, 0xCE, 0x1A, 0x08, 0x91};\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = {0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23};\nuint8_t nodeAppsKey[16] = {0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C};\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                     /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];            //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = {m_lora_app_data_buffer, 0, 0, 0, 0}; //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup()\n{\n// Sensor Power Switch\npinMode(Enable, OUTPUT);\ndigitalWrite(Enable, HIGH);\n\npinMode(LED_GREEN, OUTPUT);  // Output LED\npinMode(LED_BLUE, OUTPUT);   // Output LED\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial)\n{\nif ((millis() - timeout) < 5000)\n{\ndelay(100);\n}\nelse\n{\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA)\n{\nSerial.println(\"Type: OTAA\");\n}\nelse\n{\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion)\n{\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA)\n{\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n}\nelse\n{\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0)\n{\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"========================\");\nSerial.println(\"RAK16002 LoRaWAN example\");\nSerial.println(\"========================\");\n\nWire.begin();\n\nltc2941.initialize();\nltc2941.setBatteryFullMAh(BATTERY_CAPACITY , false);\nltc2941.setAccumulatedCharge(CURRENT_CAPACITY); // Set the current battery level to 1800 mAh.\n\n}\n\nvoid loop()\n{\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\ndigitalWrite(LED_BLUE,HIGH);\ndigitalWrite(LED_GREEN, HIGH);\n\n// Measures Coulomb, Charge and Percentage\ncoulomb = ltc2941.getCoulombs();\nmAh = ltc2941.getmAh();\npercent = ltc2941.getPercent();\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\nSerial.print(coulomb);\nSerial.print(\"C   \");\nSerial.print(mAh);\nSerial.print(\"mAh   \");\nSerial.print(percent);\nSerial.println(\"%\");\ndelay(5000);\n\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void)\n{\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void)\n{\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data)\n{\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class)\n{\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void)\n{\nif (lmh_join_status_get() != LMH_SET)\n{\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\ndata = \" Coulomb: \" + String(coulomb) + \" C \" + \" Charge: \" + String(mAh) + \" mAh \" + \" Percentage: \" + String(percent) + \" % \";\nSerial.println(data);\n\nuint32_t coulomb_data = coulomb;\nuint32_t mAh_data = mAh;\nuint16_t percent_data = percent;\n\nm_lora_app_data.buffer[i++] = 0x01;\n\nm_lora_app_data.buffer[i++] = (uint8_t)((coulomb_data  & 0xFF000000) >> 24);\nm_lora_app_data.buffer[i++] = (uint8_t)((coulomb_data  & 0x00FF0000) >> 16);\nm_lora_app_data.buffer[i++] = (uint8_t)((coulomb_data  & 0x0000FF00) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(coulomb_data  & 0x000000FF);\n\nm_lora_app_data.buffer[i++] = (uint8_t)((mAh_data & 0xFF000000) >> 24);\nm_lora_app_data.buffer[i++] = (uint8_t)((mAh_data & 0x00FF0000) >> 16);\nm_lora_app_data.buffer[i++] = (uint8_t)((mAh_data & 0x0000FF00) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(mAh_data & 0x000000FF);\n\nm_lora_app_data.buffer[i++] = (uint8_t)((percent_data) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(percent_data);\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS)\n{\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n}\nelse\n{\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x64, 0xF6, 0xCB, 0x00, 0x35, 0x2D, 0x3B, 0x99, 0x6C, 0xFB, 0x36, 0xE4, 0xCE, 0x1A, 0x08, 0x91};\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "049fe48bfedf6b8e6b7d5dc8a01d81d4", "product_family": "wisblock", "product_id": "kit4-industrial", "category": "How-To", "title": "WisBlock IoT Education Kit - Smart Industry Quick Start Guide > WisBlock IoT Education Kit - Smart Industry Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock Smart Industry Kit using TTN and Quibitro > Battery Monitoring LoRaWAN Application > LoRaWAN Code for Battery Monitoring > Battery Monitoring LoRaWAN Application Setup [CODE]", "content": "uint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x64, 0xF6, 0xCB, 0x00, 0x35, 0x2D, 0x3B, 0x99, 0x6C, 0xFB, 0x36, 0xE4, 0xCE, 0x1A, 0x08, 0x91};", "keywords": ["Arduino IDE", "RAK4631", "Battery Monitoring", "LoRaWAN", "SX126x-Arduino"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **Battery Monitoring** device. Just copy the code below for **Battery Monitoring LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the code</summary>  \n```c\n\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h> //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n#include \"LTC2941.h\"               // Click here to get the library: http://librarymanager/All#GROVE-Coulomb_Counter\n#define BATTERY_CAPACITY2200     // unit:mAh.\n#define CURRENT_CAPACITY  42352    // Set the current battery level to 1800 mAh.\n#define Enable            WB_IO2   // Sensor Power Switch\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define  RAK4631_BOARD true\n#else\n#define  RAK4631_BOARD false\n#endif\n\nlong int coulomb, mAh, percent;\n\nbool doOTAA = true;   // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                     /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                   /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5             /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                      /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                      /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = {LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF};\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = {BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler\n};\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x64, 0xF6, 0xCB, 0x00, 0x35, 0x2D, 0x3B, 0x99, 0x6C, 0xFB, 0x36, 0xE4, 0xCE, 0x1A, 0x08, 0x91};\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = {0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23};\nuint8_t nodeAppsKey[16] = {0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C};\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                     /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];            //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = {m_lora_app_data_buffer, 0, 0, 0, 0}; //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup()\n{\n// Sensor Power Switch\npinMode(Enable, OUTPUT);\ndigitalWrite(Enable, HIGH);\n\npinMode(LED_GREEN, OUTPUT);  // Output LED\npinMode(LED_BLUE, OUTPUT);   // Output LED\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial)\n{\nif ((millis() - timeout) < 5000)\n{\ndelay(100);\n}\nelse\n{\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA)\n{\nSerial.println(\"Type: OTAA\");\n}\nelse\n{\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion)\n{\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA)\n{\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n}\nelse\n{\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0)\n{\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"========================\");\nSerial.println(\"RAK16002 LoRaWAN example\");\nSerial.println(\"========================\");\n\nWire.begin();\n\nltc2941.initialize();\nltc2941.setBatteryFullMAh(BATTERY_CAPACITY , false);\nltc2941.setAccumulatedCharge(CURRENT_CAPACITY); // Set the current battery level to 1800 mAh.\n\n}\n\nvoid loop()\n{\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\ndigitalWrite(LED_BLUE,HIGH);\ndigitalWrite(LED_GREEN, HIGH);\n\n// Measures Coulomb, Charge and Percentage\ncoulomb = ltc2941.getCoulombs();\nmAh = ltc2941.getmAh();\npercent = ltc2941.getPercent();\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\nSerial.print(coulomb);\nSerial.print(\"C   \");\nSerial.print(mAh);\nSerial.print(\"mAh   \");\nSerial.print(percent);\nSerial.println(\"%\");\ndelay(5000);\n\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void)\n{\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void)\n{\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data)\n{\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class)\n{\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void)\n{\nif (lmh_join_status_get() != LMH_SET)\n{\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\ndata = \" Coulomb: \" + String(coulomb) + \" C \" + \" Charge: \" + String(mAh) + \" mAh \" + \" Percentage: \" + String(percent) + \" % \";\nSerial.println(data);\n\nuint32_t coulomb_data = coulomb;\nuint32_t mAh_data = mAh;\nuint16_t percent_data = percent;\n\nm_lora_app_data.buffer[i++] = 0x01;\n\nm_lora_app_data.buffer[i++] = (uint8_t)((coulomb_data  & 0xFF000000) >> 24);\nm_lora_app_data.buffer[i++] = (uint8_t)((coulomb_data  & 0x00FF0000) >> 16);\nm_lora_app_data.buffer[i++] = (uint8_t)((coulomb_data  & 0x0000FF00) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(coulomb_data  & 0x000000FF);\n\nm_lora_app_data.buffer[i++] = (uint8_t)((mAh_data & 0xFF000000) >> 24);\nm_lora_app_data.buffer[i++] = (uint8_t)((mAh_data & 0x00FF0000) >> 16);\nm_lora_app_data.buffer[i++] = (uint8_t)((mAh_data & 0x0000FF00) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(mAh_data & 0x000000FF);\n\nm_lora_app_data.buffer[i++] = (uint8_t)((percent_data) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(percent_data);\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS)\n{\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n}\nelse\n{\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x64, 0xF6, 0xCB, 0x00, 0x35, 0x2D, 0x3B, 0x99, 0x6C, 0xFB, 0x36, 0xE4, 0xCE, 0x1A, 0x08, 0x91};\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "0d85f88b5f34275e54812e883321f860", "product_family": "wisblock", "product_id": "kit4-industrial", "category": "How-To", "title": "WisBlock IoT Education Kit - Smart Industry Quick Start Guide > WisBlock IoT Education Kit - Smart Industry Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock Smart Industry Kit using TTN and Quibitro > Battery Monitoring LoRaWAN Application > LoRaWAN Code for Battery Monitoring > Battery Monitoring LoRaWAN Application Setup [CODE]", "content": "// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = {0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23};\nuint8_t nodeAppsKey[16] = {0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C};", "keywords": ["Arduino IDE", "RAK4631", "Battery Monitoring", "LoRaWAN", "SX126x-Arduino"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **Battery Monitoring** device. Just copy the code below for **Battery Monitoring LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the code</summary>  \n```c\n\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h> //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n#include \"LTC2941.h\"               // Click here to get the library: http://librarymanager/All#GROVE-Coulomb_Counter\n#define BATTERY_CAPACITY2200     // unit:mAh.\n#define CURRENT_CAPACITY  42352    // Set the current battery level to 1800 mAh.\n#define Enable            WB_IO2   // Sensor Power Switch\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define  RAK4631_BOARD true\n#else\n#define  RAK4631_BOARD false\n#endif\n\nlong int coulomb, mAh, percent;\n\nbool doOTAA = true;   // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                     /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                   /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5             /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                      /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                      /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = {LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF};\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = {BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler\n};\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x64, 0xF6, 0xCB, 0x00, 0x35, 0x2D, 0x3B, 0x99, 0x6C, 0xFB, 0x36, 0xE4, 0xCE, 0x1A, 0x08, 0x91};\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = {0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23};\nuint8_t nodeAppsKey[16] = {0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C};\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                     /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];            //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = {m_lora_app_data_buffer, 0, 0, 0, 0}; //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup()\n{\n// Sensor Power Switch\npinMode(Enable, OUTPUT);\ndigitalWrite(Enable, HIGH);\n\npinMode(LED_GREEN, OUTPUT);  // Output LED\npinMode(LED_BLUE, OUTPUT);   // Output LED\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial)\n{\nif ((millis() - timeout) < 5000)\n{\ndelay(100);\n}\nelse\n{\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA)\n{\nSerial.println(\"Type: OTAA\");\n}\nelse\n{\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion)\n{\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA)\n{\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n}\nelse\n{\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0)\n{\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"========================\");\nSerial.println(\"RAK16002 LoRaWAN example\");\nSerial.println(\"========================\");\n\nWire.begin();\n\nltc2941.initialize();\nltc2941.setBatteryFullMAh(BATTERY_CAPACITY , false);\nltc2941.setAccumulatedCharge(CURRENT_CAPACITY); // Set the current battery level to 1800 mAh.\n\n}\n\nvoid loop()\n{\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\ndigitalWrite(LED_BLUE,HIGH);\ndigitalWrite(LED_GREEN, HIGH);\n\n// Measures Coulomb, Charge and Percentage\ncoulomb = ltc2941.getCoulombs();\nmAh = ltc2941.getmAh();\npercent = ltc2941.getPercent();\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\nSerial.print(coulomb);\nSerial.print(\"C   \");\nSerial.print(mAh);\nSerial.print(\"mAh   \");\nSerial.print(percent);\nSerial.println(\"%\");\ndelay(5000);\n\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void)\n{\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void)\n{\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data)\n{\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class)\n{\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void)\n{\nif (lmh_join_status_get() != LMH_SET)\n{\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\ndata = \" Coulomb: \" + String(coulomb) + \" C \" + \" Charge: \" + String(mAh) + \" mAh \" + \" Percentage: \" + String(percent) + \" % \";\nSerial.println(data);\n\nuint32_t coulomb_data = coulomb;\nuint32_t mAh_data = mAh;\nuint16_t percent_data = percent;\n\nm_lora_app_data.buffer[i++] = 0x01;\n\nm_lora_app_data.buffer[i++] = (uint8_t)((coulomb_data  & 0xFF000000) >> 24);\nm_lora_app_data.buffer[i++] = (uint8_t)((coulomb_data  & 0x00FF0000) >> 16);\nm_lora_app_data.buffer[i++] = (uint8_t)((coulomb_data  & 0x0000FF00) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(coulomb_data  & 0x000000FF);\n\nm_lora_app_data.buffer[i++] = (uint8_t)((mAh_data & 0xFF000000) >> 24);\nm_lora_app_data.buffer[i++] = (uint8_t)((mAh_data & 0x00FF0000) >> 16);\nm_lora_app_data.buffer[i++] = (uint8_t)((mAh_data & 0x0000FF00) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(mAh_data & 0x000000FF);\n\nm_lora_app_data.buffer[i++] = (uint8_t)((percent_data) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(percent_data);\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS)\n{\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n}\nelse\n{\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x64, 0xF6, 0xCB, 0x00, 0x35, 0x2D, 0x3B, 0x99, 0x6C, 0xFB, 0x36, 0xE4, 0xCE, 0x1A, 0x08, 0x91};\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "46c4d8993dc3c92ea3b5b41e55cc6f75", "product_family": "wisblock", "product_id": "kit4-industrial", "category": "How-To", "title": "WisBlock IoT Education Kit - Smart Industry Quick Start Guide > WisBlock IoT Education Kit - Smart Industry Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock Smart Industry Kit using TTN and Quibitro > Battery Monitoring LoRaWAN Application > LoRaWAN Code for Battery Monitoring > Battery Monitoring LoRaWAN Application Setup [CODE]", "content": "// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                     /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];            //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = {m_lora_app_data_buffer, 0, 0, 0, 0}; //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;", "keywords": ["Arduino IDE", "RAK4631", "Battery Monitoring", "LoRaWAN", "SX126x-Arduino"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **Battery Monitoring** device. Just copy the code below for **Battery Monitoring LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the code</summary>  \n```c\n\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h> //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n#include \"LTC2941.h\"               // Click here to get the library: http://librarymanager/All#GROVE-Coulomb_Counter\n#define BATTERY_CAPACITY2200     // unit:mAh.\n#define CURRENT_CAPACITY  42352    // Set the current battery level to 1800 mAh.\n#define Enable            WB_IO2   // Sensor Power Switch\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define  RAK4631_BOARD true\n#else\n#define  RAK4631_BOARD false\n#endif\n\nlong int coulomb, mAh, percent;\n\nbool doOTAA = true;   // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                     /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                   /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5             /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                      /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                      /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = {LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF};\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = {BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler\n};\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x64, 0xF6, 0xCB, 0x00, 0x35, 0x2D, 0x3B, 0x99, 0x6C, 0xFB, 0x36, 0xE4, 0xCE, 0x1A, 0x08, 0x91};\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = {0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23};\nuint8_t nodeAppsKey[16] = {0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C};\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                     /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];            //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = {m_lora_app_data_buffer, 0, 0, 0, 0}; //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup()\n{\n// Sensor Power Switch\npinMode(Enable, OUTPUT);\ndigitalWrite(Enable, HIGH);\n\npinMode(LED_GREEN, OUTPUT);  // Output LED\npinMode(LED_BLUE, OUTPUT);   // Output LED\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial)\n{\nif ((millis() - timeout) < 5000)\n{\ndelay(100);\n}\nelse\n{\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA)\n{\nSerial.println(\"Type: OTAA\");\n}\nelse\n{\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion)\n{\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA)\n{\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n}\nelse\n{\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0)\n{\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"========================\");\nSerial.println(\"RAK16002 LoRaWAN example\");\nSerial.println(\"========================\");\n\nWire.begin();\n\nltc2941.initialize();\nltc2941.setBatteryFullMAh(BATTERY_CAPACITY , false);\nltc2941.setAccumulatedCharge(CURRENT_CAPACITY); // Set the current battery level to 1800 mAh.\n\n}\n\nvoid loop()\n{\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\ndigitalWrite(LED_BLUE,HIGH);\ndigitalWrite(LED_GREEN, HIGH);\n\n// Measures Coulomb, Charge and Percentage\ncoulomb = ltc2941.getCoulombs();\nmAh = ltc2941.getmAh();\npercent = ltc2941.getPercent();\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\nSerial.print(coulomb);\nSerial.print(\"C   \");\nSerial.print(mAh);\nSerial.print(\"mAh   \");\nSerial.print(percent);\nSerial.println(\"%\");\ndelay(5000);\n\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void)\n{\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void)\n{\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data)\n{\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class)\n{\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void)\n{\nif (lmh_join_status_get() != LMH_SET)\n{\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\ndata = \" Coulomb: \" + String(coulomb) + \" C \" + \" Charge: \" + String(mAh) + \" mAh \" + \" Percentage: \" + String(percent) + \" % \";\nSerial.println(data);\n\nuint32_t coulomb_data = coulomb;\nuint32_t mAh_data = mAh;\nuint16_t percent_data = percent;\n\nm_lora_app_data.buffer[i++] = 0x01;\n\nm_lora_app_data.buffer[i++] = (uint8_t)((coulomb_data  & 0xFF000000) >> 24);\nm_lora_app_data.buffer[i++] = (uint8_t)((coulomb_data  & 0x00FF0000) >> 16);\nm_lora_app_data.buffer[i++] = (uint8_t)((coulomb_data  & 0x0000FF00) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(coulomb_data  & 0x000000FF);\n\nm_lora_app_data.buffer[i++] = (uint8_t)((mAh_data & 0xFF000000) >> 24);\nm_lora_app_data.buffer[i++] = (uint8_t)((mAh_data & 0x00FF0000) >> 16);\nm_lora_app_data.buffer[i++] = (uint8_t)((mAh_data & 0x0000FF00) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(mAh_data & 0x000000FF);\n\nm_lora_app_data.buffer[i++] = (uint8_t)((percent_data) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(percent_data);\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS)\n{\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n}\nelse\n{\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x64, 0xF6, 0xCB, 0x00, 0x35, 0x2D, 0x3B, 0x99, 0x6C, 0xFB, 0x36, 0xE4, 0xCE, 0x1A, 0x08, 0x91};\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "422e2cefa39b073254f0459d29780b6f", "product_family": "wisblock", "product_id": "kit4-industrial", "category": "How-To", "title": "WisBlock IoT Education Kit - Smart Industry Quick Start Guide > WisBlock IoT Education Kit - Smart Industry Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock Smart Industry Kit using TTN and Quibitro > Battery Monitoring LoRaWAN Application > LoRaWAN Code for Battery Monitoring > Battery Monitoring LoRaWAN Application Setup [CODE]", "content": "static uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup()\n{\n// Sensor Power Switch\npinMode(Enable, OUTPUT);\ndigitalWrite(Enable, HIGH);\n\npinMode(LED_GREEN, OUTPUT);  // Output LED\npinMode(LED_BLUE, OUTPUT);   // Output LED\n\n// Initialize LoRa chip.\nlora_rak4630_init();", "keywords": ["Arduino IDE", "RAK4631", "Battery Monitoring", "LoRaWAN", "SX126x-Arduino"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **Battery Monitoring** device. Just copy the code below for **Battery Monitoring LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the code</summary>  \n```c\n\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h> //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n#include \"LTC2941.h\"               // Click here to get the library: http://librarymanager/All#GROVE-Coulomb_Counter\n#define BATTERY_CAPACITY2200     // unit:mAh.\n#define CURRENT_CAPACITY  42352    // Set the current battery level to 1800 mAh.\n#define Enable            WB_IO2   // Sensor Power Switch\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define  RAK4631_BOARD true\n#else\n#define  RAK4631_BOARD false\n#endif\n\nlong int coulomb, mAh, percent;\n\nbool doOTAA = true;   // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                     /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                   /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5             /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                      /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                      /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = {LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF};\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = {BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler\n};\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x64, 0xF6, 0xCB, 0x00, 0x35, 0x2D, 0x3B, 0x99, 0x6C, 0xFB, 0x36, 0xE4, 0xCE, 0x1A, 0x08, 0x91};\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = {0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23};\nuint8_t nodeAppsKey[16] = {0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C};\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                     /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];            //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = {m_lora_app_data_buffer, 0, 0, 0, 0}; //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup()\n{\n// Sensor Power Switch\npinMode(Enable, OUTPUT);\ndigitalWrite(Enable, HIGH);\n\npinMode(LED_GREEN, OUTPUT);  // Output LED\npinMode(LED_BLUE, OUTPUT);   // Output LED\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial)\n{\nif ((millis() - timeout) < 5000)\n{\ndelay(100);\n}\nelse\n{\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA)\n{\nSerial.println(\"Type: OTAA\");\n}\nelse\n{\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion)\n{\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA)\n{\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n}\nelse\n{\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0)\n{\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"========================\");\nSerial.println(\"RAK16002 LoRaWAN example\");\nSerial.println(\"========================\");\n\nWire.begin();\n\nltc2941.initialize();\nltc2941.setBatteryFullMAh(BATTERY_CAPACITY , false);\nltc2941.setAccumulatedCharge(CURRENT_CAPACITY); // Set the current battery level to 1800 mAh.\n\n}\n\nvoid loop()\n{\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\ndigitalWrite(LED_BLUE,HIGH);\ndigitalWrite(LED_GREEN, HIGH);\n\n// Measures Coulomb, Charge and Percentage\ncoulomb = ltc2941.getCoulombs();\nmAh = ltc2941.getmAh();\npercent = ltc2941.getPercent();\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\nSerial.print(coulomb);\nSerial.print(\"C   \");\nSerial.print(mAh);\nSerial.print(\"mAh   \");\nSerial.print(percent);\nSerial.println(\"%\");\ndelay(5000);\n\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void)\n{\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void)\n{\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data)\n{\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class)\n{\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void)\n{\nif (lmh_join_status_get() != LMH_SET)\n{\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\ndata = \" Coulomb: \" + String(coulomb) + \" C \" + \" Charge: \" + String(mAh) + \" mAh \" + \" Percentage: \" + String(percent) + \" % \";\nSerial.println(data);\n\nuint32_t coulomb_data = coulomb;\nuint32_t mAh_data = mAh;\nuint16_t percent_data = percent;\n\nm_lora_app_data.buffer[i++] = 0x01;\n\nm_lora_app_data.buffer[i++] = (uint8_t)((coulomb_data  & 0xFF000000) >> 24);\nm_lora_app_data.buffer[i++] = (uint8_t)((coulomb_data  & 0x00FF0000) >> 16);\nm_lora_app_data.buffer[i++] = (uint8_t)((coulomb_data  & 0x0000FF00) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(coulomb_data  & 0x000000FF);\n\nm_lora_app_data.buffer[i++] = (uint8_t)((mAh_data & 0xFF000000) >> 24);\nm_lora_app_data.buffer[i++] = (uint8_t)((mAh_data & 0x00FF0000) >> 16);\nm_lora_app_data.buffer[i++] = (uint8_t)((mAh_data & 0x0000FF00) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(mAh_data & 0x000000FF);\n\nm_lora_app_data.buffer[i++] = (uint8_t)((percent_data) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(percent_data);\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS)\n{\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n}\nelse\n{\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x64, 0xF6, 0xCB, 0x00, 0x35, 0x2D, 0x3B, 0x99, 0x6C, 0xFB, 0x36, 0xE4, 0xCE, 0x1A, 0x08, 0x91};\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "7954d2d837275d764ea3402b4f960478", "product_family": "wisblock", "product_id": "kit4-industrial", "category": "How-To", "title": "WisBlock IoT Education Kit - Smart Industry Quick Start Guide > WisBlock IoT Education Kit - Smart Industry Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock Smart Industry Kit using TTN and Quibitro > Battery Monitoring LoRaWAN Application > LoRaWAN Code for Battery Monitoring > Battery Monitoring LoRaWAN Application Setup [CODE]", "content": "// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial)\n{\nif ((millis() - timeout) < 5000)\n{\ndelay(100);\n}\nelse\n{\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA)\n{\nSerial.println(\"Type: OTAA\");\n}\nelse\n{\nSerial.println(\"Type: ABP\");\n}", "keywords": ["Arduino IDE", "RAK4631", "Battery Monitoring", "LoRaWAN", "SX126x-Arduino"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **Battery Monitoring** device. Just copy the code below for **Battery Monitoring LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the code</summary>  \n```c\n\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h> //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n#include \"LTC2941.h\"               // Click here to get the library: http://librarymanager/All#GROVE-Coulomb_Counter\n#define BATTERY_CAPACITY2200     // unit:mAh.\n#define CURRENT_CAPACITY  42352    // Set the current battery level to 1800 mAh.\n#define Enable            WB_IO2   // Sensor Power Switch\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define  RAK4631_BOARD true\n#else\n#define  RAK4631_BOARD false\n#endif\n\nlong int coulomb, mAh, percent;\n\nbool doOTAA = true;   // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                     /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                   /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5             /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                      /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                      /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = {LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF};\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = {BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler\n};\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x64, 0xF6, 0xCB, 0x00, 0x35, 0x2D, 0x3B, 0x99, 0x6C, 0xFB, 0x36, 0xE4, 0xCE, 0x1A, 0x08, 0x91};\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = {0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23};\nuint8_t nodeAppsKey[16] = {0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C};\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                     /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];            //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = {m_lora_app_data_buffer, 0, 0, 0, 0}; //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup()\n{\n// Sensor Power Switch\npinMode(Enable, OUTPUT);\ndigitalWrite(Enable, HIGH);\n\npinMode(LED_GREEN, OUTPUT);  // Output LED\npinMode(LED_BLUE, OUTPUT);   // Output LED\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial)\n{\nif ((millis() - timeout) < 5000)\n{\ndelay(100);\n}\nelse\n{\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA)\n{\nSerial.println(\"Type: OTAA\");\n}\nelse\n{\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion)\n{\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA)\n{\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n}\nelse\n{\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0)\n{\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"========================\");\nSerial.println(\"RAK16002 LoRaWAN example\");\nSerial.println(\"========================\");\n\nWire.begin();\n\nltc2941.initialize();\nltc2941.setBatteryFullMAh(BATTERY_CAPACITY , false);\nltc2941.setAccumulatedCharge(CURRENT_CAPACITY); // Set the current battery level to 1800 mAh.\n\n}\n\nvoid loop()\n{\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\ndigitalWrite(LED_BLUE,HIGH);\ndigitalWrite(LED_GREEN, HIGH);\n\n// Measures Coulomb, Charge and Percentage\ncoulomb = ltc2941.getCoulombs();\nmAh = ltc2941.getmAh();\npercent = ltc2941.getPercent();\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\nSerial.print(coulomb);\nSerial.print(\"C   \");\nSerial.print(mAh);\nSerial.print(\"mAh   \");\nSerial.print(percent);\nSerial.println(\"%\");\ndelay(5000);\n\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void)\n{\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void)\n{\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data)\n{\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class)\n{\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void)\n{\nif (lmh_join_status_get() != LMH_SET)\n{\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\ndata = \" Coulomb: \" + String(coulomb) + \" C \" + \" Charge: \" + String(mAh) + \" mAh \" + \" Percentage: \" + String(percent) + \" % \";\nSerial.println(data);\n\nuint32_t coulomb_data = coulomb;\nuint32_t mAh_data = mAh;\nuint16_t percent_data = percent;\n\nm_lora_app_data.buffer[i++] = 0x01;\n\nm_lora_app_data.buffer[i++] = (uint8_t)((coulomb_data  & 0xFF000000) >> 24);\nm_lora_app_data.buffer[i++] = (uint8_t)((coulomb_data  & 0x00FF0000) >> 16);\nm_lora_app_data.buffer[i++] = (uint8_t)((coulomb_data  & 0x0000FF00) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(coulomb_data  & 0x000000FF);\n\nm_lora_app_data.buffer[i++] = (uint8_t)((mAh_data & 0xFF000000) >> 24);\nm_lora_app_data.buffer[i++] = (uint8_t)((mAh_data & 0x00FF0000) >> 16);\nm_lora_app_data.buffer[i++] = (uint8_t)((mAh_data & 0x0000FF00) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(mAh_data & 0x000000FF);\n\nm_lora_app_data.buffer[i++] = (uint8_t)((percent_data) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(percent_data);\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS)\n{\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n}\nelse\n{\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x64, 0xF6, 0xCB, 0x00, 0x35, 0x2D, 0x3B, 0x99, 0x6C, 0xFB, 0x36, 0xE4, 0xCE, 0x1A, 0x08, 0x91};\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "aa44c3750feb04d1383e78f9386f50ff", "product_family": "wisblock", "product_id": "kit4-industrial", "category": "How-To", "title": "WisBlock IoT Education Kit - Smart Industry Quick Start Guide > WisBlock IoT Education Kit - Smart Industry Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock Smart Industry Kit using TTN and Quibitro > Battery Monitoring LoRaWAN Application > LoRaWAN Code for Battery Monitoring > Battery Monitoring LoRaWAN Application Setup [CODE]", "content": "switch (g_CurrentRegion)\n{\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;", "keywords": ["Arduino IDE", "RAK4631", "Battery Monitoring", "LoRaWAN", "SX126x-Arduino"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **Battery Monitoring** device. Just copy the code below for **Battery Monitoring LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the code</summary>  \n```c\n\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h> //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n#include \"LTC2941.h\"               // Click here to get the library: http://librarymanager/All#GROVE-Coulomb_Counter\n#define BATTERY_CAPACITY2200     // unit:mAh.\n#define CURRENT_CAPACITY  42352    // Set the current battery level to 1800 mAh.\n#define Enable            WB_IO2   // Sensor Power Switch\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define  RAK4631_BOARD true\n#else\n#define  RAK4631_BOARD false\n#endif\n\nlong int coulomb, mAh, percent;\n\nbool doOTAA = true;   // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                     /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                   /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5             /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                      /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                      /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = {LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF};\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = {BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler\n};\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x64, 0xF6, 0xCB, 0x00, 0x35, 0x2D, 0x3B, 0x99, 0x6C, 0xFB, 0x36, 0xE4, 0xCE, 0x1A, 0x08, 0x91};\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = {0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23};\nuint8_t nodeAppsKey[16] = {0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C};\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                     /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];            //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = {m_lora_app_data_buffer, 0, 0, 0, 0}; //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup()\n{\n// Sensor Power Switch\npinMode(Enable, OUTPUT);\ndigitalWrite(Enable, HIGH);\n\npinMode(LED_GREEN, OUTPUT);  // Output LED\npinMode(LED_BLUE, OUTPUT);   // Output LED\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial)\n{\nif ((millis() - timeout) < 5000)\n{\ndelay(100);\n}\nelse\n{\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA)\n{\nSerial.println(\"Type: OTAA\");\n}\nelse\n{\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion)\n{\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA)\n{\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n}\nelse\n{\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0)\n{\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"========================\");\nSerial.println(\"RAK16002 LoRaWAN example\");\nSerial.println(\"========================\");\n\nWire.begin();\n\nltc2941.initialize();\nltc2941.setBatteryFullMAh(BATTERY_CAPACITY , false);\nltc2941.setAccumulatedCharge(CURRENT_CAPACITY); // Set the current battery level to 1800 mAh.\n\n}\n\nvoid loop()\n{\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\ndigitalWrite(LED_BLUE,HIGH);\ndigitalWrite(LED_GREEN, HIGH);\n\n// Measures Coulomb, Charge and Percentage\ncoulomb = ltc2941.getCoulombs();\nmAh = ltc2941.getmAh();\npercent = ltc2941.getPercent();\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\nSerial.print(coulomb);\nSerial.print(\"C   \");\nSerial.print(mAh);\nSerial.print(\"mAh   \");\nSerial.print(percent);\nSerial.println(\"%\");\ndelay(5000);\n\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void)\n{\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void)\n{\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data)\n{\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class)\n{\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void)\n{\nif (lmh_join_status_get() != LMH_SET)\n{\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\ndata = \" Coulomb: \" + String(coulomb) + \" C \" + \" Charge: \" + String(mAh) + \" mAh \" + \" Percentage: \" + String(percent) + \" % \";\nSerial.println(data);\n\nuint32_t coulomb_data = coulomb;\nuint32_t mAh_data = mAh;\nuint16_t percent_data = percent;\n\nm_lora_app_data.buffer[i++] = 0x01;\n\nm_lora_app_data.buffer[i++] = (uint8_t)((coulomb_data  & 0xFF000000) >> 24);\nm_lora_app_data.buffer[i++] = (uint8_t)((coulomb_data  & 0x00FF0000) >> 16);\nm_lora_app_data.buffer[i++] = (uint8_t)((coulomb_data  & 0x0000FF00) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(coulomb_data  & 0x000000FF);\n\nm_lora_app_data.buffer[i++] = (uint8_t)((mAh_data & 0xFF000000) >> 24);\nm_lora_app_data.buffer[i++] = (uint8_t)((mAh_data & 0x00FF0000) >> 16);\nm_lora_app_data.buffer[i++] = (uint8_t)((mAh_data & 0x0000FF00) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(mAh_data & 0x000000FF);\n\nm_lora_app_data.buffer[i++] = (uint8_t)((percent_data) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(percent_data);\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS)\n{\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n}\nelse\n{\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x64, 0xF6, 0xCB, 0x00, 0x35, 0x2D, 0x3B, 0x99, 0x6C, 0xFB, 0x36, 0xE4, 0xCE, 0x1A, 0x08, 0x91};\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "28673224a2a1d265c7f157d2c7940868", "product_family": "wisblock", "product_id": "kit4-industrial", "category": "How-To", "title": "WisBlock IoT Education Kit - Smart Industry Quick Start Guide > WisBlock IoT Education Kit - Smart Industry Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock Smart Industry Kit using TTN and Quibitro > Battery Monitoring LoRaWAN Application > LoRaWAN Code for Battery Monitoring > Battery Monitoring LoRaWAN Application Setup [CODE]", "content": "break;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");", "keywords": ["Arduino IDE", "RAK4631", "Battery Monitoring", "LoRaWAN", "SX126x-Arduino"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **Battery Monitoring** device. Just copy the code below for **Battery Monitoring LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the code</summary>  \n```c\n\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h> //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n#include \"LTC2941.h\"               // Click here to get the library: http://librarymanager/All#GROVE-Coulomb_Counter\n#define BATTERY_CAPACITY2200     // unit:mAh.\n#define CURRENT_CAPACITY  42352    // Set the current battery level to 1800 mAh.\n#define Enable            WB_IO2   // Sensor Power Switch\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define  RAK4631_BOARD true\n#else\n#define  RAK4631_BOARD false\n#endif\n\nlong int coulomb, mAh, percent;\n\nbool doOTAA = true;   // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                     /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                   /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5             /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                      /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                      /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = {LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF};\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = {BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler\n};\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x64, 0xF6, 0xCB, 0x00, 0x35, 0x2D, 0x3B, 0x99, 0x6C, 0xFB, 0x36, 0xE4, 0xCE, 0x1A, 0x08, 0x91};\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = {0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23};\nuint8_t nodeAppsKey[16] = {0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C};\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                     /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];            //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = {m_lora_app_data_buffer, 0, 0, 0, 0}; //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup()\n{\n// Sensor Power Switch\npinMode(Enable, OUTPUT);\ndigitalWrite(Enable, HIGH);\n\npinMode(LED_GREEN, OUTPUT);  // Output LED\npinMode(LED_BLUE, OUTPUT);   // Output LED\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial)\n{\nif ((millis() - timeout) < 5000)\n{\ndelay(100);\n}\nelse\n{\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA)\n{\nSerial.println(\"Type: OTAA\");\n}\nelse\n{\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion)\n{\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA)\n{\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n}\nelse\n{\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0)\n{\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"========================\");\nSerial.println(\"RAK16002 LoRaWAN example\");\nSerial.println(\"========================\");\n\nWire.begin();\n\nltc2941.initialize();\nltc2941.setBatteryFullMAh(BATTERY_CAPACITY , false);\nltc2941.setAccumulatedCharge(CURRENT_CAPACITY); // Set the current battery level to 1800 mAh.\n\n}\n\nvoid loop()\n{\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\ndigitalWrite(LED_BLUE,HIGH);\ndigitalWrite(LED_GREEN, HIGH);\n\n// Measures Coulomb, Charge and Percentage\ncoulomb = ltc2941.getCoulombs();\nmAh = ltc2941.getmAh();\npercent = ltc2941.getPercent();\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\nSerial.print(coulomb);\nSerial.print(\"C   \");\nSerial.print(mAh);\nSerial.print(\"mAh   \");\nSerial.print(percent);\nSerial.println(\"%\");\ndelay(5000);\n\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void)\n{\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void)\n{\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data)\n{\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class)\n{\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void)\n{\nif (lmh_join_status_get() != LMH_SET)\n{\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\ndata = \" Coulomb: \" + String(coulomb) + \" C \" + \" Charge: \" + String(mAh) + \" mAh \" + \" Percentage: \" + String(percent) + \" % \";\nSerial.println(data);\n\nuint32_t coulomb_data = coulomb;\nuint32_t mAh_data = mAh;\nuint16_t percent_data = percent;\n\nm_lora_app_data.buffer[i++] = 0x01;\n\nm_lora_app_data.buffer[i++] = (uint8_t)((coulomb_data  & 0xFF000000) >> 24);\nm_lora_app_data.buffer[i++] = (uint8_t)((coulomb_data  & 0x00FF0000) >> 16);\nm_lora_app_data.buffer[i++] = (uint8_t)((coulomb_data  & 0x0000FF00) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(coulomb_data  & 0x000000FF);\n\nm_lora_app_data.buffer[i++] = (uint8_t)((mAh_data & 0xFF000000) >> 24);\nm_lora_app_data.buffer[i++] = (uint8_t)((mAh_data & 0x00FF0000) >> 16);\nm_lora_app_data.buffer[i++] = (uint8_t)((mAh_data & 0x0000FF00) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(mAh_data & 0x000000FF);\n\nm_lora_app_data.buffer[i++] = (uint8_t)((percent_data) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(percent_data);\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS)\n{\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n}\nelse\n{\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x64, 0xF6, 0xCB, 0x00, 0x35, 0x2D, 0x3B, 0x99, 0x6C, 0xFB, 0x36, 0xE4, 0xCE, 0x1A, 0x08, 0x91};\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "2a81ab0af878e06d723be735dd6b76e4", "product_family": "wisblock", "product_id": "kit4-industrial", "category": "How-To", "title": "WisBlock IoT Education Kit - Smart Industry Quick Start Guide > WisBlock IoT Education Kit - Smart Industry Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock Smart Industry Kit using TTN and Quibitro > Battery Monitoring LoRaWAN Application > LoRaWAN Code for Battery Monitoring > Battery Monitoring LoRaWAN Application Setup [CODE]", "content": "// Setup the EUIs and Keys\nif (doOTAA)\n{\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n}\nelse\n{\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0)\n{\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();", "keywords": ["Arduino IDE", "RAK4631", "Battery Monitoring", "LoRaWAN", "SX126x-Arduino"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **Battery Monitoring** device. Just copy the code below for **Battery Monitoring LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the code</summary>  \n```c\n\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h> //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n#include \"LTC2941.h\"               // Click here to get the library: http://librarymanager/All#GROVE-Coulomb_Counter\n#define BATTERY_CAPACITY2200     // unit:mAh.\n#define CURRENT_CAPACITY  42352    // Set the current battery level to 1800 mAh.\n#define Enable            WB_IO2   // Sensor Power Switch\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define  RAK4631_BOARD true\n#else\n#define  RAK4631_BOARD false\n#endif\n\nlong int coulomb, mAh, percent;\n\nbool doOTAA = true;   // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                     /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                   /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5             /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                      /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                      /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = {LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF};\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = {BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler\n};\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x64, 0xF6, 0xCB, 0x00, 0x35, 0x2D, 0x3B, 0x99, 0x6C, 0xFB, 0x36, 0xE4, 0xCE, 0x1A, 0x08, 0x91};\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = {0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23};\nuint8_t nodeAppsKey[16] = {0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C};\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                     /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];            //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = {m_lora_app_data_buffer, 0, 0, 0, 0}; //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup()\n{\n// Sensor Power Switch\npinMode(Enable, OUTPUT);\ndigitalWrite(Enable, HIGH);\n\npinMode(LED_GREEN, OUTPUT);  // Output LED\npinMode(LED_BLUE, OUTPUT);   // Output LED\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial)\n{\nif ((millis() - timeout) < 5000)\n{\ndelay(100);\n}\nelse\n{\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA)\n{\nSerial.println(\"Type: OTAA\");\n}\nelse\n{\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion)\n{\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA)\n{\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n}\nelse\n{\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0)\n{\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"========================\");\nSerial.println(\"RAK16002 LoRaWAN example\");\nSerial.println(\"========================\");\n\nWire.begin();\n\nltc2941.initialize();\nltc2941.setBatteryFullMAh(BATTERY_CAPACITY , false);\nltc2941.setAccumulatedCharge(CURRENT_CAPACITY); // Set the current battery level to 1800 mAh.\n\n}\n\nvoid loop()\n{\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\ndigitalWrite(LED_BLUE,HIGH);\ndigitalWrite(LED_GREEN, HIGH);\n\n// Measures Coulomb, Charge and Percentage\ncoulomb = ltc2941.getCoulombs();\nmAh = ltc2941.getmAh();\npercent = ltc2941.getPercent();\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\nSerial.print(coulomb);\nSerial.print(\"C   \");\nSerial.print(mAh);\nSerial.print(\"mAh   \");\nSerial.print(percent);\nSerial.println(\"%\");\ndelay(5000);\n\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void)\n{\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void)\n{\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data)\n{\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class)\n{\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void)\n{\nif (lmh_join_status_get() != LMH_SET)\n{\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\ndata = \" Coulomb: \" + String(coulomb) + \" C \" + \" Charge: \" + String(mAh) + \" mAh \" + \" Percentage: \" + String(percent) + \" % \";\nSerial.println(data);\n\nuint32_t coulomb_data = coulomb;\nuint32_t mAh_data = mAh;\nuint16_t percent_data = percent;\n\nm_lora_app_data.buffer[i++] = 0x01;\n\nm_lora_app_data.buffer[i++] = (uint8_t)((coulomb_data  & 0xFF000000) >> 24);\nm_lora_app_data.buffer[i++] = (uint8_t)((coulomb_data  & 0x00FF0000) >> 16);\nm_lora_app_data.buffer[i++] = (uint8_t)((coulomb_data  & 0x0000FF00) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(coulomb_data  & 0x000000FF);\n\nm_lora_app_data.buffer[i++] = (uint8_t)((mAh_data & 0xFF000000) >> 24);\nm_lora_app_data.buffer[i++] = (uint8_t)((mAh_data & 0x00FF0000) >> 16);\nm_lora_app_data.buffer[i++] = (uint8_t)((mAh_data & 0x0000FF00) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(mAh_data & 0x000000FF);\n\nm_lora_app_data.buffer[i++] = (uint8_t)((percent_data) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(percent_data);\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS)\n{\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n}\nelse\n{\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x64, 0xF6, 0xCB, 0x00, 0x35, 0x2D, 0x3B, 0x99, 0x6C, 0xFB, 0x36, 0xE4, 0xCE, 0x1A, 0x08, 0x91};\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "2944886d8bea5934f695a2a59016931d", "product_family": "wisblock", "product_id": "kit4-industrial", "category": "How-To", "title": "WisBlock IoT Education Kit - Smart Industry Quick Start Guide > WisBlock IoT Education Kit - Smart Industry Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock Smart Industry Kit using TTN and Quibitro > Battery Monitoring LoRaWAN Application > LoRaWAN Code for Battery Monitoring > Battery Monitoring LoRaWAN Application Setup [CODE]", "content": "// Start Join procedure\nlmh_join();\n\nSerial.println(\"========================\");\nSerial.println(\"RAK16002 LoRaWAN example\");\nSerial.println(\"========================\");\n\nWire.begin();\n\nltc2941.initialize();\nltc2941.setBatteryFullMAh(BATTERY_CAPACITY , false);\nltc2941.setAccumulatedCharge(CURRENT_CAPACITY); // Set the current battery level to 1800 mAh.\n\n}\n\nvoid loop()\n{\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.", "keywords": ["Arduino IDE", "RAK4631", "Battery Monitoring", "LoRaWAN", "SX126x-Arduino"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **Battery Monitoring** device. Just copy the code below for **Battery Monitoring LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the code</summary>  \n```c\n\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h> //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n#include \"LTC2941.h\"               // Click here to get the library: http://librarymanager/All#GROVE-Coulomb_Counter\n#define BATTERY_CAPACITY2200     // unit:mAh.\n#define CURRENT_CAPACITY  42352    // Set the current battery level to 1800 mAh.\n#define Enable            WB_IO2   // Sensor Power Switch\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define  RAK4631_BOARD true\n#else\n#define  RAK4631_BOARD false\n#endif\n\nlong int coulomb, mAh, percent;\n\nbool doOTAA = true;   // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                     /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                   /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5             /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                      /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                      /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = {LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF};\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = {BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler\n};\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x64, 0xF6, 0xCB, 0x00, 0x35, 0x2D, 0x3B, 0x99, 0x6C, 0xFB, 0x36, 0xE4, 0xCE, 0x1A, 0x08, 0x91};\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = {0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23};\nuint8_t nodeAppsKey[16] = {0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C};\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                     /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];            //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = {m_lora_app_data_buffer, 0, 0, 0, 0}; //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup()\n{\n// Sensor Power Switch\npinMode(Enable, OUTPUT);\ndigitalWrite(Enable, HIGH);\n\npinMode(LED_GREEN, OUTPUT);  // Output LED\npinMode(LED_BLUE, OUTPUT);   // Output LED\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial)\n{\nif ((millis() - timeout) < 5000)\n{\ndelay(100);\n}\nelse\n{\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA)\n{\nSerial.println(\"Type: OTAA\");\n}\nelse\n{\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion)\n{\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA)\n{\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n}\nelse\n{\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0)\n{\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"========================\");\nSerial.println(\"RAK16002 LoRaWAN example\");\nSerial.println(\"========================\");\n\nWire.begin();\n\nltc2941.initialize();\nltc2941.setBatteryFullMAh(BATTERY_CAPACITY , false);\nltc2941.setAccumulatedCharge(CURRENT_CAPACITY); // Set the current battery level to 1800 mAh.\n\n}\n\nvoid loop()\n{\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\ndigitalWrite(LED_BLUE,HIGH);\ndigitalWrite(LED_GREEN, HIGH);\n\n// Measures Coulomb, Charge and Percentage\ncoulomb = ltc2941.getCoulombs();\nmAh = ltc2941.getmAh();\npercent = ltc2941.getPercent();\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\nSerial.print(coulomb);\nSerial.print(\"C   \");\nSerial.print(mAh);\nSerial.print(\"mAh   \");\nSerial.print(percent);\nSerial.println(\"%\");\ndelay(5000);\n\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void)\n{\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void)\n{\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data)\n{\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class)\n{\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void)\n{\nif (lmh_join_status_get() != LMH_SET)\n{\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\ndata = \" Coulomb: \" + String(coulomb) + \" C \" + \" Charge: \" + String(mAh) + \" mAh \" + \" Percentage: \" + String(percent) + \" % \";\nSerial.println(data);\n\nuint32_t coulomb_data = coulomb;\nuint32_t mAh_data = mAh;\nuint16_t percent_data = percent;\n\nm_lora_app_data.buffer[i++] = 0x01;\n\nm_lora_app_data.buffer[i++] = (uint8_t)((coulomb_data  & 0xFF000000) >> 24);\nm_lora_app_data.buffer[i++] = (uint8_t)((coulomb_data  & 0x00FF0000) >> 16);\nm_lora_app_data.buffer[i++] = (uint8_t)((coulomb_data  & 0x0000FF00) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(coulomb_data  & 0x000000FF);\n\nm_lora_app_data.buffer[i++] = (uint8_t)((mAh_data & 0xFF000000) >> 24);\nm_lora_app_data.buffer[i++] = (uint8_t)((mAh_data & 0x00FF0000) >> 16);\nm_lora_app_data.buffer[i++] = (uint8_t)((mAh_data & 0x0000FF00) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(mAh_data & 0x000000FF);\n\nm_lora_app_data.buffer[i++] = (uint8_t)((percent_data) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(percent_data);\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS)\n{\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n}\nelse\n{\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x64, 0xF6, 0xCB, 0x00, 0x35, 0x2D, 0x3B, 0x99, 0x6C, 0xFB, 0x36, 0xE4, 0xCE, 0x1A, 0x08, 0x91};\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "ac34fd4e990a79475b57fc5e26a37e56", "product_family": "wisblock", "product_id": "kit4-industrial", "category": "How-To", "title": "WisBlock IoT Education Kit - Smart Industry Quick Start Guide > WisBlock IoT Education Kit - Smart Industry Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock Smart Industry Kit using TTN and Quibitro > Battery Monitoring LoRaWAN Application > LoRaWAN Code for Battery Monitoring > Battery Monitoring LoRaWAN Application Setup [CODE]", "content": "digitalWrite(LED_BLUE,HIGH);\ndigitalWrite(LED_GREEN, HIGH);\n\n// Measures Coulomb, Charge and Percentage\ncoulomb = ltc2941.getCoulombs();\nmAh = ltc2941.getmAh();\npercent = ltc2941.getPercent();\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\nSerial.print(coulomb);\nSerial.print(\"C   \");\nSerial.print(mAh);\nSerial.print(\"mAh   \");\nSerial.print(percent);\nSerial.println(\"%\");\ndelay(5000);\n\n}", "keywords": ["Arduino IDE", "RAK4631", "Battery Monitoring", "LoRaWAN", "SX126x-Arduino"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **Battery Monitoring** device. Just copy the code below for **Battery Monitoring LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the code</summary>  \n```c\n\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h> //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n#include \"LTC2941.h\"               // Click here to get the library: http://librarymanager/All#GROVE-Coulomb_Counter\n#define BATTERY_CAPACITY2200     // unit:mAh.\n#define CURRENT_CAPACITY  42352    // Set the current battery level to 1800 mAh.\n#define Enable            WB_IO2   // Sensor Power Switch\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define  RAK4631_BOARD true\n#else\n#define  RAK4631_BOARD false\n#endif\n\nlong int coulomb, mAh, percent;\n\nbool doOTAA = true;   // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                     /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                   /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5             /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                      /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                      /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = {LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF};\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = {BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler\n};\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x64, 0xF6, 0xCB, 0x00, 0x35, 0x2D, 0x3B, 0x99, 0x6C, 0xFB, 0x36, 0xE4, 0xCE, 0x1A, 0x08, 0x91};\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = {0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23};\nuint8_t nodeAppsKey[16] = {0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C};\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                     /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];            //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = {m_lora_app_data_buffer, 0, 0, 0, 0}; //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup()\n{\n// Sensor Power Switch\npinMode(Enable, OUTPUT);\ndigitalWrite(Enable, HIGH);\n\npinMode(LED_GREEN, OUTPUT);  // Output LED\npinMode(LED_BLUE, OUTPUT);   // Output LED\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial)\n{\nif ((millis() - timeout) < 5000)\n{\ndelay(100);\n}\nelse\n{\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA)\n{\nSerial.println(\"Type: OTAA\");\n}\nelse\n{\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion)\n{\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA)\n{\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n}\nelse\n{\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0)\n{\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"========================\");\nSerial.println(\"RAK16002 LoRaWAN example\");\nSerial.println(\"========================\");\n\nWire.begin();\n\nltc2941.initialize();\nltc2941.setBatteryFullMAh(BATTERY_CAPACITY , false);\nltc2941.setAccumulatedCharge(CURRENT_CAPACITY); // Set the current battery level to 1800 mAh.\n\n}\n\nvoid loop()\n{\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\ndigitalWrite(LED_BLUE,HIGH);\ndigitalWrite(LED_GREEN, HIGH);\n\n// Measures Coulomb, Charge and Percentage\ncoulomb = ltc2941.getCoulombs();\nmAh = ltc2941.getmAh();\npercent = ltc2941.getPercent();\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\nSerial.print(coulomb);\nSerial.print(\"C   \");\nSerial.print(mAh);\nSerial.print(\"mAh   \");\nSerial.print(percent);\nSerial.println(\"%\");\ndelay(5000);\n\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void)\n{\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void)\n{\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data)\n{\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class)\n{\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void)\n{\nif (lmh_join_status_get() != LMH_SET)\n{\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\ndata = \" Coulomb: \" + String(coulomb) + \" C \" + \" Charge: \" + String(mAh) + \" mAh \" + \" Percentage: \" + String(percent) + \" % \";\nSerial.println(data);\n\nuint32_t coulomb_data = coulomb;\nuint32_t mAh_data = mAh;\nuint16_t percent_data = percent;\n\nm_lora_app_data.buffer[i++] = 0x01;\n\nm_lora_app_data.buffer[i++] = (uint8_t)((coulomb_data  & 0xFF000000) >> 24);\nm_lora_app_data.buffer[i++] = (uint8_t)((coulomb_data  & 0x00FF0000) >> 16);\nm_lora_app_data.buffer[i++] = (uint8_t)((coulomb_data  & 0x0000FF00) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(coulomb_data  & 0x000000FF);\n\nm_lora_app_data.buffer[i++] = (uint8_t)((mAh_data & 0xFF000000) >> 24);\nm_lora_app_data.buffer[i++] = (uint8_t)((mAh_data & 0x00FF0000) >> 16);\nm_lora_app_data.buffer[i++] = (uint8_t)((mAh_data & 0x0000FF00) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(mAh_data & 0x000000FF);\n\nm_lora_app_data.buffer[i++] = (uint8_t)((percent_data) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(percent_data);\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS)\n{\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n}\nelse\n{\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x64, 0xF6, 0xCB, 0x00, 0x35, 0x2D, 0x3B, 0x99, 0x6C, 0xFB, 0x36, 0xE4, 0xCE, 0x1A, 0x08, 0x91};\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "cba29ef4544c906e9eee2d378527903b", "product_family": "wisblock", "product_id": "kit4-industrial", "category": "How-To", "title": "WisBlock IoT Education Kit - Smart Industry Quick Start Guide > WisBlock IoT Education Kit - Smart Industry Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock Smart Industry Kit using TTN and Quibitro > Battery Monitoring LoRaWAN Application > LoRaWAN Code for Battery Monitoring > Battery Monitoring LoRaWAN Application Setup [CODE]", "content": "}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void)\n{\nSerial.println(\"OTAA Mode, Network Joined!\");\n}", "keywords": ["Arduino IDE", "RAK4631", "Battery Monitoring", "LoRaWAN", "SX126x-Arduino"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **Battery Monitoring** device. Just copy the code below for **Battery Monitoring LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the code</summary>  \n```c\n\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h> //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n#include \"LTC2941.h\"               // Click here to get the library: http://librarymanager/All#GROVE-Coulomb_Counter\n#define BATTERY_CAPACITY2200     // unit:mAh.\n#define CURRENT_CAPACITY  42352    // Set the current battery level to 1800 mAh.\n#define Enable            WB_IO2   // Sensor Power Switch\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define  RAK4631_BOARD true\n#else\n#define  RAK4631_BOARD false\n#endif\n\nlong int coulomb, mAh, percent;\n\nbool doOTAA = true;   // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                     /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                   /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5             /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                      /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                      /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = {LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF};\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = {BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler\n};\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x64, 0xF6, 0xCB, 0x00, 0x35, 0x2D, 0x3B, 0x99, 0x6C, 0xFB, 0x36, 0xE4, 0xCE, 0x1A, 0x08, 0x91};\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = {0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23};\nuint8_t nodeAppsKey[16] = {0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C};\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                     /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];            //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = {m_lora_app_data_buffer, 0, 0, 0, 0}; //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup()\n{\n// Sensor Power Switch\npinMode(Enable, OUTPUT);\ndigitalWrite(Enable, HIGH);\n\npinMode(LED_GREEN, OUTPUT);  // Output LED\npinMode(LED_BLUE, OUTPUT);   // Output LED\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial)\n{\nif ((millis() - timeout) < 5000)\n{\ndelay(100);\n}\nelse\n{\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA)\n{\nSerial.println(\"Type: OTAA\");\n}\nelse\n{\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion)\n{\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA)\n{\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n}\nelse\n{\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0)\n{\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"========================\");\nSerial.println(\"RAK16002 LoRaWAN example\");\nSerial.println(\"========================\");\n\nWire.begin();\n\nltc2941.initialize();\nltc2941.setBatteryFullMAh(BATTERY_CAPACITY , false);\nltc2941.setAccumulatedCharge(CURRENT_CAPACITY); // Set the current battery level to 1800 mAh.\n\n}\n\nvoid loop()\n{\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\ndigitalWrite(LED_BLUE,HIGH);\ndigitalWrite(LED_GREEN, HIGH);\n\n// Measures Coulomb, Charge and Percentage\ncoulomb = ltc2941.getCoulombs();\nmAh = ltc2941.getmAh();\npercent = ltc2941.getPercent();\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\nSerial.print(coulomb);\nSerial.print(\"C   \");\nSerial.print(mAh);\nSerial.print(\"mAh   \");\nSerial.print(percent);\nSerial.println(\"%\");\ndelay(5000);\n\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void)\n{\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void)\n{\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data)\n{\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class)\n{\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void)\n{\nif (lmh_join_status_get() != LMH_SET)\n{\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\ndata = \" Coulomb: \" + String(coulomb) + \" C \" + \" Charge: \" + String(mAh) + \" mAh \" + \" Percentage: \" + String(percent) + \" % \";\nSerial.println(data);\n\nuint32_t coulomb_data = coulomb;\nuint32_t mAh_data = mAh;\nuint16_t percent_data = percent;\n\nm_lora_app_data.buffer[i++] = 0x01;\n\nm_lora_app_data.buffer[i++] = (uint8_t)((coulomb_data  & 0xFF000000) >> 24);\nm_lora_app_data.buffer[i++] = (uint8_t)((coulomb_data  & 0x00FF0000) >> 16);\nm_lora_app_data.buffer[i++] = (uint8_t)((coulomb_data  & 0x0000FF00) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(coulomb_data  & 0x000000FF);\n\nm_lora_app_data.buffer[i++] = (uint8_t)((mAh_data & 0xFF000000) >> 24);\nm_lora_app_data.buffer[i++] = (uint8_t)((mAh_data & 0x00FF0000) >> 16);\nm_lora_app_data.buffer[i++] = (uint8_t)((mAh_data & 0x0000FF00) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(mAh_data & 0x000000FF);\n\nm_lora_app_data.buffer[i++] = (uint8_t)((percent_data) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(percent_data);\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS)\n{\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n}\nelse\n{\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x64, 0xF6, 0xCB, 0x00, 0x35, 0x2D, 0x3B, 0x99, 0x6C, 0xFB, 0x36, 0xE4, 0xCE, 0x1A, 0x08, 0x91};\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "b79354833d127ac7028e918e84662e51", "product_family": "wisblock", "product_id": "kit4-industrial", "category": "How-To", "title": "WisBlock IoT Education Kit - Smart Industry Quick Start Guide > WisBlock IoT Education Kit - Smart Industry Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock Smart Industry Kit using TTN and Quibitro > Battery Monitoring LoRaWAN Application > LoRaWAN Code for Battery Monitoring > Battery Monitoring LoRaWAN Application Setup [CODE]", "content": "/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void)\n{\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data)\n{\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",", "keywords": ["Arduino IDE", "RAK4631", "Battery Monitoring", "LoRaWAN", "SX126x-Arduino"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **Battery Monitoring** device. Just copy the code below for **Battery Monitoring LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the code</summary>  \n```c\n\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h> //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n#include \"LTC2941.h\"               // Click here to get the library: http://librarymanager/All#GROVE-Coulomb_Counter\n#define BATTERY_CAPACITY2200     // unit:mAh.\n#define CURRENT_CAPACITY  42352    // Set the current battery level to 1800 mAh.\n#define Enable            WB_IO2   // Sensor Power Switch\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define  RAK4631_BOARD true\n#else\n#define  RAK4631_BOARD false\n#endif\n\nlong int coulomb, mAh, percent;\n\nbool doOTAA = true;   // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                     /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                   /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5             /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                      /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                      /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = {LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF};\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = {BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler\n};\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x64, 0xF6, 0xCB, 0x00, 0x35, 0x2D, 0x3B, 0x99, 0x6C, 0xFB, 0x36, 0xE4, 0xCE, 0x1A, 0x08, 0x91};\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = {0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23};\nuint8_t nodeAppsKey[16] = {0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C};\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                     /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];            //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = {m_lora_app_data_buffer, 0, 0, 0, 0}; //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup()\n{\n// Sensor Power Switch\npinMode(Enable, OUTPUT);\ndigitalWrite(Enable, HIGH);\n\npinMode(LED_GREEN, OUTPUT);  // Output LED\npinMode(LED_BLUE, OUTPUT);   // Output LED\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial)\n{\nif ((millis() - timeout) < 5000)\n{\ndelay(100);\n}\nelse\n{\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA)\n{\nSerial.println(\"Type: OTAA\");\n}\nelse\n{\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion)\n{\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA)\n{\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n}\nelse\n{\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0)\n{\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"========================\");\nSerial.println(\"RAK16002 LoRaWAN example\");\nSerial.println(\"========================\");\n\nWire.begin();\n\nltc2941.initialize();\nltc2941.setBatteryFullMAh(BATTERY_CAPACITY , false);\nltc2941.setAccumulatedCharge(CURRENT_CAPACITY); // Set the current battery level to 1800 mAh.\n\n}\n\nvoid loop()\n{\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\ndigitalWrite(LED_BLUE,HIGH);\ndigitalWrite(LED_GREEN, HIGH);\n\n// Measures Coulomb, Charge and Percentage\ncoulomb = ltc2941.getCoulombs();\nmAh = ltc2941.getmAh();\npercent = ltc2941.getPercent();\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\nSerial.print(coulomb);\nSerial.print(\"C   \");\nSerial.print(mAh);\nSerial.print(\"mAh   \");\nSerial.print(percent);\nSerial.println(\"%\");\ndelay(5000);\n\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void)\n{\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void)\n{\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data)\n{\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class)\n{\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void)\n{\nif (lmh_join_status_get() != LMH_SET)\n{\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\ndata = \" Coulomb: \" + String(coulomb) + \" C \" + \" Charge: \" + String(mAh) + \" mAh \" + \" Percentage: \" + String(percent) + \" % \";\nSerial.println(data);\n\nuint32_t coulomb_data = coulomb;\nuint32_t mAh_data = mAh;\nuint16_t percent_data = percent;\n\nm_lora_app_data.buffer[i++] = 0x01;\n\nm_lora_app_data.buffer[i++] = (uint8_t)((coulomb_data  & 0xFF000000) >> 24);\nm_lora_app_data.buffer[i++] = (uint8_t)((coulomb_data  & 0x00FF0000) >> 16);\nm_lora_app_data.buffer[i++] = (uint8_t)((coulomb_data  & 0x0000FF00) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(coulomb_data  & 0x000000FF);\n\nm_lora_app_data.buffer[i++] = (uint8_t)((mAh_data & 0xFF000000) >> 24);\nm_lora_app_data.buffer[i++] = (uint8_t)((mAh_data & 0x00FF0000) >> 16);\nm_lora_app_data.buffer[i++] = (uint8_t)((mAh_data & 0x0000FF00) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(mAh_data & 0x000000FF);\n\nm_lora_app_data.buffer[i++] = (uint8_t)((percent_data) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(percent_data);\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS)\n{\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n}\nelse\n{\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x64, 0xF6, 0xCB, 0x00, 0x35, 0x2D, 0x3B, 0x99, 0x6C, 0xFB, 0x36, 0xE4, 0xCE, 0x1A, 0x08, 0x91};\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "ae602c0011ca360b2066e9744d0db94d", "product_family": "wisblock", "product_id": "kit4-industrial", "category": "How-To", "title": "WisBlock IoT Education Kit - Smart Industry Quick Start Guide > WisBlock IoT Education Kit - Smart Industry Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock Smart Industry Kit using TTN and Quibitro > Battery Monitoring LoRaWAN Application > LoRaWAN Code for Battery Monitoring > Battery Monitoring LoRaWAN Application Setup [CODE]", "content": "{\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}", "keywords": ["Arduino IDE", "RAK4631", "Battery Monitoring", "LoRaWAN", "SX126x-Arduino"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **Battery Monitoring** device. Just copy the code below for **Battery Monitoring LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the code</summary>  \n```c\n\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h> //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n#include \"LTC2941.h\"               // Click here to get the library: http://librarymanager/All#GROVE-Coulomb_Counter\n#define BATTERY_CAPACITY2200     // unit:mAh.\n#define CURRENT_CAPACITY  42352    // Set the current battery level to 1800 mAh.\n#define Enable            WB_IO2   // Sensor Power Switch\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define  RAK4631_BOARD true\n#else\n#define  RAK4631_BOARD false\n#endif\n\nlong int coulomb, mAh, percent;\n\nbool doOTAA = true;   // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                     /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                   /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5             /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                      /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                      /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = {LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF};\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = {BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler\n};\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x64, 0xF6, 0xCB, 0x00, 0x35, 0x2D, 0x3B, 0x99, 0x6C, 0xFB, 0x36, 0xE4, 0xCE, 0x1A, 0x08, 0x91};\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = {0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23};\nuint8_t nodeAppsKey[16] = {0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C};\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                     /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];            //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = {m_lora_app_data_buffer, 0, 0, 0, 0}; //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup()\n{\n// Sensor Power Switch\npinMode(Enable, OUTPUT);\ndigitalWrite(Enable, HIGH);\n\npinMode(LED_GREEN, OUTPUT);  // Output LED\npinMode(LED_BLUE, OUTPUT);   // Output LED\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial)\n{\nif ((millis() - timeout) < 5000)\n{\ndelay(100);\n}\nelse\n{\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA)\n{\nSerial.println(\"Type: OTAA\");\n}\nelse\n{\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion)\n{\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA)\n{\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n}\nelse\n{\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0)\n{\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"========================\");\nSerial.println(\"RAK16002 LoRaWAN example\");\nSerial.println(\"========================\");\n\nWire.begin();\n\nltc2941.initialize();\nltc2941.setBatteryFullMAh(BATTERY_CAPACITY , false);\nltc2941.setAccumulatedCharge(CURRENT_CAPACITY); // Set the current battery level to 1800 mAh.\n\n}\n\nvoid loop()\n{\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\ndigitalWrite(LED_BLUE,HIGH);\ndigitalWrite(LED_GREEN, HIGH);\n\n// Measures Coulomb, Charge and Percentage\ncoulomb = ltc2941.getCoulombs();\nmAh = ltc2941.getmAh();\npercent = ltc2941.getPercent();\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\nSerial.print(coulomb);\nSerial.print(\"C   \");\nSerial.print(mAh);\nSerial.print(\"mAh   \");\nSerial.print(percent);\nSerial.println(\"%\");\ndelay(5000);\n\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void)\n{\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void)\n{\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data)\n{\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class)\n{\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void)\n{\nif (lmh_join_status_get() != LMH_SET)\n{\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\ndata = \" Coulomb: \" + String(coulomb) + \" C \" + \" Charge: \" + String(mAh) + \" mAh \" + \" Percentage: \" + String(percent) + \" % \";\nSerial.println(data);\n\nuint32_t coulomb_data = coulomb;\nuint32_t mAh_data = mAh;\nuint16_t percent_data = percent;\n\nm_lora_app_data.buffer[i++] = 0x01;\n\nm_lora_app_data.buffer[i++] = (uint8_t)((coulomb_data  & 0xFF000000) >> 24);\nm_lora_app_data.buffer[i++] = (uint8_t)((coulomb_data  & 0x00FF0000) >> 16);\nm_lora_app_data.buffer[i++] = (uint8_t)((coulomb_data  & 0x0000FF00) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(coulomb_data  & 0x000000FF);\n\nm_lora_app_data.buffer[i++] = (uint8_t)((mAh_data & 0xFF000000) >> 24);\nm_lora_app_data.buffer[i++] = (uint8_t)((mAh_data & 0x00FF0000) >> 16);\nm_lora_app_data.buffer[i++] = (uint8_t)((mAh_data & 0x0000FF00) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(mAh_data & 0x000000FF);\n\nm_lora_app_data.buffer[i++] = (uint8_t)((percent_data) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(percent_data);\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS)\n{\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n}\nelse\n{\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x64, 0xF6, 0xCB, 0x00, 0x35, 0x2D, 0x3B, 0x99, 0x6C, 0xFB, 0x36, 0xE4, 0xCE, 0x1A, 0x08, 0x91};\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "7038aa7a543682997c3d91038a3b7ef1", "product_family": "wisblock", "product_id": "kit4-industrial", "category": "How-To", "title": "WisBlock IoT Education Kit - Smart Industry Quick Start Guide > WisBlock IoT Education Kit - Smart Industry Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock Smart Industry Kit using TTN and Quibitro > Battery Monitoring LoRaWAN Application > LoRaWAN Code for Battery Monitoring > Battery Monitoring LoRaWAN Application Setup [CODE]", "content": "void lorawan_confirm_class_handler(DeviceClass_t Class)\n{\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void)\n{\nif (lmh_join_status_get() != LMH_SET)\n{\n//Not joined, try again later\nreturn;\n}", "keywords": ["Arduino IDE", "RAK4631", "Battery Monitoring", "LoRaWAN", "SX126x-Arduino"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **Battery Monitoring** device. Just copy the code below for **Battery Monitoring LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the code</summary>  \n```c\n\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h> //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n#include \"LTC2941.h\"               // Click here to get the library: http://librarymanager/All#GROVE-Coulomb_Counter\n#define BATTERY_CAPACITY2200     // unit:mAh.\n#define CURRENT_CAPACITY  42352    // Set the current battery level to 1800 mAh.\n#define Enable            WB_IO2   // Sensor Power Switch\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define  RAK4631_BOARD true\n#else\n#define  RAK4631_BOARD false\n#endif\n\nlong int coulomb, mAh, percent;\n\nbool doOTAA = true;   // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                     /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                   /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5             /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                      /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                      /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = {LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF};\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = {BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler\n};\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x64, 0xF6, 0xCB, 0x00, 0x35, 0x2D, 0x3B, 0x99, 0x6C, 0xFB, 0x36, 0xE4, 0xCE, 0x1A, 0x08, 0x91};\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = {0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23};\nuint8_t nodeAppsKey[16] = {0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C};\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                     /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];            //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = {m_lora_app_data_buffer, 0, 0, 0, 0}; //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup()\n{\n// Sensor Power Switch\npinMode(Enable, OUTPUT);\ndigitalWrite(Enable, HIGH);\n\npinMode(LED_GREEN, OUTPUT);  // Output LED\npinMode(LED_BLUE, OUTPUT);   // Output LED\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial)\n{\nif ((millis() - timeout) < 5000)\n{\ndelay(100);\n}\nelse\n{\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA)\n{\nSerial.println(\"Type: OTAA\");\n}\nelse\n{\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion)\n{\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA)\n{\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n}\nelse\n{\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0)\n{\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"========================\");\nSerial.println(\"RAK16002 LoRaWAN example\");\nSerial.println(\"========================\");\n\nWire.begin();\n\nltc2941.initialize();\nltc2941.setBatteryFullMAh(BATTERY_CAPACITY , false);\nltc2941.setAccumulatedCharge(CURRENT_CAPACITY); // Set the current battery level to 1800 mAh.\n\n}\n\nvoid loop()\n{\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\ndigitalWrite(LED_BLUE,HIGH);\ndigitalWrite(LED_GREEN, HIGH);\n\n// Measures Coulomb, Charge and Percentage\ncoulomb = ltc2941.getCoulombs();\nmAh = ltc2941.getmAh();\npercent = ltc2941.getPercent();\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\nSerial.print(coulomb);\nSerial.print(\"C   \");\nSerial.print(mAh);\nSerial.print(\"mAh   \");\nSerial.print(percent);\nSerial.println(\"%\");\ndelay(5000);\n\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void)\n{\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void)\n{\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data)\n{\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class)\n{\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void)\n{\nif (lmh_join_status_get() != LMH_SET)\n{\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\ndata = \" Coulomb: \" + String(coulomb) + \" C \" + \" Charge: \" + String(mAh) + \" mAh \" + \" Percentage: \" + String(percent) + \" % \";\nSerial.println(data);\n\nuint32_t coulomb_data = coulomb;\nuint32_t mAh_data = mAh;\nuint16_t percent_data = percent;\n\nm_lora_app_data.buffer[i++] = 0x01;\n\nm_lora_app_data.buffer[i++] = (uint8_t)((coulomb_data  & 0xFF000000) >> 24);\nm_lora_app_data.buffer[i++] = (uint8_t)((coulomb_data  & 0x00FF0000) >> 16);\nm_lora_app_data.buffer[i++] = (uint8_t)((coulomb_data  & 0x0000FF00) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(coulomb_data  & 0x000000FF);\n\nm_lora_app_data.buffer[i++] = (uint8_t)((mAh_data & 0xFF000000) >> 24);\nm_lora_app_data.buffer[i++] = (uint8_t)((mAh_data & 0x00FF0000) >> 16);\nm_lora_app_data.buffer[i++] = (uint8_t)((mAh_data & 0x0000FF00) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(mAh_data & 0x000000FF);\n\nm_lora_app_data.buffer[i++] = (uint8_t)((percent_data) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(percent_data);\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS)\n{\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n}\nelse\n{\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x64, 0xF6, 0xCB, 0x00, 0x35, 0x2D, 0x3B, 0x99, 0x6C, 0xFB, 0x36, 0xE4, 0xCE, 0x1A, 0x08, 0x91};\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "37200c3b572ac72bbbb6f05ec6571b67", "product_family": "wisblock", "product_id": "kit4-industrial", "category": "How-To", "title": "WisBlock IoT Education Kit - Smart Industry Quick Start Guide > WisBlock IoT Education Kit - Smart Industry Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock Smart Industry Kit using TTN and Quibitro > Battery Monitoring LoRaWAN Application > LoRaWAN Code for Battery Monitoring > Battery Monitoring LoRaWAN Application Setup [CODE]", "content": "Serial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\ndata = \" Coulomb: \" + String(coulomb) + \" C \" + \" Charge: \" + String(mAh) + \" mAh \" + \" Percentage: \" + String(percent) + \" % \";\nSerial.println(data);\n\nuint32_t coulomb_data = coulomb;\nuint32_t mAh_data = mAh;\nuint16_t percent_data = percent;\n\nm_lora_app_data.buffer[i++] = 0x01;", "keywords": ["Arduino IDE", "RAK4631", "Battery Monitoring", "LoRaWAN", "SX126x-Arduino"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **Battery Monitoring** device. Just copy the code below for **Battery Monitoring LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the code</summary>  \n```c\n\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h> //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n#include \"LTC2941.h\"               // Click here to get the library: http://librarymanager/All#GROVE-Coulomb_Counter\n#define BATTERY_CAPACITY2200     // unit:mAh.\n#define CURRENT_CAPACITY  42352    // Set the current battery level to 1800 mAh.\n#define Enable            WB_IO2   // Sensor Power Switch\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define  RAK4631_BOARD true\n#else\n#define  RAK4631_BOARD false\n#endif\n\nlong int coulomb, mAh, percent;\n\nbool doOTAA = true;   // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                     /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                   /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5             /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                      /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                      /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = {LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF};\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = {BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler\n};\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x64, 0xF6, 0xCB, 0x00, 0x35, 0x2D, 0x3B, 0x99, 0x6C, 0xFB, 0x36, 0xE4, 0xCE, 0x1A, 0x08, 0x91};\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = {0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23};\nuint8_t nodeAppsKey[16] = {0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C};\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                     /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];            //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = {m_lora_app_data_buffer, 0, 0, 0, 0}; //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup()\n{\n// Sensor Power Switch\npinMode(Enable, OUTPUT);\ndigitalWrite(Enable, HIGH);\n\npinMode(LED_GREEN, OUTPUT);  // Output LED\npinMode(LED_BLUE, OUTPUT);   // Output LED\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial)\n{\nif ((millis() - timeout) < 5000)\n{\ndelay(100);\n}\nelse\n{\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA)\n{\nSerial.println(\"Type: OTAA\");\n}\nelse\n{\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion)\n{\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA)\n{\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n}\nelse\n{\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0)\n{\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"========================\");\nSerial.println(\"RAK16002 LoRaWAN example\");\nSerial.println(\"========================\");\n\nWire.begin();\n\nltc2941.initialize();\nltc2941.setBatteryFullMAh(BATTERY_CAPACITY , false);\nltc2941.setAccumulatedCharge(CURRENT_CAPACITY); // Set the current battery level to 1800 mAh.\n\n}\n\nvoid loop()\n{\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\ndigitalWrite(LED_BLUE,HIGH);\ndigitalWrite(LED_GREEN, HIGH);\n\n// Measures Coulomb, Charge and Percentage\ncoulomb = ltc2941.getCoulombs();\nmAh = ltc2941.getmAh();\npercent = ltc2941.getPercent();\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\nSerial.print(coulomb);\nSerial.print(\"C   \");\nSerial.print(mAh);\nSerial.print(\"mAh   \");\nSerial.print(percent);\nSerial.println(\"%\");\ndelay(5000);\n\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void)\n{\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void)\n{\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data)\n{\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class)\n{\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void)\n{\nif (lmh_join_status_get() != LMH_SET)\n{\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\ndata = \" Coulomb: \" + String(coulomb) + \" C \" + \" Charge: \" + String(mAh) + \" mAh \" + \" Percentage: \" + String(percent) + \" % \";\nSerial.println(data);\n\nuint32_t coulomb_data = coulomb;\nuint32_t mAh_data = mAh;\nuint16_t percent_data = percent;\n\nm_lora_app_data.buffer[i++] = 0x01;\n\nm_lora_app_data.buffer[i++] = (uint8_t)((coulomb_data  & 0xFF000000) >> 24);\nm_lora_app_data.buffer[i++] = (uint8_t)((coulomb_data  & 0x00FF0000) >> 16);\nm_lora_app_data.buffer[i++] = (uint8_t)((coulomb_data  & 0x0000FF00) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(coulomb_data  & 0x000000FF);\n\nm_lora_app_data.buffer[i++] = (uint8_t)((mAh_data & 0xFF000000) >> 24);\nm_lora_app_data.buffer[i++] = (uint8_t)((mAh_data & 0x00FF0000) >> 16);\nm_lora_app_data.buffer[i++] = (uint8_t)((mAh_data & 0x0000FF00) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(mAh_data & 0x000000FF);\n\nm_lora_app_data.buffer[i++] = (uint8_t)((percent_data) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(percent_data);\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS)\n{\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n}\nelse\n{\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x64, 0xF6, 0xCB, 0x00, 0x35, 0x2D, 0x3B, 0x99, 0x6C, 0xFB, 0x36, 0xE4, 0xCE, 0x1A, 0x08, 0x91};\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "1e95e9800a0d5ff3041ffe424c0e8c5b", "product_family": "wisblock", "product_id": "kit4-industrial", "category": "How-To", "title": "WisBlock IoT Education Kit - Smart Industry Quick Start Guide > WisBlock IoT Education Kit - Smart Industry Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock Smart Industry Kit using TTN and Quibitro > Battery Monitoring LoRaWAN Application > LoRaWAN Code for Battery Monitoring > Battery Monitoring LoRaWAN Application Setup [CODE]", "content": "m_lora_app_data.buffer[i++] = 0x01;\n\nm_lora_app_data.buffer[i++] = (uint8_t)((coulomb_data  & 0xFF000000) >> 24);\nm_lora_app_data.buffer[i++] = (uint8_t)((coulomb_data  & 0x00FF0000) >> 16);\nm_lora_app_data.buffer[i++] = (uint8_t)((coulomb_data  & 0x0000FF00) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(coulomb_data  & 0x000000FF);", "keywords": ["Arduino IDE", "RAK4631", "Battery Monitoring", "LoRaWAN", "SX126x-Arduino"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **Battery Monitoring** device. Just copy the code below for **Battery Monitoring LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the code</summary>  \n```c\n\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h> //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n#include \"LTC2941.h\"               // Click here to get the library: http://librarymanager/All#GROVE-Coulomb_Counter\n#define BATTERY_CAPACITY2200     // unit:mAh.\n#define CURRENT_CAPACITY  42352    // Set the current battery level to 1800 mAh.\n#define Enable            WB_IO2   // Sensor Power Switch\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define  RAK4631_BOARD true\n#else\n#define  RAK4631_BOARD false\n#endif\n\nlong int coulomb, mAh, percent;\n\nbool doOTAA = true;   // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                     /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                   /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5             /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                      /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                      /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = {LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF};\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = {BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler\n};\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x64, 0xF6, 0xCB, 0x00, 0x35, 0x2D, 0x3B, 0x99, 0x6C, 0xFB, 0x36, 0xE4, 0xCE, 0x1A, 0x08, 0x91};\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = {0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23};\nuint8_t nodeAppsKey[16] = {0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C};\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                     /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];            //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = {m_lora_app_data_buffer, 0, 0, 0, 0}; //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup()\n{\n// Sensor Power Switch\npinMode(Enable, OUTPUT);\ndigitalWrite(Enable, HIGH);\n\npinMode(LED_GREEN, OUTPUT);  // Output LED\npinMode(LED_BLUE, OUTPUT);   // Output LED\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial)\n{\nif ((millis() - timeout) < 5000)\n{\ndelay(100);\n}\nelse\n{\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA)\n{\nSerial.println(\"Type: OTAA\");\n}\nelse\n{\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion)\n{\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA)\n{\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n}\nelse\n{\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0)\n{\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"========================\");\nSerial.println(\"RAK16002 LoRaWAN example\");\nSerial.println(\"========================\");\n\nWire.begin();\n\nltc2941.initialize();\nltc2941.setBatteryFullMAh(BATTERY_CAPACITY , false);\nltc2941.setAccumulatedCharge(CURRENT_CAPACITY); // Set the current battery level to 1800 mAh.\n\n}\n\nvoid loop()\n{\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\ndigitalWrite(LED_BLUE,HIGH);\ndigitalWrite(LED_GREEN, HIGH);\n\n// Measures Coulomb, Charge and Percentage\ncoulomb = ltc2941.getCoulombs();\nmAh = ltc2941.getmAh();\npercent = ltc2941.getPercent();\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\nSerial.print(coulomb);\nSerial.print(\"C   \");\nSerial.print(mAh);\nSerial.print(\"mAh   \");\nSerial.print(percent);\nSerial.println(\"%\");\ndelay(5000);\n\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void)\n{\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void)\n{\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data)\n{\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class)\n{\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void)\n{\nif (lmh_join_status_get() != LMH_SET)\n{\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\ndata = \" Coulomb: \" + String(coulomb) + \" C \" + \" Charge: \" + String(mAh) + \" mAh \" + \" Percentage: \" + String(percent) + \" % \";\nSerial.println(data);\n\nuint32_t coulomb_data = coulomb;\nuint32_t mAh_data = mAh;\nuint16_t percent_data = percent;\n\nm_lora_app_data.buffer[i++] = 0x01;\n\nm_lora_app_data.buffer[i++] = (uint8_t)((coulomb_data  & 0xFF000000) >> 24);\nm_lora_app_data.buffer[i++] = (uint8_t)((coulomb_data  & 0x00FF0000) >> 16);\nm_lora_app_data.buffer[i++] = (uint8_t)((coulomb_data  & 0x0000FF00) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(coulomb_data  & 0x000000FF);\n\nm_lora_app_data.buffer[i++] = (uint8_t)((mAh_data & 0xFF000000) >> 24);\nm_lora_app_data.buffer[i++] = (uint8_t)((mAh_data & 0x00FF0000) >> 16);\nm_lora_app_data.buffer[i++] = (uint8_t)((mAh_data & 0x0000FF00) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(mAh_data & 0x000000FF);\n\nm_lora_app_data.buffer[i++] = (uint8_t)((percent_data) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(percent_data);\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS)\n{\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n}\nelse\n{\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x64, 0xF6, 0xCB, 0x00, 0x35, 0x2D, 0x3B, 0x99, 0x6C, 0xFB, 0x36, 0xE4, 0xCE, 0x1A, 0x08, 0x91};\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "3c807b752ab5947b7f5bb9fc2f6e7fe8", "product_family": "wisblock", "product_id": "kit4-industrial", "category": "How-To", "title": "WisBlock IoT Education Kit - Smart Industry Quick Start Guide > WisBlock IoT Education Kit - Smart Industry Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock Smart Industry Kit using TTN and Quibitro > Battery Monitoring LoRaWAN Application > LoRaWAN Code for Battery Monitoring > Battery Monitoring LoRaWAN Application Setup [CODE]", "content": "m_lora_app_data.buffer[i++] = (uint8_t)((mAh_data & 0xFF000000) >> 24);\nm_lora_app_data.buffer[i++] = (uint8_t)((mAh_data & 0x00FF0000) >> 16);\nm_lora_app_data.buffer[i++] = (uint8_t)((mAh_data & 0x0000FF00) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(mAh_data & 0x000000FF);\n\nm_lora_app_data.buffer[i++] = (uint8_t)((percent_data) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(percent_data);\n\nm_lora_app_data.buffsize = i;", "keywords": ["Arduino IDE", "RAK4631", "Battery Monitoring", "LoRaWAN", "SX126x-Arduino"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **Battery Monitoring** device. Just copy the code below for **Battery Monitoring LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the code</summary>  \n```c\n\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h> //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n#include \"LTC2941.h\"               // Click here to get the library: http://librarymanager/All#GROVE-Coulomb_Counter\n#define BATTERY_CAPACITY2200     // unit:mAh.\n#define CURRENT_CAPACITY  42352    // Set the current battery level to 1800 mAh.\n#define Enable            WB_IO2   // Sensor Power Switch\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define  RAK4631_BOARD true\n#else\n#define  RAK4631_BOARD false\n#endif\n\nlong int coulomb, mAh, percent;\n\nbool doOTAA = true;   // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                     /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                   /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5             /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                      /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                      /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = {LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF};\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = {BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler\n};\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x64, 0xF6, 0xCB, 0x00, 0x35, 0x2D, 0x3B, 0x99, 0x6C, 0xFB, 0x36, 0xE4, 0xCE, 0x1A, 0x08, 0x91};\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = {0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23};\nuint8_t nodeAppsKey[16] = {0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C};\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                     /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];            //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = {m_lora_app_data_buffer, 0, 0, 0, 0}; //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup()\n{\n// Sensor Power Switch\npinMode(Enable, OUTPUT);\ndigitalWrite(Enable, HIGH);\n\npinMode(LED_GREEN, OUTPUT);  // Output LED\npinMode(LED_BLUE, OUTPUT);   // Output LED\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial)\n{\nif ((millis() - timeout) < 5000)\n{\ndelay(100);\n}\nelse\n{\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA)\n{\nSerial.println(\"Type: OTAA\");\n}\nelse\n{\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion)\n{\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA)\n{\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n}\nelse\n{\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0)\n{\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"========================\");\nSerial.println(\"RAK16002 LoRaWAN example\");\nSerial.println(\"========================\");\n\nWire.begin();\n\nltc2941.initialize();\nltc2941.setBatteryFullMAh(BATTERY_CAPACITY , false);\nltc2941.setAccumulatedCharge(CURRENT_CAPACITY); // Set the current battery level to 1800 mAh.\n\n}\n\nvoid loop()\n{\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\ndigitalWrite(LED_BLUE,HIGH);\ndigitalWrite(LED_GREEN, HIGH);\n\n// Measures Coulomb, Charge and Percentage\ncoulomb = ltc2941.getCoulombs();\nmAh = ltc2941.getmAh();\npercent = ltc2941.getPercent();\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\nSerial.print(coulomb);\nSerial.print(\"C   \");\nSerial.print(mAh);\nSerial.print(\"mAh   \");\nSerial.print(percent);\nSerial.println(\"%\");\ndelay(5000);\n\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void)\n{\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void)\n{\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data)\n{\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class)\n{\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void)\n{\nif (lmh_join_status_get() != LMH_SET)\n{\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\ndata = \" Coulomb: \" + String(coulomb) + \" C \" + \" Charge: \" + String(mAh) + \" mAh \" + \" Percentage: \" + String(percent) + \" % \";\nSerial.println(data);\n\nuint32_t coulomb_data = coulomb;\nuint32_t mAh_data = mAh;\nuint16_t percent_data = percent;\n\nm_lora_app_data.buffer[i++] = 0x01;\n\nm_lora_app_data.buffer[i++] = (uint8_t)((coulomb_data  & 0xFF000000) >> 24);\nm_lora_app_data.buffer[i++] = (uint8_t)((coulomb_data  & 0x00FF0000) >> 16);\nm_lora_app_data.buffer[i++] = (uint8_t)((coulomb_data  & 0x0000FF00) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(coulomb_data  & 0x000000FF);\n\nm_lora_app_data.buffer[i++] = (uint8_t)((mAh_data & 0xFF000000) >> 24);\nm_lora_app_data.buffer[i++] = (uint8_t)((mAh_data & 0x00FF0000) >> 16);\nm_lora_app_data.buffer[i++] = (uint8_t)((mAh_data & 0x0000FF00) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(mAh_data & 0x000000FF);\n\nm_lora_app_data.buffer[i++] = (uint8_t)((percent_data) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(percent_data);\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS)\n{\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n}\nelse\n{\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x64, 0xF6, 0xCB, 0x00, 0x35, 0x2D, 0x3B, 0x99, 0x6C, 0xFB, 0x36, 0xE4, 0xCE, 0x1A, 0x08, 0x91};\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "de4640eca3aa1463a07de2cf3d425a79", "product_family": "wisblock", "product_id": "kit4-industrial", "category": "How-To", "title": "WisBlock IoT Education Kit - Smart Industry Quick Start Guide > WisBlock IoT Education Kit - Smart Industry Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock Smart Industry Kit using TTN and Quibitro > Battery Monitoring LoRaWAN Application > LoRaWAN Code for Battery Monitoring > Battery Monitoring LoRaWAN Application Setup [CODE]", "content": "m_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS)\n{\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n}\nelse\n{\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}", "keywords": ["Arduino IDE", "RAK4631", "Battery Monitoring", "LoRaWAN", "SX126x-Arduino"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **Battery Monitoring** device. Just copy the code below for **Battery Monitoring LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the code</summary>  \n```c\n\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h> //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n#include \"LTC2941.h\"               // Click here to get the library: http://librarymanager/All#GROVE-Coulomb_Counter\n#define BATTERY_CAPACITY2200     // unit:mAh.\n#define CURRENT_CAPACITY  42352    // Set the current battery level to 1800 mAh.\n#define Enable            WB_IO2   // Sensor Power Switch\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define  RAK4631_BOARD true\n#else\n#define  RAK4631_BOARD false\n#endif\n\nlong int coulomb, mAh, percent;\n\nbool doOTAA = true;   // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                     /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                   /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5             /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                      /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                      /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = {LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF};\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = {BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler\n};\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x64, 0xF6, 0xCB, 0x00, 0x35, 0x2D, 0x3B, 0x99, 0x6C, 0xFB, 0x36, 0xE4, 0xCE, 0x1A, 0x08, 0x91};\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = {0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23};\nuint8_t nodeAppsKey[16] = {0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C};\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                     /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];            //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = {m_lora_app_data_buffer, 0, 0, 0, 0}; //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup()\n{\n// Sensor Power Switch\npinMode(Enable, OUTPUT);\ndigitalWrite(Enable, HIGH);\n\npinMode(LED_GREEN, OUTPUT);  // Output LED\npinMode(LED_BLUE, OUTPUT);   // Output LED\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial)\n{\nif ((millis() - timeout) < 5000)\n{\ndelay(100);\n}\nelse\n{\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA)\n{\nSerial.println(\"Type: OTAA\");\n}\nelse\n{\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion)\n{\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA)\n{\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n}\nelse\n{\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0)\n{\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"========================\");\nSerial.println(\"RAK16002 LoRaWAN example\");\nSerial.println(\"========================\");\n\nWire.begin();\n\nltc2941.initialize();\nltc2941.setBatteryFullMAh(BATTERY_CAPACITY , false);\nltc2941.setAccumulatedCharge(CURRENT_CAPACITY); // Set the current battery level to 1800 mAh.\n\n}\n\nvoid loop()\n{\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\ndigitalWrite(LED_BLUE,HIGH);\ndigitalWrite(LED_GREEN, HIGH);\n\n// Measures Coulomb, Charge and Percentage\ncoulomb = ltc2941.getCoulombs();\nmAh = ltc2941.getmAh();\npercent = ltc2941.getPercent();\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\nSerial.print(coulomb);\nSerial.print(\"C   \");\nSerial.print(mAh);\nSerial.print(\"mAh   \");\nSerial.print(percent);\nSerial.println(\"%\");\ndelay(5000);\n\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void)\n{\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void)\n{\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data)\n{\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class)\n{\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void)\n{\nif (lmh_join_status_get() != LMH_SET)\n{\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\ndata = \" Coulomb: \" + String(coulomb) + \" C \" + \" Charge: \" + String(mAh) + \" mAh \" + \" Percentage: \" + String(percent) + \" % \";\nSerial.println(data);\n\nuint32_t coulomb_data = coulomb;\nuint32_t mAh_data = mAh;\nuint16_t percent_data = percent;\n\nm_lora_app_data.buffer[i++] = 0x01;\n\nm_lora_app_data.buffer[i++] = (uint8_t)((coulomb_data  & 0xFF000000) >> 24);\nm_lora_app_data.buffer[i++] = (uint8_t)((coulomb_data  & 0x00FF0000) >> 16);\nm_lora_app_data.buffer[i++] = (uint8_t)((coulomb_data  & 0x0000FF00) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(coulomb_data  & 0x000000FF);\n\nm_lora_app_data.buffer[i++] = (uint8_t)((mAh_data & 0xFF000000) >> 24);\nm_lora_app_data.buffer[i++] = (uint8_t)((mAh_data & 0x00FF0000) >> 16);\nm_lora_app_data.buffer[i++] = (uint8_t)((mAh_data & 0x0000FF00) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(mAh_data & 0x000000FF);\n\nm_lora_app_data.buffer[i++] = (uint8_t)((percent_data) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(percent_data);\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS)\n{\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n}\nelse\n{\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x64, 0xF6, 0xCB, 0x00, 0x35, 0x2D, 0x3B, 0x99, 0x6C, 0xFB, 0x36, 0xE4, 0xCE, 0x1A, 0x08, 0x91};\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "1d4b4de1e91e6d4bdfe2e46d619569b0", "product_family": "wisblock", "product_id": "kit4-industrial", "category": "How-To", "title": "WisBlock IoT Education Kit - Smart Industry Quick Start Guide > WisBlock IoT Education Kit - Smart Industry Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock Smart Industry Kit using TTN and Quibitro > Battery Monitoring LoRaWAN Application > LoRaWAN Code for Battery Monitoring > Battery Monitoring LoRaWAN Application Setup [CODE]", "content": "```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.", "keywords": ["Arduino IDE", "RAK4631", "Battery Monitoring", "LoRaWAN", "SX126x-Arduino"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **Battery Monitoring** device. Just copy the code below for **Battery Monitoring LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the code</summary>  \n```c\n\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h> //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n#include \"LTC2941.h\"               // Click here to get the library: http://librarymanager/All#GROVE-Coulomb_Counter\n#define BATTERY_CAPACITY2200     // unit:mAh.\n#define CURRENT_CAPACITY  42352    // Set the current battery level to 1800 mAh.\n#define Enable            WB_IO2   // Sensor Power Switch\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define  RAK4631_BOARD true\n#else\n#define  RAK4631_BOARD false\n#endif\n\nlong int coulomb, mAh, percent;\n\nbool doOTAA = true;   // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                     /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                   /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5             /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                      /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                      /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = {LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF};\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = {BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler\n};\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x64, 0xF6, 0xCB, 0x00, 0x35, 0x2D, 0x3B, 0x99, 0x6C, 0xFB, 0x36, 0xE4, 0xCE, 0x1A, 0x08, 0x91};\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = {0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23};\nuint8_t nodeAppsKey[16] = {0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C};\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                     /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];            //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = {m_lora_app_data_buffer, 0, 0, 0, 0}; //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup()\n{\n// Sensor Power Switch\npinMode(Enable, OUTPUT);\ndigitalWrite(Enable, HIGH);\n\npinMode(LED_GREEN, OUTPUT);  // Output LED\npinMode(LED_BLUE, OUTPUT);   // Output LED\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial)\n{\nif ((millis() - timeout) < 5000)\n{\ndelay(100);\n}\nelse\n{\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA)\n{\nSerial.println(\"Type: OTAA\");\n}\nelse\n{\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion)\n{\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA)\n{\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n}\nelse\n{\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0)\n{\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"========================\");\nSerial.println(\"RAK16002 LoRaWAN example\");\nSerial.println(\"========================\");\n\nWire.begin();\n\nltc2941.initialize();\nltc2941.setBatteryFullMAh(BATTERY_CAPACITY , false);\nltc2941.setAccumulatedCharge(CURRENT_CAPACITY); // Set the current battery level to 1800 mAh.\n\n}\n\nvoid loop()\n{\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\ndigitalWrite(LED_BLUE,HIGH);\ndigitalWrite(LED_GREEN, HIGH);\n\n// Measures Coulomb, Charge and Percentage\ncoulomb = ltc2941.getCoulombs();\nmAh = ltc2941.getmAh();\npercent = ltc2941.getPercent();\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\nSerial.print(coulomb);\nSerial.print(\"C   \");\nSerial.print(mAh);\nSerial.print(\"mAh   \");\nSerial.print(percent);\nSerial.println(\"%\");\ndelay(5000);\n\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void)\n{\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void)\n{\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data)\n{\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class)\n{\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void)\n{\nif (lmh_join_status_get() != LMH_SET)\n{\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\ndata = \" Coulomb: \" + String(coulomb) + \" C \" + \" Charge: \" + String(mAh) + \" mAh \" + \" Percentage: \" + String(percent) + \" % \";\nSerial.println(data);\n\nuint32_t coulomb_data = coulomb;\nuint32_t mAh_data = mAh;\nuint16_t percent_data = percent;\n\nm_lora_app_data.buffer[i++] = 0x01;\n\nm_lora_app_data.buffer[i++] = (uint8_t)((coulomb_data  & 0xFF000000) >> 24);\nm_lora_app_data.buffer[i++] = (uint8_t)((coulomb_data  & 0x00FF0000) >> 16);\nm_lora_app_data.buffer[i++] = (uint8_t)((coulomb_data  & 0x0000FF00) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(coulomb_data  & 0x000000FF);\n\nm_lora_app_data.buffer[i++] = (uint8_t)((mAh_data & 0xFF000000) >> 24);\nm_lora_app_data.buffer[i++] = (uint8_t)((mAh_data & 0x00FF0000) >> 16);\nm_lora_app_data.buffer[i++] = (uint8_t)((mAh_data & 0x0000FF00) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(mAh_data & 0x000000FF);\n\nm_lora_app_data.buffer[i++] = (uint8_t)((percent_data) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(percent_data);\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS)\n{\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n}\nelse\n{\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x64, 0xF6, 0xCB, 0x00, 0x35, 0x2D, 0x3B, 0x99, 0x6C, 0xFB, 0x36, 0xE4, 0xCE, 0x1A, 0x08, 0x91};\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "afba98e9775af3728461095e6591fd6c", "product_family": "wisblock", "product_id": "kit4-industrial", "category": "How-To", "title": "WisBlock IoT Education Kit - Smart Industry Quick Start Guide > WisBlock IoT Education Kit - Smart Industry Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock Smart Industry Kit using TTN and Quibitro > Battery Monitoring LoRaWAN Application > LoRaWAN Code for Battery Monitoring > Battery Monitoring LoRaWAN Application Setup [CODE]", "content": "- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |", "keywords": ["Arduino IDE", "RAK4631", "Battery Monitoring", "LoRaWAN", "SX126x-Arduino"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **Battery Monitoring** device. Just copy the code below for **Battery Monitoring LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the code</summary>  \n```c\n\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h> //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n#include \"LTC2941.h\"               // Click here to get the library: http://librarymanager/All#GROVE-Coulomb_Counter\n#define BATTERY_CAPACITY2200     // unit:mAh.\n#define CURRENT_CAPACITY  42352    // Set the current battery level to 1800 mAh.\n#define Enable            WB_IO2   // Sensor Power Switch\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define  RAK4631_BOARD true\n#else\n#define  RAK4631_BOARD false\n#endif\n\nlong int coulomb, mAh, percent;\n\nbool doOTAA = true;   // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                     /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                   /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5             /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                      /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                      /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = {LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF};\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = {BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler\n};\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x64, 0xF6, 0xCB, 0x00, 0x35, 0x2D, 0x3B, 0x99, 0x6C, 0xFB, 0x36, 0xE4, 0xCE, 0x1A, 0x08, 0x91};\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = {0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23};\nuint8_t nodeAppsKey[16] = {0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C};\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                     /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];            //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = {m_lora_app_data_buffer, 0, 0, 0, 0}; //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup()\n{\n// Sensor Power Switch\npinMode(Enable, OUTPUT);\ndigitalWrite(Enable, HIGH);\n\npinMode(LED_GREEN, OUTPUT);  // Output LED\npinMode(LED_BLUE, OUTPUT);   // Output LED\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial)\n{\nif ((millis() - timeout) < 5000)\n{\ndelay(100);\n}\nelse\n{\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA)\n{\nSerial.println(\"Type: OTAA\");\n}\nelse\n{\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion)\n{\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA)\n{\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n}\nelse\n{\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0)\n{\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"========================\");\nSerial.println(\"RAK16002 LoRaWAN example\");\nSerial.println(\"========================\");\n\nWire.begin();\n\nltc2941.initialize();\nltc2941.setBatteryFullMAh(BATTERY_CAPACITY , false);\nltc2941.setAccumulatedCharge(CURRENT_CAPACITY); // Set the current battery level to 1800 mAh.\n\n}\n\nvoid loop()\n{\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\ndigitalWrite(LED_BLUE,HIGH);\ndigitalWrite(LED_GREEN, HIGH);\n\n// Measures Coulomb, Charge and Percentage\ncoulomb = ltc2941.getCoulombs();\nmAh = ltc2941.getmAh();\npercent = ltc2941.getPercent();\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\nSerial.print(coulomb);\nSerial.print(\"C   \");\nSerial.print(mAh);\nSerial.print(\"mAh   \");\nSerial.print(percent);\nSerial.println(\"%\");\ndelay(5000);\n\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void)\n{\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void)\n{\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data)\n{\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class)\n{\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void)\n{\nif (lmh_join_status_get() != LMH_SET)\n{\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\ndata = \" Coulomb: \" + String(coulomb) + \" C \" + \" Charge: \" + String(mAh) + \" mAh \" + \" Percentage: \" + String(percent) + \" % \";\nSerial.println(data);\n\nuint32_t coulomb_data = coulomb;\nuint32_t mAh_data = mAh;\nuint16_t percent_data = percent;\n\nm_lora_app_data.buffer[i++] = 0x01;\n\nm_lora_app_data.buffer[i++] = (uint8_t)((coulomb_data  & 0xFF000000) >> 24);\nm_lora_app_data.buffer[i++] = (uint8_t)((coulomb_data  & 0x00FF0000) >> 16);\nm_lora_app_data.buffer[i++] = (uint8_t)((coulomb_data  & 0x0000FF00) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(coulomb_data  & 0x000000FF);\n\nm_lora_app_data.buffer[i++] = (uint8_t)((mAh_data & 0xFF000000) >> 24);\nm_lora_app_data.buffer[i++] = (uint8_t)((mAh_data & 0x00FF0000) >> 16);\nm_lora_app_data.buffer[i++] = (uint8_t)((mAh_data & 0x0000FF00) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(mAh_data & 0x000000FF);\n\nm_lora_app_data.buffer[i++] = (uint8_t)((percent_data) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(percent_data);\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS)\n{\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n}\nelse\n{\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x64, 0xF6, 0xCB, 0x00, 0x35, 0x2D, 0x3B, 0x99, 0x6C, 0xFB, 0x36, 0xE4, 0xCE, 0x1A, 0x08, 0x91};\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "32a54ed9facd6c6c80887588160997e9", "product_family": "wisblock", "product_id": "kit4-industrial", "category": "How-To", "title": "WisBlock IoT Education Kit - Smart Industry Quick Start Guide > WisBlock IoT Education Kit - Smart Industry Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock Smart Industry Kit using TTN and Quibitro > Battery Monitoring LoRaWAN Application > LoRaWAN Code for Battery Monitoring > Battery Monitoring LoRaWAN Application Setup [CODE]", "content": "|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |", "keywords": ["Arduino IDE", "RAK4631", "Battery Monitoring", "LoRaWAN", "SX126x-Arduino"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **Battery Monitoring** device. Just copy the code below for **Battery Monitoring LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the code</summary>  \n```c\n\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h> //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n#include \"LTC2941.h\"               // Click here to get the library: http://librarymanager/All#GROVE-Coulomb_Counter\n#define BATTERY_CAPACITY2200     // unit:mAh.\n#define CURRENT_CAPACITY  42352    // Set the current battery level to 1800 mAh.\n#define Enable            WB_IO2   // Sensor Power Switch\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define  RAK4631_BOARD true\n#else\n#define  RAK4631_BOARD false\n#endif\n\nlong int coulomb, mAh, percent;\n\nbool doOTAA = true;   // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                     /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                   /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5             /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                      /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                      /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = {LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF};\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = {BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler\n};\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x64, 0xF6, 0xCB, 0x00, 0x35, 0x2D, 0x3B, 0x99, 0x6C, 0xFB, 0x36, 0xE4, 0xCE, 0x1A, 0x08, 0x91};\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = {0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23};\nuint8_t nodeAppsKey[16] = {0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C};\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                     /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];            //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = {m_lora_app_data_buffer, 0, 0, 0, 0}; //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup()\n{\n// Sensor Power Switch\npinMode(Enable, OUTPUT);\ndigitalWrite(Enable, HIGH);\n\npinMode(LED_GREEN, OUTPUT);  // Output LED\npinMode(LED_BLUE, OUTPUT);   // Output LED\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial)\n{\nif ((millis() - timeout) < 5000)\n{\ndelay(100);\n}\nelse\n{\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA)\n{\nSerial.println(\"Type: OTAA\");\n}\nelse\n{\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion)\n{\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA)\n{\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n}\nelse\n{\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0)\n{\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"========================\");\nSerial.println(\"RAK16002 LoRaWAN example\");\nSerial.println(\"========================\");\n\nWire.begin();\n\nltc2941.initialize();\nltc2941.setBatteryFullMAh(BATTERY_CAPACITY , false);\nltc2941.setAccumulatedCharge(CURRENT_CAPACITY); // Set the current battery level to 1800 mAh.\n\n}\n\nvoid loop()\n{\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\ndigitalWrite(LED_BLUE,HIGH);\ndigitalWrite(LED_GREEN, HIGH);\n\n// Measures Coulomb, Charge and Percentage\ncoulomb = ltc2941.getCoulombs();\nmAh = ltc2941.getmAh();\npercent = ltc2941.getPercent();\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\nSerial.print(coulomb);\nSerial.print(\"C   \");\nSerial.print(mAh);\nSerial.print(\"mAh   \");\nSerial.print(percent);\nSerial.println(\"%\");\ndelay(5000);\n\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void)\n{\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void)\n{\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data)\n{\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class)\n{\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void)\n{\nif (lmh_join_status_get() != LMH_SET)\n{\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\ndata = \" Coulomb: \" + String(coulomb) + \" C \" + \" Charge: \" + String(mAh) + \" mAh \" + \" Percentage: \" + String(percent) + \" % \";\nSerial.println(data);\n\nuint32_t coulomb_data = coulomb;\nuint32_t mAh_data = mAh;\nuint16_t percent_data = percent;\n\nm_lora_app_data.buffer[i++] = 0x01;\n\nm_lora_app_data.buffer[i++] = (uint8_t)((coulomb_data  & 0xFF000000) >> 24);\nm_lora_app_data.buffer[i++] = (uint8_t)((coulomb_data  & 0x00FF0000) >> 16);\nm_lora_app_data.buffer[i++] = (uint8_t)((coulomb_data  & 0x0000FF00) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(coulomb_data  & 0x000000FF);\n\nm_lora_app_data.buffer[i++] = (uint8_t)((mAh_data & 0xFF000000) >> 24);\nm_lora_app_data.buffer[i++] = (uint8_t)((mAh_data & 0x00FF0000) >> 16);\nm_lora_app_data.buffer[i++] = (uint8_t)((mAh_data & 0x0000FF00) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(mAh_data & 0x000000FF);\n\nm_lora_app_data.buffer[i++] = (uint8_t)((percent_data) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(percent_data);\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS)\n{\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n}\nelse\n{\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x64, 0xF6, 0xCB, 0x00, 0x35, 0x2D, 0x3B, 0x99, 0x6C, 0xFB, 0x36, 0xE4, 0xCE, 0x1A, 0x08, 0x91};\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "cafe36632c8e9ea2d10c0a3125918fee", "product_family": "wisblock", "product_id": "kit4-industrial", "category": "How-To", "title": "WisBlock IoT Education Kit - Smart Industry Quick Start Guide > WisBlock IoT Education Kit - Smart Industry Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock Smart Industry Kit using TTN and Quibitro > Battery Monitoring LoRaWAN Application > LoRaWAN Code for Battery Monitoring > Battery Monitoring LoRaWAN Application Setup [CODE]", "content": "|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |", "keywords": ["Arduino IDE", "RAK4631", "Battery Monitoring", "LoRaWAN", "SX126x-Arduino"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **Battery Monitoring** device. Just copy the code below for **Battery Monitoring LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the code</summary>  \n```c\n\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h> //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n#include \"LTC2941.h\"               // Click here to get the library: http://librarymanager/All#GROVE-Coulomb_Counter\n#define BATTERY_CAPACITY2200     // unit:mAh.\n#define CURRENT_CAPACITY  42352    // Set the current battery level to 1800 mAh.\n#define Enable            WB_IO2   // Sensor Power Switch\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define  RAK4631_BOARD true\n#else\n#define  RAK4631_BOARD false\n#endif\n\nlong int coulomb, mAh, percent;\n\nbool doOTAA = true;   // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                     /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                   /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5             /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                      /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                      /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = {LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF};\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = {BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler\n};\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x64, 0xF6, 0xCB, 0x00, 0x35, 0x2D, 0x3B, 0x99, 0x6C, 0xFB, 0x36, 0xE4, 0xCE, 0x1A, 0x08, 0x91};\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = {0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23};\nuint8_t nodeAppsKey[16] = {0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C};\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                     /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];            //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = {m_lora_app_data_buffer, 0, 0, 0, 0}; //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup()\n{\n// Sensor Power Switch\npinMode(Enable, OUTPUT);\ndigitalWrite(Enable, HIGH);\n\npinMode(LED_GREEN, OUTPUT);  // Output LED\npinMode(LED_BLUE, OUTPUT);   // Output LED\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial)\n{\nif ((millis() - timeout) < 5000)\n{\ndelay(100);\n}\nelse\n{\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA)\n{\nSerial.println(\"Type: OTAA\");\n}\nelse\n{\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion)\n{\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA)\n{\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n}\nelse\n{\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0)\n{\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"========================\");\nSerial.println(\"RAK16002 LoRaWAN example\");\nSerial.println(\"========================\");\n\nWire.begin();\n\nltc2941.initialize();\nltc2941.setBatteryFullMAh(BATTERY_CAPACITY , false);\nltc2941.setAccumulatedCharge(CURRENT_CAPACITY); // Set the current battery level to 1800 mAh.\n\n}\n\nvoid loop()\n{\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\ndigitalWrite(LED_BLUE,HIGH);\ndigitalWrite(LED_GREEN, HIGH);\n\n// Measures Coulomb, Charge and Percentage\ncoulomb = ltc2941.getCoulombs();\nmAh = ltc2941.getmAh();\npercent = ltc2941.getPercent();\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\nSerial.print(coulomb);\nSerial.print(\"C   \");\nSerial.print(mAh);\nSerial.print(\"mAh   \");\nSerial.print(percent);\nSerial.println(\"%\");\ndelay(5000);\n\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void)\n{\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void)\n{\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data)\n{\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class)\n{\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void)\n{\nif (lmh_join_status_get() != LMH_SET)\n{\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\ndata = \" Coulomb: \" + String(coulomb) + \" C \" + \" Charge: \" + String(mAh) + \" mAh \" + \" Percentage: \" + String(percent) + \" % \";\nSerial.println(data);\n\nuint32_t coulomb_data = coulomb;\nuint32_t mAh_data = mAh;\nuint16_t percent_data = percent;\n\nm_lora_app_data.buffer[i++] = 0x01;\n\nm_lora_app_data.buffer[i++] = (uint8_t)((coulomb_data  & 0xFF000000) >> 24);\nm_lora_app_data.buffer[i++] = (uint8_t)((coulomb_data  & 0x00FF0000) >> 16);\nm_lora_app_data.buffer[i++] = (uint8_t)((coulomb_data  & 0x0000FF00) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(coulomb_data  & 0x000000FF);\n\nm_lora_app_data.buffer[i++] = (uint8_t)((mAh_data & 0xFF000000) >> 24);\nm_lora_app_data.buffer[i++] = (uint8_t)((mAh_data & 0x00FF0000) >> 16);\nm_lora_app_data.buffer[i++] = (uint8_t)((mAh_data & 0x0000FF00) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(mAh_data & 0x000000FF);\n\nm_lora_app_data.buffer[i++] = (uint8_t)((percent_data) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(percent_data);\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS)\n{\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n}\nelse\n{\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x64, 0xF6, 0xCB, 0x00, 0x35, 0x2D, 0x3B, 0x99, 0x6C, 0xFB, 0x36, 0xE4, 0xCE, 0x1A, 0x08, 0x91};\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "31b9a157d6d27589b67afaa51721da8d", "product_family": "wisblock", "product_id": "kit4-industrial", "category": "How-To", "title": "WisBlock IoT Education Kit - Smart Industry Quick Start Guide > WisBlock IoT Education Kit - Smart Industry Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock Smart Industry Kit using TTN and Quibitro > Battery Monitoring LoRaWAN Application > LoRaWAN Code for Battery Monitoring > Battery Monitoring LoRaWAN Application Setup [CODE]", "content": "|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |", "keywords": ["Arduino IDE", "RAK4631", "Battery Monitoring", "LoRaWAN", "SX126x-Arduino"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **Battery Monitoring** device. Just copy the code below for **Battery Monitoring LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the code</summary>  \n```c\n\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h> //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n#include \"LTC2941.h\"               // Click here to get the library: http://librarymanager/All#GROVE-Coulomb_Counter\n#define BATTERY_CAPACITY2200     // unit:mAh.\n#define CURRENT_CAPACITY  42352    // Set the current battery level to 1800 mAh.\n#define Enable            WB_IO2   // Sensor Power Switch\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define  RAK4631_BOARD true\n#else\n#define  RAK4631_BOARD false\n#endif\n\nlong int coulomb, mAh, percent;\n\nbool doOTAA = true;   // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                     /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                   /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5             /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                      /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                      /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = {LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF};\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = {BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler\n};\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x64, 0xF6, 0xCB, 0x00, 0x35, 0x2D, 0x3B, 0x99, 0x6C, 0xFB, 0x36, 0xE4, 0xCE, 0x1A, 0x08, 0x91};\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = {0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23};\nuint8_t nodeAppsKey[16] = {0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C};\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                     /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];            //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = {m_lora_app_data_buffer, 0, 0, 0, 0}; //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup()\n{\n// Sensor Power Switch\npinMode(Enable, OUTPUT);\ndigitalWrite(Enable, HIGH);\n\npinMode(LED_GREEN, OUTPUT);  // Output LED\npinMode(LED_BLUE, OUTPUT);   // Output LED\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial)\n{\nif ((millis() - timeout) < 5000)\n{\ndelay(100);\n}\nelse\n{\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA)\n{\nSerial.println(\"Type: OTAA\");\n}\nelse\n{\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion)\n{\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA)\n{\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n}\nelse\n{\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0)\n{\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"========================\");\nSerial.println(\"RAK16002 LoRaWAN example\");\nSerial.println(\"========================\");\n\nWire.begin();\n\nltc2941.initialize();\nltc2941.setBatteryFullMAh(BATTERY_CAPACITY , false);\nltc2941.setAccumulatedCharge(CURRENT_CAPACITY); // Set the current battery level to 1800 mAh.\n\n}\n\nvoid loop()\n{\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\ndigitalWrite(LED_BLUE,HIGH);\ndigitalWrite(LED_GREEN, HIGH);\n\n// Measures Coulomb, Charge and Percentage\ncoulomb = ltc2941.getCoulombs();\nmAh = ltc2941.getmAh();\npercent = ltc2941.getPercent();\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\nSerial.print(coulomb);\nSerial.print(\"C   \");\nSerial.print(mAh);\nSerial.print(\"mAh   \");\nSerial.print(percent);\nSerial.println(\"%\");\ndelay(5000);\n\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void)\n{\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void)\n{\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data)\n{\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class)\n{\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void)\n{\nif (lmh_join_status_get() != LMH_SET)\n{\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\ndata = \" Coulomb: \" + String(coulomb) + \" C \" + \" Charge: \" + String(mAh) + \" mAh \" + \" Percentage: \" + String(percent) + \" % \";\nSerial.println(data);\n\nuint32_t coulomb_data = coulomb;\nuint32_t mAh_data = mAh;\nuint16_t percent_data = percent;\n\nm_lora_app_data.buffer[i++] = 0x01;\n\nm_lora_app_data.buffer[i++] = (uint8_t)((coulomb_data  & 0xFF000000) >> 24);\nm_lora_app_data.buffer[i++] = (uint8_t)((coulomb_data  & 0x00FF0000) >> 16);\nm_lora_app_data.buffer[i++] = (uint8_t)((coulomb_data  & 0x0000FF00) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(coulomb_data  & 0x000000FF);\n\nm_lora_app_data.buffer[i++] = (uint8_t)((mAh_data & 0xFF000000) >> 24);\nm_lora_app_data.buffer[i++] = (uint8_t)((mAh_data & 0x00FF0000) >> 16);\nm_lora_app_data.buffer[i++] = (uint8_t)((mAh_data & 0x0000FF00) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(mAh_data & 0x000000FF);\n\nm_lora_app_data.buffer[i++] = (uint8_t)((percent_data) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(percent_data);\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS)\n{\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n}\nelse\n{\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x64, 0xF6, 0xCB, 0x00, 0x35, 0x2D, 0x3B, 0x99, 0x6C, 0xFB, 0x36, 0xE4, 0xCE, 0x1A, 0x08, 0x91};\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "b112a6b327887b387db1a3fd52a302ef", "product_family": "wisblock", "product_id": "kit4-industrial", "category": "How-To", "title": "WisBlock IoT Education Kit - Smart Industry Quick Start Guide > WisBlock IoT Education Kit - Smart Industry Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock Smart Industry Kit using TTN and Quibitro > Battery Monitoring LoRaWAN Application > LoRaWAN Code for Battery Monitoring > Battery Monitoring LoRaWAN Application Setup [CODE]", "content": "|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```", "keywords": ["Arduino IDE", "RAK4631", "Battery Monitoring", "LoRaWAN", "SX126x-Arduino"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **Battery Monitoring** device. Just copy the code below for **Battery Monitoring LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the code</summary>  \n```c\n\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h> //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n#include \"LTC2941.h\"               // Click here to get the library: http://librarymanager/All#GROVE-Coulomb_Counter\n#define BATTERY_CAPACITY2200     // unit:mAh.\n#define CURRENT_CAPACITY  42352    // Set the current battery level to 1800 mAh.\n#define Enable            WB_IO2   // Sensor Power Switch\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define  RAK4631_BOARD true\n#else\n#define  RAK4631_BOARD false\n#endif\n\nlong int coulomb, mAh, percent;\n\nbool doOTAA = true;   // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                     /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                   /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5             /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                      /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                      /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = {LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF};\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = {BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler\n};\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x64, 0xF6, 0xCB, 0x00, 0x35, 0x2D, 0x3B, 0x99, 0x6C, 0xFB, 0x36, 0xE4, 0xCE, 0x1A, 0x08, 0x91};\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = {0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23};\nuint8_t nodeAppsKey[16] = {0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C};\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                     /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];            //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = {m_lora_app_data_buffer, 0, 0, 0, 0}; //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup()\n{\n// Sensor Power Switch\npinMode(Enable, OUTPUT);\ndigitalWrite(Enable, HIGH);\n\npinMode(LED_GREEN, OUTPUT);  // Output LED\npinMode(LED_BLUE, OUTPUT);   // Output LED\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial)\n{\nif ((millis() - timeout) < 5000)\n{\ndelay(100);\n}\nelse\n{\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA)\n{\nSerial.println(\"Type: OTAA\");\n}\nelse\n{\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion)\n{\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA)\n{\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n}\nelse\n{\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0)\n{\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"========================\");\nSerial.println(\"RAK16002 LoRaWAN example\");\nSerial.println(\"========================\");\n\nWire.begin();\n\nltc2941.initialize();\nltc2941.setBatteryFullMAh(BATTERY_CAPACITY , false);\nltc2941.setAccumulatedCharge(CURRENT_CAPACITY); // Set the current battery level to 1800 mAh.\n\n}\n\nvoid loop()\n{\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\ndigitalWrite(LED_BLUE,HIGH);\ndigitalWrite(LED_GREEN, HIGH);\n\n// Measures Coulomb, Charge and Percentage\ncoulomb = ltc2941.getCoulombs();\nmAh = ltc2941.getmAh();\npercent = ltc2941.getPercent();\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\nSerial.print(coulomb);\nSerial.print(\"C   \");\nSerial.print(mAh);\nSerial.print(\"mAh   \");\nSerial.print(percent);\nSerial.println(\"%\");\ndelay(5000);\n\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void)\n{\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void)\n{\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data)\n{\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class)\n{\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void)\n{\nif (lmh_join_status_get() != LMH_SET)\n{\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\ndata = \" Coulomb: \" + String(coulomb) + \" C \" + \" Charge: \" + String(mAh) + \" mAh \" + \" Percentage: \" + String(percent) + \" % \";\nSerial.println(data);\n\nuint32_t coulomb_data = coulomb;\nuint32_t mAh_data = mAh;\nuint16_t percent_data = percent;\n\nm_lora_app_data.buffer[i++] = 0x01;\n\nm_lora_app_data.buffer[i++] = (uint8_t)((coulomb_data  & 0xFF000000) >> 24);\nm_lora_app_data.buffer[i++] = (uint8_t)((coulomb_data  & 0x00FF0000) >> 16);\nm_lora_app_data.buffer[i++] = (uint8_t)((coulomb_data  & 0x0000FF00) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(coulomb_data  & 0x000000FF);\n\nm_lora_app_data.buffer[i++] = (uint8_t)((mAh_data & 0xFF000000) >> 24);\nm_lora_app_data.buffer[i++] = (uint8_t)((mAh_data & 0x00FF0000) >> 16);\nm_lora_app_data.buffer[i++] = (uint8_t)((mAh_data & 0x0000FF00) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(mAh_data & 0x000000FF);\n\nm_lora_app_data.buffer[i++] = (uint8_t)((percent_data) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(percent_data);\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS)\n{\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n}\nelse\n{\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x64, 0xF6, 0xCB, 0x00, 0x35, 0x2D, 0x3B, 0x99, 0x6C, 0xFB, 0x36, 0xE4, 0xCE, 0x1A, 0x08, 0x91};\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "56b38ecca46375b5c741062b7546ccb4", "product_family": "wisblock", "product_id": "kit4-industrial", "category": "How-To", "title": "WisBlock IoT Education Kit - Smart Industry Quick Start Guide > WisBlock IoT Education Kit - Smart Industry Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock Smart Industry Kit using TTN and Quibitro > Battery Monitoring LoRaWAN Application > LoRaWAN Code for Battery Monitoring > Battery Monitoring LoRaWAN Application Setup [CODE]", "content": "```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```", "keywords": ["Arduino IDE", "RAK4631", "Battery Monitoring", "LoRaWAN", "SX126x-Arduino"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **Battery Monitoring** device. Just copy the code below for **Battery Monitoring LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the code</summary>  \n```c\n\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h> //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n#include \"LTC2941.h\"               // Click here to get the library: http://librarymanager/All#GROVE-Coulomb_Counter\n#define BATTERY_CAPACITY2200     // unit:mAh.\n#define CURRENT_CAPACITY  42352    // Set the current battery level to 1800 mAh.\n#define Enable            WB_IO2   // Sensor Power Switch\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define  RAK4631_BOARD true\n#else\n#define  RAK4631_BOARD false\n#endif\n\nlong int coulomb, mAh, percent;\n\nbool doOTAA = true;   // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                     /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                   /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5             /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                      /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                      /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = {LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF};\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = {BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler\n};\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x64, 0xF6, 0xCB, 0x00, 0x35, 0x2D, 0x3B, 0x99, 0x6C, 0xFB, 0x36, 0xE4, 0xCE, 0x1A, 0x08, 0x91};\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = {0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23};\nuint8_t nodeAppsKey[16] = {0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C};\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                     /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];            //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = {m_lora_app_data_buffer, 0, 0, 0, 0}; //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup()\n{\n// Sensor Power Switch\npinMode(Enable, OUTPUT);\ndigitalWrite(Enable, HIGH);\n\npinMode(LED_GREEN, OUTPUT);  // Output LED\npinMode(LED_BLUE, OUTPUT);   // Output LED\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial)\n{\nif ((millis() - timeout) < 5000)\n{\ndelay(100);\n}\nelse\n{\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA)\n{\nSerial.println(\"Type: OTAA\");\n}\nelse\n{\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion)\n{\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA)\n{\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n}\nelse\n{\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0)\n{\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"========================\");\nSerial.println(\"RAK16002 LoRaWAN example\");\nSerial.println(\"========================\");\n\nWire.begin();\n\nltc2941.initialize();\nltc2941.setBatteryFullMAh(BATTERY_CAPACITY , false);\nltc2941.setAccumulatedCharge(CURRENT_CAPACITY); // Set the current battery level to 1800 mAh.\n\n}\n\nvoid loop()\n{\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\ndigitalWrite(LED_BLUE,HIGH);\ndigitalWrite(LED_GREEN, HIGH);\n\n// Measures Coulomb, Charge and Percentage\ncoulomb = ltc2941.getCoulombs();\nmAh = ltc2941.getmAh();\npercent = ltc2941.getPercent();\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\nSerial.print(coulomb);\nSerial.print(\"C   \");\nSerial.print(mAh);\nSerial.print(\"mAh   \");\nSerial.print(percent);\nSerial.println(\"%\");\ndelay(5000);\n\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void)\n{\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void)\n{\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data)\n{\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class)\n{\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void)\n{\nif (lmh_join_status_get() != LMH_SET)\n{\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\ndata = \" Coulomb: \" + String(coulomb) + \" C \" + \" Charge: \" + String(mAh) + \" mAh \" + \" Percentage: \" + String(percent) + \" % \";\nSerial.println(data);\n\nuint32_t coulomb_data = coulomb;\nuint32_t mAh_data = mAh;\nuint16_t percent_data = percent;\n\nm_lora_app_data.buffer[i++] = 0x01;\n\nm_lora_app_data.buffer[i++] = (uint8_t)((coulomb_data  & 0xFF000000) >> 24);\nm_lora_app_data.buffer[i++] = (uint8_t)((coulomb_data  & 0x00FF0000) >> 16);\nm_lora_app_data.buffer[i++] = (uint8_t)((coulomb_data  & 0x0000FF00) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(coulomb_data  & 0x000000FF);\n\nm_lora_app_data.buffer[i++] = (uint8_t)((mAh_data & 0xFF000000) >> 24);\nm_lora_app_data.buffer[i++] = (uint8_t)((mAh_data & 0x00FF0000) >> 16);\nm_lora_app_data.buffer[i++] = (uint8_t)((mAh_data & 0x0000FF00) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(mAh_data & 0x000000FF);\n\nm_lora_app_data.buffer[i++] = (uint8_t)((percent_data) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(percent_data);\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS)\n{\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n}\nelse\n{\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x64, 0xF6, 0xCB, 0x00, 0x35, 0x2D, 0x3B, 0x99, 0x6C, 0xFB, 0x36, 0xE4, 0xCE, 0x1A, 0x08, 0x91};\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "359f6aff76314addc95abf4f7c892d2f", "product_family": "wisblock", "product_id": "kit4-industrial", "category": "How-To", "title": "WisBlock IoT Education Kit - Smart Industry Quick Start Guide > WisBlock IoT Education Kit - Smart Industry Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock Smart Industry Kit using TTN and Quibitro > Battery Monitoring LoRaWAN Application > LoRaWAN Code for Battery Monitoring > Battery Monitoring LoRaWAN Application Setup [CODE]", "content": "```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E};", "keywords": ["Arduino IDE", "RAK4631", "Battery Monitoring", "LoRaWAN", "SX126x-Arduino"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **Battery Monitoring** device. Just copy the code below for **Battery Monitoring LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the code</summary>  \n```c\n\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h> //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n#include \"LTC2941.h\"               // Click here to get the library: http://librarymanager/All#GROVE-Coulomb_Counter\n#define BATTERY_CAPACITY2200     // unit:mAh.\n#define CURRENT_CAPACITY  42352    // Set the current battery level to 1800 mAh.\n#define Enable            WB_IO2   // Sensor Power Switch\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define  RAK4631_BOARD true\n#else\n#define  RAK4631_BOARD false\n#endif\n\nlong int coulomb, mAh, percent;\n\nbool doOTAA = true;   // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                     /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                   /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5             /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                      /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                      /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = {LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF};\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = {BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler\n};\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x64, 0xF6, 0xCB, 0x00, 0x35, 0x2D, 0x3B, 0x99, 0x6C, 0xFB, 0x36, 0xE4, 0xCE, 0x1A, 0x08, 0x91};\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = {0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23};\nuint8_t nodeAppsKey[16] = {0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C};\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                     /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];            //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = {m_lora_app_data_buffer, 0, 0, 0, 0}; //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup()\n{\n// Sensor Power Switch\npinMode(Enable, OUTPUT);\ndigitalWrite(Enable, HIGH);\n\npinMode(LED_GREEN, OUTPUT);  // Output LED\npinMode(LED_BLUE, OUTPUT);   // Output LED\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial)\n{\nif ((millis() - timeout) < 5000)\n{\ndelay(100);\n}\nelse\n{\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA)\n{\nSerial.println(\"Type: OTAA\");\n}\nelse\n{\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion)\n{\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA)\n{\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n}\nelse\n{\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0)\n{\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"========================\");\nSerial.println(\"RAK16002 LoRaWAN example\");\nSerial.println(\"========================\");\n\nWire.begin();\n\nltc2941.initialize();\nltc2941.setBatteryFullMAh(BATTERY_CAPACITY , false);\nltc2941.setAccumulatedCharge(CURRENT_CAPACITY); // Set the current battery level to 1800 mAh.\n\n}\n\nvoid loop()\n{\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\ndigitalWrite(LED_BLUE,HIGH);\ndigitalWrite(LED_GREEN, HIGH);\n\n// Measures Coulomb, Charge and Percentage\ncoulomb = ltc2941.getCoulombs();\nmAh = ltc2941.getmAh();\npercent = ltc2941.getPercent();\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\nSerial.print(coulomb);\nSerial.print(\"C   \");\nSerial.print(mAh);\nSerial.print(\"mAh   \");\nSerial.print(percent);\nSerial.println(\"%\");\ndelay(5000);\n\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void)\n{\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void)\n{\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data)\n{\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class)\n{\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void)\n{\nif (lmh_join_status_get() != LMH_SET)\n{\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\ndata = \" Coulomb: \" + String(coulomb) + \" C \" + \" Charge: \" + String(mAh) + \" mAh \" + \" Percentage: \" + String(percent) + \" % \";\nSerial.println(data);\n\nuint32_t coulomb_data = coulomb;\nuint32_t mAh_data = mAh;\nuint16_t percent_data = percent;\n\nm_lora_app_data.buffer[i++] = 0x01;\n\nm_lora_app_data.buffer[i++] = (uint8_t)((coulomb_data  & 0xFF000000) >> 24);\nm_lora_app_data.buffer[i++] = (uint8_t)((coulomb_data  & 0x00FF0000) >> 16);\nm_lora_app_data.buffer[i++] = (uint8_t)((coulomb_data  & 0x0000FF00) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(coulomb_data  & 0x000000FF);\n\nm_lora_app_data.buffer[i++] = (uint8_t)((mAh_data & 0xFF000000) >> 24);\nm_lora_app_data.buffer[i++] = (uint8_t)((mAh_data & 0x00FF0000) >> 16);\nm_lora_app_data.buffer[i++] = (uint8_t)((mAh_data & 0x0000FF00) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(mAh_data & 0x000000FF);\n\nm_lora_app_data.buffer[i++] = (uint8_t)((percent_data) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(percent_data);\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS)\n{\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n}\nelse\n{\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x64, 0xF6, 0xCB, 0x00, 0x35, 0x2D, 0x3B, 0x99, 0x6C, 0xFB, 0x36, 0xE4, 0xCE, 0x1A, 0x08, 0x91};\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "c10c4809ac11e509c597902f2c97bdba", "product_family": "wisblock", "product_id": "kit4-industrial", "category": "How-To", "title": "WisBlock IoT Education Kit - Smart Industry Quick Start Guide > WisBlock IoT Education Kit - Smart Industry Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock Smart Industry Kit using TTN and Quibitro > Battery Monitoring LoRaWAN Application > LoRaWAN Code for Battery Monitoring > Battery Monitoring LoRaWAN Application Setup [CODE]", "content": "uint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x64, 0xF6, 0xCB, 0x00, 0x35, 0x2D, 0x3B, 0x99, 0x6C, 0xFB, 0x36, 0xE4, 0xCE, 0x1A, 0x08, 0x91};\n```  \n> **Image:** Device's credentials registered in TTN", "keywords": ["Arduino IDE", "RAK4631", "Battery Monitoring", "LoRaWAN", "SX126x-Arduino"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **Battery Monitoring** device. Just copy the code below for **Battery Monitoring LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the code</summary>  \n```c\n\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h> //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n#include \"LTC2941.h\"               // Click here to get the library: http://librarymanager/All#GROVE-Coulomb_Counter\n#define BATTERY_CAPACITY2200     // unit:mAh.\n#define CURRENT_CAPACITY  42352    // Set the current battery level to 1800 mAh.\n#define Enable            WB_IO2   // Sensor Power Switch\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define  RAK4631_BOARD true\n#else\n#define  RAK4631_BOARD false\n#endif\n\nlong int coulomb, mAh, percent;\n\nbool doOTAA = true;   // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                     /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                   /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5             /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                      /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                      /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = {LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF};\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = {BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler\n};\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x64, 0xF6, 0xCB, 0x00, 0x35, 0x2D, 0x3B, 0x99, 0x6C, 0xFB, 0x36, 0xE4, 0xCE, 0x1A, 0x08, 0x91};\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = {0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23};\nuint8_t nodeAppsKey[16] = {0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C};\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                     /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];            //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = {m_lora_app_data_buffer, 0, 0, 0, 0}; //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup()\n{\n// Sensor Power Switch\npinMode(Enable, OUTPUT);\ndigitalWrite(Enable, HIGH);\n\npinMode(LED_GREEN, OUTPUT);  // Output LED\npinMode(LED_BLUE, OUTPUT);   // Output LED\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial)\n{\nif ((millis() - timeout) < 5000)\n{\ndelay(100);\n}\nelse\n{\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA)\n{\nSerial.println(\"Type: OTAA\");\n}\nelse\n{\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion)\n{\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA)\n{\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n}\nelse\n{\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0)\n{\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"========================\");\nSerial.println(\"RAK16002 LoRaWAN example\");\nSerial.println(\"========================\");\n\nWire.begin();\n\nltc2941.initialize();\nltc2941.setBatteryFullMAh(BATTERY_CAPACITY , false);\nltc2941.setAccumulatedCharge(CURRENT_CAPACITY); // Set the current battery level to 1800 mAh.\n\n}\n\nvoid loop()\n{\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\ndigitalWrite(LED_BLUE,HIGH);\ndigitalWrite(LED_GREEN, HIGH);\n\n// Measures Coulomb, Charge and Percentage\ncoulomb = ltc2941.getCoulombs();\nmAh = ltc2941.getmAh();\npercent = ltc2941.getPercent();\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\nSerial.print(coulomb);\nSerial.print(\"C   \");\nSerial.print(mAh);\nSerial.print(\"mAh   \");\nSerial.print(percent);\nSerial.println(\"%\");\ndelay(5000);\n\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void)\n{\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void)\n{\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data)\n{\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class)\n{\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void)\n{\nif (lmh_join_status_get() != LMH_SET)\n{\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\ndata = \" Coulomb: \" + String(coulomb) + \" C \" + \" Charge: \" + String(mAh) + \" mAh \" + \" Percentage: \" + String(percent) + \" % \";\nSerial.println(data);\n\nuint32_t coulomb_data = coulomb;\nuint32_t mAh_data = mAh;\nuint16_t percent_data = percent;\n\nm_lora_app_data.buffer[i++] = 0x01;\n\nm_lora_app_data.buffer[i++] = (uint8_t)((coulomb_data  & 0xFF000000) >> 24);\nm_lora_app_data.buffer[i++] = (uint8_t)((coulomb_data  & 0x00FF0000) >> 16);\nm_lora_app_data.buffer[i++] = (uint8_t)((coulomb_data  & 0x0000FF00) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(coulomb_data  & 0x000000FF);\n\nm_lora_app_data.buffer[i++] = (uint8_t)((mAh_data & 0xFF000000) >> 24);\nm_lora_app_data.buffer[i++] = (uint8_t)((mAh_data & 0x00FF0000) >> 16);\nm_lora_app_data.buffer[i++] = (uint8_t)((mAh_data & 0x0000FF00) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(mAh_data & 0x000000FF);\n\nm_lora_app_data.buffer[i++] = (uint8_t)((percent_data) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(percent_data);\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS)\n{\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n}\nelse\n{\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x64, 0xF6, 0xCB, 0x00, 0x35, 0x2D, 0x3B, 0x99, 0x6C, 0xFB, 0x36, 0xE4, 0xCE, 0x1A, 0x08, 0x91};\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "9346bca6018613d4fb4f4831a558ed40", "product_family": "wisblock", "product_id": "kit4-industrial", "category": "How-To", "title": "WisBlock IoT Education Kit - Smart Industry Quick Start Guide > WisBlock IoT Education Kit - Smart Industry Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock Smart Industry Kit using TTN and Quibitro > Battery Monitoring LoRaWAN Application > LoRaWAN Code for Battery Monitoring > Battery Monitoring LoRaWAN Application Setup [CODE]", "content": "```  \n> **Image:** Device's credentials registered in TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.", "keywords": ["Arduino IDE", "RAK4631", "Battery Monitoring", "LoRaWAN", "SX126x-Arduino"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **Battery Monitoring** device. Just copy the code below for **Battery Monitoring LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the code</summary>  \n```c\n\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h> //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n#include \"LTC2941.h\"               // Click here to get the library: http://librarymanager/All#GROVE-Coulomb_Counter\n#define BATTERY_CAPACITY2200     // unit:mAh.\n#define CURRENT_CAPACITY  42352    // Set the current battery level to 1800 mAh.\n#define Enable            WB_IO2   // Sensor Power Switch\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define  RAK4631_BOARD true\n#else\n#define  RAK4631_BOARD false\n#endif\n\nlong int coulomb, mAh, percent;\n\nbool doOTAA = true;   // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                     /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                   /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5             /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                      /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                      /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = {LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF};\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = {BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler\n};\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x64, 0xF6, 0xCB, 0x00, 0x35, 0x2D, 0x3B, 0x99, 0x6C, 0xFB, 0x36, 0xE4, 0xCE, 0x1A, 0x08, 0x91};\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = {0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23};\nuint8_t nodeAppsKey[16] = {0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C};\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                     /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];            //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = {m_lora_app_data_buffer, 0, 0, 0, 0}; //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup()\n{\n// Sensor Power Switch\npinMode(Enable, OUTPUT);\ndigitalWrite(Enable, HIGH);\n\npinMode(LED_GREEN, OUTPUT);  // Output LED\npinMode(LED_BLUE, OUTPUT);   // Output LED\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial)\n{\nif ((millis() - timeout) < 5000)\n{\ndelay(100);\n}\nelse\n{\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA)\n{\nSerial.println(\"Type: OTAA\");\n}\nelse\n{\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion)\n{\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA)\n{\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n}\nelse\n{\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0)\n{\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"========================\");\nSerial.println(\"RAK16002 LoRaWAN example\");\nSerial.println(\"========================\");\n\nWire.begin();\n\nltc2941.initialize();\nltc2941.setBatteryFullMAh(BATTERY_CAPACITY , false);\nltc2941.setAccumulatedCharge(CURRENT_CAPACITY); // Set the current battery level to 1800 mAh.\n\n}\n\nvoid loop()\n{\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\ndigitalWrite(LED_BLUE,HIGH);\ndigitalWrite(LED_GREEN, HIGH);\n\n// Measures Coulomb, Charge and Percentage\ncoulomb = ltc2941.getCoulombs();\nmAh = ltc2941.getmAh();\npercent = ltc2941.getPercent();\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\nSerial.print(coulomb);\nSerial.print(\"C   \");\nSerial.print(mAh);\nSerial.print(\"mAh   \");\nSerial.print(percent);\nSerial.println(\"%\");\ndelay(5000);\n\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void)\n{\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void)\n{\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data)\n{\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class)\n{\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void)\n{\nif (lmh_join_status_get() != LMH_SET)\n{\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\ndata = \" Coulomb: \" + String(coulomb) + \" C \" + \" Charge: \" + String(mAh) + \" mAh \" + \" Percentage: \" + String(percent) + \" % \";\nSerial.println(data);\n\nuint32_t coulomb_data = coulomb;\nuint32_t mAh_data = mAh;\nuint16_t percent_data = percent;\n\nm_lora_app_data.buffer[i++] = 0x01;\n\nm_lora_app_data.buffer[i++] = (uint8_t)((coulomb_data  & 0xFF000000) >> 24);\nm_lora_app_data.buffer[i++] = (uint8_t)((coulomb_data  & 0x00FF0000) >> 16);\nm_lora_app_data.buffer[i++] = (uint8_t)((coulomb_data  & 0x0000FF00) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(coulomb_data  & 0x000000FF);\n\nm_lora_app_data.buffer[i++] = (uint8_t)((mAh_data & 0xFF000000) >> 24);\nm_lora_app_data.buffer[i++] = (uint8_t)((mAh_data & 0x00FF0000) >> 16);\nm_lora_app_data.buffer[i++] = (uint8_t)((mAh_data & 0x0000FF00) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(mAh_data & 0x000000FF);\n\nm_lora_app_data.buffer[i++] = (uint8_t)((percent_data) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(percent_data);\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS)\n{\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n}\nelse\n{\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x64, 0xF6, 0xCB, 0x00, 0x35, 0x2D, 0x3B, 0x99, 0x6C, 0xFB, 0x36, 0xE4, 0xCE, 0x1A, 0x08, 0x91};\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "ad407acfed61e3a3be3060ebed48c480", "product_family": "wisblock", "product_id": "kit4-industrial", "category": "How-To", "title": "WisBlock IoT Education Kit - Smart Industry Quick Start Guide > WisBlock IoT Education Kit - Smart Industry Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock Smart Industry Kit using TTN and Quibitro > Battery Monitoring LoRaWAN Application > LoRaWAN Code for Battery Monitoring > Battery Monitoring LoRaWAN Application Setup [CODE]", "content": "> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board", "keywords": ["Arduino IDE", "RAK4631", "Battery Monitoring", "LoRaWAN", "SX126x-Arduino"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **Battery Monitoring** device. Just copy the code below for **Battery Monitoring LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the code</summary>  \n```c\n\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h> //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n#include \"LTC2941.h\"               // Click here to get the library: http://librarymanager/All#GROVE-Coulomb_Counter\n#define BATTERY_CAPACITY2200     // unit:mAh.\n#define CURRENT_CAPACITY  42352    // Set the current battery level to 1800 mAh.\n#define Enable            WB_IO2   // Sensor Power Switch\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define  RAK4631_BOARD true\n#else\n#define  RAK4631_BOARD false\n#endif\n\nlong int coulomb, mAh, percent;\n\nbool doOTAA = true;   // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                     /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                   /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5             /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                      /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                      /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = {LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF};\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = {BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler\n};\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x64, 0xF6, 0xCB, 0x00, 0x35, 0x2D, 0x3B, 0x99, 0x6C, 0xFB, 0x36, 0xE4, 0xCE, 0x1A, 0x08, 0x91};\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = {0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23};\nuint8_t nodeAppsKey[16] = {0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C};\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                     /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];            //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = {m_lora_app_data_buffer, 0, 0, 0, 0}; //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup()\n{\n// Sensor Power Switch\npinMode(Enable, OUTPUT);\ndigitalWrite(Enable, HIGH);\n\npinMode(LED_GREEN, OUTPUT);  // Output LED\npinMode(LED_BLUE, OUTPUT);   // Output LED\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial)\n{\nif ((millis() - timeout) < 5000)\n{\ndelay(100);\n}\nelse\n{\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA)\n{\nSerial.println(\"Type: OTAA\");\n}\nelse\n{\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion)\n{\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA)\n{\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n}\nelse\n{\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0)\n{\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"========================\");\nSerial.println(\"RAK16002 LoRaWAN example\");\nSerial.println(\"========================\");\n\nWire.begin();\n\nltc2941.initialize();\nltc2941.setBatteryFullMAh(BATTERY_CAPACITY , false);\nltc2941.setAccumulatedCharge(CURRENT_CAPACITY); // Set the current battery level to 1800 mAh.\n\n}\n\nvoid loop()\n{\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\ndigitalWrite(LED_BLUE,HIGH);\ndigitalWrite(LED_GREEN, HIGH);\n\n// Measures Coulomb, Charge and Percentage\ncoulomb = ltc2941.getCoulombs();\nmAh = ltc2941.getmAh();\npercent = ltc2941.getPercent();\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\nSerial.print(coulomb);\nSerial.print(\"C   \");\nSerial.print(mAh);\nSerial.print(\"mAh   \");\nSerial.print(percent);\nSerial.println(\"%\");\ndelay(5000);\n\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void)\n{\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void)\n{\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data)\n{\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class)\n{\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void)\n{\nif (lmh_join_status_get() != LMH_SET)\n{\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\ndata = \" Coulomb: \" + String(coulomb) + \" C \" + \" Charge: \" + String(mAh) + \" mAh \" + \" Percentage: \" + String(percent) + \" % \";\nSerial.println(data);\n\nuint32_t coulomb_data = coulomb;\nuint32_t mAh_data = mAh;\nuint16_t percent_data = percent;\n\nm_lora_app_data.buffer[i++] = 0x01;\n\nm_lora_app_data.buffer[i++] = (uint8_t)((coulomb_data  & 0xFF000000) >> 24);\nm_lora_app_data.buffer[i++] = (uint8_t)((coulomb_data  & 0x00FF0000) >> 16);\nm_lora_app_data.buffer[i++] = (uint8_t)((coulomb_data  & 0x0000FF00) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(coulomb_data  & 0x000000FF);\n\nm_lora_app_data.buffer[i++] = (uint8_t)((mAh_data & 0xFF000000) >> 24);\nm_lora_app_data.buffer[i++] = (uint8_t)((mAh_data & 0x00FF0000) >> 16);\nm_lora_app_data.buffer[i++] = (uint8_t)((mAh_data & 0x0000FF00) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(mAh_data & 0x000000FF);\n\nm_lora_app_data.buffer[i++] = (uint8_t)((percent_data) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(percent_data);\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS)\n{\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n}\nelse\n{\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x05, 0x3E, 0x3E};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x64, 0xF6, 0xCB, 0x00, 0x35, 0x2D, 0x3B, 0x99, 0x6C, 0xFB, 0x36, 0xE4, 0xCE, 0x1A, 0x08, 0x91};\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "725d9bea938ebde8b54badeae79f5cce", "product_family": "wisblock", "product_id": "kit4-industrial", "category": "Concept", "title": "WisBlock IoT Education Kit - Smart Industry Quick Start Guide > WisBlock IoT Education Kit - Smart Industry Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock Smart Industry Kit using TTN and Quibitro > Material Classifier LoRaWAN Application > Material Classifier LoRaWAN Application Overview", "content": "The **Material Classifier LoRaWAN Application** is used to monitor the distance to a certain material and at the same time, it determines whether a material is metallic or non-metallic via **TTN** or **Qubitro**. It uses **RAK12014** module responsible for accurate distance measurement based on **VL53L0X**, **RAK12029** module responsible for metal detection based on **LDC1614**, and **RAK13001** relay module that can control an external device once a metallic material is detected.", "keywords": ["Material Classifier", "LoRaWAN", "TTN", "Qubitro", "RAK12014", "VL53L0X", "RAK12029", "LDC1614", "RAK13001"], "source_file": "quickstart.md", "token_count": 0, "parent_content": "The **Material Classifier LoRaWAN Application** is used to monitor the distance to a certain material and at the same time, it determines whether a material is metallic or non-metallic via **TTN** or **Qubitro**. It uses **RAK12014** module responsible for accurate distance measurement based on **VL53L0X**, **RAK12029** module responsible for metal detection based on **LDC1614**, and **RAK13001** relay module that can control an external device once a metallic material is detected.  \n> **Image:** Material Classifier device"}
{"id": "2687a9edfd05d7c778fa6353880ffd0f", "product_family": "wisblock", "product_id": "kit4-industrial", "category": "Concept", "title": "WisBlock IoT Education Kit - Smart Industry Quick Start Guide > WisBlock IoT Education Kit - Smart Industry Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock Smart Industry Kit using TTN and Quibitro > Material Classifier LoRaWAN Application > Material Classifier LoRaWAN Application Overview", "content": "> **Image:** Material Classifier device", "keywords": ["Material Classifier", "LoRaWAN", "TTN", "Qubitro", "RAK12014", "VL53L0X", "RAK12029", "LDC1614", "RAK13001"], "source_file": "quickstart.md", "token_count": 0, "parent_content": "The **Material Classifier LoRaWAN Application** is used to monitor the distance to a certain material and at the same time, it determines whether a material is metallic or non-metallic via **TTN** or **Qubitro**. It uses **RAK12014** module responsible for accurate distance measurement based on **VL53L0X**, **RAK12029** module responsible for metal detection based on **LDC1614**, and **RAK13001** relay module that can control an external device once a metallic material is detected.  \n> **Image:** Material Classifier device"}
{"id": "e51f2d635b8808040174fd9f0b5d48cb", "product_family": "wisblock", "product_id": "kit4-industrial", "category": "How-To", "title": "WisBlock IoT Education Kit - Smart Industry Quick Start Guide > WisBlock IoT Education Kit - Smart Industry Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock Smart Industry Kit using TTN and Quibitro > Material Classifier LoRaWAN Application > Material Classifier - TTN Registration Section and Device Registration > Steps for TTN Account Creation and Device Registration", "content": "1. If you already have an existing TTN account, you may proceed to the next steps. If you haven't created any TTN account, please refer to this [link](#ttn-account-creation) to create one.  \n2. Once done with the TTN account creation, you may now proceed with the device registration. Please refer to this [guide](#device-registration) for your reference. After creating the application and adding the device in TTN, you can proceed on the LoRaWAN Code uploading steps.", "keywords": ["TTN", "account creation", "device registration", "LoRaWAN"], "source_file": "quickstart.md", "token_count": 0, "parent_content": "1. If you already have an existing TTN account, you may proceed to the next steps. If you haven't created any TTN account, please refer to this [link](#ttn-account-creation) to create one.  \n2. Once done with the TTN account creation, you may now proceed with the device registration. Please refer to this [guide](#device-registration) for your reference. After creating the application and adding the device in TTN, you can proceed on the LoRaWAN Code uploading steps."}
{"id": "fe9d67a77375e27e193ae241c811f01c", "product_family": "wisblock", "product_id": "kit4-industrial", "category": "How-To", "title": "WisBlock IoT Education Kit - Smart Industry Quick Start Guide > WisBlock IoT Education Kit - Smart Industry Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock Smart Industry Kit using TTN and Quibitro > Material Classifier LoRaWAN Application > LoRaWAN Code for Material Classifier > Programming the Material Classifier Device with LoRaWAN Application [CODE]", "content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **Material Classifier** device. Just copy the code below for **Material Classifier LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE", "keywords": ["Arduino IDE", "RAK4631", "Material Classifier", "LoRaWAN", "SX126x-Arduino"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **Material Classifier** device. Just copy the code below for **Material Classifier LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the code</summary>  \n```c\n\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h>  //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n// For RAK12014 module\n#include <vl53l0x_class.h>    // Click to install library: http://librarymanager/All#stm32duino_vl53l0x\nVL53L0X sensor_vl53l0x(&Wire, WB_IO2);\n\nuint32_t distance;\nint status;\n\n// For RAK13001 module\n#define RELAY_PIN WB_IO4\nint object;\n\n// For RAK12029 module\n#include \"RAK12029_LDC1614.h\"\n\n#define INDUCTANCE 13.000\n#define CAPATANCE 100.0\n#define GETCHANNEL LDC1614_CHANNEL_0     // LDC1614_CHANNEL_(0~3); selecting the coil channel from 0 - 3\nRAK12029_LDC1614_Inductive ldc;\n\nu16 value = 0;\nu32 ChannelData = 0;\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define RAK4631_BOARD true\n#else\n#define RAK4631_BOARD false\n#endif\n\nbool doOTAA = true;                                               // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                                       /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                                     /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5                               /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                                        /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;                           /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;                 /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                              /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = { LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF };\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = { BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler };\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xC0, 0x81, 0xBB, 0x65, 0x54, 0xCF, 0xF7, 0x65, 0x87, 0x70, 0xFD, 0x31, 0x7F, 0x01, 0x87, 0x51 };\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };\nuint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                                            /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];               //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = { m_lora_app_data_buffer, 0, 0, 0, 0 };  //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {\n// Sensor Power Switch\npinMode(WB_IO2, OUTPUT);\ndigitalWrite(WB_IO2, HIGH);\n\n// Control Chip Switch\npinMode(WB_IO5, OUTPUT);\ndigitalWrite(WB_IO5, LOW);\n\n// Control Relay Module\npinMode(RELAY_PIN,OUTPUT);\ndigitalWrite(RELAY_PIN, LOW);    // relay module initially LOW\n\npinMode(LED_GREEN, OUTPUT);      // Output LED\npinMode(LED_BLUE, OUTPUT);       // Output LED\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial) {\nif ((millis() - timeout) < 5000) {\ndelay(100);\n} else {\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA) {\nSerial.println(\"Type: OTAA\");\n} else {\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion) {\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA) {\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n} else {\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0) {\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"===========================================\");\nSerial.println(\"RAK12014 + RAK12029 + RAK13001 LoRaWAN Code\");\nSerial.println(\"===========================================\");\n\nWire.begin();\n\n// Configure VL53L0X component.\nsensor_vl53l0x.begin();\n\n// Switch off VL53L0X component.\nsensor_vl53l0x.VL53L0X_Off();\n\n// Initialize VL53L0X component.\nstatus = sensor_vl53l0x.InitSensor(0x52);\nif (status) {\nSerial.println(\"Init sensor_vl53l0x failed...\");\n}\n\n// From RAK12029\nldc.LDC1614_init();\n/*single channel use case configuration.*/\nif (ldc.LDC1614_single_channel_config(GETCHANNEL, INDUCTANCE, CAPATANCE)) {\nSerial.println(\"can't detect sensor!\");\nwhile (1) delay(100);\n}\n}\n\nvoid loop() {\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\n// Read data from RAK12014\nstatus = sensor_vl53l0x.GetDistance(&distance);\n\n// Read data from RAK12029\nldc.IIC_read_16bit(LDC1614_READ_DEVICE_ID, &value);\nif (value == 0x3055) {\n//u32 ChannelData = 0;\n/*Get channel 0 result and parse it.*/\ndelay(100);\nif (ldc.LDC1614_get_channel_result(GETCHANNEL, &ChannelData) == 0) {\n/*sensor result value.you can make a lot of application according to its changes.*/\nif (0 != ChannelData) {\ndigitalWrite(LED_BLUE, HIGH);     // Indicator Blue LED\ndigitalWrite(LED_GREEN, HIGH);    // Indicator Green LED\n}\ndelay(200);\ndigitalWrite(LED_BLUE, LOW);        // Indicator Blue LED\ndigitalWrite(LED_GREEN, LOW);       // Indicator Green LED\n}\n}\n\nif (ChannelData >= 49800000)            // metallic material sensed nearby via inductive sensor\n{\ndigitalWrite(RELAY_PIN, HIGH);        // Turns ON the relay module\nobject = 1;                           // \"1\" corresponds to metallic object\nSerial.println(\"Metal Detected\");\n}\n\nelse if (ChannelData <= 49650000)       // nothing metallic was sensed; default value sensed by the inductive sensor\n{\ndigitalWrite(RELAY_PIN, LOW);         // Turns OFF the relay module\nobject = 0;                           // \"0\" corresponds to non-metallic object\nSerial.println(\"No Metal Detected\");\n}\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\nSerial.print(distance);       // From RAK12014 module\nSerial.println(\"mm   \");\nSerial.println(object);       // From RAK13001 module\nSerial.println(ChannelData);  // From RAK12029 module\n\ndelay(5000);\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void) {\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void) {\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data) {\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class) {\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void) {\nif (lmh_join_status_get() != LMH_SET) {\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\ndata = \" Distance: \" + String(distance) + \" mm \" + \" Metallic: \" + String(object) + \" Inductive_Sense: \" + String(ChannelData);\nSerial.println(data);\n\nuint32_t distance_data = distance;    // data from RAK12014 module\nuint32_t channel_data = ChannelData;  // data from RAK12029 module\nint metallic_data = object;           // data from RAK13001 module\n\nm_lora_app_data.buffer[i++] = 0x01;  // byte[0]\n\n// Data from RAK12014 module\nm_lora_app_data.buffer[i++] = (uint8_t)((distance_data & 0xFF000000) >> 24);    // byte[1]\nm_lora_app_data.buffer[i++] = (uint8_t)((distance_data & 0x00FF0000) >> 16);    // byte[2]\nm_lora_app_data.buffer[i++] = (uint8_t)((distance_data & 0x0000FF00) >> 8);     // byte[3]\nm_lora_app_data.buffer[i++] = (uint8_t)(distance_data & 0x000000FF);            // byte[4]\n\n// Data from RAK12029 module (inductive sensor)\nm_lora_app_data.buffer[i++] = (uint8_t)((channel_data & 0xFF000000) >> 24);    // byte[5]\nm_lora_app_data.buffer[i++] = (uint8_t)((channel_data & 0x00FF0000) >> 16);    // byte[6]\nm_lora_app_data.buffer[i++] = (uint8_t)((channel_data & 0x0000FF00) >> 8);     // byte[7]\nm_lora_app_data.buffer[i++] = (uint8_t)(channel_data & 0x000000FF);            // byte[8]\n\n// Data from RAK13001 module (relay module status)\nm_lora_app_data.buffer[i++] = metallic_data;                                   // byte[9]\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS) {\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n} else {\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xC0, 0x81, 0xBB, 0x65, 0x54, 0xCF, 0xF7, 0x65, 0x87, 0x70, 0xFD, 0x31, 0x7F, 0x01, 0x87, 0x51 };\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "183bc6d35e899a0424c9e9500bab4060", "product_family": "wisblock", "product_id": "kit4-industrial", "category": "How-To", "title": "WisBlock IoT Education Kit - Smart Industry Quick Start Guide > WisBlock IoT Education Kit - Smart Industry Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock Smart Industry Kit using TTN and Quibitro > Material Classifier LoRaWAN Application > LoRaWAN Code for Material Classifier > Programming the Material Classifier Device with LoRaWAN Application [CODE]", "content": "> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the code</summary>  \n```c", "keywords": ["Arduino IDE", "RAK4631", "Material Classifier", "LoRaWAN", "SX126x-Arduino"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **Material Classifier** device. Just copy the code below for **Material Classifier LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the code</summary>  \n```c\n\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h>  //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n// For RAK12014 module\n#include <vl53l0x_class.h>    // Click to install library: http://librarymanager/All#stm32duino_vl53l0x\nVL53L0X sensor_vl53l0x(&Wire, WB_IO2);\n\nuint32_t distance;\nint status;\n\n// For RAK13001 module\n#define RELAY_PIN WB_IO4\nint object;\n\n// For RAK12029 module\n#include \"RAK12029_LDC1614.h\"\n\n#define INDUCTANCE 13.000\n#define CAPATANCE 100.0\n#define GETCHANNEL LDC1614_CHANNEL_0     // LDC1614_CHANNEL_(0~3); selecting the coil channel from 0 - 3\nRAK12029_LDC1614_Inductive ldc;\n\nu16 value = 0;\nu32 ChannelData = 0;\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define RAK4631_BOARD true\n#else\n#define RAK4631_BOARD false\n#endif\n\nbool doOTAA = true;                                               // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                                       /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                                     /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5                               /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                                        /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;                           /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;                 /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                              /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = { LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF };\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = { BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler };\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xC0, 0x81, 0xBB, 0x65, 0x54, 0xCF, 0xF7, 0x65, 0x87, 0x70, 0xFD, 0x31, 0x7F, 0x01, 0x87, 0x51 };\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };\nuint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                                            /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];               //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = { m_lora_app_data_buffer, 0, 0, 0, 0 };  //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {\n// Sensor Power Switch\npinMode(WB_IO2, OUTPUT);\ndigitalWrite(WB_IO2, HIGH);\n\n// Control Chip Switch\npinMode(WB_IO5, OUTPUT);\ndigitalWrite(WB_IO5, LOW);\n\n// Control Relay Module\npinMode(RELAY_PIN,OUTPUT);\ndigitalWrite(RELAY_PIN, LOW);    // relay module initially LOW\n\npinMode(LED_GREEN, OUTPUT);      // Output LED\npinMode(LED_BLUE, OUTPUT);       // Output LED\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial) {\nif ((millis() - timeout) < 5000) {\ndelay(100);\n} else {\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA) {\nSerial.println(\"Type: OTAA\");\n} else {\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion) {\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA) {\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n} else {\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0) {\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"===========================================\");\nSerial.println(\"RAK12014 + RAK12029 + RAK13001 LoRaWAN Code\");\nSerial.println(\"===========================================\");\n\nWire.begin();\n\n// Configure VL53L0X component.\nsensor_vl53l0x.begin();\n\n// Switch off VL53L0X component.\nsensor_vl53l0x.VL53L0X_Off();\n\n// Initialize VL53L0X component.\nstatus = sensor_vl53l0x.InitSensor(0x52);\nif (status) {\nSerial.println(\"Init sensor_vl53l0x failed...\");\n}\n\n// From RAK12029\nldc.LDC1614_init();\n/*single channel use case configuration.*/\nif (ldc.LDC1614_single_channel_config(GETCHANNEL, INDUCTANCE, CAPATANCE)) {\nSerial.println(\"can't detect sensor!\");\nwhile (1) delay(100);\n}\n}\n\nvoid loop() {\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\n// Read data from RAK12014\nstatus = sensor_vl53l0x.GetDistance(&distance);\n\n// Read data from RAK12029\nldc.IIC_read_16bit(LDC1614_READ_DEVICE_ID, &value);\nif (value == 0x3055) {\n//u32 ChannelData = 0;\n/*Get channel 0 result and parse it.*/\ndelay(100);\nif (ldc.LDC1614_get_channel_result(GETCHANNEL, &ChannelData) == 0) {\n/*sensor result value.you can make a lot of application according to its changes.*/\nif (0 != ChannelData) {\ndigitalWrite(LED_BLUE, HIGH);     // Indicator Blue LED\ndigitalWrite(LED_GREEN, HIGH);    // Indicator Green LED\n}\ndelay(200);\ndigitalWrite(LED_BLUE, LOW);        // Indicator Blue LED\ndigitalWrite(LED_GREEN, LOW);       // Indicator Green LED\n}\n}\n\nif (ChannelData >= 49800000)            // metallic material sensed nearby via inductive sensor\n{\ndigitalWrite(RELAY_PIN, HIGH);        // Turns ON the relay module\nobject = 1;                           // \"1\" corresponds to metallic object\nSerial.println(\"Metal Detected\");\n}\n\nelse if (ChannelData <= 49650000)       // nothing metallic was sensed; default value sensed by the inductive sensor\n{\ndigitalWrite(RELAY_PIN, LOW);         // Turns OFF the relay module\nobject = 0;                           // \"0\" corresponds to non-metallic object\nSerial.println(\"No Metal Detected\");\n}\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\nSerial.print(distance);       // From RAK12014 module\nSerial.println(\"mm   \");\nSerial.println(object);       // From RAK13001 module\nSerial.println(ChannelData);  // From RAK12029 module\n\ndelay(5000);\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void) {\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void) {\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data) {\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class) {\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void) {\nif (lmh_join_status_get() != LMH_SET) {\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\ndata = \" Distance: \" + String(distance) + \" mm \" + \" Metallic: \" + String(object) + \" Inductive_Sense: \" + String(ChannelData);\nSerial.println(data);\n\nuint32_t distance_data = distance;    // data from RAK12014 module\nuint32_t channel_data = ChannelData;  // data from RAK12029 module\nint metallic_data = object;           // data from RAK13001 module\n\nm_lora_app_data.buffer[i++] = 0x01;  // byte[0]\n\n// Data from RAK12014 module\nm_lora_app_data.buffer[i++] = (uint8_t)((distance_data & 0xFF000000) >> 24);    // byte[1]\nm_lora_app_data.buffer[i++] = (uint8_t)((distance_data & 0x00FF0000) >> 16);    // byte[2]\nm_lora_app_data.buffer[i++] = (uint8_t)((distance_data & 0x0000FF00) >> 8);     // byte[3]\nm_lora_app_data.buffer[i++] = (uint8_t)(distance_data & 0x000000FF);            // byte[4]\n\n// Data from RAK12029 module (inductive sensor)\nm_lora_app_data.buffer[i++] = (uint8_t)((channel_data & 0xFF000000) >> 24);    // byte[5]\nm_lora_app_data.buffer[i++] = (uint8_t)((channel_data & 0x00FF0000) >> 16);    // byte[6]\nm_lora_app_data.buffer[i++] = (uint8_t)((channel_data & 0x0000FF00) >> 8);     // byte[7]\nm_lora_app_data.buffer[i++] = (uint8_t)(channel_data & 0x000000FF);            // byte[8]\n\n// Data from RAK13001 module (relay module status)\nm_lora_app_data.buffer[i++] = metallic_data;                                   // byte[9]\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS) {\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n} else {\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xC0, 0x81, 0xBB, 0x65, 0x54, 0xCF, 0xF7, 0x65, 0x87, 0x70, 0xFD, 0x31, 0x7F, 0x01, 0x87, 0x51 };\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "f814d0043b090bf57eb03b3f4d632748", "product_family": "wisblock", "product_id": "kit4-industrial", "category": "How-To", "title": "WisBlock IoT Education Kit - Smart Industry Quick Start Guide > WisBlock IoT Education Kit - Smart Industry Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock Smart Industry Kit using TTN and Quibitro > Material Classifier LoRaWAN Application > LoRaWAN Code for Material Classifier > Programming the Material Classifier Device with LoRaWAN Application [CODE]", "content": "#include <Arduino.h>\n#include <LoRaWan-RAK4630.h>  //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n// For RAK12014 module\n#include <vl53l0x_class.h>    // Click to install library: http://librarymanager/All#stm32duino_vl53l0x\nVL53L0X sensor_vl53l0x(&Wire, WB_IO2);\n\nuint32_t distance;\nint status;\n\n// For RAK13001 module\n#define RELAY_PIN WB_IO4\nint object;\n\n// For RAK12029 module\n#include \"RAK12029_LDC1614.h\"", "keywords": ["Arduino IDE", "RAK4631", "Material Classifier", "LoRaWAN", "SX126x-Arduino"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **Material Classifier** device. Just copy the code below for **Material Classifier LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the code</summary>  \n```c\n\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h>  //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n// For RAK12014 module\n#include <vl53l0x_class.h>    // Click to install library: http://librarymanager/All#stm32duino_vl53l0x\nVL53L0X sensor_vl53l0x(&Wire, WB_IO2);\n\nuint32_t distance;\nint status;\n\n// For RAK13001 module\n#define RELAY_PIN WB_IO4\nint object;\n\n// For RAK12029 module\n#include \"RAK12029_LDC1614.h\"\n\n#define INDUCTANCE 13.000\n#define CAPATANCE 100.0\n#define GETCHANNEL LDC1614_CHANNEL_0     // LDC1614_CHANNEL_(0~3); selecting the coil channel from 0 - 3\nRAK12029_LDC1614_Inductive ldc;\n\nu16 value = 0;\nu32 ChannelData = 0;\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define RAK4631_BOARD true\n#else\n#define RAK4631_BOARD false\n#endif\n\nbool doOTAA = true;                                               // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                                       /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                                     /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5                               /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                                        /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;                           /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;                 /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                              /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = { LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF };\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = { BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler };\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xC0, 0x81, 0xBB, 0x65, 0x54, 0xCF, 0xF7, 0x65, 0x87, 0x70, 0xFD, 0x31, 0x7F, 0x01, 0x87, 0x51 };\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };\nuint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                                            /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];               //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = { m_lora_app_data_buffer, 0, 0, 0, 0 };  //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {\n// Sensor Power Switch\npinMode(WB_IO2, OUTPUT);\ndigitalWrite(WB_IO2, HIGH);\n\n// Control Chip Switch\npinMode(WB_IO5, OUTPUT);\ndigitalWrite(WB_IO5, LOW);\n\n// Control Relay Module\npinMode(RELAY_PIN,OUTPUT);\ndigitalWrite(RELAY_PIN, LOW);    // relay module initially LOW\n\npinMode(LED_GREEN, OUTPUT);      // Output LED\npinMode(LED_BLUE, OUTPUT);       // Output LED\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial) {\nif ((millis() - timeout) < 5000) {\ndelay(100);\n} else {\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA) {\nSerial.println(\"Type: OTAA\");\n} else {\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion) {\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA) {\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n} else {\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0) {\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"===========================================\");\nSerial.println(\"RAK12014 + RAK12029 + RAK13001 LoRaWAN Code\");\nSerial.println(\"===========================================\");\n\nWire.begin();\n\n// Configure VL53L0X component.\nsensor_vl53l0x.begin();\n\n// Switch off VL53L0X component.\nsensor_vl53l0x.VL53L0X_Off();\n\n// Initialize VL53L0X component.\nstatus = sensor_vl53l0x.InitSensor(0x52);\nif (status) {\nSerial.println(\"Init sensor_vl53l0x failed...\");\n}\n\n// From RAK12029\nldc.LDC1614_init();\n/*single channel use case configuration.*/\nif (ldc.LDC1614_single_channel_config(GETCHANNEL, INDUCTANCE, CAPATANCE)) {\nSerial.println(\"can't detect sensor!\");\nwhile (1) delay(100);\n}\n}\n\nvoid loop() {\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\n// Read data from RAK12014\nstatus = sensor_vl53l0x.GetDistance(&distance);\n\n// Read data from RAK12029\nldc.IIC_read_16bit(LDC1614_READ_DEVICE_ID, &value);\nif (value == 0x3055) {\n//u32 ChannelData = 0;\n/*Get channel 0 result and parse it.*/\ndelay(100);\nif (ldc.LDC1614_get_channel_result(GETCHANNEL, &ChannelData) == 0) {\n/*sensor result value.you can make a lot of application according to its changes.*/\nif (0 != ChannelData) {\ndigitalWrite(LED_BLUE, HIGH);     // Indicator Blue LED\ndigitalWrite(LED_GREEN, HIGH);    // Indicator Green LED\n}\ndelay(200);\ndigitalWrite(LED_BLUE, LOW);        // Indicator Blue LED\ndigitalWrite(LED_GREEN, LOW);       // Indicator Green LED\n}\n}\n\nif (ChannelData >= 49800000)            // metallic material sensed nearby via inductive sensor\n{\ndigitalWrite(RELAY_PIN, HIGH);        // Turns ON the relay module\nobject = 1;                           // \"1\" corresponds to metallic object\nSerial.println(\"Metal Detected\");\n}\n\nelse if (ChannelData <= 49650000)       // nothing metallic was sensed; default value sensed by the inductive sensor\n{\ndigitalWrite(RELAY_PIN, LOW);         // Turns OFF the relay module\nobject = 0;                           // \"0\" corresponds to non-metallic object\nSerial.println(\"No Metal Detected\");\n}\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\nSerial.print(distance);       // From RAK12014 module\nSerial.println(\"mm   \");\nSerial.println(object);       // From RAK13001 module\nSerial.println(ChannelData);  // From RAK12029 module\n\ndelay(5000);\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void) {\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void) {\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data) {\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class) {\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void) {\nif (lmh_join_status_get() != LMH_SET) {\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\ndata = \" Distance: \" + String(distance) + \" mm \" + \" Metallic: \" + String(object) + \" Inductive_Sense: \" + String(ChannelData);\nSerial.println(data);\n\nuint32_t distance_data = distance;    // data from RAK12014 module\nuint32_t channel_data = ChannelData;  // data from RAK12029 module\nint metallic_data = object;           // data from RAK13001 module\n\nm_lora_app_data.buffer[i++] = 0x01;  // byte[0]\n\n// Data from RAK12014 module\nm_lora_app_data.buffer[i++] = (uint8_t)((distance_data & 0xFF000000) >> 24);    // byte[1]\nm_lora_app_data.buffer[i++] = (uint8_t)((distance_data & 0x00FF0000) >> 16);    // byte[2]\nm_lora_app_data.buffer[i++] = (uint8_t)((distance_data & 0x0000FF00) >> 8);     // byte[3]\nm_lora_app_data.buffer[i++] = (uint8_t)(distance_data & 0x000000FF);            // byte[4]\n\n// Data from RAK12029 module (inductive sensor)\nm_lora_app_data.buffer[i++] = (uint8_t)((channel_data & 0xFF000000) >> 24);    // byte[5]\nm_lora_app_data.buffer[i++] = (uint8_t)((channel_data & 0x00FF0000) >> 16);    // byte[6]\nm_lora_app_data.buffer[i++] = (uint8_t)((channel_data & 0x0000FF00) >> 8);     // byte[7]\nm_lora_app_data.buffer[i++] = (uint8_t)(channel_data & 0x000000FF);            // byte[8]\n\n// Data from RAK13001 module (relay module status)\nm_lora_app_data.buffer[i++] = metallic_data;                                   // byte[9]\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS) {\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n} else {\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xC0, 0x81, 0xBB, 0x65, 0x54, 0xCF, 0xF7, 0x65, 0x87, 0x70, 0xFD, 0x31, 0x7F, 0x01, 0x87, 0x51 };\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "426b70a51dfb658d3285b19ae74dfab0", "product_family": "wisblock", "product_id": "kit4-industrial", "category": "How-To", "title": "WisBlock IoT Education Kit - Smart Industry Quick Start Guide > WisBlock IoT Education Kit - Smart Industry Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock Smart Industry Kit using TTN and Quibitro > Material Classifier LoRaWAN Application > LoRaWAN Code for Material Classifier > Programming the Material Classifier Device with LoRaWAN Application [CODE]", "content": "// For RAK12029 module\n#include \"RAK12029_LDC1614.h\"\n\n#define INDUCTANCE 13.000\n#define CAPATANCE 100.0\n#define GETCHANNEL LDC1614_CHANNEL_0     // LDC1614_CHANNEL_(0~3); selecting the coil channel from 0 - 3\nRAK12029_LDC1614_Inductive ldc;\n\nu16 value = 0;\nu32 ChannelData = 0;\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define RAK4631_BOARD true\n#else\n#define RAK4631_BOARD false\n#endif", "keywords": ["Arduino IDE", "RAK4631", "Material Classifier", "LoRaWAN", "SX126x-Arduino"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **Material Classifier** device. Just copy the code below for **Material Classifier LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the code</summary>  \n```c\n\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h>  //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n// For RAK12014 module\n#include <vl53l0x_class.h>    // Click to install library: http://librarymanager/All#stm32duino_vl53l0x\nVL53L0X sensor_vl53l0x(&Wire, WB_IO2);\n\nuint32_t distance;\nint status;\n\n// For RAK13001 module\n#define RELAY_PIN WB_IO4\nint object;\n\n// For RAK12029 module\n#include \"RAK12029_LDC1614.h\"\n\n#define INDUCTANCE 13.000\n#define CAPATANCE 100.0\n#define GETCHANNEL LDC1614_CHANNEL_0     // LDC1614_CHANNEL_(0~3); selecting the coil channel from 0 - 3\nRAK12029_LDC1614_Inductive ldc;\n\nu16 value = 0;\nu32 ChannelData = 0;\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define RAK4631_BOARD true\n#else\n#define RAK4631_BOARD false\n#endif\n\nbool doOTAA = true;                                               // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                                       /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                                     /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5                               /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                                        /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;                           /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;                 /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                              /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = { LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF };\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = { BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler };\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xC0, 0x81, 0xBB, 0x65, 0x54, 0xCF, 0xF7, 0x65, 0x87, 0x70, 0xFD, 0x31, 0x7F, 0x01, 0x87, 0x51 };\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };\nuint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                                            /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];               //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = { m_lora_app_data_buffer, 0, 0, 0, 0 };  //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {\n// Sensor Power Switch\npinMode(WB_IO2, OUTPUT);\ndigitalWrite(WB_IO2, HIGH);\n\n// Control Chip Switch\npinMode(WB_IO5, OUTPUT);\ndigitalWrite(WB_IO5, LOW);\n\n// Control Relay Module\npinMode(RELAY_PIN,OUTPUT);\ndigitalWrite(RELAY_PIN, LOW);    // relay module initially LOW\n\npinMode(LED_GREEN, OUTPUT);      // Output LED\npinMode(LED_BLUE, OUTPUT);       // Output LED\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial) {\nif ((millis() - timeout) < 5000) {\ndelay(100);\n} else {\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA) {\nSerial.println(\"Type: OTAA\");\n} else {\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion) {\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA) {\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n} else {\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0) {\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"===========================================\");\nSerial.println(\"RAK12014 + RAK12029 + RAK13001 LoRaWAN Code\");\nSerial.println(\"===========================================\");\n\nWire.begin();\n\n// Configure VL53L0X component.\nsensor_vl53l0x.begin();\n\n// Switch off VL53L0X component.\nsensor_vl53l0x.VL53L0X_Off();\n\n// Initialize VL53L0X component.\nstatus = sensor_vl53l0x.InitSensor(0x52);\nif (status) {\nSerial.println(\"Init sensor_vl53l0x failed...\");\n}\n\n// From RAK12029\nldc.LDC1614_init();\n/*single channel use case configuration.*/\nif (ldc.LDC1614_single_channel_config(GETCHANNEL, INDUCTANCE, CAPATANCE)) {\nSerial.println(\"can't detect sensor!\");\nwhile (1) delay(100);\n}\n}\n\nvoid loop() {\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\n// Read data from RAK12014\nstatus = sensor_vl53l0x.GetDistance(&distance);\n\n// Read data from RAK12029\nldc.IIC_read_16bit(LDC1614_READ_DEVICE_ID, &value);\nif (value == 0x3055) {\n//u32 ChannelData = 0;\n/*Get channel 0 result and parse it.*/\ndelay(100);\nif (ldc.LDC1614_get_channel_result(GETCHANNEL, &ChannelData) == 0) {\n/*sensor result value.you can make a lot of application according to its changes.*/\nif (0 != ChannelData) {\ndigitalWrite(LED_BLUE, HIGH);     // Indicator Blue LED\ndigitalWrite(LED_GREEN, HIGH);    // Indicator Green LED\n}\ndelay(200);\ndigitalWrite(LED_BLUE, LOW);        // Indicator Blue LED\ndigitalWrite(LED_GREEN, LOW);       // Indicator Green LED\n}\n}\n\nif (ChannelData >= 49800000)            // metallic material sensed nearby via inductive sensor\n{\ndigitalWrite(RELAY_PIN, HIGH);        // Turns ON the relay module\nobject = 1;                           // \"1\" corresponds to metallic object\nSerial.println(\"Metal Detected\");\n}\n\nelse if (ChannelData <= 49650000)       // nothing metallic was sensed; default value sensed by the inductive sensor\n{\ndigitalWrite(RELAY_PIN, LOW);         // Turns OFF the relay module\nobject = 0;                           // \"0\" corresponds to non-metallic object\nSerial.println(\"No Metal Detected\");\n}\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\nSerial.print(distance);       // From RAK12014 module\nSerial.println(\"mm   \");\nSerial.println(object);       // From RAK13001 module\nSerial.println(ChannelData);  // From RAK12029 module\n\ndelay(5000);\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void) {\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void) {\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data) {\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class) {\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void) {\nif (lmh_join_status_get() != LMH_SET) {\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\ndata = \" Distance: \" + String(distance) + \" mm \" + \" Metallic: \" + String(object) + \" Inductive_Sense: \" + String(ChannelData);\nSerial.println(data);\n\nuint32_t distance_data = distance;    // data from RAK12014 module\nuint32_t channel_data = ChannelData;  // data from RAK12029 module\nint metallic_data = object;           // data from RAK13001 module\n\nm_lora_app_data.buffer[i++] = 0x01;  // byte[0]\n\n// Data from RAK12014 module\nm_lora_app_data.buffer[i++] = (uint8_t)((distance_data & 0xFF000000) >> 24);    // byte[1]\nm_lora_app_data.buffer[i++] = (uint8_t)((distance_data & 0x00FF0000) >> 16);    // byte[2]\nm_lora_app_data.buffer[i++] = (uint8_t)((distance_data & 0x0000FF00) >> 8);     // byte[3]\nm_lora_app_data.buffer[i++] = (uint8_t)(distance_data & 0x000000FF);            // byte[4]\n\n// Data from RAK12029 module (inductive sensor)\nm_lora_app_data.buffer[i++] = (uint8_t)((channel_data & 0xFF000000) >> 24);    // byte[5]\nm_lora_app_data.buffer[i++] = (uint8_t)((channel_data & 0x00FF0000) >> 16);    // byte[6]\nm_lora_app_data.buffer[i++] = (uint8_t)((channel_data & 0x0000FF00) >> 8);     // byte[7]\nm_lora_app_data.buffer[i++] = (uint8_t)(channel_data & 0x000000FF);            // byte[8]\n\n// Data from RAK13001 module (relay module status)\nm_lora_app_data.buffer[i++] = metallic_data;                                   // byte[9]\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS) {\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n} else {\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xC0, 0x81, 0xBB, 0x65, 0x54, 0xCF, 0xF7, 0x65, 0x87, 0x70, 0xFD, 0x31, 0x7F, 0x01, 0x87, 0x51 };\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "7cb35ad2ffb18d46c19c39661b456058", "product_family": "wisblock", "product_id": "kit4-industrial", "category": "How-To", "title": "WisBlock IoT Education Kit - Smart Industry Quick Start Guide > WisBlock IoT Education Kit - Smart Industry Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock Smart Industry Kit using TTN and Quibitro > Material Classifier LoRaWAN Application > LoRaWAN Code for Material Classifier > Programming the Material Classifier Device with LoRaWAN Application [CODE]", "content": "bool doOTAA = true;                                               // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                                       /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                                     /*LoRaMac datarates definition, from DR_0 to DR_5*/", "keywords": ["Arduino IDE", "RAK4631", "Material Classifier", "LoRaWAN", "SX126x-Arduino"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **Material Classifier** device. Just copy the code below for **Material Classifier LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the code</summary>  \n```c\n\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h>  //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n// For RAK12014 module\n#include <vl53l0x_class.h>    // Click to install library: http://librarymanager/All#stm32duino_vl53l0x\nVL53L0X sensor_vl53l0x(&Wire, WB_IO2);\n\nuint32_t distance;\nint status;\n\n// For RAK13001 module\n#define RELAY_PIN WB_IO4\nint object;\n\n// For RAK12029 module\n#include \"RAK12029_LDC1614.h\"\n\n#define INDUCTANCE 13.000\n#define CAPATANCE 100.0\n#define GETCHANNEL LDC1614_CHANNEL_0     // LDC1614_CHANNEL_(0~3); selecting the coil channel from 0 - 3\nRAK12029_LDC1614_Inductive ldc;\n\nu16 value = 0;\nu32 ChannelData = 0;\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define RAK4631_BOARD true\n#else\n#define RAK4631_BOARD false\n#endif\n\nbool doOTAA = true;                                               // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                                       /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                                     /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5                               /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                                        /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;                           /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;                 /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                              /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = { LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF };\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = { BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler };\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xC0, 0x81, 0xBB, 0x65, 0x54, 0xCF, 0xF7, 0x65, 0x87, 0x70, 0xFD, 0x31, 0x7F, 0x01, 0x87, 0x51 };\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };\nuint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                                            /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];               //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = { m_lora_app_data_buffer, 0, 0, 0, 0 };  //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {\n// Sensor Power Switch\npinMode(WB_IO2, OUTPUT);\ndigitalWrite(WB_IO2, HIGH);\n\n// Control Chip Switch\npinMode(WB_IO5, OUTPUT);\ndigitalWrite(WB_IO5, LOW);\n\n// Control Relay Module\npinMode(RELAY_PIN,OUTPUT);\ndigitalWrite(RELAY_PIN, LOW);    // relay module initially LOW\n\npinMode(LED_GREEN, OUTPUT);      // Output LED\npinMode(LED_BLUE, OUTPUT);       // Output LED\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial) {\nif ((millis() - timeout) < 5000) {\ndelay(100);\n} else {\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA) {\nSerial.println(\"Type: OTAA\");\n} else {\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion) {\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA) {\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n} else {\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0) {\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"===========================================\");\nSerial.println(\"RAK12014 + RAK12029 + RAK13001 LoRaWAN Code\");\nSerial.println(\"===========================================\");\n\nWire.begin();\n\n// Configure VL53L0X component.\nsensor_vl53l0x.begin();\n\n// Switch off VL53L0X component.\nsensor_vl53l0x.VL53L0X_Off();\n\n// Initialize VL53L0X component.\nstatus = sensor_vl53l0x.InitSensor(0x52);\nif (status) {\nSerial.println(\"Init sensor_vl53l0x failed...\");\n}\n\n// From RAK12029\nldc.LDC1614_init();\n/*single channel use case configuration.*/\nif (ldc.LDC1614_single_channel_config(GETCHANNEL, INDUCTANCE, CAPATANCE)) {\nSerial.println(\"can't detect sensor!\");\nwhile (1) delay(100);\n}\n}\n\nvoid loop() {\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\n// Read data from RAK12014\nstatus = sensor_vl53l0x.GetDistance(&distance);\n\n// Read data from RAK12029\nldc.IIC_read_16bit(LDC1614_READ_DEVICE_ID, &value);\nif (value == 0x3055) {\n//u32 ChannelData = 0;\n/*Get channel 0 result and parse it.*/\ndelay(100);\nif (ldc.LDC1614_get_channel_result(GETCHANNEL, &ChannelData) == 0) {\n/*sensor result value.you can make a lot of application according to its changes.*/\nif (0 != ChannelData) {\ndigitalWrite(LED_BLUE, HIGH);     // Indicator Blue LED\ndigitalWrite(LED_GREEN, HIGH);    // Indicator Green LED\n}\ndelay(200);\ndigitalWrite(LED_BLUE, LOW);        // Indicator Blue LED\ndigitalWrite(LED_GREEN, LOW);       // Indicator Green LED\n}\n}\n\nif (ChannelData >= 49800000)            // metallic material sensed nearby via inductive sensor\n{\ndigitalWrite(RELAY_PIN, HIGH);        // Turns ON the relay module\nobject = 1;                           // \"1\" corresponds to metallic object\nSerial.println(\"Metal Detected\");\n}\n\nelse if (ChannelData <= 49650000)       // nothing metallic was sensed; default value sensed by the inductive sensor\n{\ndigitalWrite(RELAY_PIN, LOW);         // Turns OFF the relay module\nobject = 0;                           // \"0\" corresponds to non-metallic object\nSerial.println(\"No Metal Detected\");\n}\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\nSerial.print(distance);       // From RAK12014 module\nSerial.println(\"mm   \");\nSerial.println(object);       // From RAK13001 module\nSerial.println(ChannelData);  // From RAK12029 module\n\ndelay(5000);\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void) {\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void) {\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data) {\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class) {\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void) {\nif (lmh_join_status_get() != LMH_SET) {\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\ndata = \" Distance: \" + String(distance) + \" mm \" + \" Metallic: \" + String(object) + \" Inductive_Sense: \" + String(ChannelData);\nSerial.println(data);\n\nuint32_t distance_data = distance;    // data from RAK12014 module\nuint32_t channel_data = ChannelData;  // data from RAK12029 module\nint metallic_data = object;           // data from RAK13001 module\n\nm_lora_app_data.buffer[i++] = 0x01;  // byte[0]\n\n// Data from RAK12014 module\nm_lora_app_data.buffer[i++] = (uint8_t)((distance_data & 0xFF000000) >> 24);    // byte[1]\nm_lora_app_data.buffer[i++] = (uint8_t)((distance_data & 0x00FF0000) >> 16);    // byte[2]\nm_lora_app_data.buffer[i++] = (uint8_t)((distance_data & 0x0000FF00) >> 8);     // byte[3]\nm_lora_app_data.buffer[i++] = (uint8_t)(distance_data & 0x000000FF);            // byte[4]\n\n// Data from RAK12029 module (inductive sensor)\nm_lora_app_data.buffer[i++] = (uint8_t)((channel_data & 0xFF000000) >> 24);    // byte[5]\nm_lora_app_data.buffer[i++] = (uint8_t)((channel_data & 0x00FF0000) >> 16);    // byte[6]\nm_lora_app_data.buffer[i++] = (uint8_t)((channel_data & 0x0000FF00) >> 8);     // byte[7]\nm_lora_app_data.buffer[i++] = (uint8_t)(channel_data & 0x000000FF);            // byte[8]\n\n// Data from RAK13001 module (relay module status)\nm_lora_app_data.buffer[i++] = metallic_data;                                   // byte[9]\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS) {\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n} else {\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xC0, 0x81, 0xBB, 0x65, 0x54, 0xCF, 0xF7, 0x65, 0x87, 0x70, 0xFD, 0x31, 0x7F, 0x01, 0x87, 0x51 };\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "2e90aaf3ad7fe3bf0a78de57b3d214c9", "product_family": "wisblock", "product_id": "kit4-industrial", "category": "How-To", "title": "WisBlock IoT Education Kit - Smart Industry Quick Start Guide > WisBlock IoT Education Kit - Smart Industry Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock Smart Industry Kit using TTN and Quibitro > Material Classifier LoRaWAN Application > LoRaWAN Code for Material Classifier > Programming the Material Classifier Device with LoRaWAN Application [CODE]", "content": "#define LORAWAN_TX_POWER TX_POWER_5                               /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                                        /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;                           /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/", "keywords": ["Arduino IDE", "RAK4631", "Material Classifier", "LoRaWAN", "SX126x-Arduino"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **Material Classifier** device. Just copy the code below for **Material Classifier LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the code</summary>  \n```c\n\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h>  //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n// For RAK12014 module\n#include <vl53l0x_class.h>    // Click to install library: http://librarymanager/All#stm32duino_vl53l0x\nVL53L0X sensor_vl53l0x(&Wire, WB_IO2);\n\nuint32_t distance;\nint status;\n\n// For RAK13001 module\n#define RELAY_PIN WB_IO4\nint object;\n\n// For RAK12029 module\n#include \"RAK12029_LDC1614.h\"\n\n#define INDUCTANCE 13.000\n#define CAPATANCE 100.0\n#define GETCHANNEL LDC1614_CHANNEL_0     // LDC1614_CHANNEL_(0~3); selecting the coil channel from 0 - 3\nRAK12029_LDC1614_Inductive ldc;\n\nu16 value = 0;\nu32 ChannelData = 0;\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define RAK4631_BOARD true\n#else\n#define RAK4631_BOARD false\n#endif\n\nbool doOTAA = true;                                               // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                                       /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                                     /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5                               /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                                        /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;                           /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;                 /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                              /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = { LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF };\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = { BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler };\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xC0, 0x81, 0xBB, 0x65, 0x54, 0xCF, 0xF7, 0x65, 0x87, 0x70, 0xFD, 0x31, 0x7F, 0x01, 0x87, 0x51 };\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };\nuint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                                            /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];               //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = { m_lora_app_data_buffer, 0, 0, 0, 0 };  //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {\n// Sensor Power Switch\npinMode(WB_IO2, OUTPUT);\ndigitalWrite(WB_IO2, HIGH);\n\n// Control Chip Switch\npinMode(WB_IO5, OUTPUT);\ndigitalWrite(WB_IO5, LOW);\n\n// Control Relay Module\npinMode(RELAY_PIN,OUTPUT);\ndigitalWrite(RELAY_PIN, LOW);    // relay module initially LOW\n\npinMode(LED_GREEN, OUTPUT);      // Output LED\npinMode(LED_BLUE, OUTPUT);       // Output LED\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial) {\nif ((millis() - timeout) < 5000) {\ndelay(100);\n} else {\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA) {\nSerial.println(\"Type: OTAA\");\n} else {\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion) {\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA) {\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n} else {\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0) {\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"===========================================\");\nSerial.println(\"RAK12014 + RAK12029 + RAK13001 LoRaWAN Code\");\nSerial.println(\"===========================================\");\n\nWire.begin();\n\n// Configure VL53L0X component.\nsensor_vl53l0x.begin();\n\n// Switch off VL53L0X component.\nsensor_vl53l0x.VL53L0X_Off();\n\n// Initialize VL53L0X component.\nstatus = sensor_vl53l0x.InitSensor(0x52);\nif (status) {\nSerial.println(\"Init sensor_vl53l0x failed...\");\n}\n\n// From RAK12029\nldc.LDC1614_init();\n/*single channel use case configuration.*/\nif (ldc.LDC1614_single_channel_config(GETCHANNEL, INDUCTANCE, CAPATANCE)) {\nSerial.println(\"can't detect sensor!\");\nwhile (1) delay(100);\n}\n}\n\nvoid loop() {\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\n// Read data from RAK12014\nstatus = sensor_vl53l0x.GetDistance(&distance);\n\n// Read data from RAK12029\nldc.IIC_read_16bit(LDC1614_READ_DEVICE_ID, &value);\nif (value == 0x3055) {\n//u32 ChannelData = 0;\n/*Get channel 0 result and parse it.*/\ndelay(100);\nif (ldc.LDC1614_get_channel_result(GETCHANNEL, &ChannelData) == 0) {\n/*sensor result value.you can make a lot of application according to its changes.*/\nif (0 != ChannelData) {\ndigitalWrite(LED_BLUE, HIGH);     // Indicator Blue LED\ndigitalWrite(LED_GREEN, HIGH);    // Indicator Green LED\n}\ndelay(200);\ndigitalWrite(LED_BLUE, LOW);        // Indicator Blue LED\ndigitalWrite(LED_GREEN, LOW);       // Indicator Green LED\n}\n}\n\nif (ChannelData >= 49800000)            // metallic material sensed nearby via inductive sensor\n{\ndigitalWrite(RELAY_PIN, HIGH);        // Turns ON the relay module\nobject = 1;                           // \"1\" corresponds to metallic object\nSerial.println(\"Metal Detected\");\n}\n\nelse if (ChannelData <= 49650000)       // nothing metallic was sensed; default value sensed by the inductive sensor\n{\ndigitalWrite(RELAY_PIN, LOW);         // Turns OFF the relay module\nobject = 0;                           // \"0\" corresponds to non-metallic object\nSerial.println(\"No Metal Detected\");\n}\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\nSerial.print(distance);       // From RAK12014 module\nSerial.println(\"mm   \");\nSerial.println(object);       // From RAK13001 module\nSerial.println(ChannelData);  // From RAK12029 module\n\ndelay(5000);\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void) {\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void) {\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data) {\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class) {\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void) {\nif (lmh_join_status_get() != LMH_SET) {\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\ndata = \" Distance: \" + String(distance) + \" mm \" + \" Metallic: \" + String(object) + \" Inductive_Sense: \" + String(ChannelData);\nSerial.println(data);\n\nuint32_t distance_data = distance;    // data from RAK12014 module\nuint32_t channel_data = ChannelData;  // data from RAK12029 module\nint metallic_data = object;           // data from RAK13001 module\n\nm_lora_app_data.buffer[i++] = 0x01;  // byte[0]\n\n// Data from RAK12014 module\nm_lora_app_data.buffer[i++] = (uint8_t)((distance_data & 0xFF000000) >> 24);    // byte[1]\nm_lora_app_data.buffer[i++] = (uint8_t)((distance_data & 0x00FF0000) >> 16);    // byte[2]\nm_lora_app_data.buffer[i++] = (uint8_t)((distance_data & 0x0000FF00) >> 8);     // byte[3]\nm_lora_app_data.buffer[i++] = (uint8_t)(distance_data & 0x000000FF);            // byte[4]\n\n// Data from RAK12029 module (inductive sensor)\nm_lora_app_data.buffer[i++] = (uint8_t)((channel_data & 0xFF000000) >> 24);    // byte[5]\nm_lora_app_data.buffer[i++] = (uint8_t)((channel_data & 0x00FF0000) >> 16);    // byte[6]\nm_lora_app_data.buffer[i++] = (uint8_t)((channel_data & 0x0000FF00) >> 8);     // byte[7]\nm_lora_app_data.buffer[i++] = (uint8_t)(channel_data & 0x000000FF);            // byte[8]\n\n// Data from RAK13001 module (relay module status)\nm_lora_app_data.buffer[i++] = metallic_data;                                   // byte[9]\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS) {\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n} else {\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xC0, 0x81, 0xBB, 0x65, 0x54, 0xCF, 0xF7, 0x65, 0x87, 0x70, 0xFD, 0x31, 0x7F, 0x01, 0x87, 0x51 };\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "1aaf65d19d7afe48af7bb8c4fa67828c", "product_family": "wisblock", "product_id": "kit4-industrial", "category": "How-To", "title": "WisBlock IoT Education Kit - Smart Industry Quick Start Guide > WisBlock IoT Education Kit - Smart Industry Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock Smart Industry Kit using TTN and Quibitro > Material Classifier LoRaWAN Application > LoRaWAN Code for Material Classifier > Programming the Material Classifier Device with LoRaWAN Application [CODE]", "content": "LoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;                 /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                              /* data port*/", "keywords": ["Arduino IDE", "RAK4631", "Material Classifier", "LoRaWAN", "SX126x-Arduino"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **Material Classifier** device. Just copy the code below for **Material Classifier LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the code</summary>  \n```c\n\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h>  //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n// For RAK12014 module\n#include <vl53l0x_class.h>    // Click to install library: http://librarymanager/All#stm32duino_vl53l0x\nVL53L0X sensor_vl53l0x(&Wire, WB_IO2);\n\nuint32_t distance;\nint status;\n\n// For RAK13001 module\n#define RELAY_PIN WB_IO4\nint object;\n\n// For RAK12029 module\n#include \"RAK12029_LDC1614.h\"\n\n#define INDUCTANCE 13.000\n#define CAPATANCE 100.0\n#define GETCHANNEL LDC1614_CHANNEL_0     // LDC1614_CHANNEL_(0~3); selecting the coil channel from 0 - 3\nRAK12029_LDC1614_Inductive ldc;\n\nu16 value = 0;\nu32 ChannelData = 0;\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define RAK4631_BOARD true\n#else\n#define RAK4631_BOARD false\n#endif\n\nbool doOTAA = true;                                               // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                                       /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                                     /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5                               /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                                        /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;                           /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;                 /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                              /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = { LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF };\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = { BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler };\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xC0, 0x81, 0xBB, 0x65, 0x54, 0xCF, 0xF7, 0x65, 0x87, 0x70, 0xFD, 0x31, 0x7F, 0x01, 0x87, 0x51 };\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };\nuint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                                            /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];               //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = { m_lora_app_data_buffer, 0, 0, 0, 0 };  //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {\n// Sensor Power Switch\npinMode(WB_IO2, OUTPUT);\ndigitalWrite(WB_IO2, HIGH);\n\n// Control Chip Switch\npinMode(WB_IO5, OUTPUT);\ndigitalWrite(WB_IO5, LOW);\n\n// Control Relay Module\npinMode(RELAY_PIN,OUTPUT);\ndigitalWrite(RELAY_PIN, LOW);    // relay module initially LOW\n\npinMode(LED_GREEN, OUTPUT);      // Output LED\npinMode(LED_BLUE, OUTPUT);       // Output LED\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial) {\nif ((millis() - timeout) < 5000) {\ndelay(100);\n} else {\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA) {\nSerial.println(\"Type: OTAA\");\n} else {\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion) {\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA) {\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n} else {\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0) {\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"===========================================\");\nSerial.println(\"RAK12014 + RAK12029 + RAK13001 LoRaWAN Code\");\nSerial.println(\"===========================================\");\n\nWire.begin();\n\n// Configure VL53L0X component.\nsensor_vl53l0x.begin();\n\n// Switch off VL53L0X component.\nsensor_vl53l0x.VL53L0X_Off();\n\n// Initialize VL53L0X component.\nstatus = sensor_vl53l0x.InitSensor(0x52);\nif (status) {\nSerial.println(\"Init sensor_vl53l0x failed...\");\n}\n\n// From RAK12029\nldc.LDC1614_init();\n/*single channel use case configuration.*/\nif (ldc.LDC1614_single_channel_config(GETCHANNEL, INDUCTANCE, CAPATANCE)) {\nSerial.println(\"can't detect sensor!\");\nwhile (1) delay(100);\n}\n}\n\nvoid loop() {\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\n// Read data from RAK12014\nstatus = sensor_vl53l0x.GetDistance(&distance);\n\n// Read data from RAK12029\nldc.IIC_read_16bit(LDC1614_READ_DEVICE_ID, &value);\nif (value == 0x3055) {\n//u32 ChannelData = 0;\n/*Get channel 0 result and parse it.*/\ndelay(100);\nif (ldc.LDC1614_get_channel_result(GETCHANNEL, &ChannelData) == 0) {\n/*sensor result value.you can make a lot of application according to its changes.*/\nif (0 != ChannelData) {\ndigitalWrite(LED_BLUE, HIGH);     // Indicator Blue LED\ndigitalWrite(LED_GREEN, HIGH);    // Indicator Green LED\n}\ndelay(200);\ndigitalWrite(LED_BLUE, LOW);        // Indicator Blue LED\ndigitalWrite(LED_GREEN, LOW);       // Indicator Green LED\n}\n}\n\nif (ChannelData >= 49800000)            // metallic material sensed nearby via inductive sensor\n{\ndigitalWrite(RELAY_PIN, HIGH);        // Turns ON the relay module\nobject = 1;                           // \"1\" corresponds to metallic object\nSerial.println(\"Metal Detected\");\n}\n\nelse if (ChannelData <= 49650000)       // nothing metallic was sensed; default value sensed by the inductive sensor\n{\ndigitalWrite(RELAY_PIN, LOW);         // Turns OFF the relay module\nobject = 0;                           // \"0\" corresponds to non-metallic object\nSerial.println(\"No Metal Detected\");\n}\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\nSerial.print(distance);       // From RAK12014 module\nSerial.println(\"mm   \");\nSerial.println(object);       // From RAK13001 module\nSerial.println(ChannelData);  // From RAK12029 module\n\ndelay(5000);\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void) {\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void) {\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data) {\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class) {\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void) {\nif (lmh_join_status_get() != LMH_SET) {\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\ndata = \" Distance: \" + String(distance) + \" mm \" + \" Metallic: \" + String(object) + \" Inductive_Sense: \" + String(ChannelData);\nSerial.println(data);\n\nuint32_t distance_data = distance;    // data from RAK12014 module\nuint32_t channel_data = ChannelData;  // data from RAK12029 module\nint metallic_data = object;           // data from RAK13001 module\n\nm_lora_app_data.buffer[i++] = 0x01;  // byte[0]\n\n// Data from RAK12014 module\nm_lora_app_data.buffer[i++] = (uint8_t)((distance_data & 0xFF000000) >> 24);    // byte[1]\nm_lora_app_data.buffer[i++] = (uint8_t)((distance_data & 0x00FF0000) >> 16);    // byte[2]\nm_lora_app_data.buffer[i++] = (uint8_t)((distance_data & 0x0000FF00) >> 8);     // byte[3]\nm_lora_app_data.buffer[i++] = (uint8_t)(distance_data & 0x000000FF);            // byte[4]\n\n// Data from RAK12029 module (inductive sensor)\nm_lora_app_data.buffer[i++] = (uint8_t)((channel_data & 0xFF000000) >> 24);    // byte[5]\nm_lora_app_data.buffer[i++] = (uint8_t)((channel_data & 0x00FF0000) >> 16);    // byte[6]\nm_lora_app_data.buffer[i++] = (uint8_t)((channel_data & 0x0000FF00) >> 8);     // byte[7]\nm_lora_app_data.buffer[i++] = (uint8_t)(channel_data & 0x000000FF);            // byte[8]\n\n// Data from RAK13001 module (relay module status)\nm_lora_app_data.buffer[i++] = metallic_data;                                   // byte[9]\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS) {\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n} else {\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xC0, 0x81, 0xBB, 0x65, 0x54, 0xCF, 0xF7, 0x65, 0x87, 0x70, 0xFD, 0x31, 0x7F, 0x01, 0x87, 0x51 };\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "bc41c6cd1403a56d1f2e6ff7956b625f", "product_family": "wisblock", "product_id": "kit4-industrial", "category": "How-To", "title": "WisBlock IoT Education Kit - Smart Industry Quick Start Guide > WisBlock IoT Education Kit - Smart Industry Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock Smart Industry Kit using TTN and Quibitro > Material Classifier LoRaWAN Application > LoRaWAN Code for Material Classifier > Programming the Material Classifier Device with LoRaWAN Application [CODE]", "content": "/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = { LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF };", "keywords": ["Arduino IDE", "RAK4631", "Material Classifier", "LoRaWAN", "SX126x-Arduino"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **Material Classifier** device. Just copy the code below for **Material Classifier LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the code</summary>  \n```c\n\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h>  //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n// For RAK12014 module\n#include <vl53l0x_class.h>    // Click to install library: http://librarymanager/All#stm32duino_vl53l0x\nVL53L0X sensor_vl53l0x(&Wire, WB_IO2);\n\nuint32_t distance;\nint status;\n\n// For RAK13001 module\n#define RELAY_PIN WB_IO4\nint object;\n\n// For RAK12029 module\n#include \"RAK12029_LDC1614.h\"\n\n#define INDUCTANCE 13.000\n#define CAPATANCE 100.0\n#define GETCHANNEL LDC1614_CHANNEL_0     // LDC1614_CHANNEL_(0~3); selecting the coil channel from 0 - 3\nRAK12029_LDC1614_Inductive ldc;\n\nu16 value = 0;\nu32 ChannelData = 0;\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define RAK4631_BOARD true\n#else\n#define RAK4631_BOARD false\n#endif\n\nbool doOTAA = true;                                               // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                                       /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                                     /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5                               /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                                        /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;                           /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;                 /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                              /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = { LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF };\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = { BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler };\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xC0, 0x81, 0xBB, 0x65, 0x54, 0xCF, 0xF7, 0x65, 0x87, 0x70, 0xFD, 0x31, 0x7F, 0x01, 0x87, 0x51 };\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };\nuint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                                            /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];               //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = { m_lora_app_data_buffer, 0, 0, 0, 0 };  //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {\n// Sensor Power Switch\npinMode(WB_IO2, OUTPUT);\ndigitalWrite(WB_IO2, HIGH);\n\n// Control Chip Switch\npinMode(WB_IO5, OUTPUT);\ndigitalWrite(WB_IO5, LOW);\n\n// Control Relay Module\npinMode(RELAY_PIN,OUTPUT);\ndigitalWrite(RELAY_PIN, LOW);    // relay module initially LOW\n\npinMode(LED_GREEN, OUTPUT);      // Output LED\npinMode(LED_BLUE, OUTPUT);       // Output LED\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial) {\nif ((millis() - timeout) < 5000) {\ndelay(100);\n} else {\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA) {\nSerial.println(\"Type: OTAA\");\n} else {\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion) {\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA) {\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n} else {\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0) {\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"===========================================\");\nSerial.println(\"RAK12014 + RAK12029 + RAK13001 LoRaWAN Code\");\nSerial.println(\"===========================================\");\n\nWire.begin();\n\n// Configure VL53L0X component.\nsensor_vl53l0x.begin();\n\n// Switch off VL53L0X component.\nsensor_vl53l0x.VL53L0X_Off();\n\n// Initialize VL53L0X component.\nstatus = sensor_vl53l0x.InitSensor(0x52);\nif (status) {\nSerial.println(\"Init sensor_vl53l0x failed...\");\n}\n\n// From RAK12029\nldc.LDC1614_init();\n/*single channel use case configuration.*/\nif (ldc.LDC1614_single_channel_config(GETCHANNEL, INDUCTANCE, CAPATANCE)) {\nSerial.println(\"can't detect sensor!\");\nwhile (1) delay(100);\n}\n}\n\nvoid loop() {\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\n// Read data from RAK12014\nstatus = sensor_vl53l0x.GetDistance(&distance);\n\n// Read data from RAK12029\nldc.IIC_read_16bit(LDC1614_READ_DEVICE_ID, &value);\nif (value == 0x3055) {\n//u32 ChannelData = 0;\n/*Get channel 0 result and parse it.*/\ndelay(100);\nif (ldc.LDC1614_get_channel_result(GETCHANNEL, &ChannelData) == 0) {\n/*sensor result value.you can make a lot of application according to its changes.*/\nif (0 != ChannelData) {\ndigitalWrite(LED_BLUE, HIGH);     // Indicator Blue LED\ndigitalWrite(LED_GREEN, HIGH);    // Indicator Green LED\n}\ndelay(200);\ndigitalWrite(LED_BLUE, LOW);        // Indicator Blue LED\ndigitalWrite(LED_GREEN, LOW);       // Indicator Green LED\n}\n}\n\nif (ChannelData >= 49800000)            // metallic material sensed nearby via inductive sensor\n{\ndigitalWrite(RELAY_PIN, HIGH);        // Turns ON the relay module\nobject = 1;                           // \"1\" corresponds to metallic object\nSerial.println(\"Metal Detected\");\n}\n\nelse if (ChannelData <= 49650000)       // nothing metallic was sensed; default value sensed by the inductive sensor\n{\ndigitalWrite(RELAY_PIN, LOW);         // Turns OFF the relay module\nobject = 0;                           // \"0\" corresponds to non-metallic object\nSerial.println(\"No Metal Detected\");\n}\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\nSerial.print(distance);       // From RAK12014 module\nSerial.println(\"mm   \");\nSerial.println(object);       // From RAK13001 module\nSerial.println(ChannelData);  // From RAK12029 module\n\ndelay(5000);\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void) {\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void) {\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data) {\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class) {\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void) {\nif (lmh_join_status_get() != LMH_SET) {\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\ndata = \" Distance: \" + String(distance) + \" mm \" + \" Metallic: \" + String(object) + \" Inductive_Sense: \" + String(ChannelData);\nSerial.println(data);\n\nuint32_t distance_data = distance;    // data from RAK12014 module\nuint32_t channel_data = ChannelData;  // data from RAK12029 module\nint metallic_data = object;           // data from RAK13001 module\n\nm_lora_app_data.buffer[i++] = 0x01;  // byte[0]\n\n// Data from RAK12014 module\nm_lora_app_data.buffer[i++] = (uint8_t)((distance_data & 0xFF000000) >> 24);    // byte[1]\nm_lora_app_data.buffer[i++] = (uint8_t)((distance_data & 0x00FF0000) >> 16);    // byte[2]\nm_lora_app_data.buffer[i++] = (uint8_t)((distance_data & 0x0000FF00) >> 8);     // byte[3]\nm_lora_app_data.buffer[i++] = (uint8_t)(distance_data & 0x000000FF);            // byte[4]\n\n// Data from RAK12029 module (inductive sensor)\nm_lora_app_data.buffer[i++] = (uint8_t)((channel_data & 0xFF000000) >> 24);    // byte[5]\nm_lora_app_data.buffer[i++] = (uint8_t)((channel_data & 0x00FF0000) >> 16);    // byte[6]\nm_lora_app_data.buffer[i++] = (uint8_t)((channel_data & 0x0000FF00) >> 8);     // byte[7]\nm_lora_app_data.buffer[i++] = (uint8_t)(channel_data & 0x000000FF);            // byte[8]\n\n// Data from RAK13001 module (relay module status)\nm_lora_app_data.buffer[i++] = metallic_data;                                   // byte[9]\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS) {\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n} else {\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xC0, 0x81, 0xBB, 0x65, 0x54, 0xCF, 0xF7, 0x65, 0x87, 0x70, 0xFD, 0x31, 0x7F, 0x01, 0x87, 0x51 };\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "0dcd4e113d04345533f3d9b2a4901b7b", "product_family": "wisblock", "product_id": "kit4-industrial", "category": "How-To", "title": "WisBlock IoT Education Kit - Smart Industry Quick Start Guide > WisBlock IoT Education Kit - Smart Industry Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock Smart Industry Kit using TTN and Quibitro > Material Classifier LoRaWAN Application > LoRaWAN Code for Material Classifier > Programming the Material Classifier Device with LoRaWAN Application [CODE]", "content": "// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);", "keywords": ["Arduino IDE", "RAK4631", "Material Classifier", "LoRaWAN", "SX126x-Arduino"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **Material Classifier** device. Just copy the code below for **Material Classifier LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the code</summary>  \n```c\n\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h>  //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n// For RAK12014 module\n#include <vl53l0x_class.h>    // Click to install library: http://librarymanager/All#stm32duino_vl53l0x\nVL53L0X sensor_vl53l0x(&Wire, WB_IO2);\n\nuint32_t distance;\nint status;\n\n// For RAK13001 module\n#define RELAY_PIN WB_IO4\nint object;\n\n// For RAK12029 module\n#include \"RAK12029_LDC1614.h\"\n\n#define INDUCTANCE 13.000\n#define CAPATANCE 100.0\n#define GETCHANNEL LDC1614_CHANNEL_0     // LDC1614_CHANNEL_(0~3); selecting the coil channel from 0 - 3\nRAK12029_LDC1614_Inductive ldc;\n\nu16 value = 0;\nu32 ChannelData = 0;\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define RAK4631_BOARD true\n#else\n#define RAK4631_BOARD false\n#endif\n\nbool doOTAA = true;                                               // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                                       /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                                     /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5                               /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                                        /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;                           /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;                 /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                              /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = { LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF };\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = { BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler };\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xC0, 0x81, 0xBB, 0x65, 0x54, 0xCF, 0xF7, 0x65, 0x87, 0x70, 0xFD, 0x31, 0x7F, 0x01, 0x87, 0x51 };\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };\nuint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                                            /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];               //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = { m_lora_app_data_buffer, 0, 0, 0, 0 };  //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {\n// Sensor Power Switch\npinMode(WB_IO2, OUTPUT);\ndigitalWrite(WB_IO2, HIGH);\n\n// Control Chip Switch\npinMode(WB_IO5, OUTPUT);\ndigitalWrite(WB_IO5, LOW);\n\n// Control Relay Module\npinMode(RELAY_PIN,OUTPUT);\ndigitalWrite(RELAY_PIN, LOW);    // relay module initially LOW\n\npinMode(LED_GREEN, OUTPUT);      // Output LED\npinMode(LED_BLUE, OUTPUT);       // Output LED\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial) {\nif ((millis() - timeout) < 5000) {\ndelay(100);\n} else {\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA) {\nSerial.println(\"Type: OTAA\");\n} else {\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion) {\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA) {\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n} else {\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0) {\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"===========================================\");\nSerial.println(\"RAK12014 + RAK12029 + RAK13001 LoRaWAN Code\");\nSerial.println(\"===========================================\");\n\nWire.begin();\n\n// Configure VL53L0X component.\nsensor_vl53l0x.begin();\n\n// Switch off VL53L0X component.\nsensor_vl53l0x.VL53L0X_Off();\n\n// Initialize VL53L0X component.\nstatus = sensor_vl53l0x.InitSensor(0x52);\nif (status) {\nSerial.println(\"Init sensor_vl53l0x failed...\");\n}\n\n// From RAK12029\nldc.LDC1614_init();\n/*single channel use case configuration.*/\nif (ldc.LDC1614_single_channel_config(GETCHANNEL, INDUCTANCE, CAPATANCE)) {\nSerial.println(\"can't detect sensor!\");\nwhile (1) delay(100);\n}\n}\n\nvoid loop() {\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\n// Read data from RAK12014\nstatus = sensor_vl53l0x.GetDistance(&distance);\n\n// Read data from RAK12029\nldc.IIC_read_16bit(LDC1614_READ_DEVICE_ID, &value);\nif (value == 0x3055) {\n//u32 ChannelData = 0;\n/*Get channel 0 result and parse it.*/\ndelay(100);\nif (ldc.LDC1614_get_channel_result(GETCHANNEL, &ChannelData) == 0) {\n/*sensor result value.you can make a lot of application according to its changes.*/\nif (0 != ChannelData) {\ndigitalWrite(LED_BLUE, HIGH);     // Indicator Blue LED\ndigitalWrite(LED_GREEN, HIGH);    // Indicator Green LED\n}\ndelay(200);\ndigitalWrite(LED_BLUE, LOW);        // Indicator Blue LED\ndigitalWrite(LED_GREEN, LOW);       // Indicator Green LED\n}\n}\n\nif (ChannelData >= 49800000)            // metallic material sensed nearby via inductive sensor\n{\ndigitalWrite(RELAY_PIN, HIGH);        // Turns ON the relay module\nobject = 1;                           // \"1\" corresponds to metallic object\nSerial.println(\"Metal Detected\");\n}\n\nelse if (ChannelData <= 49650000)       // nothing metallic was sensed; default value sensed by the inductive sensor\n{\ndigitalWrite(RELAY_PIN, LOW);         // Turns OFF the relay module\nobject = 0;                           // \"0\" corresponds to non-metallic object\nSerial.println(\"No Metal Detected\");\n}\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\nSerial.print(distance);       // From RAK12014 module\nSerial.println(\"mm   \");\nSerial.println(object);       // From RAK13001 module\nSerial.println(ChannelData);  // From RAK12029 module\n\ndelay(5000);\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void) {\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void) {\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data) {\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class) {\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void) {\nif (lmh_join_status_get() != LMH_SET) {\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\ndata = \" Distance: \" + String(distance) + \" mm \" + \" Metallic: \" + String(object) + \" Inductive_Sense: \" + String(ChannelData);\nSerial.println(data);\n\nuint32_t distance_data = distance;    // data from RAK12014 module\nuint32_t channel_data = ChannelData;  // data from RAK12029 module\nint metallic_data = object;           // data from RAK13001 module\n\nm_lora_app_data.buffer[i++] = 0x01;  // byte[0]\n\n// Data from RAK12014 module\nm_lora_app_data.buffer[i++] = (uint8_t)((distance_data & 0xFF000000) >> 24);    // byte[1]\nm_lora_app_data.buffer[i++] = (uint8_t)((distance_data & 0x00FF0000) >> 16);    // byte[2]\nm_lora_app_data.buffer[i++] = (uint8_t)((distance_data & 0x0000FF00) >> 8);     // byte[3]\nm_lora_app_data.buffer[i++] = (uint8_t)(distance_data & 0x000000FF);            // byte[4]\n\n// Data from RAK12029 module (inductive sensor)\nm_lora_app_data.buffer[i++] = (uint8_t)((channel_data & 0xFF000000) >> 24);    // byte[5]\nm_lora_app_data.buffer[i++] = (uint8_t)((channel_data & 0x00FF0000) >> 16);    // byte[6]\nm_lora_app_data.buffer[i++] = (uint8_t)((channel_data & 0x0000FF00) >> 8);     // byte[7]\nm_lora_app_data.buffer[i++] = (uint8_t)(channel_data & 0x000000FF);            // byte[8]\n\n// Data from RAK13001 module (relay module status)\nm_lora_app_data.buffer[i++] = metallic_data;                                   // byte[9]\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS) {\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n} else {\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xC0, 0x81, 0xBB, 0x65, 0x54, 0xCF, 0xF7, 0x65, 0x87, 0x70, 0xFD, 0x31, 0x7F, 0x01, 0x87, 0x51 };\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "84754a03e46399c578aa57024a32403c", "product_family": "wisblock", "product_id": "kit4-industrial", "category": "How-To", "title": "WisBlock IoT Education Kit - Smart Industry Quick Start Guide > WisBlock IoT Education Kit - Smart Industry Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock Smart Industry Kit using TTN and Quibitro > Material Classifier LoRaWAN Application > LoRaWAN Code for Material Classifier > Programming the Material Classifier Device with LoRaWAN Application [CODE]", "content": "/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = { BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler };\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };", "keywords": ["Arduino IDE", "RAK4631", "Material Classifier", "LoRaWAN", "SX126x-Arduino"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **Material Classifier** device. Just copy the code below for **Material Classifier LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the code</summary>  \n```c\n\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h>  //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n// For RAK12014 module\n#include <vl53l0x_class.h>    // Click to install library: http://librarymanager/All#stm32duino_vl53l0x\nVL53L0X sensor_vl53l0x(&Wire, WB_IO2);\n\nuint32_t distance;\nint status;\n\n// For RAK13001 module\n#define RELAY_PIN WB_IO4\nint object;\n\n// For RAK12029 module\n#include \"RAK12029_LDC1614.h\"\n\n#define INDUCTANCE 13.000\n#define CAPATANCE 100.0\n#define GETCHANNEL LDC1614_CHANNEL_0     // LDC1614_CHANNEL_(0~3); selecting the coil channel from 0 - 3\nRAK12029_LDC1614_Inductive ldc;\n\nu16 value = 0;\nu32 ChannelData = 0;\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define RAK4631_BOARD true\n#else\n#define RAK4631_BOARD false\n#endif\n\nbool doOTAA = true;                                               // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                                       /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                                     /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5                               /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                                        /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;                           /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;                 /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                              /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = { LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF };\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = { BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler };\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xC0, 0x81, 0xBB, 0x65, 0x54, 0xCF, 0xF7, 0x65, 0x87, 0x70, 0xFD, 0x31, 0x7F, 0x01, 0x87, 0x51 };\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };\nuint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                                            /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];               //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = { m_lora_app_data_buffer, 0, 0, 0, 0 };  //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {\n// Sensor Power Switch\npinMode(WB_IO2, OUTPUT);\ndigitalWrite(WB_IO2, HIGH);\n\n// Control Chip Switch\npinMode(WB_IO5, OUTPUT);\ndigitalWrite(WB_IO5, LOW);\n\n// Control Relay Module\npinMode(RELAY_PIN,OUTPUT);\ndigitalWrite(RELAY_PIN, LOW);    // relay module initially LOW\n\npinMode(LED_GREEN, OUTPUT);      // Output LED\npinMode(LED_BLUE, OUTPUT);       // Output LED\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial) {\nif ((millis() - timeout) < 5000) {\ndelay(100);\n} else {\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA) {\nSerial.println(\"Type: OTAA\");\n} else {\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion) {\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA) {\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n} else {\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0) {\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"===========================================\");\nSerial.println(\"RAK12014 + RAK12029 + RAK13001 LoRaWAN Code\");\nSerial.println(\"===========================================\");\n\nWire.begin();\n\n// Configure VL53L0X component.\nsensor_vl53l0x.begin();\n\n// Switch off VL53L0X component.\nsensor_vl53l0x.VL53L0X_Off();\n\n// Initialize VL53L0X component.\nstatus = sensor_vl53l0x.InitSensor(0x52);\nif (status) {\nSerial.println(\"Init sensor_vl53l0x failed...\");\n}\n\n// From RAK12029\nldc.LDC1614_init();\n/*single channel use case configuration.*/\nif (ldc.LDC1614_single_channel_config(GETCHANNEL, INDUCTANCE, CAPATANCE)) {\nSerial.println(\"can't detect sensor!\");\nwhile (1) delay(100);\n}\n}\n\nvoid loop() {\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\n// Read data from RAK12014\nstatus = sensor_vl53l0x.GetDistance(&distance);\n\n// Read data from RAK12029\nldc.IIC_read_16bit(LDC1614_READ_DEVICE_ID, &value);\nif (value == 0x3055) {\n//u32 ChannelData = 0;\n/*Get channel 0 result and parse it.*/\ndelay(100);\nif (ldc.LDC1614_get_channel_result(GETCHANNEL, &ChannelData) == 0) {\n/*sensor result value.you can make a lot of application according to its changes.*/\nif (0 != ChannelData) {\ndigitalWrite(LED_BLUE, HIGH);     // Indicator Blue LED\ndigitalWrite(LED_GREEN, HIGH);    // Indicator Green LED\n}\ndelay(200);\ndigitalWrite(LED_BLUE, LOW);        // Indicator Blue LED\ndigitalWrite(LED_GREEN, LOW);       // Indicator Green LED\n}\n}\n\nif (ChannelData >= 49800000)            // metallic material sensed nearby via inductive sensor\n{\ndigitalWrite(RELAY_PIN, HIGH);        // Turns ON the relay module\nobject = 1;                           // \"1\" corresponds to metallic object\nSerial.println(\"Metal Detected\");\n}\n\nelse if (ChannelData <= 49650000)       // nothing metallic was sensed; default value sensed by the inductive sensor\n{\ndigitalWrite(RELAY_PIN, LOW);         // Turns OFF the relay module\nobject = 0;                           // \"0\" corresponds to non-metallic object\nSerial.println(\"No Metal Detected\");\n}\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\nSerial.print(distance);       // From RAK12014 module\nSerial.println(\"mm   \");\nSerial.println(object);       // From RAK13001 module\nSerial.println(ChannelData);  // From RAK12029 module\n\ndelay(5000);\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void) {\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void) {\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data) {\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class) {\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void) {\nif (lmh_join_status_get() != LMH_SET) {\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\ndata = \" Distance: \" + String(distance) + \" mm \" + \" Metallic: \" + String(object) + \" Inductive_Sense: \" + String(ChannelData);\nSerial.println(data);\n\nuint32_t distance_data = distance;    // data from RAK12014 module\nuint32_t channel_data = ChannelData;  // data from RAK12029 module\nint metallic_data = object;           // data from RAK13001 module\n\nm_lora_app_data.buffer[i++] = 0x01;  // byte[0]\n\n// Data from RAK12014 module\nm_lora_app_data.buffer[i++] = (uint8_t)((distance_data & 0xFF000000) >> 24);    // byte[1]\nm_lora_app_data.buffer[i++] = (uint8_t)((distance_data & 0x00FF0000) >> 16);    // byte[2]\nm_lora_app_data.buffer[i++] = (uint8_t)((distance_data & 0x0000FF00) >> 8);     // byte[3]\nm_lora_app_data.buffer[i++] = (uint8_t)(distance_data & 0x000000FF);            // byte[4]\n\n// Data from RAK12029 module (inductive sensor)\nm_lora_app_data.buffer[i++] = (uint8_t)((channel_data & 0xFF000000) >> 24);    // byte[5]\nm_lora_app_data.buffer[i++] = (uint8_t)((channel_data & 0x00FF0000) >> 16);    // byte[6]\nm_lora_app_data.buffer[i++] = (uint8_t)((channel_data & 0x0000FF00) >> 8);     // byte[7]\nm_lora_app_data.buffer[i++] = (uint8_t)(channel_data & 0x000000FF);            // byte[8]\n\n// Data from RAK13001 module (relay module status)\nm_lora_app_data.buffer[i++] = metallic_data;                                   // byte[9]\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS) {\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n} else {\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xC0, 0x81, 0xBB, 0x65, 0x54, 0xCF, 0xF7, 0x65, 0x87, 0x70, 0xFD, 0x31, 0x7F, 0x01, 0x87, 0x51 };\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "75ac2fdb6e8f5f5f8a12542b8a359100", "product_family": "wisblock", "product_id": "kit4-industrial", "category": "How-To", "title": "WisBlock IoT Education Kit - Smart Industry Quick Start Guide > WisBlock IoT Education Kit - Smart Industry Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock Smart Industry Kit using TTN and Quibitro > Material Classifier LoRaWAN Application > LoRaWAN Code for Material Classifier > Programming the Material Classifier Device with LoRaWAN Application [CODE]", "content": "uint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xC0, 0x81, 0xBB, 0x65, 0x54, 0xCF, 0xF7, 0x65, 0x87, 0x70, 0xFD, 0x31, 0x7F, 0x01, 0x87, 0x51 };", "keywords": ["Arduino IDE", "RAK4631", "Material Classifier", "LoRaWAN", "SX126x-Arduino"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **Material Classifier** device. Just copy the code below for **Material Classifier LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the code</summary>  \n```c\n\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h>  //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n// For RAK12014 module\n#include <vl53l0x_class.h>    // Click to install library: http://librarymanager/All#stm32duino_vl53l0x\nVL53L0X sensor_vl53l0x(&Wire, WB_IO2);\n\nuint32_t distance;\nint status;\n\n// For RAK13001 module\n#define RELAY_PIN WB_IO4\nint object;\n\n// For RAK12029 module\n#include \"RAK12029_LDC1614.h\"\n\n#define INDUCTANCE 13.000\n#define CAPATANCE 100.0\n#define GETCHANNEL LDC1614_CHANNEL_0     // LDC1614_CHANNEL_(0~3); selecting the coil channel from 0 - 3\nRAK12029_LDC1614_Inductive ldc;\n\nu16 value = 0;\nu32 ChannelData = 0;\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define RAK4631_BOARD true\n#else\n#define RAK4631_BOARD false\n#endif\n\nbool doOTAA = true;                                               // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                                       /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                                     /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5                               /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                                        /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;                           /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;                 /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                              /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = { LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF };\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = { BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler };\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xC0, 0x81, 0xBB, 0x65, 0x54, 0xCF, 0xF7, 0x65, 0x87, 0x70, 0xFD, 0x31, 0x7F, 0x01, 0x87, 0x51 };\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };\nuint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                                            /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];               //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = { m_lora_app_data_buffer, 0, 0, 0, 0 };  //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {\n// Sensor Power Switch\npinMode(WB_IO2, OUTPUT);\ndigitalWrite(WB_IO2, HIGH);\n\n// Control Chip Switch\npinMode(WB_IO5, OUTPUT);\ndigitalWrite(WB_IO5, LOW);\n\n// Control Relay Module\npinMode(RELAY_PIN,OUTPUT);\ndigitalWrite(RELAY_PIN, LOW);    // relay module initially LOW\n\npinMode(LED_GREEN, OUTPUT);      // Output LED\npinMode(LED_BLUE, OUTPUT);       // Output LED\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial) {\nif ((millis() - timeout) < 5000) {\ndelay(100);\n} else {\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA) {\nSerial.println(\"Type: OTAA\");\n} else {\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion) {\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA) {\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n} else {\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0) {\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"===========================================\");\nSerial.println(\"RAK12014 + RAK12029 + RAK13001 LoRaWAN Code\");\nSerial.println(\"===========================================\");\n\nWire.begin();\n\n// Configure VL53L0X component.\nsensor_vl53l0x.begin();\n\n// Switch off VL53L0X component.\nsensor_vl53l0x.VL53L0X_Off();\n\n// Initialize VL53L0X component.\nstatus = sensor_vl53l0x.InitSensor(0x52);\nif (status) {\nSerial.println(\"Init sensor_vl53l0x failed...\");\n}\n\n// From RAK12029\nldc.LDC1614_init();\n/*single channel use case configuration.*/\nif (ldc.LDC1614_single_channel_config(GETCHANNEL, INDUCTANCE, CAPATANCE)) {\nSerial.println(\"can't detect sensor!\");\nwhile (1) delay(100);\n}\n}\n\nvoid loop() {\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\n// Read data from RAK12014\nstatus = sensor_vl53l0x.GetDistance(&distance);\n\n// Read data from RAK12029\nldc.IIC_read_16bit(LDC1614_READ_DEVICE_ID, &value);\nif (value == 0x3055) {\n//u32 ChannelData = 0;\n/*Get channel 0 result and parse it.*/\ndelay(100);\nif (ldc.LDC1614_get_channel_result(GETCHANNEL, &ChannelData) == 0) {\n/*sensor result value.you can make a lot of application according to its changes.*/\nif (0 != ChannelData) {\ndigitalWrite(LED_BLUE, HIGH);     // Indicator Blue LED\ndigitalWrite(LED_GREEN, HIGH);    // Indicator Green LED\n}\ndelay(200);\ndigitalWrite(LED_BLUE, LOW);        // Indicator Blue LED\ndigitalWrite(LED_GREEN, LOW);       // Indicator Green LED\n}\n}\n\nif (ChannelData >= 49800000)            // metallic material sensed nearby via inductive sensor\n{\ndigitalWrite(RELAY_PIN, HIGH);        // Turns ON the relay module\nobject = 1;                           // \"1\" corresponds to metallic object\nSerial.println(\"Metal Detected\");\n}\n\nelse if (ChannelData <= 49650000)       // nothing metallic was sensed; default value sensed by the inductive sensor\n{\ndigitalWrite(RELAY_PIN, LOW);         // Turns OFF the relay module\nobject = 0;                           // \"0\" corresponds to non-metallic object\nSerial.println(\"No Metal Detected\");\n}\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\nSerial.print(distance);       // From RAK12014 module\nSerial.println(\"mm   \");\nSerial.println(object);       // From RAK13001 module\nSerial.println(ChannelData);  // From RAK12029 module\n\ndelay(5000);\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void) {\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void) {\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data) {\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class) {\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void) {\nif (lmh_join_status_get() != LMH_SET) {\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\ndata = \" Distance: \" + String(distance) + \" mm \" + \" Metallic: \" + String(object) + \" Inductive_Sense: \" + String(ChannelData);\nSerial.println(data);\n\nuint32_t distance_data = distance;    // data from RAK12014 module\nuint32_t channel_data = ChannelData;  // data from RAK12029 module\nint metallic_data = object;           // data from RAK13001 module\n\nm_lora_app_data.buffer[i++] = 0x01;  // byte[0]\n\n// Data from RAK12014 module\nm_lora_app_data.buffer[i++] = (uint8_t)((distance_data & 0xFF000000) >> 24);    // byte[1]\nm_lora_app_data.buffer[i++] = (uint8_t)((distance_data & 0x00FF0000) >> 16);    // byte[2]\nm_lora_app_data.buffer[i++] = (uint8_t)((distance_data & 0x0000FF00) >> 8);     // byte[3]\nm_lora_app_data.buffer[i++] = (uint8_t)(distance_data & 0x000000FF);            // byte[4]\n\n// Data from RAK12029 module (inductive sensor)\nm_lora_app_data.buffer[i++] = (uint8_t)((channel_data & 0xFF000000) >> 24);    // byte[5]\nm_lora_app_data.buffer[i++] = (uint8_t)((channel_data & 0x00FF0000) >> 16);    // byte[6]\nm_lora_app_data.buffer[i++] = (uint8_t)((channel_data & 0x0000FF00) >> 8);     // byte[7]\nm_lora_app_data.buffer[i++] = (uint8_t)(channel_data & 0x000000FF);            // byte[8]\n\n// Data from RAK13001 module (relay module status)\nm_lora_app_data.buffer[i++] = metallic_data;                                   // byte[9]\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS) {\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n} else {\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xC0, 0x81, 0xBB, 0x65, 0x54, 0xCF, 0xF7, 0x65, 0x87, 0x70, 0xFD, 0x31, 0x7F, 0x01, 0x87, 0x51 };\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "179b59fe71dbe118e38af1bf1c945ab1", "product_family": "wisblock", "product_id": "kit4-industrial", "category": "How-To", "title": "WisBlock IoT Education Kit - Smart Industry Quick Start Guide > WisBlock IoT Education Kit - Smart Industry Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock Smart Industry Kit using TTN and Quibitro > Material Classifier LoRaWAN Application > LoRaWAN Code for Material Classifier > Programming the Material Classifier Device with LoRaWAN Application [CODE]", "content": "// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };\nuint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };", "keywords": ["Arduino IDE", "RAK4631", "Material Classifier", "LoRaWAN", "SX126x-Arduino"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **Material Classifier** device. Just copy the code below for **Material Classifier LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the code</summary>  \n```c\n\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h>  //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n// For RAK12014 module\n#include <vl53l0x_class.h>    // Click to install library: http://librarymanager/All#stm32duino_vl53l0x\nVL53L0X sensor_vl53l0x(&Wire, WB_IO2);\n\nuint32_t distance;\nint status;\n\n// For RAK13001 module\n#define RELAY_PIN WB_IO4\nint object;\n\n// For RAK12029 module\n#include \"RAK12029_LDC1614.h\"\n\n#define INDUCTANCE 13.000\n#define CAPATANCE 100.0\n#define GETCHANNEL LDC1614_CHANNEL_0     // LDC1614_CHANNEL_(0~3); selecting the coil channel from 0 - 3\nRAK12029_LDC1614_Inductive ldc;\n\nu16 value = 0;\nu32 ChannelData = 0;\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define RAK4631_BOARD true\n#else\n#define RAK4631_BOARD false\n#endif\n\nbool doOTAA = true;                                               // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                                       /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                                     /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5                               /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                                        /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;                           /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;                 /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                              /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = { LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF };\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = { BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler };\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xC0, 0x81, 0xBB, 0x65, 0x54, 0xCF, 0xF7, 0x65, 0x87, 0x70, 0xFD, 0x31, 0x7F, 0x01, 0x87, 0x51 };\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };\nuint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                                            /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];               //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = { m_lora_app_data_buffer, 0, 0, 0, 0 };  //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {\n// Sensor Power Switch\npinMode(WB_IO2, OUTPUT);\ndigitalWrite(WB_IO2, HIGH);\n\n// Control Chip Switch\npinMode(WB_IO5, OUTPUT);\ndigitalWrite(WB_IO5, LOW);\n\n// Control Relay Module\npinMode(RELAY_PIN,OUTPUT);\ndigitalWrite(RELAY_PIN, LOW);    // relay module initially LOW\n\npinMode(LED_GREEN, OUTPUT);      // Output LED\npinMode(LED_BLUE, OUTPUT);       // Output LED\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial) {\nif ((millis() - timeout) < 5000) {\ndelay(100);\n} else {\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA) {\nSerial.println(\"Type: OTAA\");\n} else {\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion) {\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA) {\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n} else {\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0) {\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"===========================================\");\nSerial.println(\"RAK12014 + RAK12029 + RAK13001 LoRaWAN Code\");\nSerial.println(\"===========================================\");\n\nWire.begin();\n\n// Configure VL53L0X component.\nsensor_vl53l0x.begin();\n\n// Switch off VL53L0X component.\nsensor_vl53l0x.VL53L0X_Off();\n\n// Initialize VL53L0X component.\nstatus = sensor_vl53l0x.InitSensor(0x52);\nif (status) {\nSerial.println(\"Init sensor_vl53l0x failed...\");\n}\n\n// From RAK12029\nldc.LDC1614_init();\n/*single channel use case configuration.*/\nif (ldc.LDC1614_single_channel_config(GETCHANNEL, INDUCTANCE, CAPATANCE)) {\nSerial.println(\"can't detect sensor!\");\nwhile (1) delay(100);\n}\n}\n\nvoid loop() {\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\n// Read data from RAK12014\nstatus = sensor_vl53l0x.GetDistance(&distance);\n\n// Read data from RAK12029\nldc.IIC_read_16bit(LDC1614_READ_DEVICE_ID, &value);\nif (value == 0x3055) {\n//u32 ChannelData = 0;\n/*Get channel 0 result and parse it.*/\ndelay(100);\nif (ldc.LDC1614_get_channel_result(GETCHANNEL, &ChannelData) == 0) {\n/*sensor result value.you can make a lot of application according to its changes.*/\nif (0 != ChannelData) {\ndigitalWrite(LED_BLUE, HIGH);     // Indicator Blue LED\ndigitalWrite(LED_GREEN, HIGH);    // Indicator Green LED\n}\ndelay(200);\ndigitalWrite(LED_BLUE, LOW);        // Indicator Blue LED\ndigitalWrite(LED_GREEN, LOW);       // Indicator Green LED\n}\n}\n\nif (ChannelData >= 49800000)            // metallic material sensed nearby via inductive sensor\n{\ndigitalWrite(RELAY_PIN, HIGH);        // Turns ON the relay module\nobject = 1;                           // \"1\" corresponds to metallic object\nSerial.println(\"Metal Detected\");\n}\n\nelse if (ChannelData <= 49650000)       // nothing metallic was sensed; default value sensed by the inductive sensor\n{\ndigitalWrite(RELAY_PIN, LOW);         // Turns OFF the relay module\nobject = 0;                           // \"0\" corresponds to non-metallic object\nSerial.println(\"No Metal Detected\");\n}\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\nSerial.print(distance);       // From RAK12014 module\nSerial.println(\"mm   \");\nSerial.println(object);       // From RAK13001 module\nSerial.println(ChannelData);  // From RAK12029 module\n\ndelay(5000);\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void) {\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void) {\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data) {\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class) {\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void) {\nif (lmh_join_status_get() != LMH_SET) {\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\ndata = \" Distance: \" + String(distance) + \" mm \" + \" Metallic: \" + String(object) + \" Inductive_Sense: \" + String(ChannelData);\nSerial.println(data);\n\nuint32_t distance_data = distance;    // data from RAK12014 module\nuint32_t channel_data = ChannelData;  // data from RAK12029 module\nint metallic_data = object;           // data from RAK13001 module\n\nm_lora_app_data.buffer[i++] = 0x01;  // byte[0]\n\n// Data from RAK12014 module\nm_lora_app_data.buffer[i++] = (uint8_t)((distance_data & 0xFF000000) >> 24);    // byte[1]\nm_lora_app_data.buffer[i++] = (uint8_t)((distance_data & 0x00FF0000) >> 16);    // byte[2]\nm_lora_app_data.buffer[i++] = (uint8_t)((distance_data & 0x0000FF00) >> 8);     // byte[3]\nm_lora_app_data.buffer[i++] = (uint8_t)(distance_data & 0x000000FF);            // byte[4]\n\n// Data from RAK12029 module (inductive sensor)\nm_lora_app_data.buffer[i++] = (uint8_t)((channel_data & 0xFF000000) >> 24);    // byte[5]\nm_lora_app_data.buffer[i++] = (uint8_t)((channel_data & 0x00FF0000) >> 16);    // byte[6]\nm_lora_app_data.buffer[i++] = (uint8_t)((channel_data & 0x0000FF00) >> 8);     // byte[7]\nm_lora_app_data.buffer[i++] = (uint8_t)(channel_data & 0x000000FF);            // byte[8]\n\n// Data from RAK13001 module (relay module status)\nm_lora_app_data.buffer[i++] = metallic_data;                                   // byte[9]\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS) {\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n} else {\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xC0, 0x81, 0xBB, 0x65, 0x54, 0xCF, 0xF7, 0x65, 0x87, 0x70, 0xFD, 0x31, 0x7F, 0x01, 0x87, 0x51 };\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "31e00b5073a62575d199df53793a7d53", "product_family": "wisblock", "product_id": "kit4-industrial", "category": "How-To", "title": "WisBlock IoT Education Kit - Smart Industry Quick Start Guide > WisBlock IoT Education Kit - Smart Industry Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock Smart Industry Kit using TTN and Quibitro > Material Classifier LoRaWAN Application > LoRaWAN Code for Material Classifier > Programming the Material Classifier Device with LoRaWAN Application [CODE]", "content": "// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                                            /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];               //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = { m_lora_app_data_buffer, 0, 0, 0, 0 };  //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;", "keywords": ["Arduino IDE", "RAK4631", "Material Classifier", "LoRaWAN", "SX126x-Arduino"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **Material Classifier** device. Just copy the code below for **Material Classifier LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the code</summary>  \n```c\n\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h>  //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n// For RAK12014 module\n#include <vl53l0x_class.h>    // Click to install library: http://librarymanager/All#stm32duino_vl53l0x\nVL53L0X sensor_vl53l0x(&Wire, WB_IO2);\n\nuint32_t distance;\nint status;\n\n// For RAK13001 module\n#define RELAY_PIN WB_IO4\nint object;\n\n// For RAK12029 module\n#include \"RAK12029_LDC1614.h\"\n\n#define INDUCTANCE 13.000\n#define CAPATANCE 100.0\n#define GETCHANNEL LDC1614_CHANNEL_0     // LDC1614_CHANNEL_(0~3); selecting the coil channel from 0 - 3\nRAK12029_LDC1614_Inductive ldc;\n\nu16 value = 0;\nu32 ChannelData = 0;\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define RAK4631_BOARD true\n#else\n#define RAK4631_BOARD false\n#endif\n\nbool doOTAA = true;                                               // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                                       /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                                     /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5                               /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                                        /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;                           /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;                 /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                              /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = { LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF };\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = { BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler };\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xC0, 0x81, 0xBB, 0x65, 0x54, 0xCF, 0xF7, 0x65, 0x87, 0x70, 0xFD, 0x31, 0x7F, 0x01, 0x87, 0x51 };\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };\nuint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                                            /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];               //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = { m_lora_app_data_buffer, 0, 0, 0, 0 };  //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {\n// Sensor Power Switch\npinMode(WB_IO2, OUTPUT);\ndigitalWrite(WB_IO2, HIGH);\n\n// Control Chip Switch\npinMode(WB_IO5, OUTPUT);\ndigitalWrite(WB_IO5, LOW);\n\n// Control Relay Module\npinMode(RELAY_PIN,OUTPUT);\ndigitalWrite(RELAY_PIN, LOW);    // relay module initially LOW\n\npinMode(LED_GREEN, OUTPUT);      // Output LED\npinMode(LED_BLUE, OUTPUT);       // Output LED\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial) {\nif ((millis() - timeout) < 5000) {\ndelay(100);\n} else {\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA) {\nSerial.println(\"Type: OTAA\");\n} else {\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion) {\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA) {\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n} else {\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0) {\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"===========================================\");\nSerial.println(\"RAK12014 + RAK12029 + RAK13001 LoRaWAN Code\");\nSerial.println(\"===========================================\");\n\nWire.begin();\n\n// Configure VL53L0X component.\nsensor_vl53l0x.begin();\n\n// Switch off VL53L0X component.\nsensor_vl53l0x.VL53L0X_Off();\n\n// Initialize VL53L0X component.\nstatus = sensor_vl53l0x.InitSensor(0x52);\nif (status) {\nSerial.println(\"Init sensor_vl53l0x failed...\");\n}\n\n// From RAK12029\nldc.LDC1614_init();\n/*single channel use case configuration.*/\nif (ldc.LDC1614_single_channel_config(GETCHANNEL, INDUCTANCE, CAPATANCE)) {\nSerial.println(\"can't detect sensor!\");\nwhile (1) delay(100);\n}\n}\n\nvoid loop() {\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\n// Read data from RAK12014\nstatus = sensor_vl53l0x.GetDistance(&distance);\n\n// Read data from RAK12029\nldc.IIC_read_16bit(LDC1614_READ_DEVICE_ID, &value);\nif (value == 0x3055) {\n//u32 ChannelData = 0;\n/*Get channel 0 result and parse it.*/\ndelay(100);\nif (ldc.LDC1614_get_channel_result(GETCHANNEL, &ChannelData) == 0) {\n/*sensor result value.you can make a lot of application according to its changes.*/\nif (0 != ChannelData) {\ndigitalWrite(LED_BLUE, HIGH);     // Indicator Blue LED\ndigitalWrite(LED_GREEN, HIGH);    // Indicator Green LED\n}\ndelay(200);\ndigitalWrite(LED_BLUE, LOW);        // Indicator Blue LED\ndigitalWrite(LED_GREEN, LOW);       // Indicator Green LED\n}\n}\n\nif (ChannelData >= 49800000)            // metallic material sensed nearby via inductive sensor\n{\ndigitalWrite(RELAY_PIN, HIGH);        // Turns ON the relay module\nobject = 1;                           // \"1\" corresponds to metallic object\nSerial.println(\"Metal Detected\");\n}\n\nelse if (ChannelData <= 49650000)       // nothing metallic was sensed; default value sensed by the inductive sensor\n{\ndigitalWrite(RELAY_PIN, LOW);         // Turns OFF the relay module\nobject = 0;                           // \"0\" corresponds to non-metallic object\nSerial.println(\"No Metal Detected\");\n}\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\nSerial.print(distance);       // From RAK12014 module\nSerial.println(\"mm   \");\nSerial.println(object);       // From RAK13001 module\nSerial.println(ChannelData);  // From RAK12029 module\n\ndelay(5000);\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void) {\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void) {\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data) {\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class) {\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void) {\nif (lmh_join_status_get() != LMH_SET) {\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\ndata = \" Distance: \" + String(distance) + \" mm \" + \" Metallic: \" + String(object) + \" Inductive_Sense: \" + String(ChannelData);\nSerial.println(data);\n\nuint32_t distance_data = distance;    // data from RAK12014 module\nuint32_t channel_data = ChannelData;  // data from RAK12029 module\nint metallic_data = object;           // data from RAK13001 module\n\nm_lora_app_data.buffer[i++] = 0x01;  // byte[0]\n\n// Data from RAK12014 module\nm_lora_app_data.buffer[i++] = (uint8_t)((distance_data & 0xFF000000) >> 24);    // byte[1]\nm_lora_app_data.buffer[i++] = (uint8_t)((distance_data & 0x00FF0000) >> 16);    // byte[2]\nm_lora_app_data.buffer[i++] = (uint8_t)((distance_data & 0x0000FF00) >> 8);     // byte[3]\nm_lora_app_data.buffer[i++] = (uint8_t)(distance_data & 0x000000FF);            // byte[4]\n\n// Data from RAK12029 module (inductive sensor)\nm_lora_app_data.buffer[i++] = (uint8_t)((channel_data & 0xFF000000) >> 24);    // byte[5]\nm_lora_app_data.buffer[i++] = (uint8_t)((channel_data & 0x00FF0000) >> 16);    // byte[6]\nm_lora_app_data.buffer[i++] = (uint8_t)((channel_data & 0x0000FF00) >> 8);     // byte[7]\nm_lora_app_data.buffer[i++] = (uint8_t)(channel_data & 0x000000FF);            // byte[8]\n\n// Data from RAK13001 module (relay module status)\nm_lora_app_data.buffer[i++] = metallic_data;                                   // byte[9]\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS) {\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n} else {\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xC0, 0x81, 0xBB, 0x65, 0x54, 0xCF, 0xF7, 0x65, 0x87, 0x70, 0xFD, 0x31, 0x7F, 0x01, 0x87, 0x51 };\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "f256f976025e6ba8f54e24b0266c2df9", "product_family": "wisblock", "product_id": "kit4-industrial", "category": "How-To", "title": "WisBlock IoT Education Kit - Smart Industry Quick Start Guide > WisBlock IoT Education Kit - Smart Industry Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock Smart Industry Kit using TTN and Quibitro > Material Classifier LoRaWAN Application > LoRaWAN Code for Material Classifier > Programming the Material Classifier Device with LoRaWAN Application [CODE]", "content": "static uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {\n// Sensor Power Switch\npinMode(WB_IO2, OUTPUT);\ndigitalWrite(WB_IO2, HIGH);\n\n// Control Chip Switch\npinMode(WB_IO5, OUTPUT);\ndigitalWrite(WB_IO5, LOW);\n\n// Control Relay Module\npinMode(RELAY_PIN,OUTPUT);\ndigitalWrite(RELAY_PIN, LOW);    // relay module initially LOW\n\npinMode(LED_GREEN, OUTPUT);      // Output LED\npinMode(LED_BLUE, OUTPUT);       // Output LED\n\n// Initialize LoRa chip.\nlora_rak4630_init();", "keywords": ["Arduino IDE", "RAK4631", "Material Classifier", "LoRaWAN", "SX126x-Arduino"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **Material Classifier** device. Just copy the code below for **Material Classifier LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the code</summary>  \n```c\n\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h>  //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n// For RAK12014 module\n#include <vl53l0x_class.h>    // Click to install library: http://librarymanager/All#stm32duino_vl53l0x\nVL53L0X sensor_vl53l0x(&Wire, WB_IO2);\n\nuint32_t distance;\nint status;\n\n// For RAK13001 module\n#define RELAY_PIN WB_IO4\nint object;\n\n// For RAK12029 module\n#include \"RAK12029_LDC1614.h\"\n\n#define INDUCTANCE 13.000\n#define CAPATANCE 100.0\n#define GETCHANNEL LDC1614_CHANNEL_0     // LDC1614_CHANNEL_(0~3); selecting the coil channel from 0 - 3\nRAK12029_LDC1614_Inductive ldc;\n\nu16 value = 0;\nu32 ChannelData = 0;\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define RAK4631_BOARD true\n#else\n#define RAK4631_BOARD false\n#endif\n\nbool doOTAA = true;                                               // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                                       /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                                     /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5                               /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                                        /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;                           /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;                 /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                              /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = { LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF };\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = { BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler };\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xC0, 0x81, 0xBB, 0x65, 0x54, 0xCF, 0xF7, 0x65, 0x87, 0x70, 0xFD, 0x31, 0x7F, 0x01, 0x87, 0x51 };\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };\nuint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                                            /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];               //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = { m_lora_app_data_buffer, 0, 0, 0, 0 };  //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {\n// Sensor Power Switch\npinMode(WB_IO2, OUTPUT);\ndigitalWrite(WB_IO2, HIGH);\n\n// Control Chip Switch\npinMode(WB_IO5, OUTPUT);\ndigitalWrite(WB_IO5, LOW);\n\n// Control Relay Module\npinMode(RELAY_PIN,OUTPUT);\ndigitalWrite(RELAY_PIN, LOW);    // relay module initially LOW\n\npinMode(LED_GREEN, OUTPUT);      // Output LED\npinMode(LED_BLUE, OUTPUT);       // Output LED\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial) {\nif ((millis() - timeout) < 5000) {\ndelay(100);\n} else {\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA) {\nSerial.println(\"Type: OTAA\");\n} else {\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion) {\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA) {\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n} else {\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0) {\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"===========================================\");\nSerial.println(\"RAK12014 + RAK12029 + RAK13001 LoRaWAN Code\");\nSerial.println(\"===========================================\");\n\nWire.begin();\n\n// Configure VL53L0X component.\nsensor_vl53l0x.begin();\n\n// Switch off VL53L0X component.\nsensor_vl53l0x.VL53L0X_Off();\n\n// Initialize VL53L0X component.\nstatus = sensor_vl53l0x.InitSensor(0x52);\nif (status) {\nSerial.println(\"Init sensor_vl53l0x failed...\");\n}\n\n// From RAK12029\nldc.LDC1614_init();\n/*single channel use case configuration.*/\nif (ldc.LDC1614_single_channel_config(GETCHANNEL, INDUCTANCE, CAPATANCE)) {\nSerial.println(\"can't detect sensor!\");\nwhile (1) delay(100);\n}\n}\n\nvoid loop() {\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\n// Read data from RAK12014\nstatus = sensor_vl53l0x.GetDistance(&distance);\n\n// Read data from RAK12029\nldc.IIC_read_16bit(LDC1614_READ_DEVICE_ID, &value);\nif (value == 0x3055) {\n//u32 ChannelData = 0;\n/*Get channel 0 result and parse it.*/\ndelay(100);\nif (ldc.LDC1614_get_channel_result(GETCHANNEL, &ChannelData) == 0) {\n/*sensor result value.you can make a lot of application according to its changes.*/\nif (0 != ChannelData) {\ndigitalWrite(LED_BLUE, HIGH);     // Indicator Blue LED\ndigitalWrite(LED_GREEN, HIGH);    // Indicator Green LED\n}\ndelay(200);\ndigitalWrite(LED_BLUE, LOW);        // Indicator Blue LED\ndigitalWrite(LED_GREEN, LOW);       // Indicator Green LED\n}\n}\n\nif (ChannelData >= 49800000)            // metallic material sensed nearby via inductive sensor\n{\ndigitalWrite(RELAY_PIN, HIGH);        // Turns ON the relay module\nobject = 1;                           // \"1\" corresponds to metallic object\nSerial.println(\"Metal Detected\");\n}\n\nelse if (ChannelData <= 49650000)       // nothing metallic was sensed; default value sensed by the inductive sensor\n{\ndigitalWrite(RELAY_PIN, LOW);         // Turns OFF the relay module\nobject = 0;                           // \"0\" corresponds to non-metallic object\nSerial.println(\"No Metal Detected\");\n}\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\nSerial.print(distance);       // From RAK12014 module\nSerial.println(\"mm   \");\nSerial.println(object);       // From RAK13001 module\nSerial.println(ChannelData);  // From RAK12029 module\n\ndelay(5000);\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void) {\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void) {\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data) {\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class) {\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void) {\nif (lmh_join_status_get() != LMH_SET) {\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\ndata = \" Distance: \" + String(distance) + \" mm \" + \" Metallic: \" + String(object) + \" Inductive_Sense: \" + String(ChannelData);\nSerial.println(data);\n\nuint32_t distance_data = distance;    // data from RAK12014 module\nuint32_t channel_data = ChannelData;  // data from RAK12029 module\nint metallic_data = object;           // data from RAK13001 module\n\nm_lora_app_data.buffer[i++] = 0x01;  // byte[0]\n\n// Data from RAK12014 module\nm_lora_app_data.buffer[i++] = (uint8_t)((distance_data & 0xFF000000) >> 24);    // byte[1]\nm_lora_app_data.buffer[i++] = (uint8_t)((distance_data & 0x00FF0000) >> 16);    // byte[2]\nm_lora_app_data.buffer[i++] = (uint8_t)((distance_data & 0x0000FF00) >> 8);     // byte[3]\nm_lora_app_data.buffer[i++] = (uint8_t)(distance_data & 0x000000FF);            // byte[4]\n\n// Data from RAK12029 module (inductive sensor)\nm_lora_app_data.buffer[i++] = (uint8_t)((channel_data & 0xFF000000) >> 24);    // byte[5]\nm_lora_app_data.buffer[i++] = (uint8_t)((channel_data & 0x00FF0000) >> 16);    // byte[6]\nm_lora_app_data.buffer[i++] = (uint8_t)((channel_data & 0x0000FF00) >> 8);     // byte[7]\nm_lora_app_data.buffer[i++] = (uint8_t)(channel_data & 0x000000FF);            // byte[8]\n\n// Data from RAK13001 module (relay module status)\nm_lora_app_data.buffer[i++] = metallic_data;                                   // byte[9]\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS) {\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n} else {\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xC0, 0x81, 0xBB, 0x65, 0x54, 0xCF, 0xF7, 0x65, 0x87, 0x70, 0xFD, 0x31, 0x7F, 0x01, 0x87, 0x51 };\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "11e71c7780ca07c1f494d5d8f4f0fc81", "product_family": "wisblock", "product_id": "kit4-industrial", "category": "How-To", "title": "WisBlock IoT Education Kit - Smart Industry Quick Start Guide > WisBlock IoT Education Kit - Smart Industry Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock Smart Industry Kit using TTN and Quibitro > Material Classifier LoRaWAN Application > LoRaWAN Code for Material Classifier > Programming the Material Classifier Device with LoRaWAN Application [CODE]", "content": "// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial) {\nif ((millis() - timeout) < 5000) {\ndelay(100);\n} else {\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA) {\nSerial.println(\"Type: OTAA\");\n} else {\nSerial.println(\"Type: ABP\");\n}", "keywords": ["Arduino IDE", "RAK4631", "Material Classifier", "LoRaWAN", "SX126x-Arduino"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **Material Classifier** device. Just copy the code below for **Material Classifier LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the code</summary>  \n```c\n\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h>  //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n// For RAK12014 module\n#include <vl53l0x_class.h>    // Click to install library: http://librarymanager/All#stm32duino_vl53l0x\nVL53L0X sensor_vl53l0x(&Wire, WB_IO2);\n\nuint32_t distance;\nint status;\n\n// For RAK13001 module\n#define RELAY_PIN WB_IO4\nint object;\n\n// For RAK12029 module\n#include \"RAK12029_LDC1614.h\"\n\n#define INDUCTANCE 13.000\n#define CAPATANCE 100.0\n#define GETCHANNEL LDC1614_CHANNEL_0     // LDC1614_CHANNEL_(0~3); selecting the coil channel from 0 - 3\nRAK12029_LDC1614_Inductive ldc;\n\nu16 value = 0;\nu32 ChannelData = 0;\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define RAK4631_BOARD true\n#else\n#define RAK4631_BOARD false\n#endif\n\nbool doOTAA = true;                                               // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                                       /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                                     /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5                               /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                                        /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;                           /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;                 /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                              /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = { LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF };\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = { BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler };\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xC0, 0x81, 0xBB, 0x65, 0x54, 0xCF, 0xF7, 0x65, 0x87, 0x70, 0xFD, 0x31, 0x7F, 0x01, 0x87, 0x51 };\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };\nuint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                                            /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];               //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = { m_lora_app_data_buffer, 0, 0, 0, 0 };  //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {\n// Sensor Power Switch\npinMode(WB_IO2, OUTPUT);\ndigitalWrite(WB_IO2, HIGH);\n\n// Control Chip Switch\npinMode(WB_IO5, OUTPUT);\ndigitalWrite(WB_IO5, LOW);\n\n// Control Relay Module\npinMode(RELAY_PIN,OUTPUT);\ndigitalWrite(RELAY_PIN, LOW);    // relay module initially LOW\n\npinMode(LED_GREEN, OUTPUT);      // Output LED\npinMode(LED_BLUE, OUTPUT);       // Output LED\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial) {\nif ((millis() - timeout) < 5000) {\ndelay(100);\n} else {\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA) {\nSerial.println(\"Type: OTAA\");\n} else {\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion) {\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA) {\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n} else {\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0) {\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"===========================================\");\nSerial.println(\"RAK12014 + RAK12029 + RAK13001 LoRaWAN Code\");\nSerial.println(\"===========================================\");\n\nWire.begin();\n\n// Configure VL53L0X component.\nsensor_vl53l0x.begin();\n\n// Switch off VL53L0X component.\nsensor_vl53l0x.VL53L0X_Off();\n\n// Initialize VL53L0X component.\nstatus = sensor_vl53l0x.InitSensor(0x52);\nif (status) {\nSerial.println(\"Init sensor_vl53l0x failed...\");\n}\n\n// From RAK12029\nldc.LDC1614_init();\n/*single channel use case configuration.*/\nif (ldc.LDC1614_single_channel_config(GETCHANNEL, INDUCTANCE, CAPATANCE)) {\nSerial.println(\"can't detect sensor!\");\nwhile (1) delay(100);\n}\n}\n\nvoid loop() {\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\n// Read data from RAK12014\nstatus = sensor_vl53l0x.GetDistance(&distance);\n\n// Read data from RAK12029\nldc.IIC_read_16bit(LDC1614_READ_DEVICE_ID, &value);\nif (value == 0x3055) {\n//u32 ChannelData = 0;\n/*Get channel 0 result and parse it.*/\ndelay(100);\nif (ldc.LDC1614_get_channel_result(GETCHANNEL, &ChannelData) == 0) {\n/*sensor result value.you can make a lot of application according to its changes.*/\nif (0 != ChannelData) {\ndigitalWrite(LED_BLUE, HIGH);     // Indicator Blue LED\ndigitalWrite(LED_GREEN, HIGH);    // Indicator Green LED\n}\ndelay(200);\ndigitalWrite(LED_BLUE, LOW);        // Indicator Blue LED\ndigitalWrite(LED_GREEN, LOW);       // Indicator Green LED\n}\n}\n\nif (ChannelData >= 49800000)            // metallic material sensed nearby via inductive sensor\n{\ndigitalWrite(RELAY_PIN, HIGH);        // Turns ON the relay module\nobject = 1;                           // \"1\" corresponds to metallic object\nSerial.println(\"Metal Detected\");\n}\n\nelse if (ChannelData <= 49650000)       // nothing metallic was sensed; default value sensed by the inductive sensor\n{\ndigitalWrite(RELAY_PIN, LOW);         // Turns OFF the relay module\nobject = 0;                           // \"0\" corresponds to non-metallic object\nSerial.println(\"No Metal Detected\");\n}\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\nSerial.print(distance);       // From RAK12014 module\nSerial.println(\"mm   \");\nSerial.println(object);       // From RAK13001 module\nSerial.println(ChannelData);  // From RAK12029 module\n\ndelay(5000);\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void) {\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void) {\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data) {\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class) {\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void) {\nif (lmh_join_status_get() != LMH_SET) {\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\ndata = \" Distance: \" + String(distance) + \" mm \" + \" Metallic: \" + String(object) + \" Inductive_Sense: \" + String(ChannelData);\nSerial.println(data);\n\nuint32_t distance_data = distance;    // data from RAK12014 module\nuint32_t channel_data = ChannelData;  // data from RAK12029 module\nint metallic_data = object;           // data from RAK13001 module\n\nm_lora_app_data.buffer[i++] = 0x01;  // byte[0]\n\n// Data from RAK12014 module\nm_lora_app_data.buffer[i++] = (uint8_t)((distance_data & 0xFF000000) >> 24);    // byte[1]\nm_lora_app_data.buffer[i++] = (uint8_t)((distance_data & 0x00FF0000) >> 16);    // byte[2]\nm_lora_app_data.buffer[i++] = (uint8_t)((distance_data & 0x0000FF00) >> 8);     // byte[3]\nm_lora_app_data.buffer[i++] = (uint8_t)(distance_data & 0x000000FF);            // byte[4]\n\n// Data from RAK12029 module (inductive sensor)\nm_lora_app_data.buffer[i++] = (uint8_t)((channel_data & 0xFF000000) >> 24);    // byte[5]\nm_lora_app_data.buffer[i++] = (uint8_t)((channel_data & 0x00FF0000) >> 16);    // byte[6]\nm_lora_app_data.buffer[i++] = (uint8_t)((channel_data & 0x0000FF00) >> 8);     // byte[7]\nm_lora_app_data.buffer[i++] = (uint8_t)(channel_data & 0x000000FF);            // byte[8]\n\n// Data from RAK13001 module (relay module status)\nm_lora_app_data.buffer[i++] = metallic_data;                                   // byte[9]\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS) {\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n} else {\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xC0, 0x81, 0xBB, 0x65, 0x54, 0xCF, 0xF7, 0x65, 0x87, 0x70, 0xFD, 0x31, 0x7F, 0x01, 0x87, 0x51 };\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "e552b444e809b5103f43130c52220d7a", "product_family": "wisblock", "product_id": "kit4-industrial", "category": "How-To", "title": "WisBlock IoT Education Kit - Smart Industry Quick Start Guide > WisBlock IoT Education Kit - Smart Industry Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock Smart Industry Kit using TTN and Quibitro > Material Classifier LoRaWAN Application > LoRaWAN Code for Material Classifier > Programming the Material Classifier Device with LoRaWAN Application [CODE]", "content": "switch (g_CurrentRegion) {\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;", "keywords": ["Arduino IDE", "RAK4631", "Material Classifier", "LoRaWAN", "SX126x-Arduino"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **Material Classifier** device. Just copy the code below for **Material Classifier LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the code</summary>  \n```c\n\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h>  //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n// For RAK12014 module\n#include <vl53l0x_class.h>    // Click to install library: http://librarymanager/All#stm32duino_vl53l0x\nVL53L0X sensor_vl53l0x(&Wire, WB_IO2);\n\nuint32_t distance;\nint status;\n\n// For RAK13001 module\n#define RELAY_PIN WB_IO4\nint object;\n\n// For RAK12029 module\n#include \"RAK12029_LDC1614.h\"\n\n#define INDUCTANCE 13.000\n#define CAPATANCE 100.0\n#define GETCHANNEL LDC1614_CHANNEL_0     // LDC1614_CHANNEL_(0~3); selecting the coil channel from 0 - 3\nRAK12029_LDC1614_Inductive ldc;\n\nu16 value = 0;\nu32 ChannelData = 0;\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define RAK4631_BOARD true\n#else\n#define RAK4631_BOARD false\n#endif\n\nbool doOTAA = true;                                               // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                                       /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                                     /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5                               /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                                        /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;                           /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;                 /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                              /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = { LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF };\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = { BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler };\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xC0, 0x81, 0xBB, 0x65, 0x54, 0xCF, 0xF7, 0x65, 0x87, 0x70, 0xFD, 0x31, 0x7F, 0x01, 0x87, 0x51 };\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };\nuint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                                            /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];               //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = { m_lora_app_data_buffer, 0, 0, 0, 0 };  //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {\n// Sensor Power Switch\npinMode(WB_IO2, OUTPUT);\ndigitalWrite(WB_IO2, HIGH);\n\n// Control Chip Switch\npinMode(WB_IO5, OUTPUT);\ndigitalWrite(WB_IO5, LOW);\n\n// Control Relay Module\npinMode(RELAY_PIN,OUTPUT);\ndigitalWrite(RELAY_PIN, LOW);    // relay module initially LOW\n\npinMode(LED_GREEN, OUTPUT);      // Output LED\npinMode(LED_BLUE, OUTPUT);       // Output LED\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial) {\nif ((millis() - timeout) < 5000) {\ndelay(100);\n} else {\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA) {\nSerial.println(\"Type: OTAA\");\n} else {\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion) {\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA) {\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n} else {\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0) {\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"===========================================\");\nSerial.println(\"RAK12014 + RAK12029 + RAK13001 LoRaWAN Code\");\nSerial.println(\"===========================================\");\n\nWire.begin();\n\n// Configure VL53L0X component.\nsensor_vl53l0x.begin();\n\n// Switch off VL53L0X component.\nsensor_vl53l0x.VL53L0X_Off();\n\n// Initialize VL53L0X component.\nstatus = sensor_vl53l0x.InitSensor(0x52);\nif (status) {\nSerial.println(\"Init sensor_vl53l0x failed...\");\n}\n\n// From RAK12029\nldc.LDC1614_init();\n/*single channel use case configuration.*/\nif (ldc.LDC1614_single_channel_config(GETCHANNEL, INDUCTANCE, CAPATANCE)) {\nSerial.println(\"can't detect sensor!\");\nwhile (1) delay(100);\n}\n}\n\nvoid loop() {\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\n// Read data from RAK12014\nstatus = sensor_vl53l0x.GetDistance(&distance);\n\n// Read data from RAK12029\nldc.IIC_read_16bit(LDC1614_READ_DEVICE_ID, &value);\nif (value == 0x3055) {\n//u32 ChannelData = 0;\n/*Get channel 0 result and parse it.*/\ndelay(100);\nif (ldc.LDC1614_get_channel_result(GETCHANNEL, &ChannelData) == 0) {\n/*sensor result value.you can make a lot of application according to its changes.*/\nif (0 != ChannelData) {\ndigitalWrite(LED_BLUE, HIGH);     // Indicator Blue LED\ndigitalWrite(LED_GREEN, HIGH);    // Indicator Green LED\n}\ndelay(200);\ndigitalWrite(LED_BLUE, LOW);        // Indicator Blue LED\ndigitalWrite(LED_GREEN, LOW);       // Indicator Green LED\n}\n}\n\nif (ChannelData >= 49800000)            // metallic material sensed nearby via inductive sensor\n{\ndigitalWrite(RELAY_PIN, HIGH);        // Turns ON the relay module\nobject = 1;                           // \"1\" corresponds to metallic object\nSerial.println(\"Metal Detected\");\n}\n\nelse if (ChannelData <= 49650000)       // nothing metallic was sensed; default value sensed by the inductive sensor\n{\ndigitalWrite(RELAY_PIN, LOW);         // Turns OFF the relay module\nobject = 0;                           // \"0\" corresponds to non-metallic object\nSerial.println(\"No Metal Detected\");\n}\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\nSerial.print(distance);       // From RAK12014 module\nSerial.println(\"mm   \");\nSerial.println(object);       // From RAK13001 module\nSerial.println(ChannelData);  // From RAK12029 module\n\ndelay(5000);\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void) {\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void) {\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data) {\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class) {\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void) {\nif (lmh_join_status_get() != LMH_SET) {\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\ndata = \" Distance: \" + String(distance) + \" mm \" + \" Metallic: \" + String(object) + \" Inductive_Sense: \" + String(ChannelData);\nSerial.println(data);\n\nuint32_t distance_data = distance;    // data from RAK12014 module\nuint32_t channel_data = ChannelData;  // data from RAK12029 module\nint metallic_data = object;           // data from RAK13001 module\n\nm_lora_app_data.buffer[i++] = 0x01;  // byte[0]\n\n// Data from RAK12014 module\nm_lora_app_data.buffer[i++] = (uint8_t)((distance_data & 0xFF000000) >> 24);    // byte[1]\nm_lora_app_data.buffer[i++] = (uint8_t)((distance_data & 0x00FF0000) >> 16);    // byte[2]\nm_lora_app_data.buffer[i++] = (uint8_t)((distance_data & 0x0000FF00) >> 8);     // byte[3]\nm_lora_app_data.buffer[i++] = (uint8_t)(distance_data & 0x000000FF);            // byte[4]\n\n// Data from RAK12029 module (inductive sensor)\nm_lora_app_data.buffer[i++] = (uint8_t)((channel_data & 0xFF000000) >> 24);    // byte[5]\nm_lora_app_data.buffer[i++] = (uint8_t)((channel_data & 0x00FF0000) >> 16);    // byte[6]\nm_lora_app_data.buffer[i++] = (uint8_t)((channel_data & 0x0000FF00) >> 8);     // byte[7]\nm_lora_app_data.buffer[i++] = (uint8_t)(channel_data & 0x000000FF);            // byte[8]\n\n// Data from RAK13001 module (relay module status)\nm_lora_app_data.buffer[i++] = metallic_data;                                   // byte[9]\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS) {\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n} else {\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xC0, 0x81, 0xBB, 0x65, 0x54, 0xCF, 0xF7, 0x65, 0x87, 0x70, 0xFD, 0x31, 0x7F, 0x01, 0x87, 0x51 };\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "be508d56163719676116eee8c242f15a", "product_family": "wisblock", "product_id": "kit4-industrial", "category": "How-To", "title": "WisBlock IoT Education Kit - Smart Industry Quick Start Guide > WisBlock IoT Education Kit - Smart Industry Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock Smart Industry Kit using TTN and Quibitro > Material Classifier LoRaWAN Application > LoRaWAN Code for Material Classifier > Programming the Material Classifier Device with LoRaWAN Application [CODE]", "content": "break;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");", "keywords": ["Arduino IDE", "RAK4631", "Material Classifier", "LoRaWAN", "SX126x-Arduino"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **Material Classifier** device. Just copy the code below for **Material Classifier LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the code</summary>  \n```c\n\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h>  //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n// For RAK12014 module\n#include <vl53l0x_class.h>    // Click to install library: http://librarymanager/All#stm32duino_vl53l0x\nVL53L0X sensor_vl53l0x(&Wire, WB_IO2);\n\nuint32_t distance;\nint status;\n\n// For RAK13001 module\n#define RELAY_PIN WB_IO4\nint object;\n\n// For RAK12029 module\n#include \"RAK12029_LDC1614.h\"\n\n#define INDUCTANCE 13.000\n#define CAPATANCE 100.0\n#define GETCHANNEL LDC1614_CHANNEL_0     // LDC1614_CHANNEL_(0~3); selecting the coil channel from 0 - 3\nRAK12029_LDC1614_Inductive ldc;\n\nu16 value = 0;\nu32 ChannelData = 0;\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define RAK4631_BOARD true\n#else\n#define RAK4631_BOARD false\n#endif\n\nbool doOTAA = true;                                               // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                                       /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                                     /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5                               /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                                        /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;                           /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;                 /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                              /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = { LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF };\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = { BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler };\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xC0, 0x81, 0xBB, 0x65, 0x54, 0xCF, 0xF7, 0x65, 0x87, 0x70, 0xFD, 0x31, 0x7F, 0x01, 0x87, 0x51 };\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };\nuint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                                            /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];               //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = { m_lora_app_data_buffer, 0, 0, 0, 0 };  //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {\n// Sensor Power Switch\npinMode(WB_IO2, OUTPUT);\ndigitalWrite(WB_IO2, HIGH);\n\n// Control Chip Switch\npinMode(WB_IO5, OUTPUT);\ndigitalWrite(WB_IO5, LOW);\n\n// Control Relay Module\npinMode(RELAY_PIN,OUTPUT);\ndigitalWrite(RELAY_PIN, LOW);    // relay module initially LOW\n\npinMode(LED_GREEN, OUTPUT);      // Output LED\npinMode(LED_BLUE, OUTPUT);       // Output LED\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial) {\nif ((millis() - timeout) < 5000) {\ndelay(100);\n} else {\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA) {\nSerial.println(\"Type: OTAA\");\n} else {\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion) {\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA) {\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n} else {\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0) {\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"===========================================\");\nSerial.println(\"RAK12014 + RAK12029 + RAK13001 LoRaWAN Code\");\nSerial.println(\"===========================================\");\n\nWire.begin();\n\n// Configure VL53L0X component.\nsensor_vl53l0x.begin();\n\n// Switch off VL53L0X component.\nsensor_vl53l0x.VL53L0X_Off();\n\n// Initialize VL53L0X component.\nstatus = sensor_vl53l0x.InitSensor(0x52);\nif (status) {\nSerial.println(\"Init sensor_vl53l0x failed...\");\n}\n\n// From RAK12029\nldc.LDC1614_init();\n/*single channel use case configuration.*/\nif (ldc.LDC1614_single_channel_config(GETCHANNEL, INDUCTANCE, CAPATANCE)) {\nSerial.println(\"can't detect sensor!\");\nwhile (1) delay(100);\n}\n}\n\nvoid loop() {\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\n// Read data from RAK12014\nstatus = sensor_vl53l0x.GetDistance(&distance);\n\n// Read data from RAK12029\nldc.IIC_read_16bit(LDC1614_READ_DEVICE_ID, &value);\nif (value == 0x3055) {\n//u32 ChannelData = 0;\n/*Get channel 0 result and parse it.*/\ndelay(100);\nif (ldc.LDC1614_get_channel_result(GETCHANNEL, &ChannelData) == 0) {\n/*sensor result value.you can make a lot of application according to its changes.*/\nif (0 != ChannelData) {\ndigitalWrite(LED_BLUE, HIGH);     // Indicator Blue LED\ndigitalWrite(LED_GREEN, HIGH);    // Indicator Green LED\n}\ndelay(200);\ndigitalWrite(LED_BLUE, LOW);        // Indicator Blue LED\ndigitalWrite(LED_GREEN, LOW);       // Indicator Green LED\n}\n}\n\nif (ChannelData >= 49800000)            // metallic material sensed nearby via inductive sensor\n{\ndigitalWrite(RELAY_PIN, HIGH);        // Turns ON the relay module\nobject = 1;                           // \"1\" corresponds to metallic object\nSerial.println(\"Metal Detected\");\n}\n\nelse if (ChannelData <= 49650000)       // nothing metallic was sensed; default value sensed by the inductive sensor\n{\ndigitalWrite(RELAY_PIN, LOW);         // Turns OFF the relay module\nobject = 0;                           // \"0\" corresponds to non-metallic object\nSerial.println(\"No Metal Detected\");\n}\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\nSerial.print(distance);       // From RAK12014 module\nSerial.println(\"mm   \");\nSerial.println(object);       // From RAK13001 module\nSerial.println(ChannelData);  // From RAK12029 module\n\ndelay(5000);\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void) {\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void) {\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data) {\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class) {\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void) {\nif (lmh_join_status_get() != LMH_SET) {\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\ndata = \" Distance: \" + String(distance) + \" mm \" + \" Metallic: \" + String(object) + \" Inductive_Sense: \" + String(ChannelData);\nSerial.println(data);\n\nuint32_t distance_data = distance;    // data from RAK12014 module\nuint32_t channel_data = ChannelData;  // data from RAK12029 module\nint metallic_data = object;           // data from RAK13001 module\n\nm_lora_app_data.buffer[i++] = 0x01;  // byte[0]\n\n// Data from RAK12014 module\nm_lora_app_data.buffer[i++] = (uint8_t)((distance_data & 0xFF000000) >> 24);    // byte[1]\nm_lora_app_data.buffer[i++] = (uint8_t)((distance_data & 0x00FF0000) >> 16);    // byte[2]\nm_lora_app_data.buffer[i++] = (uint8_t)((distance_data & 0x0000FF00) >> 8);     // byte[3]\nm_lora_app_data.buffer[i++] = (uint8_t)(distance_data & 0x000000FF);            // byte[4]\n\n// Data from RAK12029 module (inductive sensor)\nm_lora_app_data.buffer[i++] = (uint8_t)((channel_data & 0xFF000000) >> 24);    // byte[5]\nm_lora_app_data.buffer[i++] = (uint8_t)((channel_data & 0x00FF0000) >> 16);    // byte[6]\nm_lora_app_data.buffer[i++] = (uint8_t)((channel_data & 0x0000FF00) >> 8);     // byte[7]\nm_lora_app_data.buffer[i++] = (uint8_t)(channel_data & 0x000000FF);            // byte[8]\n\n// Data from RAK13001 module (relay module status)\nm_lora_app_data.buffer[i++] = metallic_data;                                   // byte[9]\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS) {\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n} else {\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xC0, 0x81, 0xBB, 0x65, 0x54, 0xCF, 0xF7, 0x65, 0x87, 0x70, 0xFD, 0x31, 0x7F, 0x01, 0x87, 0x51 };\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "5555b0e09d6cb872428e10d3eb4054e2", "product_family": "wisblock", "product_id": "kit4-industrial", "category": "How-To", "title": "WisBlock IoT Education Kit - Smart Industry Quick Start Guide > WisBlock IoT Education Kit - Smart Industry Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock Smart Industry Kit using TTN and Quibitro > Material Classifier LoRaWAN Application > LoRaWAN Code for Material Classifier > Programming the Material Classifier Device with LoRaWAN Application [CODE]", "content": "// Setup the EUIs and Keys\nif (doOTAA) {\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n} else {\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0) {\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();", "keywords": ["Arduino IDE", "RAK4631", "Material Classifier", "LoRaWAN", "SX126x-Arduino"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **Material Classifier** device. Just copy the code below for **Material Classifier LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the code</summary>  \n```c\n\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h>  //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n// For RAK12014 module\n#include <vl53l0x_class.h>    // Click to install library: http://librarymanager/All#stm32duino_vl53l0x\nVL53L0X sensor_vl53l0x(&Wire, WB_IO2);\n\nuint32_t distance;\nint status;\n\n// For RAK13001 module\n#define RELAY_PIN WB_IO4\nint object;\n\n// For RAK12029 module\n#include \"RAK12029_LDC1614.h\"\n\n#define INDUCTANCE 13.000\n#define CAPATANCE 100.0\n#define GETCHANNEL LDC1614_CHANNEL_0     // LDC1614_CHANNEL_(0~3); selecting the coil channel from 0 - 3\nRAK12029_LDC1614_Inductive ldc;\n\nu16 value = 0;\nu32 ChannelData = 0;\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define RAK4631_BOARD true\n#else\n#define RAK4631_BOARD false\n#endif\n\nbool doOTAA = true;                                               // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                                       /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                                     /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5                               /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                                        /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;                           /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;                 /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                              /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = { LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF };\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = { BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler };\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xC0, 0x81, 0xBB, 0x65, 0x54, 0xCF, 0xF7, 0x65, 0x87, 0x70, 0xFD, 0x31, 0x7F, 0x01, 0x87, 0x51 };\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };\nuint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                                            /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];               //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = { m_lora_app_data_buffer, 0, 0, 0, 0 };  //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {\n// Sensor Power Switch\npinMode(WB_IO2, OUTPUT);\ndigitalWrite(WB_IO2, HIGH);\n\n// Control Chip Switch\npinMode(WB_IO5, OUTPUT);\ndigitalWrite(WB_IO5, LOW);\n\n// Control Relay Module\npinMode(RELAY_PIN,OUTPUT);\ndigitalWrite(RELAY_PIN, LOW);    // relay module initially LOW\n\npinMode(LED_GREEN, OUTPUT);      // Output LED\npinMode(LED_BLUE, OUTPUT);       // Output LED\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial) {\nif ((millis() - timeout) < 5000) {\ndelay(100);\n} else {\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA) {\nSerial.println(\"Type: OTAA\");\n} else {\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion) {\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA) {\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n} else {\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0) {\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"===========================================\");\nSerial.println(\"RAK12014 + RAK12029 + RAK13001 LoRaWAN Code\");\nSerial.println(\"===========================================\");\n\nWire.begin();\n\n// Configure VL53L0X component.\nsensor_vl53l0x.begin();\n\n// Switch off VL53L0X component.\nsensor_vl53l0x.VL53L0X_Off();\n\n// Initialize VL53L0X component.\nstatus = sensor_vl53l0x.InitSensor(0x52);\nif (status) {\nSerial.println(\"Init sensor_vl53l0x failed...\");\n}\n\n// From RAK12029\nldc.LDC1614_init();\n/*single channel use case configuration.*/\nif (ldc.LDC1614_single_channel_config(GETCHANNEL, INDUCTANCE, CAPATANCE)) {\nSerial.println(\"can't detect sensor!\");\nwhile (1) delay(100);\n}\n}\n\nvoid loop() {\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\n// Read data from RAK12014\nstatus = sensor_vl53l0x.GetDistance(&distance);\n\n// Read data from RAK12029\nldc.IIC_read_16bit(LDC1614_READ_DEVICE_ID, &value);\nif (value == 0x3055) {\n//u32 ChannelData = 0;\n/*Get channel 0 result and parse it.*/\ndelay(100);\nif (ldc.LDC1614_get_channel_result(GETCHANNEL, &ChannelData) == 0) {\n/*sensor result value.you can make a lot of application according to its changes.*/\nif (0 != ChannelData) {\ndigitalWrite(LED_BLUE, HIGH);     // Indicator Blue LED\ndigitalWrite(LED_GREEN, HIGH);    // Indicator Green LED\n}\ndelay(200);\ndigitalWrite(LED_BLUE, LOW);        // Indicator Blue LED\ndigitalWrite(LED_GREEN, LOW);       // Indicator Green LED\n}\n}\n\nif (ChannelData >= 49800000)            // metallic material sensed nearby via inductive sensor\n{\ndigitalWrite(RELAY_PIN, HIGH);        // Turns ON the relay module\nobject = 1;                           // \"1\" corresponds to metallic object\nSerial.println(\"Metal Detected\");\n}\n\nelse if (ChannelData <= 49650000)       // nothing metallic was sensed; default value sensed by the inductive sensor\n{\ndigitalWrite(RELAY_PIN, LOW);         // Turns OFF the relay module\nobject = 0;                           // \"0\" corresponds to non-metallic object\nSerial.println(\"No Metal Detected\");\n}\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\nSerial.print(distance);       // From RAK12014 module\nSerial.println(\"mm   \");\nSerial.println(object);       // From RAK13001 module\nSerial.println(ChannelData);  // From RAK12029 module\n\ndelay(5000);\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void) {\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void) {\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data) {\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class) {\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void) {\nif (lmh_join_status_get() != LMH_SET) {\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\ndata = \" Distance: \" + String(distance) + \" mm \" + \" Metallic: \" + String(object) + \" Inductive_Sense: \" + String(ChannelData);\nSerial.println(data);\n\nuint32_t distance_data = distance;    // data from RAK12014 module\nuint32_t channel_data = ChannelData;  // data from RAK12029 module\nint metallic_data = object;           // data from RAK13001 module\n\nm_lora_app_data.buffer[i++] = 0x01;  // byte[0]\n\n// Data from RAK12014 module\nm_lora_app_data.buffer[i++] = (uint8_t)((distance_data & 0xFF000000) >> 24);    // byte[1]\nm_lora_app_data.buffer[i++] = (uint8_t)((distance_data & 0x00FF0000) >> 16);    // byte[2]\nm_lora_app_data.buffer[i++] = (uint8_t)((distance_data & 0x0000FF00) >> 8);     // byte[3]\nm_lora_app_data.buffer[i++] = (uint8_t)(distance_data & 0x000000FF);            // byte[4]\n\n// Data from RAK12029 module (inductive sensor)\nm_lora_app_data.buffer[i++] = (uint8_t)((channel_data & 0xFF000000) >> 24);    // byte[5]\nm_lora_app_data.buffer[i++] = (uint8_t)((channel_data & 0x00FF0000) >> 16);    // byte[6]\nm_lora_app_data.buffer[i++] = (uint8_t)((channel_data & 0x0000FF00) >> 8);     // byte[7]\nm_lora_app_data.buffer[i++] = (uint8_t)(channel_data & 0x000000FF);            // byte[8]\n\n// Data from RAK13001 module (relay module status)\nm_lora_app_data.buffer[i++] = metallic_data;                                   // byte[9]\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS) {\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n} else {\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xC0, 0x81, 0xBB, 0x65, 0x54, 0xCF, 0xF7, 0x65, 0x87, 0x70, 0xFD, 0x31, 0x7F, 0x01, 0x87, 0x51 };\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "2bdbd32d2ca164c4f6f31df5d5378bdb", "product_family": "wisblock", "product_id": "kit4-industrial", "category": "How-To", "title": "WisBlock IoT Education Kit - Smart Industry Quick Start Guide > WisBlock IoT Education Kit - Smart Industry Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock Smart Industry Kit using TTN and Quibitro > Material Classifier LoRaWAN Application > LoRaWAN Code for Material Classifier > Programming the Material Classifier Device with LoRaWAN Application [CODE]", "content": "// Start Join procedure\nlmh_join();\n\nSerial.println(\"===========================================\");\nSerial.println(\"RAK12014 + RAK12029 + RAK13001 LoRaWAN Code\");\nSerial.println(\"===========================================\");\n\nWire.begin();\n\n// Configure VL53L0X component.\nsensor_vl53l0x.begin();\n\n// Switch off VL53L0X component.\nsensor_vl53l0x.VL53L0X_Off();", "keywords": ["Arduino IDE", "RAK4631", "Material Classifier", "LoRaWAN", "SX126x-Arduino"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **Material Classifier** device. Just copy the code below for **Material Classifier LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the code</summary>  \n```c\n\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h>  //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n// For RAK12014 module\n#include <vl53l0x_class.h>    // Click to install library: http://librarymanager/All#stm32duino_vl53l0x\nVL53L0X sensor_vl53l0x(&Wire, WB_IO2);\n\nuint32_t distance;\nint status;\n\n// For RAK13001 module\n#define RELAY_PIN WB_IO4\nint object;\n\n// For RAK12029 module\n#include \"RAK12029_LDC1614.h\"\n\n#define INDUCTANCE 13.000\n#define CAPATANCE 100.0\n#define GETCHANNEL LDC1614_CHANNEL_0     // LDC1614_CHANNEL_(0~3); selecting the coil channel from 0 - 3\nRAK12029_LDC1614_Inductive ldc;\n\nu16 value = 0;\nu32 ChannelData = 0;\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define RAK4631_BOARD true\n#else\n#define RAK4631_BOARD false\n#endif\n\nbool doOTAA = true;                                               // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                                       /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                                     /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5                               /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                                        /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;                           /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;                 /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                              /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = { LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF };\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = { BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler };\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xC0, 0x81, 0xBB, 0x65, 0x54, 0xCF, 0xF7, 0x65, 0x87, 0x70, 0xFD, 0x31, 0x7F, 0x01, 0x87, 0x51 };\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };\nuint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                                            /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];               //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = { m_lora_app_data_buffer, 0, 0, 0, 0 };  //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {\n// Sensor Power Switch\npinMode(WB_IO2, OUTPUT);\ndigitalWrite(WB_IO2, HIGH);\n\n// Control Chip Switch\npinMode(WB_IO5, OUTPUT);\ndigitalWrite(WB_IO5, LOW);\n\n// Control Relay Module\npinMode(RELAY_PIN,OUTPUT);\ndigitalWrite(RELAY_PIN, LOW);    // relay module initially LOW\n\npinMode(LED_GREEN, OUTPUT);      // Output LED\npinMode(LED_BLUE, OUTPUT);       // Output LED\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial) {\nif ((millis() - timeout) < 5000) {\ndelay(100);\n} else {\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA) {\nSerial.println(\"Type: OTAA\");\n} else {\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion) {\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA) {\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n} else {\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0) {\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"===========================================\");\nSerial.println(\"RAK12014 + RAK12029 + RAK13001 LoRaWAN Code\");\nSerial.println(\"===========================================\");\n\nWire.begin();\n\n// Configure VL53L0X component.\nsensor_vl53l0x.begin();\n\n// Switch off VL53L0X component.\nsensor_vl53l0x.VL53L0X_Off();\n\n// Initialize VL53L0X component.\nstatus = sensor_vl53l0x.InitSensor(0x52);\nif (status) {\nSerial.println(\"Init sensor_vl53l0x failed...\");\n}\n\n// From RAK12029\nldc.LDC1614_init();\n/*single channel use case configuration.*/\nif (ldc.LDC1614_single_channel_config(GETCHANNEL, INDUCTANCE, CAPATANCE)) {\nSerial.println(\"can't detect sensor!\");\nwhile (1) delay(100);\n}\n}\n\nvoid loop() {\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\n// Read data from RAK12014\nstatus = sensor_vl53l0x.GetDistance(&distance);\n\n// Read data from RAK12029\nldc.IIC_read_16bit(LDC1614_READ_DEVICE_ID, &value);\nif (value == 0x3055) {\n//u32 ChannelData = 0;\n/*Get channel 0 result and parse it.*/\ndelay(100);\nif (ldc.LDC1614_get_channel_result(GETCHANNEL, &ChannelData) == 0) {\n/*sensor result value.you can make a lot of application according to its changes.*/\nif (0 != ChannelData) {\ndigitalWrite(LED_BLUE, HIGH);     // Indicator Blue LED\ndigitalWrite(LED_GREEN, HIGH);    // Indicator Green LED\n}\ndelay(200);\ndigitalWrite(LED_BLUE, LOW);        // Indicator Blue LED\ndigitalWrite(LED_GREEN, LOW);       // Indicator Green LED\n}\n}\n\nif (ChannelData >= 49800000)            // metallic material sensed nearby via inductive sensor\n{\ndigitalWrite(RELAY_PIN, HIGH);        // Turns ON the relay module\nobject = 1;                           // \"1\" corresponds to metallic object\nSerial.println(\"Metal Detected\");\n}\n\nelse if (ChannelData <= 49650000)       // nothing metallic was sensed; default value sensed by the inductive sensor\n{\ndigitalWrite(RELAY_PIN, LOW);         // Turns OFF the relay module\nobject = 0;                           // \"0\" corresponds to non-metallic object\nSerial.println(\"No Metal Detected\");\n}\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\nSerial.print(distance);       // From RAK12014 module\nSerial.println(\"mm   \");\nSerial.println(object);       // From RAK13001 module\nSerial.println(ChannelData);  // From RAK12029 module\n\ndelay(5000);\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void) {\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void) {\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data) {\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class) {\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void) {\nif (lmh_join_status_get() != LMH_SET) {\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\ndata = \" Distance: \" + String(distance) + \" mm \" + \" Metallic: \" + String(object) + \" Inductive_Sense: \" + String(ChannelData);\nSerial.println(data);\n\nuint32_t distance_data = distance;    // data from RAK12014 module\nuint32_t channel_data = ChannelData;  // data from RAK12029 module\nint metallic_data = object;           // data from RAK13001 module\n\nm_lora_app_data.buffer[i++] = 0x01;  // byte[0]\n\n// Data from RAK12014 module\nm_lora_app_data.buffer[i++] = (uint8_t)((distance_data & 0xFF000000) >> 24);    // byte[1]\nm_lora_app_data.buffer[i++] = (uint8_t)((distance_data & 0x00FF0000) >> 16);    // byte[2]\nm_lora_app_data.buffer[i++] = (uint8_t)((distance_data & 0x0000FF00) >> 8);     // byte[3]\nm_lora_app_data.buffer[i++] = (uint8_t)(distance_data & 0x000000FF);            // byte[4]\n\n// Data from RAK12029 module (inductive sensor)\nm_lora_app_data.buffer[i++] = (uint8_t)((channel_data & 0xFF000000) >> 24);    // byte[5]\nm_lora_app_data.buffer[i++] = (uint8_t)((channel_data & 0x00FF0000) >> 16);    // byte[6]\nm_lora_app_data.buffer[i++] = (uint8_t)((channel_data & 0x0000FF00) >> 8);     // byte[7]\nm_lora_app_data.buffer[i++] = (uint8_t)(channel_data & 0x000000FF);            // byte[8]\n\n// Data from RAK13001 module (relay module status)\nm_lora_app_data.buffer[i++] = metallic_data;                                   // byte[9]\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS) {\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n} else {\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xC0, 0x81, 0xBB, 0x65, 0x54, 0xCF, 0xF7, 0x65, 0x87, 0x70, 0xFD, 0x31, 0x7F, 0x01, 0x87, 0x51 };\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "79bce07908440d29d38558e8fe6c2d79", "product_family": "wisblock", "product_id": "kit4-industrial", "category": "How-To", "title": "WisBlock IoT Education Kit - Smart Industry Quick Start Guide > WisBlock IoT Education Kit - Smart Industry Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock Smart Industry Kit using TTN and Quibitro > Material Classifier LoRaWAN Application > LoRaWAN Code for Material Classifier > Programming the Material Classifier Device with LoRaWAN Application [CODE]", "content": "// Switch off VL53L0X component.\nsensor_vl53l0x.VL53L0X_Off();\n\n// Initialize VL53L0X component.\nstatus = sensor_vl53l0x.InitSensor(0x52);\nif (status) {\nSerial.println(\"Init sensor_vl53l0x failed...\");\n}\n\n// From RAK12029\nldc.LDC1614_init();\n/*single channel use case configuration.*/\nif (ldc.LDC1614_single_channel_config(GETCHANNEL, INDUCTANCE, CAPATANCE)) {\nSerial.println(\"can't detect sensor!\");\nwhile (1) delay(100);\n}\n}", "keywords": ["Arduino IDE", "RAK4631", "Material Classifier", "LoRaWAN", "SX126x-Arduino"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **Material Classifier** device. Just copy the code below for **Material Classifier LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the code</summary>  \n```c\n\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h>  //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n// For RAK12014 module\n#include <vl53l0x_class.h>    // Click to install library: http://librarymanager/All#stm32duino_vl53l0x\nVL53L0X sensor_vl53l0x(&Wire, WB_IO2);\n\nuint32_t distance;\nint status;\n\n// For RAK13001 module\n#define RELAY_PIN WB_IO4\nint object;\n\n// For RAK12029 module\n#include \"RAK12029_LDC1614.h\"\n\n#define INDUCTANCE 13.000\n#define CAPATANCE 100.0\n#define GETCHANNEL LDC1614_CHANNEL_0     // LDC1614_CHANNEL_(0~3); selecting the coil channel from 0 - 3\nRAK12029_LDC1614_Inductive ldc;\n\nu16 value = 0;\nu32 ChannelData = 0;\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define RAK4631_BOARD true\n#else\n#define RAK4631_BOARD false\n#endif\n\nbool doOTAA = true;                                               // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                                       /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                                     /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5                               /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                                        /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;                           /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;                 /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                              /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = { LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF };\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = { BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler };\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xC0, 0x81, 0xBB, 0x65, 0x54, 0xCF, 0xF7, 0x65, 0x87, 0x70, 0xFD, 0x31, 0x7F, 0x01, 0x87, 0x51 };\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };\nuint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                                            /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];               //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = { m_lora_app_data_buffer, 0, 0, 0, 0 };  //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {\n// Sensor Power Switch\npinMode(WB_IO2, OUTPUT);\ndigitalWrite(WB_IO2, HIGH);\n\n// Control Chip Switch\npinMode(WB_IO5, OUTPUT);\ndigitalWrite(WB_IO5, LOW);\n\n// Control Relay Module\npinMode(RELAY_PIN,OUTPUT);\ndigitalWrite(RELAY_PIN, LOW);    // relay module initially LOW\n\npinMode(LED_GREEN, OUTPUT);      // Output LED\npinMode(LED_BLUE, OUTPUT);       // Output LED\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial) {\nif ((millis() - timeout) < 5000) {\ndelay(100);\n} else {\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA) {\nSerial.println(\"Type: OTAA\");\n} else {\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion) {\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA) {\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n} else {\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0) {\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"===========================================\");\nSerial.println(\"RAK12014 + RAK12029 + RAK13001 LoRaWAN Code\");\nSerial.println(\"===========================================\");\n\nWire.begin();\n\n// Configure VL53L0X component.\nsensor_vl53l0x.begin();\n\n// Switch off VL53L0X component.\nsensor_vl53l0x.VL53L0X_Off();\n\n// Initialize VL53L0X component.\nstatus = sensor_vl53l0x.InitSensor(0x52);\nif (status) {\nSerial.println(\"Init sensor_vl53l0x failed...\");\n}\n\n// From RAK12029\nldc.LDC1614_init();\n/*single channel use case configuration.*/\nif (ldc.LDC1614_single_channel_config(GETCHANNEL, INDUCTANCE, CAPATANCE)) {\nSerial.println(\"can't detect sensor!\");\nwhile (1) delay(100);\n}\n}\n\nvoid loop() {\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\n// Read data from RAK12014\nstatus = sensor_vl53l0x.GetDistance(&distance);\n\n// Read data from RAK12029\nldc.IIC_read_16bit(LDC1614_READ_DEVICE_ID, &value);\nif (value == 0x3055) {\n//u32 ChannelData = 0;\n/*Get channel 0 result and parse it.*/\ndelay(100);\nif (ldc.LDC1614_get_channel_result(GETCHANNEL, &ChannelData) == 0) {\n/*sensor result value.you can make a lot of application according to its changes.*/\nif (0 != ChannelData) {\ndigitalWrite(LED_BLUE, HIGH);     // Indicator Blue LED\ndigitalWrite(LED_GREEN, HIGH);    // Indicator Green LED\n}\ndelay(200);\ndigitalWrite(LED_BLUE, LOW);        // Indicator Blue LED\ndigitalWrite(LED_GREEN, LOW);       // Indicator Green LED\n}\n}\n\nif (ChannelData >= 49800000)            // metallic material sensed nearby via inductive sensor\n{\ndigitalWrite(RELAY_PIN, HIGH);        // Turns ON the relay module\nobject = 1;                           // \"1\" corresponds to metallic object\nSerial.println(\"Metal Detected\");\n}\n\nelse if (ChannelData <= 49650000)       // nothing metallic was sensed; default value sensed by the inductive sensor\n{\ndigitalWrite(RELAY_PIN, LOW);         // Turns OFF the relay module\nobject = 0;                           // \"0\" corresponds to non-metallic object\nSerial.println(\"No Metal Detected\");\n}\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\nSerial.print(distance);       // From RAK12014 module\nSerial.println(\"mm   \");\nSerial.println(object);       // From RAK13001 module\nSerial.println(ChannelData);  // From RAK12029 module\n\ndelay(5000);\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void) {\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void) {\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data) {\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class) {\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void) {\nif (lmh_join_status_get() != LMH_SET) {\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\ndata = \" Distance: \" + String(distance) + \" mm \" + \" Metallic: \" + String(object) + \" Inductive_Sense: \" + String(ChannelData);\nSerial.println(data);\n\nuint32_t distance_data = distance;    // data from RAK12014 module\nuint32_t channel_data = ChannelData;  // data from RAK12029 module\nint metallic_data = object;           // data from RAK13001 module\n\nm_lora_app_data.buffer[i++] = 0x01;  // byte[0]\n\n// Data from RAK12014 module\nm_lora_app_data.buffer[i++] = (uint8_t)((distance_data & 0xFF000000) >> 24);    // byte[1]\nm_lora_app_data.buffer[i++] = (uint8_t)((distance_data & 0x00FF0000) >> 16);    // byte[2]\nm_lora_app_data.buffer[i++] = (uint8_t)((distance_data & 0x0000FF00) >> 8);     // byte[3]\nm_lora_app_data.buffer[i++] = (uint8_t)(distance_data & 0x000000FF);            // byte[4]\n\n// Data from RAK12029 module (inductive sensor)\nm_lora_app_data.buffer[i++] = (uint8_t)((channel_data & 0xFF000000) >> 24);    // byte[5]\nm_lora_app_data.buffer[i++] = (uint8_t)((channel_data & 0x00FF0000) >> 16);    // byte[6]\nm_lora_app_data.buffer[i++] = (uint8_t)((channel_data & 0x0000FF00) >> 8);     // byte[7]\nm_lora_app_data.buffer[i++] = (uint8_t)(channel_data & 0x000000FF);            // byte[8]\n\n// Data from RAK13001 module (relay module status)\nm_lora_app_data.buffer[i++] = metallic_data;                                   // byte[9]\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS) {\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n} else {\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xC0, 0x81, 0xBB, 0x65, 0x54, 0xCF, 0xF7, 0x65, 0x87, 0x70, 0xFD, 0x31, 0x7F, 0x01, 0x87, 0x51 };\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "0d8f334f97833f5527120faab2b5d683", "product_family": "wisblock", "product_id": "kit4-industrial", "category": "How-To", "title": "WisBlock IoT Education Kit - Smart Industry Quick Start Guide > WisBlock IoT Education Kit - Smart Industry Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock Smart Industry Kit using TTN and Quibitro > Material Classifier LoRaWAN Application > LoRaWAN Code for Material Classifier > Programming the Material Classifier Device with LoRaWAN Application [CODE]", "content": "void loop() {\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\n// Read data from RAK12014\nstatus = sensor_vl53l0x.GetDistance(&distance);", "keywords": ["Arduino IDE", "RAK4631", "Material Classifier", "LoRaWAN", "SX126x-Arduino"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **Material Classifier** device. Just copy the code below for **Material Classifier LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the code</summary>  \n```c\n\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h>  //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n// For RAK12014 module\n#include <vl53l0x_class.h>    // Click to install library: http://librarymanager/All#stm32duino_vl53l0x\nVL53L0X sensor_vl53l0x(&Wire, WB_IO2);\n\nuint32_t distance;\nint status;\n\n// For RAK13001 module\n#define RELAY_PIN WB_IO4\nint object;\n\n// For RAK12029 module\n#include \"RAK12029_LDC1614.h\"\n\n#define INDUCTANCE 13.000\n#define CAPATANCE 100.0\n#define GETCHANNEL LDC1614_CHANNEL_0     // LDC1614_CHANNEL_(0~3); selecting the coil channel from 0 - 3\nRAK12029_LDC1614_Inductive ldc;\n\nu16 value = 0;\nu32 ChannelData = 0;\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define RAK4631_BOARD true\n#else\n#define RAK4631_BOARD false\n#endif\n\nbool doOTAA = true;                                               // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                                       /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                                     /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5                               /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                                        /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;                           /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;                 /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                              /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = { LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF };\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = { BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler };\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xC0, 0x81, 0xBB, 0x65, 0x54, 0xCF, 0xF7, 0x65, 0x87, 0x70, 0xFD, 0x31, 0x7F, 0x01, 0x87, 0x51 };\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };\nuint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                                            /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];               //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = { m_lora_app_data_buffer, 0, 0, 0, 0 };  //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {\n// Sensor Power Switch\npinMode(WB_IO2, OUTPUT);\ndigitalWrite(WB_IO2, HIGH);\n\n// Control Chip Switch\npinMode(WB_IO5, OUTPUT);\ndigitalWrite(WB_IO5, LOW);\n\n// Control Relay Module\npinMode(RELAY_PIN,OUTPUT);\ndigitalWrite(RELAY_PIN, LOW);    // relay module initially LOW\n\npinMode(LED_GREEN, OUTPUT);      // Output LED\npinMode(LED_BLUE, OUTPUT);       // Output LED\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial) {\nif ((millis() - timeout) < 5000) {\ndelay(100);\n} else {\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA) {\nSerial.println(\"Type: OTAA\");\n} else {\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion) {\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA) {\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n} else {\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0) {\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"===========================================\");\nSerial.println(\"RAK12014 + RAK12029 + RAK13001 LoRaWAN Code\");\nSerial.println(\"===========================================\");\n\nWire.begin();\n\n// Configure VL53L0X component.\nsensor_vl53l0x.begin();\n\n// Switch off VL53L0X component.\nsensor_vl53l0x.VL53L0X_Off();\n\n// Initialize VL53L0X component.\nstatus = sensor_vl53l0x.InitSensor(0x52);\nif (status) {\nSerial.println(\"Init sensor_vl53l0x failed...\");\n}\n\n// From RAK12029\nldc.LDC1614_init();\n/*single channel use case configuration.*/\nif (ldc.LDC1614_single_channel_config(GETCHANNEL, INDUCTANCE, CAPATANCE)) {\nSerial.println(\"can't detect sensor!\");\nwhile (1) delay(100);\n}\n}\n\nvoid loop() {\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\n// Read data from RAK12014\nstatus = sensor_vl53l0x.GetDistance(&distance);\n\n// Read data from RAK12029\nldc.IIC_read_16bit(LDC1614_READ_DEVICE_ID, &value);\nif (value == 0x3055) {\n//u32 ChannelData = 0;\n/*Get channel 0 result and parse it.*/\ndelay(100);\nif (ldc.LDC1614_get_channel_result(GETCHANNEL, &ChannelData) == 0) {\n/*sensor result value.you can make a lot of application according to its changes.*/\nif (0 != ChannelData) {\ndigitalWrite(LED_BLUE, HIGH);     // Indicator Blue LED\ndigitalWrite(LED_GREEN, HIGH);    // Indicator Green LED\n}\ndelay(200);\ndigitalWrite(LED_BLUE, LOW);        // Indicator Blue LED\ndigitalWrite(LED_GREEN, LOW);       // Indicator Green LED\n}\n}\n\nif (ChannelData >= 49800000)            // metallic material sensed nearby via inductive sensor\n{\ndigitalWrite(RELAY_PIN, HIGH);        // Turns ON the relay module\nobject = 1;                           // \"1\" corresponds to metallic object\nSerial.println(\"Metal Detected\");\n}\n\nelse if (ChannelData <= 49650000)       // nothing metallic was sensed; default value sensed by the inductive sensor\n{\ndigitalWrite(RELAY_PIN, LOW);         // Turns OFF the relay module\nobject = 0;                           // \"0\" corresponds to non-metallic object\nSerial.println(\"No Metal Detected\");\n}\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\nSerial.print(distance);       // From RAK12014 module\nSerial.println(\"mm   \");\nSerial.println(object);       // From RAK13001 module\nSerial.println(ChannelData);  // From RAK12029 module\n\ndelay(5000);\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void) {\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void) {\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data) {\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class) {\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void) {\nif (lmh_join_status_get() != LMH_SET) {\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\ndata = \" Distance: \" + String(distance) + \" mm \" + \" Metallic: \" + String(object) + \" Inductive_Sense: \" + String(ChannelData);\nSerial.println(data);\n\nuint32_t distance_data = distance;    // data from RAK12014 module\nuint32_t channel_data = ChannelData;  // data from RAK12029 module\nint metallic_data = object;           // data from RAK13001 module\n\nm_lora_app_data.buffer[i++] = 0x01;  // byte[0]\n\n// Data from RAK12014 module\nm_lora_app_data.buffer[i++] = (uint8_t)((distance_data & 0xFF000000) >> 24);    // byte[1]\nm_lora_app_data.buffer[i++] = (uint8_t)((distance_data & 0x00FF0000) >> 16);    // byte[2]\nm_lora_app_data.buffer[i++] = (uint8_t)((distance_data & 0x0000FF00) >> 8);     // byte[3]\nm_lora_app_data.buffer[i++] = (uint8_t)(distance_data & 0x000000FF);            // byte[4]\n\n// Data from RAK12029 module (inductive sensor)\nm_lora_app_data.buffer[i++] = (uint8_t)((channel_data & 0xFF000000) >> 24);    // byte[5]\nm_lora_app_data.buffer[i++] = (uint8_t)((channel_data & 0x00FF0000) >> 16);    // byte[6]\nm_lora_app_data.buffer[i++] = (uint8_t)((channel_data & 0x0000FF00) >> 8);     // byte[7]\nm_lora_app_data.buffer[i++] = (uint8_t)(channel_data & 0x000000FF);            // byte[8]\n\n// Data from RAK13001 module (relay module status)\nm_lora_app_data.buffer[i++] = metallic_data;                                   // byte[9]\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS) {\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n} else {\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xC0, 0x81, 0xBB, 0x65, 0x54, 0xCF, 0xF7, 0x65, 0x87, 0x70, 0xFD, 0x31, 0x7F, 0x01, 0x87, 0x51 };\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "21e2f931173cebf6524b0ffc3d36e4a4", "product_family": "wisblock", "product_id": "kit4-industrial", "category": "How-To", "title": "WisBlock IoT Education Kit - Smart Industry Quick Start Guide > WisBlock IoT Education Kit - Smart Industry Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock Smart Industry Kit using TTN and Quibitro > Material Classifier LoRaWAN Application > LoRaWAN Code for Material Classifier > Programming the Material Classifier Device with LoRaWAN Application [CODE]", "content": "// Read data from RAK12029\nldc.IIC_read_16bit(LDC1614_READ_DEVICE_ID, &value);\nif (value == 0x3055) {\n//u32 ChannelData = 0;\n/*Get channel 0 result and parse it.*/\ndelay(100);\nif (ldc.LDC1614_get_channel_result(GETCHANNEL, &ChannelData) == 0) {\n/*sensor result value.you can make a lot of application according to its changes.*/\nif (0 != ChannelData) {\ndigitalWrite(LED_BLUE, HIGH);     // Indicator Blue LED\ndigitalWrite(LED_GREEN, HIGH);    // Indicator Green LED\n}\ndelay(200);", "keywords": ["Arduino IDE", "RAK4631", "Material Classifier", "LoRaWAN", "SX126x-Arduino"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **Material Classifier** device. Just copy the code below for **Material Classifier LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the code</summary>  \n```c\n\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h>  //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n// For RAK12014 module\n#include <vl53l0x_class.h>    // Click to install library: http://librarymanager/All#stm32duino_vl53l0x\nVL53L0X sensor_vl53l0x(&Wire, WB_IO2);\n\nuint32_t distance;\nint status;\n\n// For RAK13001 module\n#define RELAY_PIN WB_IO4\nint object;\n\n// For RAK12029 module\n#include \"RAK12029_LDC1614.h\"\n\n#define INDUCTANCE 13.000\n#define CAPATANCE 100.0\n#define GETCHANNEL LDC1614_CHANNEL_0     // LDC1614_CHANNEL_(0~3); selecting the coil channel from 0 - 3\nRAK12029_LDC1614_Inductive ldc;\n\nu16 value = 0;\nu32 ChannelData = 0;\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define RAK4631_BOARD true\n#else\n#define RAK4631_BOARD false\n#endif\n\nbool doOTAA = true;                                               // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                                       /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                                     /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5                               /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                                        /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;                           /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;                 /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                              /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = { LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF };\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = { BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler };\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xC0, 0x81, 0xBB, 0x65, 0x54, 0xCF, 0xF7, 0x65, 0x87, 0x70, 0xFD, 0x31, 0x7F, 0x01, 0x87, 0x51 };\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };\nuint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                                            /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];               //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = { m_lora_app_data_buffer, 0, 0, 0, 0 };  //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {\n// Sensor Power Switch\npinMode(WB_IO2, OUTPUT);\ndigitalWrite(WB_IO2, HIGH);\n\n// Control Chip Switch\npinMode(WB_IO5, OUTPUT);\ndigitalWrite(WB_IO5, LOW);\n\n// Control Relay Module\npinMode(RELAY_PIN,OUTPUT);\ndigitalWrite(RELAY_PIN, LOW);    // relay module initially LOW\n\npinMode(LED_GREEN, OUTPUT);      // Output LED\npinMode(LED_BLUE, OUTPUT);       // Output LED\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial) {\nif ((millis() - timeout) < 5000) {\ndelay(100);\n} else {\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA) {\nSerial.println(\"Type: OTAA\");\n} else {\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion) {\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA) {\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n} else {\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0) {\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"===========================================\");\nSerial.println(\"RAK12014 + RAK12029 + RAK13001 LoRaWAN Code\");\nSerial.println(\"===========================================\");\n\nWire.begin();\n\n// Configure VL53L0X component.\nsensor_vl53l0x.begin();\n\n// Switch off VL53L0X component.\nsensor_vl53l0x.VL53L0X_Off();\n\n// Initialize VL53L0X component.\nstatus = sensor_vl53l0x.InitSensor(0x52);\nif (status) {\nSerial.println(\"Init sensor_vl53l0x failed...\");\n}\n\n// From RAK12029\nldc.LDC1614_init();\n/*single channel use case configuration.*/\nif (ldc.LDC1614_single_channel_config(GETCHANNEL, INDUCTANCE, CAPATANCE)) {\nSerial.println(\"can't detect sensor!\");\nwhile (1) delay(100);\n}\n}\n\nvoid loop() {\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\n// Read data from RAK12014\nstatus = sensor_vl53l0x.GetDistance(&distance);\n\n// Read data from RAK12029\nldc.IIC_read_16bit(LDC1614_READ_DEVICE_ID, &value);\nif (value == 0x3055) {\n//u32 ChannelData = 0;\n/*Get channel 0 result and parse it.*/\ndelay(100);\nif (ldc.LDC1614_get_channel_result(GETCHANNEL, &ChannelData) == 0) {\n/*sensor result value.you can make a lot of application according to its changes.*/\nif (0 != ChannelData) {\ndigitalWrite(LED_BLUE, HIGH);     // Indicator Blue LED\ndigitalWrite(LED_GREEN, HIGH);    // Indicator Green LED\n}\ndelay(200);\ndigitalWrite(LED_BLUE, LOW);        // Indicator Blue LED\ndigitalWrite(LED_GREEN, LOW);       // Indicator Green LED\n}\n}\n\nif (ChannelData >= 49800000)            // metallic material sensed nearby via inductive sensor\n{\ndigitalWrite(RELAY_PIN, HIGH);        // Turns ON the relay module\nobject = 1;                           // \"1\" corresponds to metallic object\nSerial.println(\"Metal Detected\");\n}\n\nelse if (ChannelData <= 49650000)       // nothing metallic was sensed; default value sensed by the inductive sensor\n{\ndigitalWrite(RELAY_PIN, LOW);         // Turns OFF the relay module\nobject = 0;                           // \"0\" corresponds to non-metallic object\nSerial.println(\"No Metal Detected\");\n}\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\nSerial.print(distance);       // From RAK12014 module\nSerial.println(\"mm   \");\nSerial.println(object);       // From RAK13001 module\nSerial.println(ChannelData);  // From RAK12029 module\n\ndelay(5000);\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void) {\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void) {\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data) {\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class) {\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void) {\nif (lmh_join_status_get() != LMH_SET) {\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\ndata = \" Distance: \" + String(distance) + \" mm \" + \" Metallic: \" + String(object) + \" Inductive_Sense: \" + String(ChannelData);\nSerial.println(data);\n\nuint32_t distance_data = distance;    // data from RAK12014 module\nuint32_t channel_data = ChannelData;  // data from RAK12029 module\nint metallic_data = object;           // data from RAK13001 module\n\nm_lora_app_data.buffer[i++] = 0x01;  // byte[0]\n\n// Data from RAK12014 module\nm_lora_app_data.buffer[i++] = (uint8_t)((distance_data & 0xFF000000) >> 24);    // byte[1]\nm_lora_app_data.buffer[i++] = (uint8_t)((distance_data & 0x00FF0000) >> 16);    // byte[2]\nm_lora_app_data.buffer[i++] = (uint8_t)((distance_data & 0x0000FF00) >> 8);     // byte[3]\nm_lora_app_data.buffer[i++] = (uint8_t)(distance_data & 0x000000FF);            // byte[4]\n\n// Data from RAK12029 module (inductive sensor)\nm_lora_app_data.buffer[i++] = (uint8_t)((channel_data & 0xFF000000) >> 24);    // byte[5]\nm_lora_app_data.buffer[i++] = (uint8_t)((channel_data & 0x00FF0000) >> 16);    // byte[6]\nm_lora_app_data.buffer[i++] = (uint8_t)((channel_data & 0x0000FF00) >> 8);     // byte[7]\nm_lora_app_data.buffer[i++] = (uint8_t)(channel_data & 0x000000FF);            // byte[8]\n\n// Data from RAK13001 module (relay module status)\nm_lora_app_data.buffer[i++] = metallic_data;                                   // byte[9]\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS) {\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n} else {\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xC0, 0x81, 0xBB, 0x65, 0x54, 0xCF, 0xF7, 0x65, 0x87, 0x70, 0xFD, 0x31, 0x7F, 0x01, 0x87, 0x51 };\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "a585750251ff835e3e4fbf8a9b92bcb0", "product_family": "wisblock", "product_id": "kit4-industrial", "category": "How-To", "title": "WisBlock IoT Education Kit - Smart Industry Quick Start Guide > WisBlock IoT Education Kit - Smart Industry Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock Smart Industry Kit using TTN and Quibitro > Material Classifier LoRaWAN Application > LoRaWAN Code for Material Classifier > Programming the Material Classifier Device with LoRaWAN Application [CODE]", "content": "digitalWrite(LED_GREEN, HIGH);    // Indicator Green LED\n}\ndelay(200);\ndigitalWrite(LED_BLUE, LOW);        // Indicator Blue LED\ndigitalWrite(LED_GREEN, LOW);       // Indicator Green LED\n}\n}", "keywords": ["Arduino IDE", "RAK4631", "Material Classifier", "LoRaWAN", "SX126x-Arduino"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **Material Classifier** device. Just copy the code below for **Material Classifier LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the code</summary>  \n```c\n\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h>  //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n// For RAK12014 module\n#include <vl53l0x_class.h>    // Click to install library: http://librarymanager/All#stm32duino_vl53l0x\nVL53L0X sensor_vl53l0x(&Wire, WB_IO2);\n\nuint32_t distance;\nint status;\n\n// For RAK13001 module\n#define RELAY_PIN WB_IO4\nint object;\n\n// For RAK12029 module\n#include \"RAK12029_LDC1614.h\"\n\n#define INDUCTANCE 13.000\n#define CAPATANCE 100.0\n#define GETCHANNEL LDC1614_CHANNEL_0     // LDC1614_CHANNEL_(0~3); selecting the coil channel from 0 - 3\nRAK12029_LDC1614_Inductive ldc;\n\nu16 value = 0;\nu32 ChannelData = 0;\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define RAK4631_BOARD true\n#else\n#define RAK4631_BOARD false\n#endif\n\nbool doOTAA = true;                                               // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                                       /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                                     /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5                               /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                                        /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;                           /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;                 /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                              /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = { LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF };\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = { BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler };\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xC0, 0x81, 0xBB, 0x65, 0x54, 0xCF, 0xF7, 0x65, 0x87, 0x70, 0xFD, 0x31, 0x7F, 0x01, 0x87, 0x51 };\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };\nuint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                                            /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];               //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = { m_lora_app_data_buffer, 0, 0, 0, 0 };  //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {\n// Sensor Power Switch\npinMode(WB_IO2, OUTPUT);\ndigitalWrite(WB_IO2, HIGH);\n\n// Control Chip Switch\npinMode(WB_IO5, OUTPUT);\ndigitalWrite(WB_IO5, LOW);\n\n// Control Relay Module\npinMode(RELAY_PIN,OUTPUT);\ndigitalWrite(RELAY_PIN, LOW);    // relay module initially LOW\n\npinMode(LED_GREEN, OUTPUT);      // Output LED\npinMode(LED_BLUE, OUTPUT);       // Output LED\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial) {\nif ((millis() - timeout) < 5000) {\ndelay(100);\n} else {\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA) {\nSerial.println(\"Type: OTAA\");\n} else {\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion) {\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA) {\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n} else {\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0) {\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"===========================================\");\nSerial.println(\"RAK12014 + RAK12029 + RAK13001 LoRaWAN Code\");\nSerial.println(\"===========================================\");\n\nWire.begin();\n\n// Configure VL53L0X component.\nsensor_vl53l0x.begin();\n\n// Switch off VL53L0X component.\nsensor_vl53l0x.VL53L0X_Off();\n\n// Initialize VL53L0X component.\nstatus = sensor_vl53l0x.InitSensor(0x52);\nif (status) {\nSerial.println(\"Init sensor_vl53l0x failed...\");\n}\n\n// From RAK12029\nldc.LDC1614_init();\n/*single channel use case configuration.*/\nif (ldc.LDC1614_single_channel_config(GETCHANNEL, INDUCTANCE, CAPATANCE)) {\nSerial.println(\"can't detect sensor!\");\nwhile (1) delay(100);\n}\n}\n\nvoid loop() {\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\n// Read data from RAK12014\nstatus = sensor_vl53l0x.GetDistance(&distance);\n\n// Read data from RAK12029\nldc.IIC_read_16bit(LDC1614_READ_DEVICE_ID, &value);\nif (value == 0x3055) {\n//u32 ChannelData = 0;\n/*Get channel 0 result and parse it.*/\ndelay(100);\nif (ldc.LDC1614_get_channel_result(GETCHANNEL, &ChannelData) == 0) {\n/*sensor result value.you can make a lot of application according to its changes.*/\nif (0 != ChannelData) {\ndigitalWrite(LED_BLUE, HIGH);     // Indicator Blue LED\ndigitalWrite(LED_GREEN, HIGH);    // Indicator Green LED\n}\ndelay(200);\ndigitalWrite(LED_BLUE, LOW);        // Indicator Blue LED\ndigitalWrite(LED_GREEN, LOW);       // Indicator Green LED\n}\n}\n\nif (ChannelData >= 49800000)            // metallic material sensed nearby via inductive sensor\n{\ndigitalWrite(RELAY_PIN, HIGH);        // Turns ON the relay module\nobject = 1;                           // \"1\" corresponds to metallic object\nSerial.println(\"Metal Detected\");\n}\n\nelse if (ChannelData <= 49650000)       // nothing metallic was sensed; default value sensed by the inductive sensor\n{\ndigitalWrite(RELAY_PIN, LOW);         // Turns OFF the relay module\nobject = 0;                           // \"0\" corresponds to non-metallic object\nSerial.println(\"No Metal Detected\");\n}\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\nSerial.print(distance);       // From RAK12014 module\nSerial.println(\"mm   \");\nSerial.println(object);       // From RAK13001 module\nSerial.println(ChannelData);  // From RAK12029 module\n\ndelay(5000);\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void) {\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void) {\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data) {\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class) {\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void) {\nif (lmh_join_status_get() != LMH_SET) {\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\ndata = \" Distance: \" + String(distance) + \" mm \" + \" Metallic: \" + String(object) + \" Inductive_Sense: \" + String(ChannelData);\nSerial.println(data);\n\nuint32_t distance_data = distance;    // data from RAK12014 module\nuint32_t channel_data = ChannelData;  // data from RAK12029 module\nint metallic_data = object;           // data from RAK13001 module\n\nm_lora_app_data.buffer[i++] = 0x01;  // byte[0]\n\n// Data from RAK12014 module\nm_lora_app_data.buffer[i++] = (uint8_t)((distance_data & 0xFF000000) >> 24);    // byte[1]\nm_lora_app_data.buffer[i++] = (uint8_t)((distance_data & 0x00FF0000) >> 16);    // byte[2]\nm_lora_app_data.buffer[i++] = (uint8_t)((distance_data & 0x0000FF00) >> 8);     // byte[3]\nm_lora_app_data.buffer[i++] = (uint8_t)(distance_data & 0x000000FF);            // byte[4]\n\n// Data from RAK12029 module (inductive sensor)\nm_lora_app_data.buffer[i++] = (uint8_t)((channel_data & 0xFF000000) >> 24);    // byte[5]\nm_lora_app_data.buffer[i++] = (uint8_t)((channel_data & 0x00FF0000) >> 16);    // byte[6]\nm_lora_app_data.buffer[i++] = (uint8_t)((channel_data & 0x0000FF00) >> 8);     // byte[7]\nm_lora_app_data.buffer[i++] = (uint8_t)(channel_data & 0x000000FF);            // byte[8]\n\n// Data from RAK13001 module (relay module status)\nm_lora_app_data.buffer[i++] = metallic_data;                                   // byte[9]\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS) {\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n} else {\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xC0, 0x81, 0xBB, 0x65, 0x54, 0xCF, 0xF7, 0x65, 0x87, 0x70, 0xFD, 0x31, 0x7F, 0x01, 0x87, 0x51 };\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "80438fe6a8b3ba93bb1d66f11022604e", "product_family": "wisblock", "product_id": "kit4-industrial", "category": "How-To", "title": "WisBlock IoT Education Kit - Smart Industry Quick Start Guide > WisBlock IoT Education Kit - Smart Industry Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock Smart Industry Kit using TTN and Quibitro > Material Classifier LoRaWAN Application > LoRaWAN Code for Material Classifier > Programming the Material Classifier Device with LoRaWAN Application [CODE]", "content": "if (ChannelData >= 49800000)            // metallic material sensed nearby via inductive sensor\n{\ndigitalWrite(RELAY_PIN, HIGH);        // Turns ON the relay module\nobject = 1;                           // \"1\" corresponds to metallic object\nSerial.println(\"Metal Detected\");\n}", "keywords": ["Arduino IDE", "RAK4631", "Material Classifier", "LoRaWAN", "SX126x-Arduino"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **Material Classifier** device. Just copy the code below for **Material Classifier LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the code</summary>  \n```c\n\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h>  //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n// For RAK12014 module\n#include <vl53l0x_class.h>    // Click to install library: http://librarymanager/All#stm32duino_vl53l0x\nVL53L0X sensor_vl53l0x(&Wire, WB_IO2);\n\nuint32_t distance;\nint status;\n\n// For RAK13001 module\n#define RELAY_PIN WB_IO4\nint object;\n\n// For RAK12029 module\n#include \"RAK12029_LDC1614.h\"\n\n#define INDUCTANCE 13.000\n#define CAPATANCE 100.0\n#define GETCHANNEL LDC1614_CHANNEL_0     // LDC1614_CHANNEL_(0~3); selecting the coil channel from 0 - 3\nRAK12029_LDC1614_Inductive ldc;\n\nu16 value = 0;\nu32 ChannelData = 0;\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define RAK4631_BOARD true\n#else\n#define RAK4631_BOARD false\n#endif\n\nbool doOTAA = true;                                               // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                                       /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                                     /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5                               /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                                        /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;                           /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;                 /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                              /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = { LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF };\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = { BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler };\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xC0, 0x81, 0xBB, 0x65, 0x54, 0xCF, 0xF7, 0x65, 0x87, 0x70, 0xFD, 0x31, 0x7F, 0x01, 0x87, 0x51 };\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };\nuint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                                            /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];               //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = { m_lora_app_data_buffer, 0, 0, 0, 0 };  //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {\n// Sensor Power Switch\npinMode(WB_IO2, OUTPUT);\ndigitalWrite(WB_IO2, HIGH);\n\n// Control Chip Switch\npinMode(WB_IO5, OUTPUT);\ndigitalWrite(WB_IO5, LOW);\n\n// Control Relay Module\npinMode(RELAY_PIN,OUTPUT);\ndigitalWrite(RELAY_PIN, LOW);    // relay module initially LOW\n\npinMode(LED_GREEN, OUTPUT);      // Output LED\npinMode(LED_BLUE, OUTPUT);       // Output LED\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial) {\nif ((millis() - timeout) < 5000) {\ndelay(100);\n} else {\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA) {\nSerial.println(\"Type: OTAA\");\n} else {\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion) {\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA) {\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n} else {\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0) {\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"===========================================\");\nSerial.println(\"RAK12014 + RAK12029 + RAK13001 LoRaWAN Code\");\nSerial.println(\"===========================================\");\n\nWire.begin();\n\n// Configure VL53L0X component.\nsensor_vl53l0x.begin();\n\n// Switch off VL53L0X component.\nsensor_vl53l0x.VL53L0X_Off();\n\n// Initialize VL53L0X component.\nstatus = sensor_vl53l0x.InitSensor(0x52);\nif (status) {\nSerial.println(\"Init sensor_vl53l0x failed...\");\n}\n\n// From RAK12029\nldc.LDC1614_init();\n/*single channel use case configuration.*/\nif (ldc.LDC1614_single_channel_config(GETCHANNEL, INDUCTANCE, CAPATANCE)) {\nSerial.println(\"can't detect sensor!\");\nwhile (1) delay(100);\n}\n}\n\nvoid loop() {\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\n// Read data from RAK12014\nstatus = sensor_vl53l0x.GetDistance(&distance);\n\n// Read data from RAK12029\nldc.IIC_read_16bit(LDC1614_READ_DEVICE_ID, &value);\nif (value == 0x3055) {\n//u32 ChannelData = 0;\n/*Get channel 0 result and parse it.*/\ndelay(100);\nif (ldc.LDC1614_get_channel_result(GETCHANNEL, &ChannelData) == 0) {\n/*sensor result value.you can make a lot of application according to its changes.*/\nif (0 != ChannelData) {\ndigitalWrite(LED_BLUE, HIGH);     // Indicator Blue LED\ndigitalWrite(LED_GREEN, HIGH);    // Indicator Green LED\n}\ndelay(200);\ndigitalWrite(LED_BLUE, LOW);        // Indicator Blue LED\ndigitalWrite(LED_GREEN, LOW);       // Indicator Green LED\n}\n}\n\nif (ChannelData >= 49800000)            // metallic material sensed nearby via inductive sensor\n{\ndigitalWrite(RELAY_PIN, HIGH);        // Turns ON the relay module\nobject = 1;                           // \"1\" corresponds to metallic object\nSerial.println(\"Metal Detected\");\n}\n\nelse if (ChannelData <= 49650000)       // nothing metallic was sensed; default value sensed by the inductive sensor\n{\ndigitalWrite(RELAY_PIN, LOW);         // Turns OFF the relay module\nobject = 0;                           // \"0\" corresponds to non-metallic object\nSerial.println(\"No Metal Detected\");\n}\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\nSerial.print(distance);       // From RAK12014 module\nSerial.println(\"mm   \");\nSerial.println(object);       // From RAK13001 module\nSerial.println(ChannelData);  // From RAK12029 module\n\ndelay(5000);\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void) {\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void) {\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data) {\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class) {\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void) {\nif (lmh_join_status_get() != LMH_SET) {\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\ndata = \" Distance: \" + String(distance) + \" mm \" + \" Metallic: \" + String(object) + \" Inductive_Sense: \" + String(ChannelData);\nSerial.println(data);\n\nuint32_t distance_data = distance;    // data from RAK12014 module\nuint32_t channel_data = ChannelData;  // data from RAK12029 module\nint metallic_data = object;           // data from RAK13001 module\n\nm_lora_app_data.buffer[i++] = 0x01;  // byte[0]\n\n// Data from RAK12014 module\nm_lora_app_data.buffer[i++] = (uint8_t)((distance_data & 0xFF000000) >> 24);    // byte[1]\nm_lora_app_data.buffer[i++] = (uint8_t)((distance_data & 0x00FF0000) >> 16);    // byte[2]\nm_lora_app_data.buffer[i++] = (uint8_t)((distance_data & 0x0000FF00) >> 8);     // byte[3]\nm_lora_app_data.buffer[i++] = (uint8_t)(distance_data & 0x000000FF);            // byte[4]\n\n// Data from RAK12029 module (inductive sensor)\nm_lora_app_data.buffer[i++] = (uint8_t)((channel_data & 0xFF000000) >> 24);    // byte[5]\nm_lora_app_data.buffer[i++] = (uint8_t)((channel_data & 0x00FF0000) >> 16);    // byte[6]\nm_lora_app_data.buffer[i++] = (uint8_t)((channel_data & 0x0000FF00) >> 8);     // byte[7]\nm_lora_app_data.buffer[i++] = (uint8_t)(channel_data & 0x000000FF);            // byte[8]\n\n// Data from RAK13001 module (relay module status)\nm_lora_app_data.buffer[i++] = metallic_data;                                   // byte[9]\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS) {\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n} else {\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xC0, 0x81, 0xBB, 0x65, 0x54, 0xCF, 0xF7, 0x65, 0x87, 0x70, 0xFD, 0x31, 0x7F, 0x01, 0x87, 0x51 };\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "308e1e5fc4a98e7b905f613c5f76c21b", "product_family": "wisblock", "product_id": "kit4-industrial", "category": "How-To", "title": "WisBlock IoT Education Kit - Smart Industry Quick Start Guide > WisBlock IoT Education Kit - Smart Industry Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock Smart Industry Kit using TTN and Quibitro > Material Classifier LoRaWAN Application > LoRaWAN Code for Material Classifier > Programming the Material Classifier Device with LoRaWAN Application [CODE]", "content": "else if (ChannelData <= 49650000)       // nothing metallic was sensed; default value sensed by the inductive sensor\n{\ndigitalWrite(RELAY_PIN, LOW);         // Turns OFF the relay module\nobject = 0;                           // \"0\" corresponds to non-metallic object\nSerial.println(\"No Metal Detected\");\n}\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();", "keywords": ["Arduino IDE", "RAK4631", "Material Classifier", "LoRaWAN", "SX126x-Arduino"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **Material Classifier** device. Just copy the code below for **Material Classifier LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the code</summary>  \n```c\n\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h>  //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n// For RAK12014 module\n#include <vl53l0x_class.h>    // Click to install library: http://librarymanager/All#stm32duino_vl53l0x\nVL53L0X sensor_vl53l0x(&Wire, WB_IO2);\n\nuint32_t distance;\nint status;\n\n// For RAK13001 module\n#define RELAY_PIN WB_IO4\nint object;\n\n// For RAK12029 module\n#include \"RAK12029_LDC1614.h\"\n\n#define INDUCTANCE 13.000\n#define CAPATANCE 100.0\n#define GETCHANNEL LDC1614_CHANNEL_0     // LDC1614_CHANNEL_(0~3); selecting the coil channel from 0 - 3\nRAK12029_LDC1614_Inductive ldc;\n\nu16 value = 0;\nu32 ChannelData = 0;\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define RAK4631_BOARD true\n#else\n#define RAK4631_BOARD false\n#endif\n\nbool doOTAA = true;                                               // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                                       /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                                     /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5                               /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                                        /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;                           /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;                 /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                              /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = { LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF };\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = { BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler };\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xC0, 0x81, 0xBB, 0x65, 0x54, 0xCF, 0xF7, 0x65, 0x87, 0x70, 0xFD, 0x31, 0x7F, 0x01, 0x87, 0x51 };\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };\nuint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                                            /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];               //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = { m_lora_app_data_buffer, 0, 0, 0, 0 };  //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {\n// Sensor Power Switch\npinMode(WB_IO2, OUTPUT);\ndigitalWrite(WB_IO2, HIGH);\n\n// Control Chip Switch\npinMode(WB_IO5, OUTPUT);\ndigitalWrite(WB_IO5, LOW);\n\n// Control Relay Module\npinMode(RELAY_PIN,OUTPUT);\ndigitalWrite(RELAY_PIN, LOW);    // relay module initially LOW\n\npinMode(LED_GREEN, OUTPUT);      // Output LED\npinMode(LED_BLUE, OUTPUT);       // Output LED\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial) {\nif ((millis() - timeout) < 5000) {\ndelay(100);\n} else {\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA) {\nSerial.println(\"Type: OTAA\");\n} else {\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion) {\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA) {\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n} else {\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0) {\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"===========================================\");\nSerial.println(\"RAK12014 + RAK12029 + RAK13001 LoRaWAN Code\");\nSerial.println(\"===========================================\");\n\nWire.begin();\n\n// Configure VL53L0X component.\nsensor_vl53l0x.begin();\n\n// Switch off VL53L0X component.\nsensor_vl53l0x.VL53L0X_Off();\n\n// Initialize VL53L0X component.\nstatus = sensor_vl53l0x.InitSensor(0x52);\nif (status) {\nSerial.println(\"Init sensor_vl53l0x failed...\");\n}\n\n// From RAK12029\nldc.LDC1614_init();\n/*single channel use case configuration.*/\nif (ldc.LDC1614_single_channel_config(GETCHANNEL, INDUCTANCE, CAPATANCE)) {\nSerial.println(\"can't detect sensor!\");\nwhile (1) delay(100);\n}\n}\n\nvoid loop() {\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\n// Read data from RAK12014\nstatus = sensor_vl53l0x.GetDistance(&distance);\n\n// Read data from RAK12029\nldc.IIC_read_16bit(LDC1614_READ_DEVICE_ID, &value);\nif (value == 0x3055) {\n//u32 ChannelData = 0;\n/*Get channel 0 result and parse it.*/\ndelay(100);\nif (ldc.LDC1614_get_channel_result(GETCHANNEL, &ChannelData) == 0) {\n/*sensor result value.you can make a lot of application according to its changes.*/\nif (0 != ChannelData) {\ndigitalWrite(LED_BLUE, HIGH);     // Indicator Blue LED\ndigitalWrite(LED_GREEN, HIGH);    // Indicator Green LED\n}\ndelay(200);\ndigitalWrite(LED_BLUE, LOW);        // Indicator Blue LED\ndigitalWrite(LED_GREEN, LOW);       // Indicator Green LED\n}\n}\n\nif (ChannelData >= 49800000)            // metallic material sensed nearby via inductive sensor\n{\ndigitalWrite(RELAY_PIN, HIGH);        // Turns ON the relay module\nobject = 1;                           // \"1\" corresponds to metallic object\nSerial.println(\"Metal Detected\");\n}\n\nelse if (ChannelData <= 49650000)       // nothing metallic was sensed; default value sensed by the inductive sensor\n{\ndigitalWrite(RELAY_PIN, LOW);         // Turns OFF the relay module\nobject = 0;                           // \"0\" corresponds to non-metallic object\nSerial.println(\"No Metal Detected\");\n}\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\nSerial.print(distance);       // From RAK12014 module\nSerial.println(\"mm   \");\nSerial.println(object);       // From RAK13001 module\nSerial.println(ChannelData);  // From RAK12029 module\n\ndelay(5000);\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void) {\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void) {\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data) {\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class) {\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void) {\nif (lmh_join_status_get() != LMH_SET) {\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\ndata = \" Distance: \" + String(distance) + \" mm \" + \" Metallic: \" + String(object) + \" Inductive_Sense: \" + String(ChannelData);\nSerial.println(data);\n\nuint32_t distance_data = distance;    // data from RAK12014 module\nuint32_t channel_data = ChannelData;  // data from RAK12029 module\nint metallic_data = object;           // data from RAK13001 module\n\nm_lora_app_data.buffer[i++] = 0x01;  // byte[0]\n\n// Data from RAK12014 module\nm_lora_app_data.buffer[i++] = (uint8_t)((distance_data & 0xFF000000) >> 24);    // byte[1]\nm_lora_app_data.buffer[i++] = (uint8_t)((distance_data & 0x00FF0000) >> 16);    // byte[2]\nm_lora_app_data.buffer[i++] = (uint8_t)((distance_data & 0x0000FF00) >> 8);     // byte[3]\nm_lora_app_data.buffer[i++] = (uint8_t)(distance_data & 0x000000FF);            // byte[4]\n\n// Data from RAK12029 module (inductive sensor)\nm_lora_app_data.buffer[i++] = (uint8_t)((channel_data & 0xFF000000) >> 24);    // byte[5]\nm_lora_app_data.buffer[i++] = (uint8_t)((channel_data & 0x00FF0000) >> 16);    // byte[6]\nm_lora_app_data.buffer[i++] = (uint8_t)((channel_data & 0x0000FF00) >> 8);     // byte[7]\nm_lora_app_data.buffer[i++] = (uint8_t)(channel_data & 0x000000FF);            // byte[8]\n\n// Data from RAK13001 module (relay module status)\nm_lora_app_data.buffer[i++] = metallic_data;                                   // byte[9]\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS) {\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n} else {\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xC0, 0x81, 0xBB, 0x65, 0x54, 0xCF, 0xF7, 0x65, 0x87, 0x70, 0xFD, 0x31, 0x7F, 0x01, 0x87, 0x51 };\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "988c5cf48b9b00fdbd58ebee18b31c36", "product_family": "wisblock", "product_id": "kit4-industrial", "category": "How-To", "title": "WisBlock IoT Education Kit - Smart Industry Quick Start Guide > WisBlock IoT Education Kit - Smart Industry Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock Smart Industry Kit using TTN and Quibitro > Material Classifier LoRaWAN Application > LoRaWAN Code for Material Classifier > Programming the Material Classifier Device with LoRaWAN Application [CODE]", "content": "Serial.println(\"Sending frame now...\");\nsend_lora_frame();\n\nSerial.print(distance);       // From RAK12014 module\nSerial.println(\"mm   \");\nSerial.println(object);       // From RAK13001 module\nSerial.println(ChannelData);  // From RAK12029 module\n\ndelay(5000);\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void) {\nSerial.println(\"OTAA Mode, Network Joined!\");\n}", "keywords": ["Arduino IDE", "RAK4631", "Material Classifier", "LoRaWAN", "SX126x-Arduino"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **Material Classifier** device. Just copy the code below for **Material Classifier LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the code</summary>  \n```c\n\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h>  //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n// For RAK12014 module\n#include <vl53l0x_class.h>    // Click to install library: http://librarymanager/All#stm32duino_vl53l0x\nVL53L0X sensor_vl53l0x(&Wire, WB_IO2);\n\nuint32_t distance;\nint status;\n\n// For RAK13001 module\n#define RELAY_PIN WB_IO4\nint object;\n\n// For RAK12029 module\n#include \"RAK12029_LDC1614.h\"\n\n#define INDUCTANCE 13.000\n#define CAPATANCE 100.0\n#define GETCHANNEL LDC1614_CHANNEL_0     // LDC1614_CHANNEL_(0~3); selecting the coil channel from 0 - 3\nRAK12029_LDC1614_Inductive ldc;\n\nu16 value = 0;\nu32 ChannelData = 0;\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define RAK4631_BOARD true\n#else\n#define RAK4631_BOARD false\n#endif\n\nbool doOTAA = true;                                               // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                                       /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                                     /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5                               /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                                        /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;                           /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;                 /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                              /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = { LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF };\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = { BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler };\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xC0, 0x81, 0xBB, 0x65, 0x54, 0xCF, 0xF7, 0x65, 0x87, 0x70, 0xFD, 0x31, 0x7F, 0x01, 0x87, 0x51 };\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };\nuint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                                            /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];               //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = { m_lora_app_data_buffer, 0, 0, 0, 0 };  //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {\n// Sensor Power Switch\npinMode(WB_IO2, OUTPUT);\ndigitalWrite(WB_IO2, HIGH);\n\n// Control Chip Switch\npinMode(WB_IO5, OUTPUT);\ndigitalWrite(WB_IO5, LOW);\n\n// Control Relay Module\npinMode(RELAY_PIN,OUTPUT);\ndigitalWrite(RELAY_PIN, LOW);    // relay module initially LOW\n\npinMode(LED_GREEN, OUTPUT);      // Output LED\npinMode(LED_BLUE, OUTPUT);       // Output LED\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial) {\nif ((millis() - timeout) < 5000) {\ndelay(100);\n} else {\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA) {\nSerial.println(\"Type: OTAA\");\n} else {\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion) {\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA) {\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n} else {\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0) {\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"===========================================\");\nSerial.println(\"RAK12014 + RAK12029 + RAK13001 LoRaWAN Code\");\nSerial.println(\"===========================================\");\n\nWire.begin();\n\n// Configure VL53L0X component.\nsensor_vl53l0x.begin();\n\n// Switch off VL53L0X component.\nsensor_vl53l0x.VL53L0X_Off();\n\n// Initialize VL53L0X component.\nstatus = sensor_vl53l0x.InitSensor(0x52);\nif (status) {\nSerial.println(\"Init sensor_vl53l0x failed...\");\n}\n\n// From RAK12029\nldc.LDC1614_init();\n/*single channel use case configuration.*/\nif (ldc.LDC1614_single_channel_config(GETCHANNEL, INDUCTANCE, CAPATANCE)) {\nSerial.println(\"can't detect sensor!\");\nwhile (1) delay(100);\n}\n}\n\nvoid loop() {\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\n// Read data from RAK12014\nstatus = sensor_vl53l0x.GetDistance(&distance);\n\n// Read data from RAK12029\nldc.IIC_read_16bit(LDC1614_READ_DEVICE_ID, &value);\nif (value == 0x3055) {\n//u32 ChannelData = 0;\n/*Get channel 0 result and parse it.*/\ndelay(100);\nif (ldc.LDC1614_get_channel_result(GETCHANNEL, &ChannelData) == 0) {\n/*sensor result value.you can make a lot of application according to its changes.*/\nif (0 != ChannelData) {\ndigitalWrite(LED_BLUE, HIGH);     // Indicator Blue LED\ndigitalWrite(LED_GREEN, HIGH);    // Indicator Green LED\n}\ndelay(200);\ndigitalWrite(LED_BLUE, LOW);        // Indicator Blue LED\ndigitalWrite(LED_GREEN, LOW);       // Indicator Green LED\n}\n}\n\nif (ChannelData >= 49800000)            // metallic material sensed nearby via inductive sensor\n{\ndigitalWrite(RELAY_PIN, HIGH);        // Turns ON the relay module\nobject = 1;                           // \"1\" corresponds to metallic object\nSerial.println(\"Metal Detected\");\n}\n\nelse if (ChannelData <= 49650000)       // nothing metallic was sensed; default value sensed by the inductive sensor\n{\ndigitalWrite(RELAY_PIN, LOW);         // Turns OFF the relay module\nobject = 0;                           // \"0\" corresponds to non-metallic object\nSerial.println(\"No Metal Detected\");\n}\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\nSerial.print(distance);       // From RAK12014 module\nSerial.println(\"mm   \");\nSerial.println(object);       // From RAK13001 module\nSerial.println(ChannelData);  // From RAK12029 module\n\ndelay(5000);\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void) {\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void) {\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data) {\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class) {\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void) {\nif (lmh_join_status_get() != LMH_SET) {\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\ndata = \" Distance: \" + String(distance) + \" mm \" + \" Metallic: \" + String(object) + \" Inductive_Sense: \" + String(ChannelData);\nSerial.println(data);\n\nuint32_t distance_data = distance;    // data from RAK12014 module\nuint32_t channel_data = ChannelData;  // data from RAK12029 module\nint metallic_data = object;           // data from RAK13001 module\n\nm_lora_app_data.buffer[i++] = 0x01;  // byte[0]\n\n// Data from RAK12014 module\nm_lora_app_data.buffer[i++] = (uint8_t)((distance_data & 0xFF000000) >> 24);    // byte[1]\nm_lora_app_data.buffer[i++] = (uint8_t)((distance_data & 0x00FF0000) >> 16);    // byte[2]\nm_lora_app_data.buffer[i++] = (uint8_t)((distance_data & 0x0000FF00) >> 8);     // byte[3]\nm_lora_app_data.buffer[i++] = (uint8_t)(distance_data & 0x000000FF);            // byte[4]\n\n// Data from RAK12029 module (inductive sensor)\nm_lora_app_data.buffer[i++] = (uint8_t)((channel_data & 0xFF000000) >> 24);    // byte[5]\nm_lora_app_data.buffer[i++] = (uint8_t)((channel_data & 0x00FF0000) >> 16);    // byte[6]\nm_lora_app_data.buffer[i++] = (uint8_t)((channel_data & 0x0000FF00) >> 8);     // byte[7]\nm_lora_app_data.buffer[i++] = (uint8_t)(channel_data & 0x000000FF);            // byte[8]\n\n// Data from RAK13001 module (relay module status)\nm_lora_app_data.buffer[i++] = metallic_data;                                   // byte[9]\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS) {\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n} else {\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xC0, 0x81, 0xBB, 0x65, 0x54, 0xCF, 0xF7, 0x65, 0x87, 0x70, 0xFD, 0x31, 0x7F, 0x01, 0x87, 0x51 };\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "b93647f1eeedf6bf8a31f6c56a0277f0", "product_family": "wisblock", "product_id": "kit4-industrial", "category": "How-To", "title": "WisBlock IoT Education Kit - Smart Industry Quick Start Guide > WisBlock IoT Education Kit - Smart Industry Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock Smart Industry Kit using TTN and Quibitro > Material Classifier LoRaWAN Application > LoRaWAN Code for Material Classifier > Programming the Material Classifier Device with LoRaWAN Application [CODE]", "content": "/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void) {\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data) {\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",", "keywords": ["Arduino IDE", "RAK4631", "Material Classifier", "LoRaWAN", "SX126x-Arduino"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **Material Classifier** device. Just copy the code below for **Material Classifier LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the code</summary>  \n```c\n\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h>  //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n// For RAK12014 module\n#include <vl53l0x_class.h>    // Click to install library: http://librarymanager/All#stm32duino_vl53l0x\nVL53L0X sensor_vl53l0x(&Wire, WB_IO2);\n\nuint32_t distance;\nint status;\n\n// For RAK13001 module\n#define RELAY_PIN WB_IO4\nint object;\n\n// For RAK12029 module\n#include \"RAK12029_LDC1614.h\"\n\n#define INDUCTANCE 13.000\n#define CAPATANCE 100.0\n#define GETCHANNEL LDC1614_CHANNEL_0     // LDC1614_CHANNEL_(0~3); selecting the coil channel from 0 - 3\nRAK12029_LDC1614_Inductive ldc;\n\nu16 value = 0;\nu32 ChannelData = 0;\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define RAK4631_BOARD true\n#else\n#define RAK4631_BOARD false\n#endif\n\nbool doOTAA = true;                                               // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                                       /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                                     /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5                               /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                                        /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;                           /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;                 /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                              /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = { LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF };\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = { BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler };\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xC0, 0x81, 0xBB, 0x65, 0x54, 0xCF, 0xF7, 0x65, 0x87, 0x70, 0xFD, 0x31, 0x7F, 0x01, 0x87, 0x51 };\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };\nuint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                                            /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];               //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = { m_lora_app_data_buffer, 0, 0, 0, 0 };  //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {\n// Sensor Power Switch\npinMode(WB_IO2, OUTPUT);\ndigitalWrite(WB_IO2, HIGH);\n\n// Control Chip Switch\npinMode(WB_IO5, OUTPUT);\ndigitalWrite(WB_IO5, LOW);\n\n// Control Relay Module\npinMode(RELAY_PIN,OUTPUT);\ndigitalWrite(RELAY_PIN, LOW);    // relay module initially LOW\n\npinMode(LED_GREEN, OUTPUT);      // Output LED\npinMode(LED_BLUE, OUTPUT);       // Output LED\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial) {\nif ((millis() - timeout) < 5000) {\ndelay(100);\n} else {\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA) {\nSerial.println(\"Type: OTAA\");\n} else {\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion) {\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA) {\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n} else {\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0) {\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"===========================================\");\nSerial.println(\"RAK12014 + RAK12029 + RAK13001 LoRaWAN Code\");\nSerial.println(\"===========================================\");\n\nWire.begin();\n\n// Configure VL53L0X component.\nsensor_vl53l0x.begin();\n\n// Switch off VL53L0X component.\nsensor_vl53l0x.VL53L0X_Off();\n\n// Initialize VL53L0X component.\nstatus = sensor_vl53l0x.InitSensor(0x52);\nif (status) {\nSerial.println(\"Init sensor_vl53l0x failed...\");\n}\n\n// From RAK12029\nldc.LDC1614_init();\n/*single channel use case configuration.*/\nif (ldc.LDC1614_single_channel_config(GETCHANNEL, INDUCTANCE, CAPATANCE)) {\nSerial.println(\"can't detect sensor!\");\nwhile (1) delay(100);\n}\n}\n\nvoid loop() {\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\n// Read data from RAK12014\nstatus = sensor_vl53l0x.GetDistance(&distance);\n\n// Read data from RAK12029\nldc.IIC_read_16bit(LDC1614_READ_DEVICE_ID, &value);\nif (value == 0x3055) {\n//u32 ChannelData = 0;\n/*Get channel 0 result and parse it.*/\ndelay(100);\nif (ldc.LDC1614_get_channel_result(GETCHANNEL, &ChannelData) == 0) {\n/*sensor result value.you can make a lot of application according to its changes.*/\nif (0 != ChannelData) {\ndigitalWrite(LED_BLUE, HIGH);     // Indicator Blue LED\ndigitalWrite(LED_GREEN, HIGH);    // Indicator Green LED\n}\ndelay(200);\ndigitalWrite(LED_BLUE, LOW);        // Indicator Blue LED\ndigitalWrite(LED_GREEN, LOW);       // Indicator Green LED\n}\n}\n\nif (ChannelData >= 49800000)            // metallic material sensed nearby via inductive sensor\n{\ndigitalWrite(RELAY_PIN, HIGH);        // Turns ON the relay module\nobject = 1;                           // \"1\" corresponds to metallic object\nSerial.println(\"Metal Detected\");\n}\n\nelse if (ChannelData <= 49650000)       // nothing metallic was sensed; default value sensed by the inductive sensor\n{\ndigitalWrite(RELAY_PIN, LOW);         // Turns OFF the relay module\nobject = 0;                           // \"0\" corresponds to non-metallic object\nSerial.println(\"No Metal Detected\");\n}\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\nSerial.print(distance);       // From RAK12014 module\nSerial.println(\"mm   \");\nSerial.println(object);       // From RAK13001 module\nSerial.println(ChannelData);  // From RAK12029 module\n\ndelay(5000);\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void) {\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void) {\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data) {\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class) {\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void) {\nif (lmh_join_status_get() != LMH_SET) {\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\ndata = \" Distance: \" + String(distance) + \" mm \" + \" Metallic: \" + String(object) + \" Inductive_Sense: \" + String(ChannelData);\nSerial.println(data);\n\nuint32_t distance_data = distance;    // data from RAK12014 module\nuint32_t channel_data = ChannelData;  // data from RAK12029 module\nint metallic_data = object;           // data from RAK13001 module\n\nm_lora_app_data.buffer[i++] = 0x01;  // byte[0]\n\n// Data from RAK12014 module\nm_lora_app_data.buffer[i++] = (uint8_t)((distance_data & 0xFF000000) >> 24);    // byte[1]\nm_lora_app_data.buffer[i++] = (uint8_t)((distance_data & 0x00FF0000) >> 16);    // byte[2]\nm_lora_app_data.buffer[i++] = (uint8_t)((distance_data & 0x0000FF00) >> 8);     // byte[3]\nm_lora_app_data.buffer[i++] = (uint8_t)(distance_data & 0x000000FF);            // byte[4]\n\n// Data from RAK12029 module (inductive sensor)\nm_lora_app_data.buffer[i++] = (uint8_t)((channel_data & 0xFF000000) >> 24);    // byte[5]\nm_lora_app_data.buffer[i++] = (uint8_t)((channel_data & 0x00FF0000) >> 16);    // byte[6]\nm_lora_app_data.buffer[i++] = (uint8_t)((channel_data & 0x0000FF00) >> 8);     // byte[7]\nm_lora_app_data.buffer[i++] = (uint8_t)(channel_data & 0x000000FF);            // byte[8]\n\n// Data from RAK13001 module (relay module status)\nm_lora_app_data.buffer[i++] = metallic_data;                                   // byte[9]\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS) {\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n} else {\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xC0, 0x81, 0xBB, 0x65, 0x54, 0xCF, 0xF7, 0x65, 0x87, 0x70, 0xFD, 0x31, 0x7F, 0x01, 0x87, 0x51 };\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "efb2716b676f122270a882314fad43a7", "product_family": "wisblock", "product_id": "kit4-industrial", "category": "How-To", "title": "WisBlock IoT Education Kit - Smart Industry Quick Start Guide > WisBlock IoT Education Kit - Smart Industry Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock Smart Industry Kit using TTN and Quibitro > Material Classifier LoRaWAN Application > LoRaWAN Code for Material Classifier > Programming the Material Classifier Device with LoRaWAN Application [CODE]", "content": "Serial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}", "keywords": ["Arduino IDE", "RAK4631", "Material Classifier", "LoRaWAN", "SX126x-Arduino"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **Material Classifier** device. Just copy the code below for **Material Classifier LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the code</summary>  \n```c\n\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h>  //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n// For RAK12014 module\n#include <vl53l0x_class.h>    // Click to install library: http://librarymanager/All#stm32duino_vl53l0x\nVL53L0X sensor_vl53l0x(&Wire, WB_IO2);\n\nuint32_t distance;\nint status;\n\n// For RAK13001 module\n#define RELAY_PIN WB_IO4\nint object;\n\n// For RAK12029 module\n#include \"RAK12029_LDC1614.h\"\n\n#define INDUCTANCE 13.000\n#define CAPATANCE 100.0\n#define GETCHANNEL LDC1614_CHANNEL_0     // LDC1614_CHANNEL_(0~3); selecting the coil channel from 0 - 3\nRAK12029_LDC1614_Inductive ldc;\n\nu16 value = 0;\nu32 ChannelData = 0;\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define RAK4631_BOARD true\n#else\n#define RAK4631_BOARD false\n#endif\n\nbool doOTAA = true;                                               // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                                       /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                                     /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5                               /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                                        /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;                           /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;                 /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                              /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = { LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF };\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = { BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler };\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xC0, 0x81, 0xBB, 0x65, 0x54, 0xCF, 0xF7, 0x65, 0x87, 0x70, 0xFD, 0x31, 0x7F, 0x01, 0x87, 0x51 };\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };\nuint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                                            /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];               //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = { m_lora_app_data_buffer, 0, 0, 0, 0 };  //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {\n// Sensor Power Switch\npinMode(WB_IO2, OUTPUT);\ndigitalWrite(WB_IO2, HIGH);\n\n// Control Chip Switch\npinMode(WB_IO5, OUTPUT);\ndigitalWrite(WB_IO5, LOW);\n\n// Control Relay Module\npinMode(RELAY_PIN,OUTPUT);\ndigitalWrite(RELAY_PIN, LOW);    // relay module initially LOW\n\npinMode(LED_GREEN, OUTPUT);      // Output LED\npinMode(LED_BLUE, OUTPUT);       // Output LED\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial) {\nif ((millis() - timeout) < 5000) {\ndelay(100);\n} else {\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA) {\nSerial.println(\"Type: OTAA\");\n} else {\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion) {\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA) {\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n} else {\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0) {\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"===========================================\");\nSerial.println(\"RAK12014 + RAK12029 + RAK13001 LoRaWAN Code\");\nSerial.println(\"===========================================\");\n\nWire.begin();\n\n// Configure VL53L0X component.\nsensor_vl53l0x.begin();\n\n// Switch off VL53L0X component.\nsensor_vl53l0x.VL53L0X_Off();\n\n// Initialize VL53L0X component.\nstatus = sensor_vl53l0x.InitSensor(0x52);\nif (status) {\nSerial.println(\"Init sensor_vl53l0x failed...\");\n}\n\n// From RAK12029\nldc.LDC1614_init();\n/*single channel use case configuration.*/\nif (ldc.LDC1614_single_channel_config(GETCHANNEL, INDUCTANCE, CAPATANCE)) {\nSerial.println(\"can't detect sensor!\");\nwhile (1) delay(100);\n}\n}\n\nvoid loop() {\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\n// Read data from RAK12014\nstatus = sensor_vl53l0x.GetDistance(&distance);\n\n// Read data from RAK12029\nldc.IIC_read_16bit(LDC1614_READ_DEVICE_ID, &value);\nif (value == 0x3055) {\n//u32 ChannelData = 0;\n/*Get channel 0 result and parse it.*/\ndelay(100);\nif (ldc.LDC1614_get_channel_result(GETCHANNEL, &ChannelData) == 0) {\n/*sensor result value.you can make a lot of application according to its changes.*/\nif (0 != ChannelData) {\ndigitalWrite(LED_BLUE, HIGH);     // Indicator Blue LED\ndigitalWrite(LED_GREEN, HIGH);    // Indicator Green LED\n}\ndelay(200);\ndigitalWrite(LED_BLUE, LOW);        // Indicator Blue LED\ndigitalWrite(LED_GREEN, LOW);       // Indicator Green LED\n}\n}\n\nif (ChannelData >= 49800000)            // metallic material sensed nearby via inductive sensor\n{\ndigitalWrite(RELAY_PIN, HIGH);        // Turns ON the relay module\nobject = 1;                           // \"1\" corresponds to metallic object\nSerial.println(\"Metal Detected\");\n}\n\nelse if (ChannelData <= 49650000)       // nothing metallic was sensed; default value sensed by the inductive sensor\n{\ndigitalWrite(RELAY_PIN, LOW);         // Turns OFF the relay module\nobject = 0;                           // \"0\" corresponds to non-metallic object\nSerial.println(\"No Metal Detected\");\n}\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\nSerial.print(distance);       // From RAK12014 module\nSerial.println(\"mm   \");\nSerial.println(object);       // From RAK13001 module\nSerial.println(ChannelData);  // From RAK12029 module\n\ndelay(5000);\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void) {\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void) {\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data) {\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class) {\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void) {\nif (lmh_join_status_get() != LMH_SET) {\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\ndata = \" Distance: \" + String(distance) + \" mm \" + \" Metallic: \" + String(object) + \" Inductive_Sense: \" + String(ChannelData);\nSerial.println(data);\n\nuint32_t distance_data = distance;    // data from RAK12014 module\nuint32_t channel_data = ChannelData;  // data from RAK12029 module\nint metallic_data = object;           // data from RAK13001 module\n\nm_lora_app_data.buffer[i++] = 0x01;  // byte[0]\n\n// Data from RAK12014 module\nm_lora_app_data.buffer[i++] = (uint8_t)((distance_data & 0xFF000000) >> 24);    // byte[1]\nm_lora_app_data.buffer[i++] = (uint8_t)((distance_data & 0x00FF0000) >> 16);    // byte[2]\nm_lora_app_data.buffer[i++] = (uint8_t)((distance_data & 0x0000FF00) >> 8);     // byte[3]\nm_lora_app_data.buffer[i++] = (uint8_t)(distance_data & 0x000000FF);            // byte[4]\n\n// Data from RAK12029 module (inductive sensor)\nm_lora_app_data.buffer[i++] = (uint8_t)((channel_data & 0xFF000000) >> 24);    // byte[5]\nm_lora_app_data.buffer[i++] = (uint8_t)((channel_data & 0x00FF0000) >> 16);    // byte[6]\nm_lora_app_data.buffer[i++] = (uint8_t)((channel_data & 0x0000FF00) >> 8);     // byte[7]\nm_lora_app_data.buffer[i++] = (uint8_t)(channel_data & 0x000000FF);            // byte[8]\n\n// Data from RAK13001 module (relay module status)\nm_lora_app_data.buffer[i++] = metallic_data;                                   // byte[9]\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS) {\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n} else {\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xC0, 0x81, 0xBB, 0x65, 0x54, 0xCF, 0xF7, 0x65, 0x87, 0x70, 0xFD, 0x31, 0x7F, 0x01, 0x87, 0x51 };\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "599d8a16173a243700811aaf75d6d9ee", "product_family": "wisblock", "product_id": "kit4-industrial", "category": "How-To", "title": "WisBlock IoT Education Kit - Smart Industry Quick Start Guide > WisBlock IoT Education Kit - Smart Industry Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock Smart Industry Kit using TTN and Quibitro > Material Classifier LoRaWAN Application > LoRaWAN Code for Material Classifier > Programming the Material Classifier Device with LoRaWAN Application [CODE]", "content": "void lorawan_confirm_class_handler(DeviceClass_t Class) {\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void) {\nif (lmh_join_status_get() != LMH_SET) {\n//Not joined, try again later\nreturn;\n}", "keywords": ["Arduino IDE", "RAK4631", "Material Classifier", "LoRaWAN", "SX126x-Arduino"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **Material Classifier** device. Just copy the code below for **Material Classifier LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the code</summary>  \n```c\n\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h>  //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n// For RAK12014 module\n#include <vl53l0x_class.h>    // Click to install library: http://librarymanager/All#stm32duino_vl53l0x\nVL53L0X sensor_vl53l0x(&Wire, WB_IO2);\n\nuint32_t distance;\nint status;\n\n// For RAK13001 module\n#define RELAY_PIN WB_IO4\nint object;\n\n// For RAK12029 module\n#include \"RAK12029_LDC1614.h\"\n\n#define INDUCTANCE 13.000\n#define CAPATANCE 100.0\n#define GETCHANNEL LDC1614_CHANNEL_0     // LDC1614_CHANNEL_(0~3); selecting the coil channel from 0 - 3\nRAK12029_LDC1614_Inductive ldc;\n\nu16 value = 0;\nu32 ChannelData = 0;\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define RAK4631_BOARD true\n#else\n#define RAK4631_BOARD false\n#endif\n\nbool doOTAA = true;                                               // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                                       /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                                     /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5                               /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                                        /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;                           /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;                 /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                              /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = { LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF };\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = { BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler };\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xC0, 0x81, 0xBB, 0x65, 0x54, 0xCF, 0xF7, 0x65, 0x87, 0x70, 0xFD, 0x31, 0x7F, 0x01, 0x87, 0x51 };\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };\nuint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                                            /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];               //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = { m_lora_app_data_buffer, 0, 0, 0, 0 };  //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {\n// Sensor Power Switch\npinMode(WB_IO2, OUTPUT);\ndigitalWrite(WB_IO2, HIGH);\n\n// Control Chip Switch\npinMode(WB_IO5, OUTPUT);\ndigitalWrite(WB_IO5, LOW);\n\n// Control Relay Module\npinMode(RELAY_PIN,OUTPUT);\ndigitalWrite(RELAY_PIN, LOW);    // relay module initially LOW\n\npinMode(LED_GREEN, OUTPUT);      // Output LED\npinMode(LED_BLUE, OUTPUT);       // Output LED\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial) {\nif ((millis() - timeout) < 5000) {\ndelay(100);\n} else {\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA) {\nSerial.println(\"Type: OTAA\");\n} else {\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion) {\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA) {\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n} else {\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0) {\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"===========================================\");\nSerial.println(\"RAK12014 + RAK12029 + RAK13001 LoRaWAN Code\");\nSerial.println(\"===========================================\");\n\nWire.begin();\n\n// Configure VL53L0X component.\nsensor_vl53l0x.begin();\n\n// Switch off VL53L0X component.\nsensor_vl53l0x.VL53L0X_Off();\n\n// Initialize VL53L0X component.\nstatus = sensor_vl53l0x.InitSensor(0x52);\nif (status) {\nSerial.println(\"Init sensor_vl53l0x failed...\");\n}\n\n// From RAK12029\nldc.LDC1614_init();\n/*single channel use case configuration.*/\nif (ldc.LDC1614_single_channel_config(GETCHANNEL, INDUCTANCE, CAPATANCE)) {\nSerial.println(\"can't detect sensor!\");\nwhile (1) delay(100);\n}\n}\n\nvoid loop() {\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\n// Read data from RAK12014\nstatus = sensor_vl53l0x.GetDistance(&distance);\n\n// Read data from RAK12029\nldc.IIC_read_16bit(LDC1614_READ_DEVICE_ID, &value);\nif (value == 0x3055) {\n//u32 ChannelData = 0;\n/*Get channel 0 result and parse it.*/\ndelay(100);\nif (ldc.LDC1614_get_channel_result(GETCHANNEL, &ChannelData) == 0) {\n/*sensor result value.you can make a lot of application according to its changes.*/\nif (0 != ChannelData) {\ndigitalWrite(LED_BLUE, HIGH);     // Indicator Blue LED\ndigitalWrite(LED_GREEN, HIGH);    // Indicator Green LED\n}\ndelay(200);\ndigitalWrite(LED_BLUE, LOW);        // Indicator Blue LED\ndigitalWrite(LED_GREEN, LOW);       // Indicator Green LED\n}\n}\n\nif (ChannelData >= 49800000)            // metallic material sensed nearby via inductive sensor\n{\ndigitalWrite(RELAY_PIN, HIGH);        // Turns ON the relay module\nobject = 1;                           // \"1\" corresponds to metallic object\nSerial.println(\"Metal Detected\");\n}\n\nelse if (ChannelData <= 49650000)       // nothing metallic was sensed; default value sensed by the inductive sensor\n{\ndigitalWrite(RELAY_PIN, LOW);         // Turns OFF the relay module\nobject = 0;                           // \"0\" corresponds to non-metallic object\nSerial.println(\"No Metal Detected\");\n}\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\nSerial.print(distance);       // From RAK12014 module\nSerial.println(\"mm   \");\nSerial.println(object);       // From RAK13001 module\nSerial.println(ChannelData);  // From RAK12029 module\n\ndelay(5000);\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void) {\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void) {\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data) {\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class) {\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void) {\nif (lmh_join_status_get() != LMH_SET) {\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\ndata = \" Distance: \" + String(distance) + \" mm \" + \" Metallic: \" + String(object) + \" Inductive_Sense: \" + String(ChannelData);\nSerial.println(data);\n\nuint32_t distance_data = distance;    // data from RAK12014 module\nuint32_t channel_data = ChannelData;  // data from RAK12029 module\nint metallic_data = object;           // data from RAK13001 module\n\nm_lora_app_data.buffer[i++] = 0x01;  // byte[0]\n\n// Data from RAK12014 module\nm_lora_app_data.buffer[i++] = (uint8_t)((distance_data & 0xFF000000) >> 24);    // byte[1]\nm_lora_app_data.buffer[i++] = (uint8_t)((distance_data & 0x00FF0000) >> 16);    // byte[2]\nm_lora_app_data.buffer[i++] = (uint8_t)((distance_data & 0x0000FF00) >> 8);     // byte[3]\nm_lora_app_data.buffer[i++] = (uint8_t)(distance_data & 0x000000FF);            // byte[4]\n\n// Data from RAK12029 module (inductive sensor)\nm_lora_app_data.buffer[i++] = (uint8_t)((channel_data & 0xFF000000) >> 24);    // byte[5]\nm_lora_app_data.buffer[i++] = (uint8_t)((channel_data & 0x00FF0000) >> 16);    // byte[6]\nm_lora_app_data.buffer[i++] = (uint8_t)((channel_data & 0x0000FF00) >> 8);     // byte[7]\nm_lora_app_data.buffer[i++] = (uint8_t)(channel_data & 0x000000FF);            // byte[8]\n\n// Data from RAK13001 module (relay module status)\nm_lora_app_data.buffer[i++] = metallic_data;                                   // byte[9]\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS) {\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n} else {\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xC0, 0x81, 0xBB, 0x65, 0x54, 0xCF, 0xF7, 0x65, 0x87, 0x70, 0xFD, 0x31, 0x7F, 0x01, 0x87, 0x51 };\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "69f83a8c914f85609b6136bdb3796b69", "product_family": "wisblock", "product_id": "kit4-industrial", "category": "How-To", "title": "WisBlock IoT Education Kit - Smart Industry Quick Start Guide > WisBlock IoT Education Kit - Smart Industry Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock Smart Industry Kit using TTN and Quibitro > Material Classifier LoRaWAN Application > LoRaWAN Code for Material Classifier > Programming the Material Classifier Device with LoRaWAN Application [CODE]", "content": "Serial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\ndata = \" Distance: \" + String(distance) + \" mm \" + \" Metallic: \" + String(object) + \" Inductive_Sense: \" + String(ChannelData);\nSerial.println(data);\n\nuint32_t distance_data = distance;    // data from RAK12014 module\nuint32_t channel_data = ChannelData;  // data from RAK12029 module\nint metallic_data = object;           // data from RAK13001 module", "keywords": ["Arduino IDE", "RAK4631", "Material Classifier", "LoRaWAN", "SX126x-Arduino"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **Material Classifier** device. Just copy the code below for **Material Classifier LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the code</summary>  \n```c\n\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h>  //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n// For RAK12014 module\n#include <vl53l0x_class.h>    // Click to install library: http://librarymanager/All#stm32duino_vl53l0x\nVL53L0X sensor_vl53l0x(&Wire, WB_IO2);\n\nuint32_t distance;\nint status;\n\n// For RAK13001 module\n#define RELAY_PIN WB_IO4\nint object;\n\n// For RAK12029 module\n#include \"RAK12029_LDC1614.h\"\n\n#define INDUCTANCE 13.000\n#define CAPATANCE 100.0\n#define GETCHANNEL LDC1614_CHANNEL_0     // LDC1614_CHANNEL_(0~3); selecting the coil channel from 0 - 3\nRAK12029_LDC1614_Inductive ldc;\n\nu16 value = 0;\nu32 ChannelData = 0;\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define RAK4631_BOARD true\n#else\n#define RAK4631_BOARD false\n#endif\n\nbool doOTAA = true;                                               // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                                       /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                                     /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5                               /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                                        /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;                           /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;                 /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                              /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = { LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF };\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = { BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler };\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xC0, 0x81, 0xBB, 0x65, 0x54, 0xCF, 0xF7, 0x65, 0x87, 0x70, 0xFD, 0x31, 0x7F, 0x01, 0x87, 0x51 };\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };\nuint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                                            /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];               //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = { m_lora_app_data_buffer, 0, 0, 0, 0 };  //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {\n// Sensor Power Switch\npinMode(WB_IO2, OUTPUT);\ndigitalWrite(WB_IO2, HIGH);\n\n// Control Chip Switch\npinMode(WB_IO5, OUTPUT);\ndigitalWrite(WB_IO5, LOW);\n\n// Control Relay Module\npinMode(RELAY_PIN,OUTPUT);\ndigitalWrite(RELAY_PIN, LOW);    // relay module initially LOW\n\npinMode(LED_GREEN, OUTPUT);      // Output LED\npinMode(LED_BLUE, OUTPUT);       // Output LED\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial) {\nif ((millis() - timeout) < 5000) {\ndelay(100);\n} else {\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA) {\nSerial.println(\"Type: OTAA\");\n} else {\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion) {\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA) {\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n} else {\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0) {\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"===========================================\");\nSerial.println(\"RAK12014 + RAK12029 + RAK13001 LoRaWAN Code\");\nSerial.println(\"===========================================\");\n\nWire.begin();\n\n// Configure VL53L0X component.\nsensor_vl53l0x.begin();\n\n// Switch off VL53L0X component.\nsensor_vl53l0x.VL53L0X_Off();\n\n// Initialize VL53L0X component.\nstatus = sensor_vl53l0x.InitSensor(0x52);\nif (status) {\nSerial.println(\"Init sensor_vl53l0x failed...\");\n}\n\n// From RAK12029\nldc.LDC1614_init();\n/*single channel use case configuration.*/\nif (ldc.LDC1614_single_channel_config(GETCHANNEL, INDUCTANCE, CAPATANCE)) {\nSerial.println(\"can't detect sensor!\");\nwhile (1) delay(100);\n}\n}\n\nvoid loop() {\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\n// Read data from RAK12014\nstatus = sensor_vl53l0x.GetDistance(&distance);\n\n// Read data from RAK12029\nldc.IIC_read_16bit(LDC1614_READ_DEVICE_ID, &value);\nif (value == 0x3055) {\n//u32 ChannelData = 0;\n/*Get channel 0 result and parse it.*/\ndelay(100);\nif (ldc.LDC1614_get_channel_result(GETCHANNEL, &ChannelData) == 0) {\n/*sensor result value.you can make a lot of application according to its changes.*/\nif (0 != ChannelData) {\ndigitalWrite(LED_BLUE, HIGH);     // Indicator Blue LED\ndigitalWrite(LED_GREEN, HIGH);    // Indicator Green LED\n}\ndelay(200);\ndigitalWrite(LED_BLUE, LOW);        // Indicator Blue LED\ndigitalWrite(LED_GREEN, LOW);       // Indicator Green LED\n}\n}\n\nif (ChannelData >= 49800000)            // metallic material sensed nearby via inductive sensor\n{\ndigitalWrite(RELAY_PIN, HIGH);        // Turns ON the relay module\nobject = 1;                           // \"1\" corresponds to metallic object\nSerial.println(\"Metal Detected\");\n}\n\nelse if (ChannelData <= 49650000)       // nothing metallic was sensed; default value sensed by the inductive sensor\n{\ndigitalWrite(RELAY_PIN, LOW);         // Turns OFF the relay module\nobject = 0;                           // \"0\" corresponds to non-metallic object\nSerial.println(\"No Metal Detected\");\n}\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\nSerial.print(distance);       // From RAK12014 module\nSerial.println(\"mm   \");\nSerial.println(object);       // From RAK13001 module\nSerial.println(ChannelData);  // From RAK12029 module\n\ndelay(5000);\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void) {\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void) {\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data) {\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class) {\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void) {\nif (lmh_join_status_get() != LMH_SET) {\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\ndata = \" Distance: \" + String(distance) + \" mm \" + \" Metallic: \" + String(object) + \" Inductive_Sense: \" + String(ChannelData);\nSerial.println(data);\n\nuint32_t distance_data = distance;    // data from RAK12014 module\nuint32_t channel_data = ChannelData;  // data from RAK12029 module\nint metallic_data = object;           // data from RAK13001 module\n\nm_lora_app_data.buffer[i++] = 0x01;  // byte[0]\n\n// Data from RAK12014 module\nm_lora_app_data.buffer[i++] = (uint8_t)((distance_data & 0xFF000000) >> 24);    // byte[1]\nm_lora_app_data.buffer[i++] = (uint8_t)((distance_data & 0x00FF0000) >> 16);    // byte[2]\nm_lora_app_data.buffer[i++] = (uint8_t)((distance_data & 0x0000FF00) >> 8);     // byte[3]\nm_lora_app_data.buffer[i++] = (uint8_t)(distance_data & 0x000000FF);            // byte[4]\n\n// Data from RAK12029 module (inductive sensor)\nm_lora_app_data.buffer[i++] = (uint8_t)((channel_data & 0xFF000000) >> 24);    // byte[5]\nm_lora_app_data.buffer[i++] = (uint8_t)((channel_data & 0x00FF0000) >> 16);    // byte[6]\nm_lora_app_data.buffer[i++] = (uint8_t)((channel_data & 0x0000FF00) >> 8);     // byte[7]\nm_lora_app_data.buffer[i++] = (uint8_t)(channel_data & 0x000000FF);            // byte[8]\n\n// Data from RAK13001 module (relay module status)\nm_lora_app_data.buffer[i++] = metallic_data;                                   // byte[9]\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS) {\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n} else {\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xC0, 0x81, 0xBB, 0x65, 0x54, 0xCF, 0xF7, 0x65, 0x87, 0x70, 0xFD, 0x31, 0x7F, 0x01, 0x87, 0x51 };\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "8ae297284f85eae1a21ade59d8f68114", "product_family": "wisblock", "product_id": "kit4-industrial", "category": "How-To", "title": "WisBlock IoT Education Kit - Smart Industry Quick Start Guide > WisBlock IoT Education Kit - Smart Industry Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock Smart Industry Kit using TTN and Quibitro > Material Classifier LoRaWAN Application > LoRaWAN Code for Material Classifier > Programming the Material Classifier Device with LoRaWAN Application [CODE]", "content": "m_lora_app_data.buffer[i++] = 0x01;  // byte[0]\n\n// Data from RAK12014 module\nm_lora_app_data.buffer[i++] = (uint8_t)((distance_data & 0xFF000000) >> 24);    // byte[1]\nm_lora_app_data.buffer[i++] = (uint8_t)((distance_data & 0x00FF0000) >> 16);    // byte[2]\nm_lora_app_data.buffer[i++] = (uint8_t)((distance_data & 0x0000FF00) >> 8);     // byte[3]\nm_lora_app_data.buffer[i++] = (uint8_t)(distance_data & 0x000000FF);            // byte[4]", "keywords": ["Arduino IDE", "RAK4631", "Material Classifier", "LoRaWAN", "SX126x-Arduino"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **Material Classifier** device. Just copy the code below for **Material Classifier LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the code</summary>  \n```c\n\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h>  //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n// For RAK12014 module\n#include <vl53l0x_class.h>    // Click to install library: http://librarymanager/All#stm32duino_vl53l0x\nVL53L0X sensor_vl53l0x(&Wire, WB_IO2);\n\nuint32_t distance;\nint status;\n\n// For RAK13001 module\n#define RELAY_PIN WB_IO4\nint object;\n\n// For RAK12029 module\n#include \"RAK12029_LDC1614.h\"\n\n#define INDUCTANCE 13.000\n#define CAPATANCE 100.0\n#define GETCHANNEL LDC1614_CHANNEL_0     // LDC1614_CHANNEL_(0~3); selecting the coil channel from 0 - 3\nRAK12029_LDC1614_Inductive ldc;\n\nu16 value = 0;\nu32 ChannelData = 0;\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define RAK4631_BOARD true\n#else\n#define RAK4631_BOARD false\n#endif\n\nbool doOTAA = true;                                               // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                                       /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                                     /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5                               /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                                        /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;                           /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;                 /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                              /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = { LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF };\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = { BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler };\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xC0, 0x81, 0xBB, 0x65, 0x54, 0xCF, 0xF7, 0x65, 0x87, 0x70, 0xFD, 0x31, 0x7F, 0x01, 0x87, 0x51 };\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };\nuint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                                            /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];               //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = { m_lora_app_data_buffer, 0, 0, 0, 0 };  //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {\n// Sensor Power Switch\npinMode(WB_IO2, OUTPUT);\ndigitalWrite(WB_IO2, HIGH);\n\n// Control Chip Switch\npinMode(WB_IO5, OUTPUT);\ndigitalWrite(WB_IO5, LOW);\n\n// Control Relay Module\npinMode(RELAY_PIN,OUTPUT);\ndigitalWrite(RELAY_PIN, LOW);    // relay module initially LOW\n\npinMode(LED_GREEN, OUTPUT);      // Output LED\npinMode(LED_BLUE, OUTPUT);       // Output LED\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial) {\nif ((millis() - timeout) < 5000) {\ndelay(100);\n} else {\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA) {\nSerial.println(\"Type: OTAA\");\n} else {\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion) {\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA) {\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n} else {\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0) {\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"===========================================\");\nSerial.println(\"RAK12014 + RAK12029 + RAK13001 LoRaWAN Code\");\nSerial.println(\"===========================================\");\n\nWire.begin();\n\n// Configure VL53L0X component.\nsensor_vl53l0x.begin();\n\n// Switch off VL53L0X component.\nsensor_vl53l0x.VL53L0X_Off();\n\n// Initialize VL53L0X component.\nstatus = sensor_vl53l0x.InitSensor(0x52);\nif (status) {\nSerial.println(\"Init sensor_vl53l0x failed...\");\n}\n\n// From RAK12029\nldc.LDC1614_init();\n/*single channel use case configuration.*/\nif (ldc.LDC1614_single_channel_config(GETCHANNEL, INDUCTANCE, CAPATANCE)) {\nSerial.println(\"can't detect sensor!\");\nwhile (1) delay(100);\n}\n}\n\nvoid loop() {\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\n// Read data from RAK12014\nstatus = sensor_vl53l0x.GetDistance(&distance);\n\n// Read data from RAK12029\nldc.IIC_read_16bit(LDC1614_READ_DEVICE_ID, &value);\nif (value == 0x3055) {\n//u32 ChannelData = 0;\n/*Get channel 0 result and parse it.*/\ndelay(100);\nif (ldc.LDC1614_get_channel_result(GETCHANNEL, &ChannelData) == 0) {\n/*sensor result value.you can make a lot of application according to its changes.*/\nif (0 != ChannelData) {\ndigitalWrite(LED_BLUE, HIGH);     // Indicator Blue LED\ndigitalWrite(LED_GREEN, HIGH);    // Indicator Green LED\n}\ndelay(200);\ndigitalWrite(LED_BLUE, LOW);        // Indicator Blue LED\ndigitalWrite(LED_GREEN, LOW);       // Indicator Green LED\n}\n}\n\nif (ChannelData >= 49800000)            // metallic material sensed nearby via inductive sensor\n{\ndigitalWrite(RELAY_PIN, HIGH);        // Turns ON the relay module\nobject = 1;                           // \"1\" corresponds to metallic object\nSerial.println(\"Metal Detected\");\n}\n\nelse if (ChannelData <= 49650000)       // nothing metallic was sensed; default value sensed by the inductive sensor\n{\ndigitalWrite(RELAY_PIN, LOW);         // Turns OFF the relay module\nobject = 0;                           // \"0\" corresponds to non-metallic object\nSerial.println(\"No Metal Detected\");\n}\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\nSerial.print(distance);       // From RAK12014 module\nSerial.println(\"mm   \");\nSerial.println(object);       // From RAK13001 module\nSerial.println(ChannelData);  // From RAK12029 module\n\ndelay(5000);\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void) {\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void) {\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data) {\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class) {\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void) {\nif (lmh_join_status_get() != LMH_SET) {\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\ndata = \" Distance: \" + String(distance) + \" mm \" + \" Metallic: \" + String(object) + \" Inductive_Sense: \" + String(ChannelData);\nSerial.println(data);\n\nuint32_t distance_data = distance;    // data from RAK12014 module\nuint32_t channel_data = ChannelData;  // data from RAK12029 module\nint metallic_data = object;           // data from RAK13001 module\n\nm_lora_app_data.buffer[i++] = 0x01;  // byte[0]\n\n// Data from RAK12014 module\nm_lora_app_data.buffer[i++] = (uint8_t)((distance_data & 0xFF000000) >> 24);    // byte[1]\nm_lora_app_data.buffer[i++] = (uint8_t)((distance_data & 0x00FF0000) >> 16);    // byte[2]\nm_lora_app_data.buffer[i++] = (uint8_t)((distance_data & 0x0000FF00) >> 8);     // byte[3]\nm_lora_app_data.buffer[i++] = (uint8_t)(distance_data & 0x000000FF);            // byte[4]\n\n// Data from RAK12029 module (inductive sensor)\nm_lora_app_data.buffer[i++] = (uint8_t)((channel_data & 0xFF000000) >> 24);    // byte[5]\nm_lora_app_data.buffer[i++] = (uint8_t)((channel_data & 0x00FF0000) >> 16);    // byte[6]\nm_lora_app_data.buffer[i++] = (uint8_t)((channel_data & 0x0000FF00) >> 8);     // byte[7]\nm_lora_app_data.buffer[i++] = (uint8_t)(channel_data & 0x000000FF);            // byte[8]\n\n// Data from RAK13001 module (relay module status)\nm_lora_app_data.buffer[i++] = metallic_data;                                   // byte[9]\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS) {\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n} else {\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xC0, 0x81, 0xBB, 0x65, 0x54, 0xCF, 0xF7, 0x65, 0x87, 0x70, 0xFD, 0x31, 0x7F, 0x01, 0x87, 0x51 };\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "6d6a1b40ca9bbed1aad071c93aac72ec", "product_family": "wisblock", "product_id": "kit4-industrial", "category": "How-To", "title": "WisBlock IoT Education Kit - Smart Industry Quick Start Guide > WisBlock IoT Education Kit - Smart Industry Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock Smart Industry Kit using TTN and Quibitro > Material Classifier LoRaWAN Application > LoRaWAN Code for Material Classifier > Programming the Material Classifier Device with LoRaWAN Application [CODE]", "content": "// Data from RAK12029 module (inductive sensor)\nm_lora_app_data.buffer[i++] = (uint8_t)((channel_data & 0xFF000000) >> 24);    // byte[5]\nm_lora_app_data.buffer[i++] = (uint8_t)((channel_data & 0x00FF0000) >> 16);    // byte[6]\nm_lora_app_data.buffer[i++] = (uint8_t)((channel_data & 0x0000FF00) >> 8);     // byte[7]\nm_lora_app_data.buffer[i++] = (uint8_t)(channel_data & 0x000000FF);            // byte[8]", "keywords": ["Arduino IDE", "RAK4631", "Material Classifier", "LoRaWAN", "SX126x-Arduino"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **Material Classifier** device. Just copy the code below for **Material Classifier LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the code</summary>  \n```c\n\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h>  //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n// For RAK12014 module\n#include <vl53l0x_class.h>    // Click to install library: http://librarymanager/All#stm32duino_vl53l0x\nVL53L0X sensor_vl53l0x(&Wire, WB_IO2);\n\nuint32_t distance;\nint status;\n\n// For RAK13001 module\n#define RELAY_PIN WB_IO4\nint object;\n\n// For RAK12029 module\n#include \"RAK12029_LDC1614.h\"\n\n#define INDUCTANCE 13.000\n#define CAPATANCE 100.0\n#define GETCHANNEL LDC1614_CHANNEL_0     // LDC1614_CHANNEL_(0~3); selecting the coil channel from 0 - 3\nRAK12029_LDC1614_Inductive ldc;\n\nu16 value = 0;\nu32 ChannelData = 0;\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define RAK4631_BOARD true\n#else\n#define RAK4631_BOARD false\n#endif\n\nbool doOTAA = true;                                               // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                                       /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                                     /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5                               /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                                        /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;                           /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;                 /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                              /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = { LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF };\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = { BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler };\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xC0, 0x81, 0xBB, 0x65, 0x54, 0xCF, 0xF7, 0x65, 0x87, 0x70, 0xFD, 0x31, 0x7F, 0x01, 0x87, 0x51 };\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };\nuint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                                            /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];               //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = { m_lora_app_data_buffer, 0, 0, 0, 0 };  //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {\n// Sensor Power Switch\npinMode(WB_IO2, OUTPUT);\ndigitalWrite(WB_IO2, HIGH);\n\n// Control Chip Switch\npinMode(WB_IO5, OUTPUT);\ndigitalWrite(WB_IO5, LOW);\n\n// Control Relay Module\npinMode(RELAY_PIN,OUTPUT);\ndigitalWrite(RELAY_PIN, LOW);    // relay module initially LOW\n\npinMode(LED_GREEN, OUTPUT);      // Output LED\npinMode(LED_BLUE, OUTPUT);       // Output LED\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial) {\nif ((millis() - timeout) < 5000) {\ndelay(100);\n} else {\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA) {\nSerial.println(\"Type: OTAA\");\n} else {\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion) {\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA) {\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n} else {\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0) {\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"===========================================\");\nSerial.println(\"RAK12014 + RAK12029 + RAK13001 LoRaWAN Code\");\nSerial.println(\"===========================================\");\n\nWire.begin();\n\n// Configure VL53L0X component.\nsensor_vl53l0x.begin();\n\n// Switch off VL53L0X component.\nsensor_vl53l0x.VL53L0X_Off();\n\n// Initialize VL53L0X component.\nstatus = sensor_vl53l0x.InitSensor(0x52);\nif (status) {\nSerial.println(\"Init sensor_vl53l0x failed...\");\n}\n\n// From RAK12029\nldc.LDC1614_init();\n/*single channel use case configuration.*/\nif (ldc.LDC1614_single_channel_config(GETCHANNEL, INDUCTANCE, CAPATANCE)) {\nSerial.println(\"can't detect sensor!\");\nwhile (1) delay(100);\n}\n}\n\nvoid loop() {\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\n// Read data from RAK12014\nstatus = sensor_vl53l0x.GetDistance(&distance);\n\n// Read data from RAK12029\nldc.IIC_read_16bit(LDC1614_READ_DEVICE_ID, &value);\nif (value == 0x3055) {\n//u32 ChannelData = 0;\n/*Get channel 0 result and parse it.*/\ndelay(100);\nif (ldc.LDC1614_get_channel_result(GETCHANNEL, &ChannelData) == 0) {\n/*sensor result value.you can make a lot of application according to its changes.*/\nif (0 != ChannelData) {\ndigitalWrite(LED_BLUE, HIGH);     // Indicator Blue LED\ndigitalWrite(LED_GREEN, HIGH);    // Indicator Green LED\n}\ndelay(200);\ndigitalWrite(LED_BLUE, LOW);        // Indicator Blue LED\ndigitalWrite(LED_GREEN, LOW);       // Indicator Green LED\n}\n}\n\nif (ChannelData >= 49800000)            // metallic material sensed nearby via inductive sensor\n{\ndigitalWrite(RELAY_PIN, HIGH);        // Turns ON the relay module\nobject = 1;                           // \"1\" corresponds to metallic object\nSerial.println(\"Metal Detected\");\n}\n\nelse if (ChannelData <= 49650000)       // nothing metallic was sensed; default value sensed by the inductive sensor\n{\ndigitalWrite(RELAY_PIN, LOW);         // Turns OFF the relay module\nobject = 0;                           // \"0\" corresponds to non-metallic object\nSerial.println(\"No Metal Detected\");\n}\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\nSerial.print(distance);       // From RAK12014 module\nSerial.println(\"mm   \");\nSerial.println(object);       // From RAK13001 module\nSerial.println(ChannelData);  // From RAK12029 module\n\ndelay(5000);\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void) {\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void) {\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data) {\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class) {\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void) {\nif (lmh_join_status_get() != LMH_SET) {\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\ndata = \" Distance: \" + String(distance) + \" mm \" + \" Metallic: \" + String(object) + \" Inductive_Sense: \" + String(ChannelData);\nSerial.println(data);\n\nuint32_t distance_data = distance;    // data from RAK12014 module\nuint32_t channel_data = ChannelData;  // data from RAK12029 module\nint metallic_data = object;           // data from RAK13001 module\n\nm_lora_app_data.buffer[i++] = 0x01;  // byte[0]\n\n// Data from RAK12014 module\nm_lora_app_data.buffer[i++] = (uint8_t)((distance_data & 0xFF000000) >> 24);    // byte[1]\nm_lora_app_data.buffer[i++] = (uint8_t)((distance_data & 0x00FF0000) >> 16);    // byte[2]\nm_lora_app_data.buffer[i++] = (uint8_t)((distance_data & 0x0000FF00) >> 8);     // byte[3]\nm_lora_app_data.buffer[i++] = (uint8_t)(distance_data & 0x000000FF);            // byte[4]\n\n// Data from RAK12029 module (inductive sensor)\nm_lora_app_data.buffer[i++] = (uint8_t)((channel_data & 0xFF000000) >> 24);    // byte[5]\nm_lora_app_data.buffer[i++] = (uint8_t)((channel_data & 0x00FF0000) >> 16);    // byte[6]\nm_lora_app_data.buffer[i++] = (uint8_t)((channel_data & 0x0000FF00) >> 8);     // byte[7]\nm_lora_app_data.buffer[i++] = (uint8_t)(channel_data & 0x000000FF);            // byte[8]\n\n// Data from RAK13001 module (relay module status)\nm_lora_app_data.buffer[i++] = metallic_data;                                   // byte[9]\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS) {\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n} else {\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xC0, 0x81, 0xBB, 0x65, 0x54, 0xCF, 0xF7, 0x65, 0x87, 0x70, 0xFD, 0x31, 0x7F, 0x01, 0x87, 0x51 };\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "3cb154b56b848f5fc280aa1e8d6759ef", "product_family": "wisblock", "product_id": "kit4-industrial", "category": "How-To", "title": "WisBlock IoT Education Kit - Smart Industry Quick Start Guide > WisBlock IoT Education Kit - Smart Industry Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock Smart Industry Kit using TTN and Quibitro > Material Classifier LoRaWAN Application > LoRaWAN Code for Material Classifier > Programming the Material Classifier Device with LoRaWAN Application [CODE]", "content": "// Data from RAK13001 module (relay module status)\nm_lora_app_data.buffer[i++] = metallic_data;                                   // byte[9]\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS) {\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n} else {\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}", "keywords": ["Arduino IDE", "RAK4631", "Material Classifier", "LoRaWAN", "SX126x-Arduino"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **Material Classifier** device. Just copy the code below for **Material Classifier LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the code</summary>  \n```c\n\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h>  //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n// For RAK12014 module\n#include <vl53l0x_class.h>    // Click to install library: http://librarymanager/All#stm32duino_vl53l0x\nVL53L0X sensor_vl53l0x(&Wire, WB_IO2);\n\nuint32_t distance;\nint status;\n\n// For RAK13001 module\n#define RELAY_PIN WB_IO4\nint object;\n\n// For RAK12029 module\n#include \"RAK12029_LDC1614.h\"\n\n#define INDUCTANCE 13.000\n#define CAPATANCE 100.0\n#define GETCHANNEL LDC1614_CHANNEL_0     // LDC1614_CHANNEL_(0~3); selecting the coil channel from 0 - 3\nRAK12029_LDC1614_Inductive ldc;\n\nu16 value = 0;\nu32 ChannelData = 0;\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define RAK4631_BOARD true\n#else\n#define RAK4631_BOARD false\n#endif\n\nbool doOTAA = true;                                               // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                                       /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                                     /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5                               /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                                        /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;                           /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;                 /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                              /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = { LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF };\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = { BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler };\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xC0, 0x81, 0xBB, 0x65, 0x54, 0xCF, 0xF7, 0x65, 0x87, 0x70, 0xFD, 0x31, 0x7F, 0x01, 0x87, 0x51 };\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };\nuint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                                            /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];               //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = { m_lora_app_data_buffer, 0, 0, 0, 0 };  //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {\n// Sensor Power Switch\npinMode(WB_IO2, OUTPUT);\ndigitalWrite(WB_IO2, HIGH);\n\n// Control Chip Switch\npinMode(WB_IO5, OUTPUT);\ndigitalWrite(WB_IO5, LOW);\n\n// Control Relay Module\npinMode(RELAY_PIN,OUTPUT);\ndigitalWrite(RELAY_PIN, LOW);    // relay module initially LOW\n\npinMode(LED_GREEN, OUTPUT);      // Output LED\npinMode(LED_BLUE, OUTPUT);       // Output LED\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial) {\nif ((millis() - timeout) < 5000) {\ndelay(100);\n} else {\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA) {\nSerial.println(\"Type: OTAA\");\n} else {\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion) {\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA) {\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n} else {\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0) {\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"===========================================\");\nSerial.println(\"RAK12014 + RAK12029 + RAK13001 LoRaWAN Code\");\nSerial.println(\"===========================================\");\n\nWire.begin();\n\n// Configure VL53L0X component.\nsensor_vl53l0x.begin();\n\n// Switch off VL53L0X component.\nsensor_vl53l0x.VL53L0X_Off();\n\n// Initialize VL53L0X component.\nstatus = sensor_vl53l0x.InitSensor(0x52);\nif (status) {\nSerial.println(\"Init sensor_vl53l0x failed...\");\n}\n\n// From RAK12029\nldc.LDC1614_init();\n/*single channel use case configuration.*/\nif (ldc.LDC1614_single_channel_config(GETCHANNEL, INDUCTANCE, CAPATANCE)) {\nSerial.println(\"can't detect sensor!\");\nwhile (1) delay(100);\n}\n}\n\nvoid loop() {\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\n// Read data from RAK12014\nstatus = sensor_vl53l0x.GetDistance(&distance);\n\n// Read data from RAK12029\nldc.IIC_read_16bit(LDC1614_READ_DEVICE_ID, &value);\nif (value == 0x3055) {\n//u32 ChannelData = 0;\n/*Get channel 0 result and parse it.*/\ndelay(100);\nif (ldc.LDC1614_get_channel_result(GETCHANNEL, &ChannelData) == 0) {\n/*sensor result value.you can make a lot of application according to its changes.*/\nif (0 != ChannelData) {\ndigitalWrite(LED_BLUE, HIGH);     // Indicator Blue LED\ndigitalWrite(LED_GREEN, HIGH);    // Indicator Green LED\n}\ndelay(200);\ndigitalWrite(LED_BLUE, LOW);        // Indicator Blue LED\ndigitalWrite(LED_GREEN, LOW);       // Indicator Green LED\n}\n}\n\nif (ChannelData >= 49800000)            // metallic material sensed nearby via inductive sensor\n{\ndigitalWrite(RELAY_PIN, HIGH);        // Turns ON the relay module\nobject = 1;                           // \"1\" corresponds to metallic object\nSerial.println(\"Metal Detected\");\n}\n\nelse if (ChannelData <= 49650000)       // nothing metallic was sensed; default value sensed by the inductive sensor\n{\ndigitalWrite(RELAY_PIN, LOW);         // Turns OFF the relay module\nobject = 0;                           // \"0\" corresponds to non-metallic object\nSerial.println(\"No Metal Detected\");\n}\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\nSerial.print(distance);       // From RAK12014 module\nSerial.println(\"mm   \");\nSerial.println(object);       // From RAK13001 module\nSerial.println(ChannelData);  // From RAK12029 module\n\ndelay(5000);\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void) {\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void) {\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data) {\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class) {\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void) {\nif (lmh_join_status_get() != LMH_SET) {\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\ndata = \" Distance: \" + String(distance) + \" mm \" + \" Metallic: \" + String(object) + \" Inductive_Sense: \" + String(ChannelData);\nSerial.println(data);\n\nuint32_t distance_data = distance;    // data from RAK12014 module\nuint32_t channel_data = ChannelData;  // data from RAK12029 module\nint metallic_data = object;           // data from RAK13001 module\n\nm_lora_app_data.buffer[i++] = 0x01;  // byte[0]\n\n// Data from RAK12014 module\nm_lora_app_data.buffer[i++] = (uint8_t)((distance_data & 0xFF000000) >> 24);    // byte[1]\nm_lora_app_data.buffer[i++] = (uint8_t)((distance_data & 0x00FF0000) >> 16);    // byte[2]\nm_lora_app_data.buffer[i++] = (uint8_t)((distance_data & 0x0000FF00) >> 8);     // byte[3]\nm_lora_app_data.buffer[i++] = (uint8_t)(distance_data & 0x000000FF);            // byte[4]\n\n// Data from RAK12029 module (inductive sensor)\nm_lora_app_data.buffer[i++] = (uint8_t)((channel_data & 0xFF000000) >> 24);    // byte[5]\nm_lora_app_data.buffer[i++] = (uint8_t)((channel_data & 0x00FF0000) >> 16);    // byte[6]\nm_lora_app_data.buffer[i++] = (uint8_t)((channel_data & 0x0000FF00) >> 8);     // byte[7]\nm_lora_app_data.buffer[i++] = (uint8_t)(channel_data & 0x000000FF);            // byte[8]\n\n// Data from RAK13001 module (relay module status)\nm_lora_app_data.buffer[i++] = metallic_data;                                   // byte[9]\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS) {\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n} else {\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xC0, 0x81, 0xBB, 0x65, 0x54, 0xCF, 0xF7, 0x65, 0x87, 0x70, 0xFD, 0x31, 0x7F, 0x01, 0x87, 0x51 };\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "27e23f066b07e39493956c049f2e7ad1", "product_family": "wisblock", "product_id": "kit4-industrial", "category": "How-To", "title": "WisBlock IoT Education Kit - Smart Industry Quick Start Guide > WisBlock IoT Education Kit - Smart Industry Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock Smart Industry Kit using TTN and Quibitro > Material Classifier LoRaWAN Application > LoRaWAN Code for Material Classifier > Programming the Material Classifier Device with LoRaWAN Application [CODE]", "content": "```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.", "keywords": ["Arduino IDE", "RAK4631", "Material Classifier", "LoRaWAN", "SX126x-Arduino"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **Material Classifier** device. Just copy the code below for **Material Classifier LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the code</summary>  \n```c\n\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h>  //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n// For RAK12014 module\n#include <vl53l0x_class.h>    // Click to install library: http://librarymanager/All#stm32duino_vl53l0x\nVL53L0X sensor_vl53l0x(&Wire, WB_IO2);\n\nuint32_t distance;\nint status;\n\n// For RAK13001 module\n#define RELAY_PIN WB_IO4\nint object;\n\n// For RAK12029 module\n#include \"RAK12029_LDC1614.h\"\n\n#define INDUCTANCE 13.000\n#define CAPATANCE 100.0\n#define GETCHANNEL LDC1614_CHANNEL_0     // LDC1614_CHANNEL_(0~3); selecting the coil channel from 0 - 3\nRAK12029_LDC1614_Inductive ldc;\n\nu16 value = 0;\nu32 ChannelData = 0;\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define RAK4631_BOARD true\n#else\n#define RAK4631_BOARD false\n#endif\n\nbool doOTAA = true;                                               // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                                       /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                                     /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5                               /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                                        /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;                           /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;                 /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                              /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = { LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF };\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = { BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler };\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xC0, 0x81, 0xBB, 0x65, 0x54, 0xCF, 0xF7, 0x65, 0x87, 0x70, 0xFD, 0x31, 0x7F, 0x01, 0x87, 0x51 };\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };\nuint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                                            /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];               //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = { m_lora_app_data_buffer, 0, 0, 0, 0 };  //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {\n// Sensor Power Switch\npinMode(WB_IO2, OUTPUT);\ndigitalWrite(WB_IO2, HIGH);\n\n// Control Chip Switch\npinMode(WB_IO5, OUTPUT);\ndigitalWrite(WB_IO5, LOW);\n\n// Control Relay Module\npinMode(RELAY_PIN,OUTPUT);\ndigitalWrite(RELAY_PIN, LOW);    // relay module initially LOW\n\npinMode(LED_GREEN, OUTPUT);      // Output LED\npinMode(LED_BLUE, OUTPUT);       // Output LED\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial) {\nif ((millis() - timeout) < 5000) {\ndelay(100);\n} else {\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA) {\nSerial.println(\"Type: OTAA\");\n} else {\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion) {\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA) {\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n} else {\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0) {\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"===========================================\");\nSerial.println(\"RAK12014 + RAK12029 + RAK13001 LoRaWAN Code\");\nSerial.println(\"===========================================\");\n\nWire.begin();\n\n// Configure VL53L0X component.\nsensor_vl53l0x.begin();\n\n// Switch off VL53L0X component.\nsensor_vl53l0x.VL53L0X_Off();\n\n// Initialize VL53L0X component.\nstatus = sensor_vl53l0x.InitSensor(0x52);\nif (status) {\nSerial.println(\"Init sensor_vl53l0x failed...\");\n}\n\n// From RAK12029\nldc.LDC1614_init();\n/*single channel use case configuration.*/\nif (ldc.LDC1614_single_channel_config(GETCHANNEL, INDUCTANCE, CAPATANCE)) {\nSerial.println(\"can't detect sensor!\");\nwhile (1) delay(100);\n}\n}\n\nvoid loop() {\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\n// Read data from RAK12014\nstatus = sensor_vl53l0x.GetDistance(&distance);\n\n// Read data from RAK12029\nldc.IIC_read_16bit(LDC1614_READ_DEVICE_ID, &value);\nif (value == 0x3055) {\n//u32 ChannelData = 0;\n/*Get channel 0 result and parse it.*/\ndelay(100);\nif (ldc.LDC1614_get_channel_result(GETCHANNEL, &ChannelData) == 0) {\n/*sensor result value.you can make a lot of application according to its changes.*/\nif (0 != ChannelData) {\ndigitalWrite(LED_BLUE, HIGH);     // Indicator Blue LED\ndigitalWrite(LED_GREEN, HIGH);    // Indicator Green LED\n}\ndelay(200);\ndigitalWrite(LED_BLUE, LOW);        // Indicator Blue LED\ndigitalWrite(LED_GREEN, LOW);       // Indicator Green LED\n}\n}\n\nif (ChannelData >= 49800000)            // metallic material sensed nearby via inductive sensor\n{\ndigitalWrite(RELAY_PIN, HIGH);        // Turns ON the relay module\nobject = 1;                           // \"1\" corresponds to metallic object\nSerial.println(\"Metal Detected\");\n}\n\nelse if (ChannelData <= 49650000)       // nothing metallic was sensed; default value sensed by the inductive sensor\n{\ndigitalWrite(RELAY_PIN, LOW);         // Turns OFF the relay module\nobject = 0;                           // \"0\" corresponds to non-metallic object\nSerial.println(\"No Metal Detected\");\n}\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\nSerial.print(distance);       // From RAK12014 module\nSerial.println(\"mm   \");\nSerial.println(object);       // From RAK13001 module\nSerial.println(ChannelData);  // From RAK12029 module\n\ndelay(5000);\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void) {\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void) {\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data) {\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class) {\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void) {\nif (lmh_join_status_get() != LMH_SET) {\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\ndata = \" Distance: \" + String(distance) + \" mm \" + \" Metallic: \" + String(object) + \" Inductive_Sense: \" + String(ChannelData);\nSerial.println(data);\n\nuint32_t distance_data = distance;    // data from RAK12014 module\nuint32_t channel_data = ChannelData;  // data from RAK12029 module\nint metallic_data = object;           // data from RAK13001 module\n\nm_lora_app_data.buffer[i++] = 0x01;  // byte[0]\n\n// Data from RAK12014 module\nm_lora_app_data.buffer[i++] = (uint8_t)((distance_data & 0xFF000000) >> 24);    // byte[1]\nm_lora_app_data.buffer[i++] = (uint8_t)((distance_data & 0x00FF0000) >> 16);    // byte[2]\nm_lora_app_data.buffer[i++] = (uint8_t)((distance_data & 0x0000FF00) >> 8);     // byte[3]\nm_lora_app_data.buffer[i++] = (uint8_t)(distance_data & 0x000000FF);            // byte[4]\n\n// Data from RAK12029 module (inductive sensor)\nm_lora_app_data.buffer[i++] = (uint8_t)((channel_data & 0xFF000000) >> 24);    // byte[5]\nm_lora_app_data.buffer[i++] = (uint8_t)((channel_data & 0x00FF0000) >> 16);    // byte[6]\nm_lora_app_data.buffer[i++] = (uint8_t)((channel_data & 0x0000FF00) >> 8);     // byte[7]\nm_lora_app_data.buffer[i++] = (uint8_t)(channel_data & 0x000000FF);            // byte[8]\n\n// Data from RAK13001 module (relay module status)\nm_lora_app_data.buffer[i++] = metallic_data;                                   // byte[9]\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS) {\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n} else {\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xC0, 0x81, 0xBB, 0x65, 0x54, 0xCF, 0xF7, 0x65, 0x87, 0x70, 0xFD, 0x31, 0x7F, 0x01, 0x87, 0x51 };\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "0f8155e1a32e4fcb41191f0290faefb1", "product_family": "wisblock", "product_id": "kit4-industrial", "category": "How-To", "title": "WisBlock IoT Education Kit - Smart Industry Quick Start Guide > WisBlock IoT Education Kit - Smart Industry Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock Smart Industry Kit using TTN and Quibitro > Material Classifier LoRaWAN Application > LoRaWAN Code for Material Classifier > Programming the Material Classifier Device with LoRaWAN Application [CODE]", "content": "- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |", "keywords": ["Arduino IDE", "RAK4631", "Material Classifier", "LoRaWAN", "SX126x-Arduino"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **Material Classifier** device. Just copy the code below for **Material Classifier LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the code</summary>  \n```c\n\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h>  //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n// For RAK12014 module\n#include <vl53l0x_class.h>    // Click to install library: http://librarymanager/All#stm32duino_vl53l0x\nVL53L0X sensor_vl53l0x(&Wire, WB_IO2);\n\nuint32_t distance;\nint status;\n\n// For RAK13001 module\n#define RELAY_PIN WB_IO4\nint object;\n\n// For RAK12029 module\n#include \"RAK12029_LDC1614.h\"\n\n#define INDUCTANCE 13.000\n#define CAPATANCE 100.0\n#define GETCHANNEL LDC1614_CHANNEL_0     // LDC1614_CHANNEL_(0~3); selecting the coil channel from 0 - 3\nRAK12029_LDC1614_Inductive ldc;\n\nu16 value = 0;\nu32 ChannelData = 0;\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define RAK4631_BOARD true\n#else\n#define RAK4631_BOARD false\n#endif\n\nbool doOTAA = true;                                               // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                                       /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                                     /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5                               /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                                        /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;                           /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;                 /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                              /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = { LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF };\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = { BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler };\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xC0, 0x81, 0xBB, 0x65, 0x54, 0xCF, 0xF7, 0x65, 0x87, 0x70, 0xFD, 0x31, 0x7F, 0x01, 0x87, 0x51 };\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };\nuint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                                            /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];               //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = { m_lora_app_data_buffer, 0, 0, 0, 0 };  //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {\n// Sensor Power Switch\npinMode(WB_IO2, OUTPUT);\ndigitalWrite(WB_IO2, HIGH);\n\n// Control Chip Switch\npinMode(WB_IO5, OUTPUT);\ndigitalWrite(WB_IO5, LOW);\n\n// Control Relay Module\npinMode(RELAY_PIN,OUTPUT);\ndigitalWrite(RELAY_PIN, LOW);    // relay module initially LOW\n\npinMode(LED_GREEN, OUTPUT);      // Output LED\npinMode(LED_BLUE, OUTPUT);       // Output LED\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial) {\nif ((millis() - timeout) < 5000) {\ndelay(100);\n} else {\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA) {\nSerial.println(\"Type: OTAA\");\n} else {\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion) {\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA) {\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n} else {\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0) {\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"===========================================\");\nSerial.println(\"RAK12014 + RAK12029 + RAK13001 LoRaWAN Code\");\nSerial.println(\"===========================================\");\n\nWire.begin();\n\n// Configure VL53L0X component.\nsensor_vl53l0x.begin();\n\n// Switch off VL53L0X component.\nsensor_vl53l0x.VL53L0X_Off();\n\n// Initialize VL53L0X component.\nstatus = sensor_vl53l0x.InitSensor(0x52);\nif (status) {\nSerial.println(\"Init sensor_vl53l0x failed...\");\n}\n\n// From RAK12029\nldc.LDC1614_init();\n/*single channel use case configuration.*/\nif (ldc.LDC1614_single_channel_config(GETCHANNEL, INDUCTANCE, CAPATANCE)) {\nSerial.println(\"can't detect sensor!\");\nwhile (1) delay(100);\n}\n}\n\nvoid loop() {\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\n// Read data from RAK12014\nstatus = sensor_vl53l0x.GetDistance(&distance);\n\n// Read data from RAK12029\nldc.IIC_read_16bit(LDC1614_READ_DEVICE_ID, &value);\nif (value == 0x3055) {\n//u32 ChannelData = 0;\n/*Get channel 0 result and parse it.*/\ndelay(100);\nif (ldc.LDC1614_get_channel_result(GETCHANNEL, &ChannelData) == 0) {\n/*sensor result value.you can make a lot of application according to its changes.*/\nif (0 != ChannelData) {\ndigitalWrite(LED_BLUE, HIGH);     // Indicator Blue LED\ndigitalWrite(LED_GREEN, HIGH);    // Indicator Green LED\n}\ndelay(200);\ndigitalWrite(LED_BLUE, LOW);        // Indicator Blue LED\ndigitalWrite(LED_GREEN, LOW);       // Indicator Green LED\n}\n}\n\nif (ChannelData >= 49800000)            // metallic material sensed nearby via inductive sensor\n{\ndigitalWrite(RELAY_PIN, HIGH);        // Turns ON the relay module\nobject = 1;                           // \"1\" corresponds to metallic object\nSerial.println(\"Metal Detected\");\n}\n\nelse if (ChannelData <= 49650000)       // nothing metallic was sensed; default value sensed by the inductive sensor\n{\ndigitalWrite(RELAY_PIN, LOW);         // Turns OFF the relay module\nobject = 0;                           // \"0\" corresponds to non-metallic object\nSerial.println(\"No Metal Detected\");\n}\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\nSerial.print(distance);       // From RAK12014 module\nSerial.println(\"mm   \");\nSerial.println(object);       // From RAK13001 module\nSerial.println(ChannelData);  // From RAK12029 module\n\ndelay(5000);\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void) {\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void) {\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data) {\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class) {\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void) {\nif (lmh_join_status_get() != LMH_SET) {\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\ndata = \" Distance: \" + String(distance) + \" mm \" + \" Metallic: \" + String(object) + \" Inductive_Sense: \" + String(ChannelData);\nSerial.println(data);\n\nuint32_t distance_data = distance;    // data from RAK12014 module\nuint32_t channel_data = ChannelData;  // data from RAK12029 module\nint metallic_data = object;           // data from RAK13001 module\n\nm_lora_app_data.buffer[i++] = 0x01;  // byte[0]\n\n// Data from RAK12014 module\nm_lora_app_data.buffer[i++] = (uint8_t)((distance_data & 0xFF000000) >> 24);    // byte[1]\nm_lora_app_data.buffer[i++] = (uint8_t)((distance_data & 0x00FF0000) >> 16);    // byte[2]\nm_lora_app_data.buffer[i++] = (uint8_t)((distance_data & 0x0000FF00) >> 8);     // byte[3]\nm_lora_app_data.buffer[i++] = (uint8_t)(distance_data & 0x000000FF);            // byte[4]\n\n// Data from RAK12029 module (inductive sensor)\nm_lora_app_data.buffer[i++] = (uint8_t)((channel_data & 0xFF000000) >> 24);    // byte[5]\nm_lora_app_data.buffer[i++] = (uint8_t)((channel_data & 0x00FF0000) >> 16);    // byte[6]\nm_lora_app_data.buffer[i++] = (uint8_t)((channel_data & 0x0000FF00) >> 8);     // byte[7]\nm_lora_app_data.buffer[i++] = (uint8_t)(channel_data & 0x000000FF);            // byte[8]\n\n// Data from RAK13001 module (relay module status)\nm_lora_app_data.buffer[i++] = metallic_data;                                   // byte[9]\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS) {\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n} else {\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xC0, 0x81, 0xBB, 0x65, 0x54, 0xCF, 0xF7, 0x65, 0x87, 0x70, 0xFD, 0x31, 0x7F, 0x01, 0x87, 0x51 };\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "ffdb0e462316edae811a5b1b248f9597", "product_family": "wisblock", "product_id": "kit4-industrial", "category": "How-To", "title": "WisBlock IoT Education Kit - Smart Industry Quick Start Guide > WisBlock IoT Education Kit - Smart Industry Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock Smart Industry Kit using TTN and Quibitro > Material Classifier LoRaWAN Application > LoRaWAN Code for Material Classifier > Programming the Material Classifier Device with LoRaWAN Application [CODE]", "content": "|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |", "keywords": ["Arduino IDE", "RAK4631", "Material Classifier", "LoRaWAN", "SX126x-Arduino"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **Material Classifier** device. Just copy the code below for **Material Classifier LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the code</summary>  \n```c\n\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h>  //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n// For RAK12014 module\n#include <vl53l0x_class.h>    // Click to install library: http://librarymanager/All#stm32duino_vl53l0x\nVL53L0X sensor_vl53l0x(&Wire, WB_IO2);\n\nuint32_t distance;\nint status;\n\n// For RAK13001 module\n#define RELAY_PIN WB_IO4\nint object;\n\n// For RAK12029 module\n#include \"RAK12029_LDC1614.h\"\n\n#define INDUCTANCE 13.000\n#define CAPATANCE 100.0\n#define GETCHANNEL LDC1614_CHANNEL_0     // LDC1614_CHANNEL_(0~3); selecting the coil channel from 0 - 3\nRAK12029_LDC1614_Inductive ldc;\n\nu16 value = 0;\nu32 ChannelData = 0;\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define RAK4631_BOARD true\n#else\n#define RAK4631_BOARD false\n#endif\n\nbool doOTAA = true;                                               // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                                       /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                                     /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5                               /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                                        /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;                           /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;                 /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                              /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = { LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF };\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = { BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler };\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xC0, 0x81, 0xBB, 0x65, 0x54, 0xCF, 0xF7, 0x65, 0x87, 0x70, 0xFD, 0x31, 0x7F, 0x01, 0x87, 0x51 };\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };\nuint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                                            /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];               //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = { m_lora_app_data_buffer, 0, 0, 0, 0 };  //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {\n// Sensor Power Switch\npinMode(WB_IO2, OUTPUT);\ndigitalWrite(WB_IO2, HIGH);\n\n// Control Chip Switch\npinMode(WB_IO5, OUTPUT);\ndigitalWrite(WB_IO5, LOW);\n\n// Control Relay Module\npinMode(RELAY_PIN,OUTPUT);\ndigitalWrite(RELAY_PIN, LOW);    // relay module initially LOW\n\npinMode(LED_GREEN, OUTPUT);      // Output LED\npinMode(LED_BLUE, OUTPUT);       // Output LED\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial) {\nif ((millis() - timeout) < 5000) {\ndelay(100);\n} else {\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA) {\nSerial.println(\"Type: OTAA\");\n} else {\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion) {\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA) {\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n} else {\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0) {\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"===========================================\");\nSerial.println(\"RAK12014 + RAK12029 + RAK13001 LoRaWAN Code\");\nSerial.println(\"===========================================\");\n\nWire.begin();\n\n// Configure VL53L0X component.\nsensor_vl53l0x.begin();\n\n// Switch off VL53L0X component.\nsensor_vl53l0x.VL53L0X_Off();\n\n// Initialize VL53L0X component.\nstatus = sensor_vl53l0x.InitSensor(0x52);\nif (status) {\nSerial.println(\"Init sensor_vl53l0x failed...\");\n}\n\n// From RAK12029\nldc.LDC1614_init();\n/*single channel use case configuration.*/\nif (ldc.LDC1614_single_channel_config(GETCHANNEL, INDUCTANCE, CAPATANCE)) {\nSerial.println(\"can't detect sensor!\");\nwhile (1) delay(100);\n}\n}\n\nvoid loop() {\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\n// Read data from RAK12014\nstatus = sensor_vl53l0x.GetDistance(&distance);\n\n// Read data from RAK12029\nldc.IIC_read_16bit(LDC1614_READ_DEVICE_ID, &value);\nif (value == 0x3055) {\n//u32 ChannelData = 0;\n/*Get channel 0 result and parse it.*/\ndelay(100);\nif (ldc.LDC1614_get_channel_result(GETCHANNEL, &ChannelData) == 0) {\n/*sensor result value.you can make a lot of application according to its changes.*/\nif (0 != ChannelData) {\ndigitalWrite(LED_BLUE, HIGH);     // Indicator Blue LED\ndigitalWrite(LED_GREEN, HIGH);    // Indicator Green LED\n}\ndelay(200);\ndigitalWrite(LED_BLUE, LOW);        // Indicator Blue LED\ndigitalWrite(LED_GREEN, LOW);       // Indicator Green LED\n}\n}\n\nif (ChannelData >= 49800000)            // metallic material sensed nearby via inductive sensor\n{\ndigitalWrite(RELAY_PIN, HIGH);        // Turns ON the relay module\nobject = 1;                           // \"1\" corresponds to metallic object\nSerial.println(\"Metal Detected\");\n}\n\nelse if (ChannelData <= 49650000)       // nothing metallic was sensed; default value sensed by the inductive sensor\n{\ndigitalWrite(RELAY_PIN, LOW);         // Turns OFF the relay module\nobject = 0;                           // \"0\" corresponds to non-metallic object\nSerial.println(\"No Metal Detected\");\n}\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\nSerial.print(distance);       // From RAK12014 module\nSerial.println(\"mm   \");\nSerial.println(object);       // From RAK13001 module\nSerial.println(ChannelData);  // From RAK12029 module\n\ndelay(5000);\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void) {\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void) {\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data) {\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class) {\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void) {\nif (lmh_join_status_get() != LMH_SET) {\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\ndata = \" Distance: \" + String(distance) + \" mm \" + \" Metallic: \" + String(object) + \" Inductive_Sense: \" + String(ChannelData);\nSerial.println(data);\n\nuint32_t distance_data = distance;    // data from RAK12014 module\nuint32_t channel_data = ChannelData;  // data from RAK12029 module\nint metallic_data = object;           // data from RAK13001 module\n\nm_lora_app_data.buffer[i++] = 0x01;  // byte[0]\n\n// Data from RAK12014 module\nm_lora_app_data.buffer[i++] = (uint8_t)((distance_data & 0xFF000000) >> 24);    // byte[1]\nm_lora_app_data.buffer[i++] = (uint8_t)((distance_data & 0x00FF0000) >> 16);    // byte[2]\nm_lora_app_data.buffer[i++] = (uint8_t)((distance_data & 0x0000FF00) >> 8);     // byte[3]\nm_lora_app_data.buffer[i++] = (uint8_t)(distance_data & 0x000000FF);            // byte[4]\n\n// Data from RAK12029 module (inductive sensor)\nm_lora_app_data.buffer[i++] = (uint8_t)((channel_data & 0xFF000000) >> 24);    // byte[5]\nm_lora_app_data.buffer[i++] = (uint8_t)((channel_data & 0x00FF0000) >> 16);    // byte[6]\nm_lora_app_data.buffer[i++] = (uint8_t)((channel_data & 0x0000FF00) >> 8);     // byte[7]\nm_lora_app_data.buffer[i++] = (uint8_t)(channel_data & 0x000000FF);            // byte[8]\n\n// Data from RAK13001 module (relay module status)\nm_lora_app_data.buffer[i++] = metallic_data;                                   // byte[9]\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS) {\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n} else {\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xC0, 0x81, 0xBB, 0x65, 0x54, 0xCF, 0xF7, 0x65, 0x87, 0x70, 0xFD, 0x31, 0x7F, 0x01, 0x87, 0x51 };\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "ee6490c3814a547a0879a7d3aa8fce80", "product_family": "wisblock", "product_id": "kit4-industrial", "category": "How-To", "title": "WisBlock IoT Education Kit - Smart Industry Quick Start Guide > WisBlock IoT Education Kit - Smart Industry Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock Smart Industry Kit using TTN and Quibitro > Material Classifier LoRaWAN Application > LoRaWAN Code for Material Classifier > Programming the Material Classifier Device with LoRaWAN Application [CODE]", "content": "|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |", "keywords": ["Arduino IDE", "RAK4631", "Material Classifier", "LoRaWAN", "SX126x-Arduino"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **Material Classifier** device. Just copy the code below for **Material Classifier LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the code</summary>  \n```c\n\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h>  //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n// For RAK12014 module\n#include <vl53l0x_class.h>    // Click to install library: http://librarymanager/All#stm32duino_vl53l0x\nVL53L0X sensor_vl53l0x(&Wire, WB_IO2);\n\nuint32_t distance;\nint status;\n\n// For RAK13001 module\n#define RELAY_PIN WB_IO4\nint object;\n\n// For RAK12029 module\n#include \"RAK12029_LDC1614.h\"\n\n#define INDUCTANCE 13.000\n#define CAPATANCE 100.0\n#define GETCHANNEL LDC1614_CHANNEL_0     // LDC1614_CHANNEL_(0~3); selecting the coil channel from 0 - 3\nRAK12029_LDC1614_Inductive ldc;\n\nu16 value = 0;\nu32 ChannelData = 0;\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define RAK4631_BOARD true\n#else\n#define RAK4631_BOARD false\n#endif\n\nbool doOTAA = true;                                               // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                                       /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                                     /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5                               /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                                        /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;                           /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;                 /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                              /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = { LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF };\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = { BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler };\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xC0, 0x81, 0xBB, 0x65, 0x54, 0xCF, 0xF7, 0x65, 0x87, 0x70, 0xFD, 0x31, 0x7F, 0x01, 0x87, 0x51 };\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };\nuint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                                            /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];               //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = { m_lora_app_data_buffer, 0, 0, 0, 0 };  //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {\n// Sensor Power Switch\npinMode(WB_IO2, OUTPUT);\ndigitalWrite(WB_IO2, HIGH);\n\n// Control Chip Switch\npinMode(WB_IO5, OUTPUT);\ndigitalWrite(WB_IO5, LOW);\n\n// Control Relay Module\npinMode(RELAY_PIN,OUTPUT);\ndigitalWrite(RELAY_PIN, LOW);    // relay module initially LOW\n\npinMode(LED_GREEN, OUTPUT);      // Output LED\npinMode(LED_BLUE, OUTPUT);       // Output LED\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial) {\nif ((millis() - timeout) < 5000) {\ndelay(100);\n} else {\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA) {\nSerial.println(\"Type: OTAA\");\n} else {\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion) {\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA) {\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n} else {\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0) {\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"===========================================\");\nSerial.println(\"RAK12014 + RAK12029 + RAK13001 LoRaWAN Code\");\nSerial.println(\"===========================================\");\n\nWire.begin();\n\n// Configure VL53L0X component.\nsensor_vl53l0x.begin();\n\n// Switch off VL53L0X component.\nsensor_vl53l0x.VL53L0X_Off();\n\n// Initialize VL53L0X component.\nstatus = sensor_vl53l0x.InitSensor(0x52);\nif (status) {\nSerial.println(\"Init sensor_vl53l0x failed...\");\n}\n\n// From RAK12029\nldc.LDC1614_init();\n/*single channel use case configuration.*/\nif (ldc.LDC1614_single_channel_config(GETCHANNEL, INDUCTANCE, CAPATANCE)) {\nSerial.println(\"can't detect sensor!\");\nwhile (1) delay(100);\n}\n}\n\nvoid loop() {\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\n// Read data from RAK12014\nstatus = sensor_vl53l0x.GetDistance(&distance);\n\n// Read data from RAK12029\nldc.IIC_read_16bit(LDC1614_READ_DEVICE_ID, &value);\nif (value == 0x3055) {\n//u32 ChannelData = 0;\n/*Get channel 0 result and parse it.*/\ndelay(100);\nif (ldc.LDC1614_get_channel_result(GETCHANNEL, &ChannelData) == 0) {\n/*sensor result value.you can make a lot of application according to its changes.*/\nif (0 != ChannelData) {\ndigitalWrite(LED_BLUE, HIGH);     // Indicator Blue LED\ndigitalWrite(LED_GREEN, HIGH);    // Indicator Green LED\n}\ndelay(200);\ndigitalWrite(LED_BLUE, LOW);        // Indicator Blue LED\ndigitalWrite(LED_GREEN, LOW);       // Indicator Green LED\n}\n}\n\nif (ChannelData >= 49800000)            // metallic material sensed nearby via inductive sensor\n{\ndigitalWrite(RELAY_PIN, HIGH);        // Turns ON the relay module\nobject = 1;                           // \"1\" corresponds to metallic object\nSerial.println(\"Metal Detected\");\n}\n\nelse if (ChannelData <= 49650000)       // nothing metallic was sensed; default value sensed by the inductive sensor\n{\ndigitalWrite(RELAY_PIN, LOW);         // Turns OFF the relay module\nobject = 0;                           // \"0\" corresponds to non-metallic object\nSerial.println(\"No Metal Detected\");\n}\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\nSerial.print(distance);       // From RAK12014 module\nSerial.println(\"mm   \");\nSerial.println(object);       // From RAK13001 module\nSerial.println(ChannelData);  // From RAK12029 module\n\ndelay(5000);\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void) {\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void) {\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data) {\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class) {\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void) {\nif (lmh_join_status_get() != LMH_SET) {\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\ndata = \" Distance: \" + String(distance) + \" mm \" + \" Metallic: \" + String(object) + \" Inductive_Sense: \" + String(ChannelData);\nSerial.println(data);\n\nuint32_t distance_data = distance;    // data from RAK12014 module\nuint32_t channel_data = ChannelData;  // data from RAK12029 module\nint metallic_data = object;           // data from RAK13001 module\n\nm_lora_app_data.buffer[i++] = 0x01;  // byte[0]\n\n// Data from RAK12014 module\nm_lora_app_data.buffer[i++] = (uint8_t)((distance_data & 0xFF000000) >> 24);    // byte[1]\nm_lora_app_data.buffer[i++] = (uint8_t)((distance_data & 0x00FF0000) >> 16);    // byte[2]\nm_lora_app_data.buffer[i++] = (uint8_t)((distance_data & 0x0000FF00) >> 8);     // byte[3]\nm_lora_app_data.buffer[i++] = (uint8_t)(distance_data & 0x000000FF);            // byte[4]\n\n// Data from RAK12029 module (inductive sensor)\nm_lora_app_data.buffer[i++] = (uint8_t)((channel_data & 0xFF000000) >> 24);    // byte[5]\nm_lora_app_data.buffer[i++] = (uint8_t)((channel_data & 0x00FF0000) >> 16);    // byte[6]\nm_lora_app_data.buffer[i++] = (uint8_t)((channel_data & 0x0000FF00) >> 8);     // byte[7]\nm_lora_app_data.buffer[i++] = (uint8_t)(channel_data & 0x000000FF);            // byte[8]\n\n// Data from RAK13001 module (relay module status)\nm_lora_app_data.buffer[i++] = metallic_data;                                   // byte[9]\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS) {\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n} else {\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xC0, 0x81, 0xBB, 0x65, 0x54, 0xCF, 0xF7, 0x65, 0x87, 0x70, 0xFD, 0x31, 0x7F, 0x01, 0x87, 0x51 };\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "bc2d922f2e3a6121ec071c6ada816259", "product_family": "wisblock", "product_id": "kit4-industrial", "category": "How-To", "title": "WisBlock IoT Education Kit - Smart Industry Quick Start Guide > WisBlock IoT Education Kit - Smart Industry Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock Smart Industry Kit using TTN and Quibitro > Material Classifier LoRaWAN Application > LoRaWAN Code for Material Classifier > Programming the Material Classifier Device with LoRaWAN Application [CODE]", "content": "|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |", "keywords": ["Arduino IDE", "RAK4631", "Material Classifier", "LoRaWAN", "SX126x-Arduino"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **Material Classifier** device. Just copy the code below for **Material Classifier LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the code</summary>  \n```c\n\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h>  //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n// For RAK12014 module\n#include <vl53l0x_class.h>    // Click to install library: http://librarymanager/All#stm32duino_vl53l0x\nVL53L0X sensor_vl53l0x(&Wire, WB_IO2);\n\nuint32_t distance;\nint status;\n\n// For RAK13001 module\n#define RELAY_PIN WB_IO4\nint object;\n\n// For RAK12029 module\n#include \"RAK12029_LDC1614.h\"\n\n#define INDUCTANCE 13.000\n#define CAPATANCE 100.0\n#define GETCHANNEL LDC1614_CHANNEL_0     // LDC1614_CHANNEL_(0~3); selecting the coil channel from 0 - 3\nRAK12029_LDC1614_Inductive ldc;\n\nu16 value = 0;\nu32 ChannelData = 0;\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define RAK4631_BOARD true\n#else\n#define RAK4631_BOARD false\n#endif\n\nbool doOTAA = true;                                               // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                                       /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                                     /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5                               /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                                        /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;                           /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;                 /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                              /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = { LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF };\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = { BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler };\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xC0, 0x81, 0xBB, 0x65, 0x54, 0xCF, 0xF7, 0x65, 0x87, 0x70, 0xFD, 0x31, 0x7F, 0x01, 0x87, 0x51 };\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };\nuint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                                            /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];               //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = { m_lora_app_data_buffer, 0, 0, 0, 0 };  //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {\n// Sensor Power Switch\npinMode(WB_IO2, OUTPUT);\ndigitalWrite(WB_IO2, HIGH);\n\n// Control Chip Switch\npinMode(WB_IO5, OUTPUT);\ndigitalWrite(WB_IO5, LOW);\n\n// Control Relay Module\npinMode(RELAY_PIN,OUTPUT);\ndigitalWrite(RELAY_PIN, LOW);    // relay module initially LOW\n\npinMode(LED_GREEN, OUTPUT);      // Output LED\npinMode(LED_BLUE, OUTPUT);       // Output LED\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial) {\nif ((millis() - timeout) < 5000) {\ndelay(100);\n} else {\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA) {\nSerial.println(\"Type: OTAA\");\n} else {\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion) {\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA) {\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n} else {\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0) {\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"===========================================\");\nSerial.println(\"RAK12014 + RAK12029 + RAK13001 LoRaWAN Code\");\nSerial.println(\"===========================================\");\n\nWire.begin();\n\n// Configure VL53L0X component.\nsensor_vl53l0x.begin();\n\n// Switch off VL53L0X component.\nsensor_vl53l0x.VL53L0X_Off();\n\n// Initialize VL53L0X component.\nstatus = sensor_vl53l0x.InitSensor(0x52);\nif (status) {\nSerial.println(\"Init sensor_vl53l0x failed...\");\n}\n\n// From RAK12029\nldc.LDC1614_init();\n/*single channel use case configuration.*/\nif (ldc.LDC1614_single_channel_config(GETCHANNEL, INDUCTANCE, CAPATANCE)) {\nSerial.println(\"can't detect sensor!\");\nwhile (1) delay(100);\n}\n}\n\nvoid loop() {\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\n// Read data from RAK12014\nstatus = sensor_vl53l0x.GetDistance(&distance);\n\n// Read data from RAK12029\nldc.IIC_read_16bit(LDC1614_READ_DEVICE_ID, &value);\nif (value == 0x3055) {\n//u32 ChannelData = 0;\n/*Get channel 0 result and parse it.*/\ndelay(100);\nif (ldc.LDC1614_get_channel_result(GETCHANNEL, &ChannelData) == 0) {\n/*sensor result value.you can make a lot of application according to its changes.*/\nif (0 != ChannelData) {\ndigitalWrite(LED_BLUE, HIGH);     // Indicator Blue LED\ndigitalWrite(LED_GREEN, HIGH);    // Indicator Green LED\n}\ndelay(200);\ndigitalWrite(LED_BLUE, LOW);        // Indicator Blue LED\ndigitalWrite(LED_GREEN, LOW);       // Indicator Green LED\n}\n}\n\nif (ChannelData >= 49800000)            // metallic material sensed nearby via inductive sensor\n{\ndigitalWrite(RELAY_PIN, HIGH);        // Turns ON the relay module\nobject = 1;                           // \"1\" corresponds to metallic object\nSerial.println(\"Metal Detected\");\n}\n\nelse if (ChannelData <= 49650000)       // nothing metallic was sensed; default value sensed by the inductive sensor\n{\ndigitalWrite(RELAY_PIN, LOW);         // Turns OFF the relay module\nobject = 0;                           // \"0\" corresponds to non-metallic object\nSerial.println(\"No Metal Detected\");\n}\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\nSerial.print(distance);       // From RAK12014 module\nSerial.println(\"mm   \");\nSerial.println(object);       // From RAK13001 module\nSerial.println(ChannelData);  // From RAK12029 module\n\ndelay(5000);\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void) {\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void) {\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data) {\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class) {\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void) {\nif (lmh_join_status_get() != LMH_SET) {\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\ndata = \" Distance: \" + String(distance) + \" mm \" + \" Metallic: \" + String(object) + \" Inductive_Sense: \" + String(ChannelData);\nSerial.println(data);\n\nuint32_t distance_data = distance;    // data from RAK12014 module\nuint32_t channel_data = ChannelData;  // data from RAK12029 module\nint metallic_data = object;           // data from RAK13001 module\n\nm_lora_app_data.buffer[i++] = 0x01;  // byte[0]\n\n// Data from RAK12014 module\nm_lora_app_data.buffer[i++] = (uint8_t)((distance_data & 0xFF000000) >> 24);    // byte[1]\nm_lora_app_data.buffer[i++] = (uint8_t)((distance_data & 0x00FF0000) >> 16);    // byte[2]\nm_lora_app_data.buffer[i++] = (uint8_t)((distance_data & 0x0000FF00) >> 8);     // byte[3]\nm_lora_app_data.buffer[i++] = (uint8_t)(distance_data & 0x000000FF);            // byte[4]\n\n// Data from RAK12029 module (inductive sensor)\nm_lora_app_data.buffer[i++] = (uint8_t)((channel_data & 0xFF000000) >> 24);    // byte[5]\nm_lora_app_data.buffer[i++] = (uint8_t)((channel_data & 0x00FF0000) >> 16);    // byte[6]\nm_lora_app_data.buffer[i++] = (uint8_t)((channel_data & 0x0000FF00) >> 8);     // byte[7]\nm_lora_app_data.buffer[i++] = (uint8_t)(channel_data & 0x000000FF);            // byte[8]\n\n// Data from RAK13001 module (relay module status)\nm_lora_app_data.buffer[i++] = metallic_data;                                   // byte[9]\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS) {\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n} else {\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xC0, 0x81, 0xBB, 0x65, 0x54, 0xCF, 0xF7, 0x65, 0x87, 0x70, 0xFD, 0x31, 0x7F, 0x01, 0x87, 0x51 };\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "3874ac29e3e3f7c7eaed7e4ecde608dc", "product_family": "wisblock", "product_id": "kit4-industrial", "category": "How-To", "title": "WisBlock IoT Education Kit - Smart Industry Quick Start Guide > WisBlock IoT Education Kit - Smart Industry Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock Smart Industry Kit using TTN and Quibitro > Material Classifier LoRaWAN Application > LoRaWAN Code for Material Classifier > Programming the Material Classifier Device with LoRaWAN Application [CODE]", "content": "|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```", "keywords": ["Arduino IDE", "RAK4631", "Material Classifier", "LoRaWAN", "SX126x-Arduino"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **Material Classifier** device. Just copy the code below for **Material Classifier LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the code</summary>  \n```c\n\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h>  //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n// For RAK12014 module\n#include <vl53l0x_class.h>    // Click to install library: http://librarymanager/All#stm32duino_vl53l0x\nVL53L0X sensor_vl53l0x(&Wire, WB_IO2);\n\nuint32_t distance;\nint status;\n\n// For RAK13001 module\n#define RELAY_PIN WB_IO4\nint object;\n\n// For RAK12029 module\n#include \"RAK12029_LDC1614.h\"\n\n#define INDUCTANCE 13.000\n#define CAPATANCE 100.0\n#define GETCHANNEL LDC1614_CHANNEL_0     // LDC1614_CHANNEL_(0~3); selecting the coil channel from 0 - 3\nRAK12029_LDC1614_Inductive ldc;\n\nu16 value = 0;\nu32 ChannelData = 0;\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define RAK4631_BOARD true\n#else\n#define RAK4631_BOARD false\n#endif\n\nbool doOTAA = true;                                               // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                                       /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                                     /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5                               /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                                        /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;                           /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;                 /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                              /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = { LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF };\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = { BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler };\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xC0, 0x81, 0xBB, 0x65, 0x54, 0xCF, 0xF7, 0x65, 0x87, 0x70, 0xFD, 0x31, 0x7F, 0x01, 0x87, 0x51 };\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };\nuint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                                            /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];               //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = { m_lora_app_data_buffer, 0, 0, 0, 0 };  //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {\n// Sensor Power Switch\npinMode(WB_IO2, OUTPUT);\ndigitalWrite(WB_IO2, HIGH);\n\n// Control Chip Switch\npinMode(WB_IO5, OUTPUT);\ndigitalWrite(WB_IO5, LOW);\n\n// Control Relay Module\npinMode(RELAY_PIN,OUTPUT);\ndigitalWrite(RELAY_PIN, LOW);    // relay module initially LOW\n\npinMode(LED_GREEN, OUTPUT);      // Output LED\npinMode(LED_BLUE, OUTPUT);       // Output LED\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial) {\nif ((millis() - timeout) < 5000) {\ndelay(100);\n} else {\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA) {\nSerial.println(\"Type: OTAA\");\n} else {\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion) {\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA) {\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n} else {\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0) {\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"===========================================\");\nSerial.println(\"RAK12014 + RAK12029 + RAK13001 LoRaWAN Code\");\nSerial.println(\"===========================================\");\n\nWire.begin();\n\n// Configure VL53L0X component.\nsensor_vl53l0x.begin();\n\n// Switch off VL53L0X component.\nsensor_vl53l0x.VL53L0X_Off();\n\n// Initialize VL53L0X component.\nstatus = sensor_vl53l0x.InitSensor(0x52);\nif (status) {\nSerial.println(\"Init sensor_vl53l0x failed...\");\n}\n\n// From RAK12029\nldc.LDC1614_init();\n/*single channel use case configuration.*/\nif (ldc.LDC1614_single_channel_config(GETCHANNEL, INDUCTANCE, CAPATANCE)) {\nSerial.println(\"can't detect sensor!\");\nwhile (1) delay(100);\n}\n}\n\nvoid loop() {\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\n// Read data from RAK12014\nstatus = sensor_vl53l0x.GetDistance(&distance);\n\n// Read data from RAK12029\nldc.IIC_read_16bit(LDC1614_READ_DEVICE_ID, &value);\nif (value == 0x3055) {\n//u32 ChannelData = 0;\n/*Get channel 0 result and parse it.*/\ndelay(100);\nif (ldc.LDC1614_get_channel_result(GETCHANNEL, &ChannelData) == 0) {\n/*sensor result value.you can make a lot of application according to its changes.*/\nif (0 != ChannelData) {\ndigitalWrite(LED_BLUE, HIGH);     // Indicator Blue LED\ndigitalWrite(LED_GREEN, HIGH);    // Indicator Green LED\n}\ndelay(200);\ndigitalWrite(LED_BLUE, LOW);        // Indicator Blue LED\ndigitalWrite(LED_GREEN, LOW);       // Indicator Green LED\n}\n}\n\nif (ChannelData >= 49800000)            // metallic material sensed nearby via inductive sensor\n{\ndigitalWrite(RELAY_PIN, HIGH);        // Turns ON the relay module\nobject = 1;                           // \"1\" corresponds to metallic object\nSerial.println(\"Metal Detected\");\n}\n\nelse if (ChannelData <= 49650000)       // nothing metallic was sensed; default value sensed by the inductive sensor\n{\ndigitalWrite(RELAY_PIN, LOW);         // Turns OFF the relay module\nobject = 0;                           // \"0\" corresponds to non-metallic object\nSerial.println(\"No Metal Detected\");\n}\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\nSerial.print(distance);       // From RAK12014 module\nSerial.println(\"mm   \");\nSerial.println(object);       // From RAK13001 module\nSerial.println(ChannelData);  // From RAK12029 module\n\ndelay(5000);\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void) {\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void) {\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data) {\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class) {\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void) {\nif (lmh_join_status_get() != LMH_SET) {\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\ndata = \" Distance: \" + String(distance) + \" mm \" + \" Metallic: \" + String(object) + \" Inductive_Sense: \" + String(ChannelData);\nSerial.println(data);\n\nuint32_t distance_data = distance;    // data from RAK12014 module\nuint32_t channel_data = ChannelData;  // data from RAK12029 module\nint metallic_data = object;           // data from RAK13001 module\n\nm_lora_app_data.buffer[i++] = 0x01;  // byte[0]\n\n// Data from RAK12014 module\nm_lora_app_data.buffer[i++] = (uint8_t)((distance_data & 0xFF000000) >> 24);    // byte[1]\nm_lora_app_data.buffer[i++] = (uint8_t)((distance_data & 0x00FF0000) >> 16);    // byte[2]\nm_lora_app_data.buffer[i++] = (uint8_t)((distance_data & 0x0000FF00) >> 8);     // byte[3]\nm_lora_app_data.buffer[i++] = (uint8_t)(distance_data & 0x000000FF);            // byte[4]\n\n// Data from RAK12029 module (inductive sensor)\nm_lora_app_data.buffer[i++] = (uint8_t)((channel_data & 0xFF000000) >> 24);    // byte[5]\nm_lora_app_data.buffer[i++] = (uint8_t)((channel_data & 0x00FF0000) >> 16);    // byte[6]\nm_lora_app_data.buffer[i++] = (uint8_t)((channel_data & 0x0000FF00) >> 8);     // byte[7]\nm_lora_app_data.buffer[i++] = (uint8_t)(channel_data & 0x000000FF);            // byte[8]\n\n// Data from RAK13001 module (relay module status)\nm_lora_app_data.buffer[i++] = metallic_data;                                   // byte[9]\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS) {\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n} else {\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xC0, 0x81, 0xBB, 0x65, 0x54, 0xCF, 0xF7, 0x65, 0x87, 0x70, 0xFD, 0x31, 0x7F, 0x01, 0x87, 0x51 };\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "ba2e3cb20833da255e790f95e529c510", "product_family": "wisblock", "product_id": "kit4-industrial", "category": "How-To", "title": "WisBlock IoT Education Kit - Smart Industry Quick Start Guide > WisBlock IoT Education Kit - Smart Industry Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock Smart Industry Kit using TTN and Quibitro > Material Classifier LoRaWAN Application > LoRaWAN Code for Material Classifier > Programming the Material Classifier Device with LoRaWAN Application [CODE]", "content": "```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```", "keywords": ["Arduino IDE", "RAK4631", "Material Classifier", "LoRaWAN", "SX126x-Arduino"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **Material Classifier** device. Just copy the code below for **Material Classifier LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the code</summary>  \n```c\n\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h>  //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n// For RAK12014 module\n#include <vl53l0x_class.h>    // Click to install library: http://librarymanager/All#stm32duino_vl53l0x\nVL53L0X sensor_vl53l0x(&Wire, WB_IO2);\n\nuint32_t distance;\nint status;\n\n// For RAK13001 module\n#define RELAY_PIN WB_IO4\nint object;\n\n// For RAK12029 module\n#include \"RAK12029_LDC1614.h\"\n\n#define INDUCTANCE 13.000\n#define CAPATANCE 100.0\n#define GETCHANNEL LDC1614_CHANNEL_0     // LDC1614_CHANNEL_(0~3); selecting the coil channel from 0 - 3\nRAK12029_LDC1614_Inductive ldc;\n\nu16 value = 0;\nu32 ChannelData = 0;\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define RAK4631_BOARD true\n#else\n#define RAK4631_BOARD false\n#endif\n\nbool doOTAA = true;                                               // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                                       /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                                     /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5                               /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                                        /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;                           /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;                 /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                              /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = { LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF };\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = { BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler };\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xC0, 0x81, 0xBB, 0x65, 0x54, 0xCF, 0xF7, 0x65, 0x87, 0x70, 0xFD, 0x31, 0x7F, 0x01, 0x87, 0x51 };\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };\nuint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                                            /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];               //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = { m_lora_app_data_buffer, 0, 0, 0, 0 };  //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {\n// Sensor Power Switch\npinMode(WB_IO2, OUTPUT);\ndigitalWrite(WB_IO2, HIGH);\n\n// Control Chip Switch\npinMode(WB_IO5, OUTPUT);\ndigitalWrite(WB_IO5, LOW);\n\n// Control Relay Module\npinMode(RELAY_PIN,OUTPUT);\ndigitalWrite(RELAY_PIN, LOW);    // relay module initially LOW\n\npinMode(LED_GREEN, OUTPUT);      // Output LED\npinMode(LED_BLUE, OUTPUT);       // Output LED\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial) {\nif ((millis() - timeout) < 5000) {\ndelay(100);\n} else {\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA) {\nSerial.println(\"Type: OTAA\");\n} else {\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion) {\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA) {\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n} else {\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0) {\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"===========================================\");\nSerial.println(\"RAK12014 + RAK12029 + RAK13001 LoRaWAN Code\");\nSerial.println(\"===========================================\");\n\nWire.begin();\n\n// Configure VL53L0X component.\nsensor_vl53l0x.begin();\n\n// Switch off VL53L0X component.\nsensor_vl53l0x.VL53L0X_Off();\n\n// Initialize VL53L0X component.\nstatus = sensor_vl53l0x.InitSensor(0x52);\nif (status) {\nSerial.println(\"Init sensor_vl53l0x failed...\");\n}\n\n// From RAK12029\nldc.LDC1614_init();\n/*single channel use case configuration.*/\nif (ldc.LDC1614_single_channel_config(GETCHANNEL, INDUCTANCE, CAPATANCE)) {\nSerial.println(\"can't detect sensor!\");\nwhile (1) delay(100);\n}\n}\n\nvoid loop() {\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\n// Read data from RAK12014\nstatus = sensor_vl53l0x.GetDistance(&distance);\n\n// Read data from RAK12029\nldc.IIC_read_16bit(LDC1614_READ_DEVICE_ID, &value);\nif (value == 0x3055) {\n//u32 ChannelData = 0;\n/*Get channel 0 result and parse it.*/\ndelay(100);\nif (ldc.LDC1614_get_channel_result(GETCHANNEL, &ChannelData) == 0) {\n/*sensor result value.you can make a lot of application according to its changes.*/\nif (0 != ChannelData) {\ndigitalWrite(LED_BLUE, HIGH);     // Indicator Blue LED\ndigitalWrite(LED_GREEN, HIGH);    // Indicator Green LED\n}\ndelay(200);\ndigitalWrite(LED_BLUE, LOW);        // Indicator Blue LED\ndigitalWrite(LED_GREEN, LOW);       // Indicator Green LED\n}\n}\n\nif (ChannelData >= 49800000)            // metallic material sensed nearby via inductive sensor\n{\ndigitalWrite(RELAY_PIN, HIGH);        // Turns ON the relay module\nobject = 1;                           // \"1\" corresponds to metallic object\nSerial.println(\"Metal Detected\");\n}\n\nelse if (ChannelData <= 49650000)       // nothing metallic was sensed; default value sensed by the inductive sensor\n{\ndigitalWrite(RELAY_PIN, LOW);         // Turns OFF the relay module\nobject = 0;                           // \"0\" corresponds to non-metallic object\nSerial.println(\"No Metal Detected\");\n}\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\nSerial.print(distance);       // From RAK12014 module\nSerial.println(\"mm   \");\nSerial.println(object);       // From RAK13001 module\nSerial.println(ChannelData);  // From RAK12029 module\n\ndelay(5000);\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void) {\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void) {\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data) {\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class) {\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void) {\nif (lmh_join_status_get() != LMH_SET) {\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\ndata = \" Distance: \" + String(distance) + \" mm \" + \" Metallic: \" + String(object) + \" Inductive_Sense: \" + String(ChannelData);\nSerial.println(data);\n\nuint32_t distance_data = distance;    // data from RAK12014 module\nuint32_t channel_data = ChannelData;  // data from RAK12029 module\nint metallic_data = object;           // data from RAK13001 module\n\nm_lora_app_data.buffer[i++] = 0x01;  // byte[0]\n\n// Data from RAK12014 module\nm_lora_app_data.buffer[i++] = (uint8_t)((distance_data & 0xFF000000) >> 24);    // byte[1]\nm_lora_app_data.buffer[i++] = (uint8_t)((distance_data & 0x00FF0000) >> 16);    // byte[2]\nm_lora_app_data.buffer[i++] = (uint8_t)((distance_data & 0x0000FF00) >> 8);     // byte[3]\nm_lora_app_data.buffer[i++] = (uint8_t)(distance_data & 0x000000FF);            // byte[4]\n\n// Data from RAK12029 module (inductive sensor)\nm_lora_app_data.buffer[i++] = (uint8_t)((channel_data & 0xFF000000) >> 24);    // byte[5]\nm_lora_app_data.buffer[i++] = (uint8_t)((channel_data & 0x00FF0000) >> 16);    // byte[6]\nm_lora_app_data.buffer[i++] = (uint8_t)((channel_data & 0x0000FF00) >> 8);     // byte[7]\nm_lora_app_data.buffer[i++] = (uint8_t)(channel_data & 0x000000FF);            // byte[8]\n\n// Data from RAK13001 module (relay module status)\nm_lora_app_data.buffer[i++] = metallic_data;                                   // byte[9]\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS) {\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n} else {\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xC0, 0x81, 0xBB, 0x65, 0x54, 0xCF, 0xF7, 0x65, 0x87, 0x70, 0xFD, 0x31, 0x7F, 0x01, 0x87, 0x51 };\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "d5a871d69780ec50e6b76bb1e6af7849", "product_family": "wisblock", "product_id": "kit4-industrial", "category": "How-To", "title": "WisBlock IoT Education Kit - Smart Industry Quick Start Guide > WisBlock IoT Education Kit - Smart Industry Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock Smart Industry Kit using TTN and Quibitro > Material Classifier LoRaWAN Application > LoRaWAN Code for Material Classifier > Programming the Material Classifier Device with LoRaWAN Application [CODE]", "content": "```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };", "keywords": ["Arduino IDE", "RAK4631", "Material Classifier", "LoRaWAN", "SX126x-Arduino"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **Material Classifier** device. Just copy the code below for **Material Classifier LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the code</summary>  \n```c\n\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h>  //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n// For RAK12014 module\n#include <vl53l0x_class.h>    // Click to install library: http://librarymanager/All#stm32duino_vl53l0x\nVL53L0X sensor_vl53l0x(&Wire, WB_IO2);\n\nuint32_t distance;\nint status;\n\n// For RAK13001 module\n#define RELAY_PIN WB_IO4\nint object;\n\n// For RAK12029 module\n#include \"RAK12029_LDC1614.h\"\n\n#define INDUCTANCE 13.000\n#define CAPATANCE 100.0\n#define GETCHANNEL LDC1614_CHANNEL_0     // LDC1614_CHANNEL_(0~3); selecting the coil channel from 0 - 3\nRAK12029_LDC1614_Inductive ldc;\n\nu16 value = 0;\nu32 ChannelData = 0;\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define RAK4631_BOARD true\n#else\n#define RAK4631_BOARD false\n#endif\n\nbool doOTAA = true;                                               // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                                       /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                                     /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5                               /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                                        /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;                           /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;                 /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                              /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = { LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF };\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = { BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler };\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xC0, 0x81, 0xBB, 0x65, 0x54, 0xCF, 0xF7, 0x65, 0x87, 0x70, 0xFD, 0x31, 0x7F, 0x01, 0x87, 0x51 };\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };\nuint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                                            /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];               //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = { m_lora_app_data_buffer, 0, 0, 0, 0 };  //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {\n// Sensor Power Switch\npinMode(WB_IO2, OUTPUT);\ndigitalWrite(WB_IO2, HIGH);\n\n// Control Chip Switch\npinMode(WB_IO5, OUTPUT);\ndigitalWrite(WB_IO5, LOW);\n\n// Control Relay Module\npinMode(RELAY_PIN,OUTPUT);\ndigitalWrite(RELAY_PIN, LOW);    // relay module initially LOW\n\npinMode(LED_GREEN, OUTPUT);      // Output LED\npinMode(LED_BLUE, OUTPUT);       // Output LED\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial) {\nif ((millis() - timeout) < 5000) {\ndelay(100);\n} else {\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA) {\nSerial.println(\"Type: OTAA\");\n} else {\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion) {\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA) {\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n} else {\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0) {\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"===========================================\");\nSerial.println(\"RAK12014 + RAK12029 + RAK13001 LoRaWAN Code\");\nSerial.println(\"===========================================\");\n\nWire.begin();\n\n// Configure VL53L0X component.\nsensor_vl53l0x.begin();\n\n// Switch off VL53L0X component.\nsensor_vl53l0x.VL53L0X_Off();\n\n// Initialize VL53L0X component.\nstatus = sensor_vl53l0x.InitSensor(0x52);\nif (status) {\nSerial.println(\"Init sensor_vl53l0x failed...\");\n}\n\n// From RAK12029\nldc.LDC1614_init();\n/*single channel use case configuration.*/\nif (ldc.LDC1614_single_channel_config(GETCHANNEL, INDUCTANCE, CAPATANCE)) {\nSerial.println(\"can't detect sensor!\");\nwhile (1) delay(100);\n}\n}\n\nvoid loop() {\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\n// Read data from RAK12014\nstatus = sensor_vl53l0x.GetDistance(&distance);\n\n// Read data from RAK12029\nldc.IIC_read_16bit(LDC1614_READ_DEVICE_ID, &value);\nif (value == 0x3055) {\n//u32 ChannelData = 0;\n/*Get channel 0 result and parse it.*/\ndelay(100);\nif (ldc.LDC1614_get_channel_result(GETCHANNEL, &ChannelData) == 0) {\n/*sensor result value.you can make a lot of application according to its changes.*/\nif (0 != ChannelData) {\ndigitalWrite(LED_BLUE, HIGH);     // Indicator Blue LED\ndigitalWrite(LED_GREEN, HIGH);    // Indicator Green LED\n}\ndelay(200);\ndigitalWrite(LED_BLUE, LOW);        // Indicator Blue LED\ndigitalWrite(LED_GREEN, LOW);       // Indicator Green LED\n}\n}\n\nif (ChannelData >= 49800000)            // metallic material sensed nearby via inductive sensor\n{\ndigitalWrite(RELAY_PIN, HIGH);        // Turns ON the relay module\nobject = 1;                           // \"1\" corresponds to metallic object\nSerial.println(\"Metal Detected\");\n}\n\nelse if (ChannelData <= 49650000)       // nothing metallic was sensed; default value sensed by the inductive sensor\n{\ndigitalWrite(RELAY_PIN, LOW);         // Turns OFF the relay module\nobject = 0;                           // \"0\" corresponds to non-metallic object\nSerial.println(\"No Metal Detected\");\n}\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\nSerial.print(distance);       // From RAK12014 module\nSerial.println(\"mm   \");\nSerial.println(object);       // From RAK13001 module\nSerial.println(ChannelData);  // From RAK12029 module\n\ndelay(5000);\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void) {\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void) {\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data) {\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class) {\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void) {\nif (lmh_join_status_get() != LMH_SET) {\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\ndata = \" Distance: \" + String(distance) + \" mm \" + \" Metallic: \" + String(object) + \" Inductive_Sense: \" + String(ChannelData);\nSerial.println(data);\n\nuint32_t distance_data = distance;    // data from RAK12014 module\nuint32_t channel_data = ChannelData;  // data from RAK12029 module\nint metallic_data = object;           // data from RAK13001 module\n\nm_lora_app_data.buffer[i++] = 0x01;  // byte[0]\n\n// Data from RAK12014 module\nm_lora_app_data.buffer[i++] = (uint8_t)((distance_data & 0xFF000000) >> 24);    // byte[1]\nm_lora_app_data.buffer[i++] = (uint8_t)((distance_data & 0x00FF0000) >> 16);    // byte[2]\nm_lora_app_data.buffer[i++] = (uint8_t)((distance_data & 0x0000FF00) >> 8);     // byte[3]\nm_lora_app_data.buffer[i++] = (uint8_t)(distance_data & 0x000000FF);            // byte[4]\n\n// Data from RAK12029 module (inductive sensor)\nm_lora_app_data.buffer[i++] = (uint8_t)((channel_data & 0xFF000000) >> 24);    // byte[5]\nm_lora_app_data.buffer[i++] = (uint8_t)((channel_data & 0x00FF0000) >> 16);    // byte[6]\nm_lora_app_data.buffer[i++] = (uint8_t)((channel_data & 0x0000FF00) >> 8);     // byte[7]\nm_lora_app_data.buffer[i++] = (uint8_t)(channel_data & 0x000000FF);            // byte[8]\n\n// Data from RAK13001 module (relay module status)\nm_lora_app_data.buffer[i++] = metallic_data;                                   // byte[9]\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS) {\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n} else {\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xC0, 0x81, 0xBB, 0x65, 0x54, 0xCF, 0xF7, 0x65, 0x87, 0x70, 0xFD, 0x31, 0x7F, 0x01, 0x87, 0x51 };\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "f685fe690ff040edd9eb590fff1a8d07", "product_family": "wisblock", "product_id": "kit4-industrial", "category": "How-To", "title": "WisBlock IoT Education Kit - Smart Industry Quick Start Guide > WisBlock IoT Education Kit - Smart Industry Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock Smart Industry Kit using TTN and Quibitro > Material Classifier LoRaWAN Application > LoRaWAN Code for Material Classifier > Programming the Material Classifier Device with LoRaWAN Application [CODE]", "content": "uint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xC0, 0x81, 0xBB, 0x65, 0x54, 0xCF, 0xF7, 0x65, 0x87, 0x70, 0xFD, 0x31, 0x7F, 0x01, 0x87, 0x51 };\n```  \n> **Image:** Device's credentials registered in TTN", "keywords": ["Arduino IDE", "RAK4631", "Material Classifier", "LoRaWAN", "SX126x-Arduino"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **Material Classifier** device. Just copy the code below for **Material Classifier LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the code</summary>  \n```c\n\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h>  //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n// For RAK12014 module\n#include <vl53l0x_class.h>    // Click to install library: http://librarymanager/All#stm32duino_vl53l0x\nVL53L0X sensor_vl53l0x(&Wire, WB_IO2);\n\nuint32_t distance;\nint status;\n\n// For RAK13001 module\n#define RELAY_PIN WB_IO4\nint object;\n\n// For RAK12029 module\n#include \"RAK12029_LDC1614.h\"\n\n#define INDUCTANCE 13.000\n#define CAPATANCE 100.0\n#define GETCHANNEL LDC1614_CHANNEL_0     // LDC1614_CHANNEL_(0~3); selecting the coil channel from 0 - 3\nRAK12029_LDC1614_Inductive ldc;\n\nu16 value = 0;\nu32 ChannelData = 0;\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define RAK4631_BOARD true\n#else\n#define RAK4631_BOARD false\n#endif\n\nbool doOTAA = true;                                               // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                                       /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                                     /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5                               /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                                        /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;                           /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;                 /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                              /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = { LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF };\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = { BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler };\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xC0, 0x81, 0xBB, 0x65, 0x54, 0xCF, 0xF7, 0x65, 0x87, 0x70, 0xFD, 0x31, 0x7F, 0x01, 0x87, 0x51 };\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };\nuint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                                            /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];               //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = { m_lora_app_data_buffer, 0, 0, 0, 0 };  //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {\n// Sensor Power Switch\npinMode(WB_IO2, OUTPUT);\ndigitalWrite(WB_IO2, HIGH);\n\n// Control Chip Switch\npinMode(WB_IO5, OUTPUT);\ndigitalWrite(WB_IO5, LOW);\n\n// Control Relay Module\npinMode(RELAY_PIN,OUTPUT);\ndigitalWrite(RELAY_PIN, LOW);    // relay module initially LOW\n\npinMode(LED_GREEN, OUTPUT);      // Output LED\npinMode(LED_BLUE, OUTPUT);       // Output LED\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial) {\nif ((millis() - timeout) < 5000) {\ndelay(100);\n} else {\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA) {\nSerial.println(\"Type: OTAA\");\n} else {\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion) {\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA) {\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n} else {\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0) {\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"===========================================\");\nSerial.println(\"RAK12014 + RAK12029 + RAK13001 LoRaWAN Code\");\nSerial.println(\"===========================================\");\n\nWire.begin();\n\n// Configure VL53L0X component.\nsensor_vl53l0x.begin();\n\n// Switch off VL53L0X component.\nsensor_vl53l0x.VL53L0X_Off();\n\n// Initialize VL53L0X component.\nstatus = sensor_vl53l0x.InitSensor(0x52);\nif (status) {\nSerial.println(\"Init sensor_vl53l0x failed...\");\n}\n\n// From RAK12029\nldc.LDC1614_init();\n/*single channel use case configuration.*/\nif (ldc.LDC1614_single_channel_config(GETCHANNEL, INDUCTANCE, CAPATANCE)) {\nSerial.println(\"can't detect sensor!\");\nwhile (1) delay(100);\n}\n}\n\nvoid loop() {\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\n// Read data from RAK12014\nstatus = sensor_vl53l0x.GetDistance(&distance);\n\n// Read data from RAK12029\nldc.IIC_read_16bit(LDC1614_READ_DEVICE_ID, &value);\nif (value == 0x3055) {\n//u32 ChannelData = 0;\n/*Get channel 0 result and parse it.*/\ndelay(100);\nif (ldc.LDC1614_get_channel_result(GETCHANNEL, &ChannelData) == 0) {\n/*sensor result value.you can make a lot of application according to its changes.*/\nif (0 != ChannelData) {\ndigitalWrite(LED_BLUE, HIGH);     // Indicator Blue LED\ndigitalWrite(LED_GREEN, HIGH);    // Indicator Green LED\n}\ndelay(200);\ndigitalWrite(LED_BLUE, LOW);        // Indicator Blue LED\ndigitalWrite(LED_GREEN, LOW);       // Indicator Green LED\n}\n}\n\nif (ChannelData >= 49800000)            // metallic material sensed nearby via inductive sensor\n{\ndigitalWrite(RELAY_PIN, HIGH);        // Turns ON the relay module\nobject = 1;                           // \"1\" corresponds to metallic object\nSerial.println(\"Metal Detected\");\n}\n\nelse if (ChannelData <= 49650000)       // nothing metallic was sensed; default value sensed by the inductive sensor\n{\ndigitalWrite(RELAY_PIN, LOW);         // Turns OFF the relay module\nobject = 0;                           // \"0\" corresponds to non-metallic object\nSerial.println(\"No Metal Detected\");\n}\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\nSerial.print(distance);       // From RAK12014 module\nSerial.println(\"mm   \");\nSerial.println(object);       // From RAK13001 module\nSerial.println(ChannelData);  // From RAK12029 module\n\ndelay(5000);\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void) {\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void) {\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data) {\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class) {\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void) {\nif (lmh_join_status_get() != LMH_SET) {\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\ndata = \" Distance: \" + String(distance) + \" mm \" + \" Metallic: \" + String(object) + \" Inductive_Sense: \" + String(ChannelData);\nSerial.println(data);\n\nuint32_t distance_data = distance;    // data from RAK12014 module\nuint32_t channel_data = ChannelData;  // data from RAK12029 module\nint metallic_data = object;           // data from RAK13001 module\n\nm_lora_app_data.buffer[i++] = 0x01;  // byte[0]\n\n// Data from RAK12014 module\nm_lora_app_data.buffer[i++] = (uint8_t)((distance_data & 0xFF000000) >> 24);    // byte[1]\nm_lora_app_data.buffer[i++] = (uint8_t)((distance_data & 0x00FF0000) >> 16);    // byte[2]\nm_lora_app_data.buffer[i++] = (uint8_t)((distance_data & 0x0000FF00) >> 8);     // byte[3]\nm_lora_app_data.buffer[i++] = (uint8_t)(distance_data & 0x000000FF);            // byte[4]\n\n// Data from RAK12029 module (inductive sensor)\nm_lora_app_data.buffer[i++] = (uint8_t)((channel_data & 0xFF000000) >> 24);    // byte[5]\nm_lora_app_data.buffer[i++] = (uint8_t)((channel_data & 0x00FF0000) >> 16);    // byte[6]\nm_lora_app_data.buffer[i++] = (uint8_t)((channel_data & 0x0000FF00) >> 8);     // byte[7]\nm_lora_app_data.buffer[i++] = (uint8_t)(channel_data & 0x000000FF);            // byte[8]\n\n// Data from RAK13001 module (relay module status)\nm_lora_app_data.buffer[i++] = metallic_data;                                   // byte[9]\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS) {\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n} else {\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xC0, 0x81, 0xBB, 0x65, 0x54, 0xCF, 0xF7, 0x65, 0x87, 0x70, 0xFD, 0x31, 0x7F, 0x01, 0x87, 0x51 };\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "be74de79b501b9f3f02f53b9c6dd274d", "product_family": "wisblock", "product_id": "kit4-industrial", "category": "How-To", "title": "WisBlock IoT Education Kit - Smart Industry Quick Start Guide > WisBlock IoT Education Kit - Smart Industry Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock Smart Industry Kit using TTN and Quibitro > Material Classifier LoRaWAN Application > LoRaWAN Code for Material Classifier > Programming the Material Classifier Device with LoRaWAN Application [CODE]", "content": "```  \n> **Image:** Device's credentials registered in TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.", "keywords": ["Arduino IDE", "RAK4631", "Material Classifier", "LoRaWAN", "SX126x-Arduino"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **Material Classifier** device. Just copy the code below for **Material Classifier LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the code</summary>  \n```c\n\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h>  //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n// For RAK12014 module\n#include <vl53l0x_class.h>    // Click to install library: http://librarymanager/All#stm32duino_vl53l0x\nVL53L0X sensor_vl53l0x(&Wire, WB_IO2);\n\nuint32_t distance;\nint status;\n\n// For RAK13001 module\n#define RELAY_PIN WB_IO4\nint object;\n\n// For RAK12029 module\n#include \"RAK12029_LDC1614.h\"\n\n#define INDUCTANCE 13.000\n#define CAPATANCE 100.0\n#define GETCHANNEL LDC1614_CHANNEL_0     // LDC1614_CHANNEL_(0~3); selecting the coil channel from 0 - 3\nRAK12029_LDC1614_Inductive ldc;\n\nu16 value = 0;\nu32 ChannelData = 0;\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define RAK4631_BOARD true\n#else\n#define RAK4631_BOARD false\n#endif\n\nbool doOTAA = true;                                               // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                                       /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                                     /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5                               /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                                        /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;                           /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;                 /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                              /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = { LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF };\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = { BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler };\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xC0, 0x81, 0xBB, 0x65, 0x54, 0xCF, 0xF7, 0x65, 0x87, 0x70, 0xFD, 0x31, 0x7F, 0x01, 0x87, 0x51 };\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };\nuint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                                            /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];               //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = { m_lora_app_data_buffer, 0, 0, 0, 0 };  //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {\n// Sensor Power Switch\npinMode(WB_IO2, OUTPUT);\ndigitalWrite(WB_IO2, HIGH);\n\n// Control Chip Switch\npinMode(WB_IO5, OUTPUT);\ndigitalWrite(WB_IO5, LOW);\n\n// Control Relay Module\npinMode(RELAY_PIN,OUTPUT);\ndigitalWrite(RELAY_PIN, LOW);    // relay module initially LOW\n\npinMode(LED_GREEN, OUTPUT);      // Output LED\npinMode(LED_BLUE, OUTPUT);       // Output LED\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial) {\nif ((millis() - timeout) < 5000) {\ndelay(100);\n} else {\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA) {\nSerial.println(\"Type: OTAA\");\n} else {\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion) {\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA) {\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n} else {\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0) {\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"===========================================\");\nSerial.println(\"RAK12014 + RAK12029 + RAK13001 LoRaWAN Code\");\nSerial.println(\"===========================================\");\n\nWire.begin();\n\n// Configure VL53L0X component.\nsensor_vl53l0x.begin();\n\n// Switch off VL53L0X component.\nsensor_vl53l0x.VL53L0X_Off();\n\n// Initialize VL53L0X component.\nstatus = sensor_vl53l0x.InitSensor(0x52);\nif (status) {\nSerial.println(\"Init sensor_vl53l0x failed...\");\n}\n\n// From RAK12029\nldc.LDC1614_init();\n/*single channel use case configuration.*/\nif (ldc.LDC1614_single_channel_config(GETCHANNEL, INDUCTANCE, CAPATANCE)) {\nSerial.println(\"can't detect sensor!\");\nwhile (1) delay(100);\n}\n}\n\nvoid loop() {\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\n// Read data from RAK12014\nstatus = sensor_vl53l0x.GetDistance(&distance);\n\n// Read data from RAK12029\nldc.IIC_read_16bit(LDC1614_READ_DEVICE_ID, &value);\nif (value == 0x3055) {\n//u32 ChannelData = 0;\n/*Get channel 0 result and parse it.*/\ndelay(100);\nif (ldc.LDC1614_get_channel_result(GETCHANNEL, &ChannelData) == 0) {\n/*sensor result value.you can make a lot of application according to its changes.*/\nif (0 != ChannelData) {\ndigitalWrite(LED_BLUE, HIGH);     // Indicator Blue LED\ndigitalWrite(LED_GREEN, HIGH);    // Indicator Green LED\n}\ndelay(200);\ndigitalWrite(LED_BLUE, LOW);        // Indicator Blue LED\ndigitalWrite(LED_GREEN, LOW);       // Indicator Green LED\n}\n}\n\nif (ChannelData >= 49800000)            // metallic material sensed nearby via inductive sensor\n{\ndigitalWrite(RELAY_PIN, HIGH);        // Turns ON the relay module\nobject = 1;                           // \"1\" corresponds to metallic object\nSerial.println(\"Metal Detected\");\n}\n\nelse if (ChannelData <= 49650000)       // nothing metallic was sensed; default value sensed by the inductive sensor\n{\ndigitalWrite(RELAY_PIN, LOW);         // Turns OFF the relay module\nobject = 0;                           // \"0\" corresponds to non-metallic object\nSerial.println(\"No Metal Detected\");\n}\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\nSerial.print(distance);       // From RAK12014 module\nSerial.println(\"mm   \");\nSerial.println(object);       // From RAK13001 module\nSerial.println(ChannelData);  // From RAK12029 module\n\ndelay(5000);\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void) {\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void) {\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data) {\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class) {\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void) {\nif (lmh_join_status_get() != LMH_SET) {\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\ndata = \" Distance: \" + String(distance) + \" mm \" + \" Metallic: \" + String(object) + \" Inductive_Sense: \" + String(ChannelData);\nSerial.println(data);\n\nuint32_t distance_data = distance;    // data from RAK12014 module\nuint32_t channel_data = ChannelData;  // data from RAK12029 module\nint metallic_data = object;           // data from RAK13001 module\n\nm_lora_app_data.buffer[i++] = 0x01;  // byte[0]\n\n// Data from RAK12014 module\nm_lora_app_data.buffer[i++] = (uint8_t)((distance_data & 0xFF000000) >> 24);    // byte[1]\nm_lora_app_data.buffer[i++] = (uint8_t)((distance_data & 0x00FF0000) >> 16);    // byte[2]\nm_lora_app_data.buffer[i++] = (uint8_t)((distance_data & 0x0000FF00) >> 8);     // byte[3]\nm_lora_app_data.buffer[i++] = (uint8_t)(distance_data & 0x000000FF);            // byte[4]\n\n// Data from RAK12029 module (inductive sensor)\nm_lora_app_data.buffer[i++] = (uint8_t)((channel_data & 0xFF000000) >> 24);    // byte[5]\nm_lora_app_data.buffer[i++] = (uint8_t)((channel_data & 0x00FF0000) >> 16);    // byte[6]\nm_lora_app_data.buffer[i++] = (uint8_t)((channel_data & 0x0000FF00) >> 8);     // byte[7]\nm_lora_app_data.buffer[i++] = (uint8_t)(channel_data & 0x000000FF);            // byte[8]\n\n// Data from RAK13001 module (relay module status)\nm_lora_app_data.buffer[i++] = metallic_data;                                   // byte[9]\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS) {\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n} else {\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xC0, 0x81, 0xBB, 0x65, 0x54, 0xCF, 0xF7, 0x65, 0x87, 0x70, 0xFD, 0x31, 0x7F, 0x01, 0x87, 0x51 };\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "0bad201633553701e5dcf111c264870a", "product_family": "wisblock", "product_id": "kit4-industrial", "category": "How-To", "title": "WisBlock IoT Education Kit - Smart Industry Quick Start Guide > WisBlock IoT Education Kit - Smart Industry Quick Start Guide > Product Configuration > Software Configuration and Examples > LoRaWAN Applications for WisBlock Smart Industry Kit using TTN and Quibitro > Material Classifier LoRaWAN Application > LoRaWAN Code for Material Classifier > Programming the Material Classifier Device with LoRaWAN Application [CODE]", "content": "> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board", "keywords": ["Arduino IDE", "RAK4631", "Material Classifier", "LoRaWAN", "SX126x-Arduino"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed to your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you haven't yet installed the **Arduino IDE**, please refer to this [link](#arduino-ide-installation-rak4631) for the steps.  \n2. After the installation, you can now proceed programming your **Material Classifier** device. Just copy the code below for **Material Classifier LoRaWAN Application** and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n<details>\n<summary> Click to view the code</summary>  \n```c\n\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h>  //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n// For RAK12014 module\n#include <vl53l0x_class.h>    // Click to install library: http://librarymanager/All#stm32duino_vl53l0x\nVL53L0X sensor_vl53l0x(&Wire, WB_IO2);\n\nuint32_t distance;\nint status;\n\n// For RAK13001 module\n#define RELAY_PIN WB_IO4\nint object;\n\n// For RAK12029 module\n#include \"RAK12029_LDC1614.h\"\n\n#define INDUCTANCE 13.000\n#define CAPATANCE 100.0\n#define GETCHANNEL LDC1614_CHANNEL_0     // LDC1614_CHANNEL_(0~3); selecting the coil channel from 0 - 3\nRAK12029_LDC1614_Inductive ldc;\n\nu16 value = 0;\nu32 ChannelData = 0;\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define RAK4631_BOARD true\n#else\n#define RAK4631_BOARD false\n#endif\n\nbool doOTAA = true;                                               // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                                       /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                                     /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5                               /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                                        /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;                           /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;           /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;                 /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                              /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = { LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF };\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = { BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler };\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xC0, 0x81, 0xBB, 0x65, 0x54, 0xCF, 0xF7, 0x65, 0x87, 0x70, 0xFD, 0x31, 0x7F, 0x01, 0x87, 0x51 };\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };\nuint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                                            /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];               //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = { m_lora_app_data_buffer, 0, 0, 0, 0 };  //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup() {\n// Sensor Power Switch\npinMode(WB_IO2, OUTPUT);\ndigitalWrite(WB_IO2, HIGH);\n\n// Control Chip Switch\npinMode(WB_IO5, OUTPUT);\ndigitalWrite(WB_IO5, LOW);\n\n// Control Relay Module\npinMode(RELAY_PIN,OUTPUT);\ndigitalWrite(RELAY_PIN, LOW);    // relay module initially LOW\n\npinMode(LED_GREEN, OUTPUT);      // Output LED\npinMode(LED_BLUE, OUTPUT);       // Output LED\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial) {\nif ((millis() - timeout) < 5000) {\ndelay(100);\n} else {\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA) {\nSerial.println(\"Type: OTAA\");\n} else {\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion) {\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA) {\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n} else {\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0) {\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"===========================================\");\nSerial.println(\"RAK12014 + RAK12029 + RAK13001 LoRaWAN Code\");\nSerial.println(\"===========================================\");\n\nWire.begin();\n\n// Configure VL53L0X component.\nsensor_vl53l0x.begin();\n\n// Switch off VL53L0X component.\nsensor_vl53l0x.VL53L0X_Off();\n\n// Initialize VL53L0X component.\nstatus = sensor_vl53l0x.InitSensor(0x52);\nif (status) {\nSerial.println(\"Init sensor_vl53l0x failed...\");\n}\n\n// From RAK12029\nldc.LDC1614_init();\n/*single channel use case configuration.*/\nif (ldc.LDC1614_single_channel_config(GETCHANNEL, INDUCTANCE, CAPATANCE)) {\nSerial.println(\"can't detect sensor!\");\nwhile (1) delay(100);\n}\n}\n\nvoid loop() {\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\n// Read data from RAK12014\nstatus = sensor_vl53l0x.GetDistance(&distance);\n\n// Read data from RAK12029\nldc.IIC_read_16bit(LDC1614_READ_DEVICE_ID, &value);\nif (value == 0x3055) {\n//u32 ChannelData = 0;\n/*Get channel 0 result and parse it.*/\ndelay(100);\nif (ldc.LDC1614_get_channel_result(GETCHANNEL, &ChannelData) == 0) {\n/*sensor result value.you can make a lot of application according to its changes.*/\nif (0 != ChannelData) {\ndigitalWrite(LED_BLUE, HIGH);     // Indicator Blue LED\ndigitalWrite(LED_GREEN, HIGH);    // Indicator Green LED\n}\ndelay(200);\ndigitalWrite(LED_BLUE, LOW);        // Indicator Blue LED\ndigitalWrite(LED_GREEN, LOW);       // Indicator Green LED\n}\n}\n\nif (ChannelData >= 49800000)            // metallic material sensed nearby via inductive sensor\n{\ndigitalWrite(RELAY_PIN, HIGH);        // Turns ON the relay module\nobject = 1;                           // \"1\" corresponds to metallic object\nSerial.println(\"Metal Detected\");\n}\n\nelse if (ChannelData <= 49650000)       // nothing metallic was sensed; default value sensed by the inductive sensor\n{\ndigitalWrite(RELAY_PIN, LOW);         // Turns OFF the relay module\nobject = 0;                           // \"0\" corresponds to non-metallic object\nSerial.println(\"No Metal Detected\");\n}\n\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\n\nSerial.print(distance);       // From RAK12014 module\nSerial.println(\"mm   \");\nSerial.println(object);       // From RAK13001 module\nSerial.println(ChannelData);  // From RAK12029 module\n\ndelay(5000);\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void) {\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void) {\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data) {\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class) {\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void) {\nif (lmh_join_status_get() != LMH_SET) {\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\ndata = \" Distance: \" + String(distance) + \" mm \" + \" Metallic: \" + String(object) + \" Inductive_Sense: \" + String(ChannelData);\nSerial.println(data);\n\nuint32_t distance_data = distance;    // data from RAK12014 module\nuint32_t channel_data = ChannelData;  // data from RAK12029 module\nint metallic_data = object;           // data from RAK13001 module\n\nm_lora_app_data.buffer[i++] = 0x01;  // byte[0]\n\n// Data from RAK12014 module\nm_lora_app_data.buffer[i++] = (uint8_t)((distance_data & 0xFF000000) >> 24);    // byte[1]\nm_lora_app_data.buffer[i++] = (uint8_t)((distance_data & 0x00FF0000) >> 16);    // byte[2]\nm_lora_app_data.buffer[i++] = (uint8_t)((distance_data & 0x0000FF00) >> 8);     // byte[3]\nm_lora_app_data.buffer[i++] = (uint8_t)(distance_data & 0x000000FF);            // byte[4]\n\n// Data from RAK12029 module (inductive sensor)\nm_lora_app_data.buffer[i++] = (uint8_t)((channel_data & 0xFF000000) >> 24);    // byte[5]\nm_lora_app_data.buffer[i++] = (uint8_t)((channel_data & 0x00FF0000) >> 16);    // byte[6]\nm_lora_app_data.buffer[i++] = (uint8_t)((channel_data & 0x0000FF00) >> 8);     // byte[7]\nm_lora_app_data.buffer[i++] = (uint8_t)(channel_data & 0x000000FF);            // byte[8]\n\n// Data from RAK13001 module (relay module status)\nm_lora_app_data.buffer[i++] = metallic_data;                                   // byte[9]\n\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS) {\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n} else {\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```\n</details>  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The steps below will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired region to work with. You can change this to a region that is applicable to you like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc. Below is the table of LoRaWAN regions and their respective countries where they are used in:  \n|     LoRaWAN Region      |                               Usage                                  |\n| ----------------------- | -------------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1  | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan             |\n| LORAMAC_REGION_AS923-2  | Vietnam                                                              |\n| LORAMAC_REGION_AS923-3  | Philippines, Albania, Algeria, Denmark, Greenland, Jordan            |\n| LORAMAC_REGION_AS923-4  | Israel                                                               |\n| LORAMAC_REGION_AU915    | Australia, Anguilla, Argentina, and many parts of South America      |\n| LORAMAC_REGION_CN470    | China                                                                |\n| LORAMAC_REGION_EU433    | EU, UK, Brazil, Costa Rica, Cuba, and many parts of Africa           |\n| LORAMAC_REGION_IN865    | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger    |\n| LORAMAC_REGION_EU868    | EU, UK and many parts of Africa                                      |\n| LORAMAC_REGION_KR920    | Republic of Korea                                                    |\n| LORAMAC_REGION_US915    | USA                                                                  |\n| LORAMAC_REGION_RU864    | Russia                                                               |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n```\n- Set up the LoRaWAN activation method. In this case, we will be using the **OTAA** configuration which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n```  \n- Setup the EUIs and KEY. The **DeviceEUI**, **AppEUI** and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = { 0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9 };\nuint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nuint8_t nodeAppKey[16] = { 0xC0, 0x81, 0xBB, 0x65, 0x54, 0xCF, 0xF7, 0x65, 0x87, 0x70, 0xFD, 0x31, 0x7F, 0x01, 0x87, 0x51 };\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once done with the code, you can now proceed uploading it into your device. You need to select first your RAK4631 board from desktop or laptop. To do this, go to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** > **WisBlock RAK4631**. After you selected your board, you need to select the specific port of your board. To do this, go to **Tools** > **Port** > then the specific port of your board.  \n> **Image:** Selecting the RAK4631 board  \n> **Image:** Selecting the port of RAK4631 board  \n4. Once done, you can now upload your code. Simply click the right arrow sign at the upper left portion of your Arduino IDE. Once done, you will see the **Device programmed** notification at the bottom part of your Arduino IDE.  \n> **Image:** Uploading your code into your RAK4631 board  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "3137d85e34d33438985e2084b9a5e384", "product_family": "wisblock", "product_id": "kit4-industrial", "category": "How-To", "title": "WisBlock IoT Education Kit - Smart Industry Quick Start Guide > WisBlock IoT Education Kit - Smart Industry Quick Start Guide > Miscellaneous > TTN Account Creation > How to Register an Application on The Things Network (TTN)", "content": "1. The first step is to go to [The Things Network](https://www.thethingsnetwork.org/) and sign up an account shown in the figure below. Then select a cluster as shown in the figure below.  \n> **Image:** Signing up an account in TTN  \n> **Image:** Signing up an account in TTN  \n> **Image:** Selecting Cluster in TTN  \n> **Image:** Signing up through the Things ID  \n> **Image:** Creation of an account through the Things ID  \n> **Image:** Creation of an account through the Things ID", "keywords": ["The Things Network", "TTN", "application registration", "LoRaWAN", "RAK16002"], "source_file": "quickstart.md", "token_count": 250, "parent_content": "1. The first step is to go to [The Things Network](https://www.thethingsnetwork.org/) and sign up an account shown in the figure below. Then select a cluster as shown in the figure below.  \n> **Image:** Signing up an account in TTN  \n> **Image:** Signing up an account in TTN  \n> **Image:** Selecting Cluster in TTN  \n> **Image:** Signing up through the Things ID  \n> **Image:** Creation of an account through the Things ID  \n> **Image:** Creation of an account through the Things ID  \nYou can use the same login credentials on the TTN V2 if you have one. If you have no account yet, you need to create one.  \n2. Now that you are logged in to the platform, the next step is to create an application. Click **Create an application**.  \n> **Image:** The Things Stack Platform  \n> **Image:** Creating TTN Application of your LoRaWAN devices  \n3. To have an application registered, input first the specific details and necessary information about your application then click **Create application**.  \n> **Image:** Details of the TTN application  \n> **TIP:** NOTE  \nThe details and information are dependent to what device you are using (e.g. **RAK16002**, etc.).  \n4. If you have no error on the previous step, you should now be on the application console page.  \n> **TIP:** NOTE  \nAbove procedures are applicable to all applications you will be using.  \n- For **Battery Monitoring**, go to this [link](#battery-monitoring-ttn-registration-section-and-device-registration) once done with the TTN account creation.\n- For **Material Classifier**, go to this [link](#material-classifier-ttn-registration-section-and-device-registration) once done with the TTN account creation."}
{"id": "39881f95f1ca9e49362f071a8b4c9e93", "product_family": "wisblock", "product_id": "kit4-industrial", "category": "How-To", "title": "WisBlock IoT Education Kit - Smart Industry Quick Start Guide > WisBlock IoT Education Kit - Smart Industry Quick Start Guide > Miscellaneous > TTN Account Creation > How to Register an Application on The Things Network (TTN)", "content": "> **Image:** Creation of an account through the Things ID  \nYou can use the same login credentials on the TTN V2 if you have one. If you have no account yet, you need to create one.  \n2. Now that you are logged in to the platform, the next step is to create an application. Click **Create an application**.  \n> **Image:** The Things Stack Platform  \n> **Image:** Creating TTN Application of your LoRaWAN devices", "keywords": ["The Things Network", "TTN", "application registration", "LoRaWAN", "RAK16002"], "source_file": "quickstart.md", "token_count": 250, "parent_content": "1. The first step is to go to [The Things Network](https://www.thethingsnetwork.org/) and sign up an account shown in the figure below. Then select a cluster as shown in the figure below.  \n> **Image:** Signing up an account in TTN  \n> **Image:** Signing up an account in TTN  \n> **Image:** Selecting Cluster in TTN  \n> **Image:** Signing up through the Things ID  \n> **Image:** Creation of an account through the Things ID  \n> **Image:** Creation of an account through the Things ID  \nYou can use the same login credentials on the TTN V2 if you have one. If you have no account yet, you need to create one.  \n2. Now that you are logged in to the platform, the next step is to create an application. Click **Create an application**.  \n> **Image:** The Things Stack Platform  \n> **Image:** Creating TTN Application of your LoRaWAN devices  \n3. To have an application registered, input first the specific details and necessary information about your application then click **Create application**.  \n> **Image:** Details of the TTN application  \n> **TIP:** NOTE  \nThe details and information are dependent to what device you are using (e.g. **RAK16002**, etc.).  \n4. If you have no error on the previous step, you should now be on the application console page.  \n> **TIP:** NOTE  \nAbove procedures are applicable to all applications you will be using.  \n- For **Battery Monitoring**, go to this [link](#battery-monitoring-ttn-registration-section-and-device-registration) once done with the TTN account creation.\n- For **Material Classifier**, go to this [link](#material-classifier-ttn-registration-section-and-device-registration) once done with the TTN account creation."}
{"id": "bf33dd3b46f4f9995ce408a8d4ccc810", "product_family": "wisblock", "product_id": "kit4-industrial", "category": "How-To", "title": "WisBlock IoT Education Kit - Smart Industry Quick Start Guide > WisBlock IoT Education Kit - Smart Industry Quick Start Guide > Miscellaneous > TTN Account Creation > How to Register an Application on The Things Network (TTN)", "content": "> **Image:** Creating TTN Application of your LoRaWAN devices  \n3. To have an application registered, input first the specific details and necessary information about your application then click **Create application**.  \n> **Image:** Details of the TTN application  \n> **TIP:** NOTE  \nThe details and information are dependent to what device you are using (e.g. **RAK16002**, etc.).  \n4. If you have no error on the previous step, you should now be on the application console page.", "keywords": ["The Things Network", "TTN", "application registration", "LoRaWAN", "RAK16002"], "source_file": "quickstart.md", "token_count": 250, "parent_content": "1. The first step is to go to [The Things Network](https://www.thethingsnetwork.org/) and sign up an account shown in the figure below. Then select a cluster as shown in the figure below.  \n> **Image:** Signing up an account in TTN  \n> **Image:** Signing up an account in TTN  \n> **Image:** Selecting Cluster in TTN  \n> **Image:** Signing up through the Things ID  \n> **Image:** Creation of an account through the Things ID  \n> **Image:** Creation of an account through the Things ID  \nYou can use the same login credentials on the TTN V2 if you have one. If you have no account yet, you need to create one.  \n2. Now that you are logged in to the platform, the next step is to create an application. Click **Create an application**.  \n> **Image:** The Things Stack Platform  \n> **Image:** Creating TTN Application of your LoRaWAN devices  \n3. To have an application registered, input first the specific details and necessary information about your application then click **Create application**.  \n> **Image:** Details of the TTN application  \n> **TIP:** NOTE  \nThe details and information are dependent to what device you are using (e.g. **RAK16002**, etc.).  \n4. If you have no error on the previous step, you should now be on the application console page.  \n> **TIP:** NOTE  \nAbove procedures are applicable to all applications you will be using.  \n- For **Battery Monitoring**, go to this [link](#battery-monitoring-ttn-registration-section-and-device-registration) once done with the TTN account creation.\n- For **Material Classifier**, go to this [link](#material-classifier-ttn-registration-section-and-device-registration) once done with the TTN account creation."}
{"id": "11fffd84b1c7f7f73b848cc9fb704e16", "product_family": "wisblock", "product_id": "kit4-industrial", "category": "How-To", "title": "WisBlock IoT Education Kit - Smart Industry Quick Start Guide > WisBlock IoT Education Kit - Smart Industry Quick Start Guide > Miscellaneous > TTN Account Creation > How to Register an Application on The Things Network (TTN)", "content": "4. If you have no error on the previous step, you should now be on the application console page.  \n> **TIP:** NOTE  \nAbove procedures are applicable to all applications you will be using.  \n- For **Battery Monitoring**, go to this [link](#battery-monitoring-ttn-registration-section-and-device-registration) once done with the TTN account creation.", "keywords": ["The Things Network", "TTN", "application registration", "LoRaWAN", "RAK16002"], "source_file": "quickstart.md", "token_count": 250, "parent_content": "1. The first step is to go to [The Things Network](https://www.thethingsnetwork.org/) and sign up an account shown in the figure below. Then select a cluster as shown in the figure below.  \n> **Image:** Signing up an account in TTN  \n> **Image:** Signing up an account in TTN  \n> **Image:** Selecting Cluster in TTN  \n> **Image:** Signing up through the Things ID  \n> **Image:** Creation of an account through the Things ID  \n> **Image:** Creation of an account through the Things ID  \nYou can use the same login credentials on the TTN V2 if you have one. If you have no account yet, you need to create one.  \n2. Now that you are logged in to the platform, the next step is to create an application. Click **Create an application**.  \n> **Image:** The Things Stack Platform  \n> **Image:** Creating TTN Application of your LoRaWAN devices  \n3. To have an application registered, input first the specific details and necessary information about your application then click **Create application**.  \n> **Image:** Details of the TTN application  \n> **TIP:** NOTE  \nThe details and information are dependent to what device you are using (e.g. **RAK16002**, etc.).  \n4. If you have no error on the previous step, you should now be on the application console page.  \n> **TIP:** NOTE  \nAbove procedures are applicable to all applications you will be using.  \n- For **Battery Monitoring**, go to this [link](#battery-monitoring-ttn-registration-section-and-device-registration) once done with the TTN account creation.\n- For **Material Classifier**, go to this [link](#material-classifier-ttn-registration-section-and-device-registration) once done with the TTN account creation."}
{"id": "5e20564f5ada550bd71c18e51634f500", "product_family": "wisblock", "product_id": "kit4-industrial", "category": "How-To", "title": "WisBlock IoT Education Kit - Smart Industry Quick Start Guide > WisBlock IoT Education Kit - Smart Industry Quick Start Guide > Miscellaneous > TTN Account Creation > How to Register an Application on The Things Network (TTN)", "content": "- For **Material Classifier**, go to this [link](#material-classifier-ttn-registration-section-and-device-registration) once done with the TTN account creation.", "keywords": ["The Things Network", "TTN", "application registration", "LoRaWAN", "RAK16002"], "source_file": "quickstart.md", "token_count": 250, "parent_content": "1. The first step is to go to [The Things Network](https://www.thethingsnetwork.org/) and sign up an account shown in the figure below. Then select a cluster as shown in the figure below.  \n> **Image:** Signing up an account in TTN  \n> **Image:** Signing up an account in TTN  \n> **Image:** Selecting Cluster in TTN  \n> **Image:** Signing up through the Things ID  \n> **Image:** Creation of an account through the Things ID  \n> **Image:** Creation of an account through the Things ID  \nYou can use the same login credentials on the TTN V2 if you have one. If you have no account yet, you need to create one.  \n2. Now that you are logged in to the platform, the next step is to create an application. Click **Create an application**.  \n> **Image:** The Things Stack Platform  \n> **Image:** Creating TTN Application of your LoRaWAN devices  \n3. To have an application registered, input first the specific details and necessary information about your application then click **Create application**.  \n> **Image:** Details of the TTN application  \n> **TIP:** NOTE  \nThe details and information are dependent to what device you are using (e.g. **RAK16002**, etc.).  \n4. If you have no error on the previous step, you should now be on the application console page.  \n> **TIP:** NOTE  \nAbove procedures are applicable to all applications you will be using.  \n- For **Battery Monitoring**, go to this [link](#battery-monitoring-ttn-registration-section-and-device-registration) once done with the TTN account creation.\n- For **Material Classifier**, go to this [link](#material-classifier-ttn-registration-section-and-device-registration) once done with the TTN account creation."}
{"id": "ef6694cf54524a89c0660c29bf673c8a", "product_family": "wisblock", "product_id": "kit4-industrial", "category": "How-To", "title": "WisBlock IoT Education Kit - Smart Industry Quick Start Guide > WisBlock IoT Education Kit - Smart Industry Quick Start Guide > Miscellaneous > Device Registration > Registering an OTAA End-Device on TTN Console", "content": "1. Go to your application console to register a device. To start adding an OTAA end-device, click **+ Register end device**, as shown below.  \n> **Image:** Register End Device  \n2. To register the board, click the **Enter end device specifics manually**.  \n> **Image:** Enter end device specifics manually", "keywords": ["OTAA", "TTN", "end-device", "registration", "LoRaWAN"], "source_file": "quickstart.md", "token_count": 0, "parent_content": "1. Go to your application console to register a device. To start adding an OTAA end-device, click **+ Register end device**, as shown below.  \n> **Image:** Register End Device  \n2. To register the board, click the **Enter end device specifics manually**.  \n> **Image:** Enter end device specifics manually  \n3. Next step is to set up **Frequency plan**, compatible **LoRaWAN version**, and **Regional Parameters version** supported. Then provide the **JoinEUI** credentials by entering zeroes into it.  \n> **Image:** Setting up your device  \n> **Image:** Setting up your device  \n4. Then click **Show advanced activation, LoRaWAN class and cluster settings**. Configure the activation mode by selecting **Over the air activation (OTAA)** and Additional LoRaWAN class capabilities to **class A only**. Then click **Confirm**.  \n> **Image:** Setting up your device  \n> **Image:** Setting up your device  \n5. Once done, provide the DevEUI credentials of your device into the **DevEUI** portion. This will automatically generate the specific End\ndevice ID of your board. Then click **Generate** under **AppKey** under Provisioning information section. Once done, you need to change the **End device ID** since it is automatically prefilled using the **DevEUI** of your device. Then click **Register end device**.  \n> **TIP:** NOTE  \n- The **AppEUI**, **DevEUI**, and **AppKey** are hidden in this section as these are unique from a specific device. The **DevEUI** credential is unique to every **RAK4631** device. Also, you should generate your own **AppEUI** and **AppKey** credentials for your specific device and application.  \n- The **AppEUI** is the same as **JoinEUI**.  \n- The details under **End device ID** are dependent to what device you are using (e.g. **rak16002-application**, etc.).  \n> **Image:** Setting up your device  \n> **Image:** Setting up your device  \n> **Image:** Changing the End device ID  \n> **Image:** Register End Device  \n6. You should now be able to see the device on the TTN console after you fully register your device, as shown below.  \n> **TIP:** NOTE  \n- The **AppEUI**, **DevEUI**, and **AppKey** are the parameters that you will need to activate your LoRaWAN end-device via OTAA. The **AppKey** is hidden by default for security reasons, but you can easily show it by clicking the show button. You can also copy the parameters quickly using the copy button.  \n- These parameters are always accessible on the device console page, as highlighted in the figure below.  \n> **Image:** OTAA device successfully registered to TTN  \n> **TIP:** NOTE  \nAbove procedures are applicable to all applications you will be using.  \n- For **Battery Monitoring**, go to this [link](#lorawan-code-for-battery-monitoring) once done with the device registration.\n- For **Material Classifier**, go to this [link](#lorawan-code-for-material-classifier) once done with the device registration."}
{"id": "a7fbd7f1a31063e01ce21d9c2cb07646", "product_family": "wisblock", "product_id": "kit4-industrial", "category": "How-To", "title": "WisBlock IoT Education Kit - Smart Industry Quick Start Guide > WisBlock IoT Education Kit - Smart Industry Quick Start Guide > Miscellaneous > Device Registration > Registering an OTAA End-Device on TTN Console", "content": "> **Image:** Enter end device specifics manually  \n3. Next step is to set up **Frequency plan**, compatible **LoRaWAN version**, and **Regional Parameters version** supported. Then provide the **JoinEUI** credentials by entering zeroes into it.  \n> **Image:** Setting up your device  \n> **Image:** Setting up your device", "keywords": ["OTAA", "TTN", "end-device", "registration", "LoRaWAN"], "source_file": "quickstart.md", "token_count": 0, "parent_content": "1. Go to your application console to register a device. To start adding an OTAA end-device, click **+ Register end device**, as shown below.  \n> **Image:** Register End Device  \n2. To register the board, click the **Enter end device specifics manually**.  \n> **Image:** Enter end device specifics manually  \n3. Next step is to set up **Frequency plan**, compatible **LoRaWAN version**, and **Regional Parameters version** supported. Then provide the **JoinEUI** credentials by entering zeroes into it.  \n> **Image:** Setting up your device  \n> **Image:** Setting up your device  \n4. Then click **Show advanced activation, LoRaWAN class and cluster settings**. Configure the activation mode by selecting **Over the air activation (OTAA)** and Additional LoRaWAN class capabilities to **class A only**. Then click **Confirm**.  \n> **Image:** Setting up your device  \n> **Image:** Setting up your device  \n5. Once done, provide the DevEUI credentials of your device into the **DevEUI** portion. This will automatically generate the specific End\ndevice ID of your board. Then click **Generate** under **AppKey** under Provisioning information section. Once done, you need to change the **End device ID** since it is automatically prefilled using the **DevEUI** of your device. Then click **Register end device**.  \n> **TIP:** NOTE  \n- The **AppEUI**, **DevEUI**, and **AppKey** are hidden in this section as these are unique from a specific device. The **DevEUI** credential is unique to every **RAK4631** device. Also, you should generate your own **AppEUI** and **AppKey** credentials for your specific device and application.  \n- The **AppEUI** is the same as **JoinEUI**.  \n- The details under **End device ID** are dependent to what device you are using (e.g. **rak16002-application**, etc.).  \n> **Image:** Setting up your device  \n> **Image:** Setting up your device  \n> **Image:** Changing the End device ID  \n> **Image:** Register End Device  \n6. You should now be able to see the device on the TTN console after you fully register your device, as shown below.  \n> **TIP:** NOTE  \n- The **AppEUI**, **DevEUI**, and **AppKey** are the parameters that you will need to activate your LoRaWAN end-device via OTAA. The **AppKey** is hidden by default for security reasons, but you can easily show it by clicking the show button. You can also copy the parameters quickly using the copy button.  \n- These parameters are always accessible on the device console page, as highlighted in the figure below.  \n> **Image:** OTAA device successfully registered to TTN  \n> **TIP:** NOTE  \nAbove procedures are applicable to all applications you will be using.  \n- For **Battery Monitoring**, go to this [link](#lorawan-code-for-battery-monitoring) once done with the device registration.\n- For **Material Classifier**, go to this [link](#lorawan-code-for-material-classifier) once done with the device registration."}
{"id": "f532472f6a86433614a05924f0d0d8bc", "product_family": "wisblock", "product_id": "kit4-industrial", "category": "How-To", "title": "WisBlock IoT Education Kit - Smart Industry Quick Start Guide > WisBlock IoT Education Kit - Smart Industry Quick Start Guide > Miscellaneous > Device Registration > Registering an OTAA End-Device on TTN Console", "content": "> **Image:** Setting up your device  \n> **Image:** Setting up your device  \n4. Then click **Show advanced activation, LoRaWAN class and cluster settings**. Configure the activation mode by selecting **Over the air activation (OTAA)** and Additional LoRaWAN class capabilities to **class A only**. Then click **Confirm**.  \n> **Image:** Setting up your device  \n> **Image:** Setting up your device", "keywords": ["OTAA", "TTN", "end-device", "registration", "LoRaWAN"], "source_file": "quickstart.md", "token_count": 0, "parent_content": "1. Go to your application console to register a device. To start adding an OTAA end-device, click **+ Register end device**, as shown below.  \n> **Image:** Register End Device  \n2. To register the board, click the **Enter end device specifics manually**.  \n> **Image:** Enter end device specifics manually  \n3. Next step is to set up **Frequency plan**, compatible **LoRaWAN version**, and **Regional Parameters version** supported. Then provide the **JoinEUI** credentials by entering zeroes into it.  \n> **Image:** Setting up your device  \n> **Image:** Setting up your device  \n4. Then click **Show advanced activation, LoRaWAN class and cluster settings**. Configure the activation mode by selecting **Over the air activation (OTAA)** and Additional LoRaWAN class capabilities to **class A only**. Then click **Confirm**.  \n> **Image:** Setting up your device  \n> **Image:** Setting up your device  \n5. Once done, provide the DevEUI credentials of your device into the **DevEUI** portion. This will automatically generate the specific End\ndevice ID of your board. Then click **Generate** under **AppKey** under Provisioning information section. Once done, you need to change the **End device ID** since it is automatically prefilled using the **DevEUI** of your device. Then click **Register end device**.  \n> **TIP:** NOTE  \n- The **AppEUI**, **DevEUI**, and **AppKey** are hidden in this section as these are unique from a specific device. The **DevEUI** credential is unique to every **RAK4631** device. Also, you should generate your own **AppEUI** and **AppKey** credentials for your specific device and application.  \n- The **AppEUI** is the same as **JoinEUI**.  \n- The details under **End device ID** are dependent to what device you are using (e.g. **rak16002-application**, etc.).  \n> **Image:** Setting up your device  \n> **Image:** Setting up your device  \n> **Image:** Changing the End device ID  \n> **Image:** Register End Device  \n6. You should now be able to see the device on the TTN console after you fully register your device, as shown below.  \n> **TIP:** NOTE  \n- The **AppEUI**, **DevEUI**, and **AppKey** are the parameters that you will need to activate your LoRaWAN end-device via OTAA. The **AppKey** is hidden by default for security reasons, but you can easily show it by clicking the show button. You can also copy the parameters quickly using the copy button.  \n- These parameters are always accessible on the device console page, as highlighted in the figure below.  \n> **Image:** OTAA device successfully registered to TTN  \n> **TIP:** NOTE  \nAbove procedures are applicable to all applications you will be using.  \n- For **Battery Monitoring**, go to this [link](#lorawan-code-for-battery-monitoring) once done with the device registration.\n- For **Material Classifier**, go to this [link](#lorawan-code-for-material-classifier) once done with the device registration."}
{"id": "abed83003f3a5c577058a6d150c37efc", "product_family": "wisblock", "product_id": "kit4-industrial", "category": "How-To", "title": "WisBlock IoT Education Kit - Smart Industry Quick Start Guide > WisBlock IoT Education Kit - Smart Industry Quick Start Guide > Miscellaneous > Device Registration > Registering an OTAA End-Device on TTN Console", "content": "> **Image:** Setting up your device  \n> **Image:** Setting up your device  \n5. Once done, provide the DevEUI credentials of your device into the **DevEUI** portion. This will automatically generate the specific End\ndevice ID of your board. Then click **Generate** under **AppKey** under Provisioning information section. Once done, you need to change the **End device ID** since it is automatically prefilled using the **DevEUI** of your device. Then click **Register end device**.", "keywords": ["OTAA", "TTN", "end-device", "registration", "LoRaWAN"], "source_file": "quickstart.md", "token_count": 0, "parent_content": "1. Go to your application console to register a device. To start adding an OTAA end-device, click **+ Register end device**, as shown below.  \n> **Image:** Register End Device  \n2. To register the board, click the **Enter end device specifics manually**.  \n> **Image:** Enter end device specifics manually  \n3. Next step is to set up **Frequency plan**, compatible **LoRaWAN version**, and **Regional Parameters version** supported. Then provide the **JoinEUI** credentials by entering zeroes into it.  \n> **Image:** Setting up your device  \n> **Image:** Setting up your device  \n4. Then click **Show advanced activation, LoRaWAN class and cluster settings**. Configure the activation mode by selecting **Over the air activation (OTAA)** and Additional LoRaWAN class capabilities to **class A only**. Then click **Confirm**.  \n> **Image:** Setting up your device  \n> **Image:** Setting up your device  \n5. Once done, provide the DevEUI credentials of your device into the **DevEUI** portion. This will automatically generate the specific End\ndevice ID of your board. Then click **Generate** under **AppKey** under Provisioning information section. Once done, you need to change the **End device ID** since it is automatically prefilled using the **DevEUI** of your device. Then click **Register end device**.  \n> **TIP:** NOTE  \n- The **AppEUI**, **DevEUI**, and **AppKey** are hidden in this section as these are unique from a specific device. The **DevEUI** credential is unique to every **RAK4631** device. Also, you should generate your own **AppEUI** and **AppKey** credentials for your specific device and application.  \n- The **AppEUI** is the same as **JoinEUI**.  \n- The details under **End device ID** are dependent to what device you are using (e.g. **rak16002-application**, etc.).  \n> **Image:** Setting up your device  \n> **Image:** Setting up your device  \n> **Image:** Changing the End device ID  \n> **Image:** Register End Device  \n6. You should now be able to see the device on the TTN console after you fully register your device, as shown below.  \n> **TIP:** NOTE  \n- The **AppEUI**, **DevEUI**, and **AppKey** are the parameters that you will need to activate your LoRaWAN end-device via OTAA. The **AppKey** is hidden by default for security reasons, but you can easily show it by clicking the show button. You can also copy the parameters quickly using the copy button.  \n- These parameters are always accessible on the device console page, as highlighted in the figure below.  \n> **Image:** OTAA device successfully registered to TTN  \n> **TIP:** NOTE  \nAbove procedures are applicable to all applications you will be using.  \n- For **Battery Monitoring**, go to this [link](#lorawan-code-for-battery-monitoring) once done with the device registration.\n- For **Material Classifier**, go to this [link](#lorawan-code-for-material-classifier) once done with the device registration."}
{"id": "13b2d524940d87b6eae7303b7125c9c9", "product_family": "wisblock", "product_id": "kit4-industrial", "category": "How-To", "title": "WisBlock IoT Education Kit - Smart Industry Quick Start Guide > WisBlock IoT Education Kit - Smart Industry Quick Start Guide > Miscellaneous > Device Registration > Registering an OTAA End-Device on TTN Console", "content": "> **TIP:** NOTE  \n- The **AppEUI**, **DevEUI**, and **AppKey** are hidden in this section as these are unique from a specific device. The **DevEUI** credential is unique to every **RAK4631** device. Also, you should generate your own **AppEUI** and **AppKey** credentials for your specific device and application.  \n- The **AppEUI** is the same as **JoinEUI**.  \n- The details under **End device ID** are dependent to what device you are using (e.g. **rak16002-application**, etc.).", "keywords": ["OTAA", "TTN", "end-device", "registration", "LoRaWAN"], "source_file": "quickstart.md", "token_count": 0, "parent_content": "1. Go to your application console to register a device. To start adding an OTAA end-device, click **+ Register end device**, as shown below.  \n> **Image:** Register End Device  \n2. To register the board, click the **Enter end device specifics manually**.  \n> **Image:** Enter end device specifics manually  \n3. Next step is to set up **Frequency plan**, compatible **LoRaWAN version**, and **Regional Parameters version** supported. Then provide the **JoinEUI** credentials by entering zeroes into it.  \n> **Image:** Setting up your device  \n> **Image:** Setting up your device  \n4. Then click **Show advanced activation, LoRaWAN class and cluster settings**. Configure the activation mode by selecting **Over the air activation (OTAA)** and Additional LoRaWAN class capabilities to **class A only**. Then click **Confirm**.  \n> **Image:** Setting up your device  \n> **Image:** Setting up your device  \n5. Once done, provide the DevEUI credentials of your device into the **DevEUI** portion. This will automatically generate the specific End\ndevice ID of your board. Then click **Generate** under **AppKey** under Provisioning information section. Once done, you need to change the **End device ID** since it is automatically prefilled using the **DevEUI** of your device. Then click **Register end device**.  \n> **TIP:** NOTE  \n- The **AppEUI**, **DevEUI**, and **AppKey** are hidden in this section as these are unique from a specific device. The **DevEUI** credential is unique to every **RAK4631** device. Also, you should generate your own **AppEUI** and **AppKey** credentials for your specific device and application.  \n- The **AppEUI** is the same as **JoinEUI**.  \n- The details under **End device ID** are dependent to what device you are using (e.g. **rak16002-application**, etc.).  \n> **Image:** Setting up your device  \n> **Image:** Setting up your device  \n> **Image:** Changing the End device ID  \n> **Image:** Register End Device  \n6. You should now be able to see the device on the TTN console after you fully register your device, as shown below.  \n> **TIP:** NOTE  \n- The **AppEUI**, **DevEUI**, and **AppKey** are the parameters that you will need to activate your LoRaWAN end-device via OTAA. The **AppKey** is hidden by default for security reasons, but you can easily show it by clicking the show button. You can also copy the parameters quickly using the copy button.  \n- These parameters are always accessible on the device console page, as highlighted in the figure below.  \n> **Image:** OTAA device successfully registered to TTN  \n> **TIP:** NOTE  \nAbove procedures are applicable to all applications you will be using.  \n- For **Battery Monitoring**, go to this [link](#lorawan-code-for-battery-monitoring) once done with the device registration.\n- For **Material Classifier**, go to this [link](#lorawan-code-for-material-classifier) once done with the device registration."}
{"id": "7240f73b87da62822af503da4c67cf46", "product_family": "wisblock", "product_id": "kit4-industrial", "category": "How-To", "title": "WisBlock IoT Education Kit - Smart Industry Quick Start Guide > WisBlock IoT Education Kit - Smart Industry Quick Start Guide > Miscellaneous > Device Registration > Registering an OTAA End-Device on TTN Console", "content": "> **Image:** Setting up your device  \n> **Image:** Setting up your device  \n> **Image:** Changing the End device ID  \n> **Image:** Register End Device  \n6. You should now be able to see the device on the TTN console after you fully register your device, as shown below.  \n> **TIP:** NOTE", "keywords": ["OTAA", "TTN", "end-device", "registration", "LoRaWAN"], "source_file": "quickstart.md", "token_count": 0, "parent_content": "1. Go to your application console to register a device. To start adding an OTAA end-device, click **+ Register end device**, as shown below.  \n> **Image:** Register End Device  \n2. To register the board, click the **Enter end device specifics manually**.  \n> **Image:** Enter end device specifics manually  \n3. Next step is to set up **Frequency plan**, compatible **LoRaWAN version**, and **Regional Parameters version** supported. Then provide the **JoinEUI** credentials by entering zeroes into it.  \n> **Image:** Setting up your device  \n> **Image:** Setting up your device  \n4. Then click **Show advanced activation, LoRaWAN class and cluster settings**. Configure the activation mode by selecting **Over the air activation (OTAA)** and Additional LoRaWAN class capabilities to **class A only**. Then click **Confirm**.  \n> **Image:** Setting up your device  \n> **Image:** Setting up your device  \n5. Once done, provide the DevEUI credentials of your device into the **DevEUI** portion. This will automatically generate the specific End\ndevice ID of your board. Then click **Generate** under **AppKey** under Provisioning information section. Once done, you need to change the **End device ID** since it is automatically prefilled using the **DevEUI** of your device. Then click **Register end device**.  \n> **TIP:** NOTE  \n- The **AppEUI**, **DevEUI**, and **AppKey** are hidden in this section as these are unique from a specific device. The **DevEUI** credential is unique to every **RAK4631** device. Also, you should generate your own **AppEUI** and **AppKey** credentials for your specific device and application.  \n- The **AppEUI** is the same as **JoinEUI**.  \n- The details under **End device ID** are dependent to what device you are using (e.g. **rak16002-application**, etc.).  \n> **Image:** Setting up your device  \n> **Image:** Setting up your device  \n> **Image:** Changing the End device ID  \n> **Image:** Register End Device  \n6. You should now be able to see the device on the TTN console after you fully register your device, as shown below.  \n> **TIP:** NOTE  \n- The **AppEUI**, **DevEUI**, and **AppKey** are the parameters that you will need to activate your LoRaWAN end-device via OTAA. The **AppKey** is hidden by default for security reasons, but you can easily show it by clicking the show button. You can also copy the parameters quickly using the copy button.  \n- These parameters are always accessible on the device console page, as highlighted in the figure below.  \n> **Image:** OTAA device successfully registered to TTN  \n> **TIP:** NOTE  \nAbove procedures are applicable to all applications you will be using.  \n- For **Battery Monitoring**, go to this [link](#lorawan-code-for-battery-monitoring) once done with the device registration.\n- For **Material Classifier**, go to this [link](#lorawan-code-for-material-classifier) once done with the device registration."}
{"id": "9488eac043d57762a032b45bb70c5d3f", "product_family": "wisblock", "product_id": "kit4-industrial", "category": "How-To", "title": "WisBlock IoT Education Kit - Smart Industry Quick Start Guide > WisBlock IoT Education Kit - Smart Industry Quick Start Guide > Miscellaneous > Device Registration > Registering an OTAA End-Device on TTN Console", "content": "> **TIP:** NOTE  \n- The **AppEUI**, **DevEUI**, and **AppKey** are the parameters that you will need to activate your LoRaWAN end-device via OTAA. The **AppKey** is hidden by default for security reasons, but you can easily show it by clicking the show button. You can also copy the parameters quickly using the copy button.  \n- These parameters are always accessible on the device console page, as highlighted in the figure below.  \n> **Image:** OTAA device successfully registered to TTN", "keywords": ["OTAA", "TTN", "end-device", "registration", "LoRaWAN"], "source_file": "quickstart.md", "token_count": 0, "parent_content": "1. Go to your application console to register a device. To start adding an OTAA end-device, click **+ Register end device**, as shown below.  \n> **Image:** Register End Device  \n2. To register the board, click the **Enter end device specifics manually**.  \n> **Image:** Enter end device specifics manually  \n3. Next step is to set up **Frequency plan**, compatible **LoRaWAN version**, and **Regional Parameters version** supported. Then provide the **JoinEUI** credentials by entering zeroes into it.  \n> **Image:** Setting up your device  \n> **Image:** Setting up your device  \n4. Then click **Show advanced activation, LoRaWAN class and cluster settings**. Configure the activation mode by selecting **Over the air activation (OTAA)** and Additional LoRaWAN class capabilities to **class A only**. Then click **Confirm**.  \n> **Image:** Setting up your device  \n> **Image:** Setting up your device  \n5. Once done, provide the DevEUI credentials of your device into the **DevEUI** portion. This will automatically generate the specific End\ndevice ID of your board. Then click **Generate** under **AppKey** under Provisioning information section. Once done, you need to change the **End device ID** since it is automatically prefilled using the **DevEUI** of your device. Then click **Register end device**.  \n> **TIP:** NOTE  \n- The **AppEUI**, **DevEUI**, and **AppKey** are hidden in this section as these are unique from a specific device. The **DevEUI** credential is unique to every **RAK4631** device. Also, you should generate your own **AppEUI** and **AppKey** credentials for your specific device and application.  \n- The **AppEUI** is the same as **JoinEUI**.  \n- The details under **End device ID** are dependent to what device you are using (e.g. **rak16002-application**, etc.).  \n> **Image:** Setting up your device  \n> **Image:** Setting up your device  \n> **Image:** Changing the End device ID  \n> **Image:** Register End Device  \n6. You should now be able to see the device on the TTN console after you fully register your device, as shown below.  \n> **TIP:** NOTE  \n- The **AppEUI**, **DevEUI**, and **AppKey** are the parameters that you will need to activate your LoRaWAN end-device via OTAA. The **AppKey** is hidden by default for security reasons, but you can easily show it by clicking the show button. You can also copy the parameters quickly using the copy button.  \n- These parameters are always accessible on the device console page, as highlighted in the figure below.  \n> **Image:** OTAA device successfully registered to TTN  \n> **TIP:** NOTE  \nAbove procedures are applicable to all applications you will be using.  \n- For **Battery Monitoring**, go to this [link](#lorawan-code-for-battery-monitoring) once done with the device registration.\n- For **Material Classifier**, go to this [link](#lorawan-code-for-material-classifier) once done with the device registration."}
{"id": "3353e6ed9b22dffff822005e2bce889d", "product_family": "wisblock", "product_id": "kit4-industrial", "category": "How-To", "title": "WisBlock IoT Education Kit - Smart Industry Quick Start Guide > WisBlock IoT Education Kit - Smart Industry Quick Start Guide > Miscellaneous > Device Registration > Registering an OTAA End-Device on TTN Console", "content": "> **Image:** OTAA device successfully registered to TTN  \n> **TIP:** NOTE  \nAbove procedures are applicable to all applications you will be using.  \n- For **Battery Monitoring**, go to this [link](#lorawan-code-for-battery-monitoring) once done with the device registration.\n- For **Material Classifier**, go to this [link](#lorawan-code-for-material-classifier) once done with the device registration.", "keywords": ["OTAA", "TTN", "end-device", "registration", "LoRaWAN"], "source_file": "quickstart.md", "token_count": 0, "parent_content": "1. Go to your application console to register a device. To start adding an OTAA end-device, click **+ Register end device**, as shown below.  \n> **Image:** Register End Device  \n2. To register the board, click the **Enter end device specifics manually**.  \n> **Image:** Enter end device specifics manually  \n3. Next step is to set up **Frequency plan**, compatible **LoRaWAN version**, and **Regional Parameters version** supported. Then provide the **JoinEUI** credentials by entering zeroes into it.  \n> **Image:** Setting up your device  \n> **Image:** Setting up your device  \n4. Then click **Show advanced activation, LoRaWAN class and cluster settings**. Configure the activation mode by selecting **Over the air activation (OTAA)** and Additional LoRaWAN class capabilities to **class A only**. Then click **Confirm**.  \n> **Image:** Setting up your device  \n> **Image:** Setting up your device  \n5. Once done, provide the DevEUI credentials of your device into the **DevEUI** portion. This will automatically generate the specific End\ndevice ID of your board. Then click **Generate** under **AppKey** under Provisioning information section. Once done, you need to change the **End device ID** since it is automatically prefilled using the **DevEUI** of your device. Then click **Register end device**.  \n> **TIP:** NOTE  \n- The **AppEUI**, **DevEUI**, and **AppKey** are hidden in this section as these are unique from a specific device. The **DevEUI** credential is unique to every **RAK4631** device. Also, you should generate your own **AppEUI** and **AppKey** credentials for your specific device and application.  \n- The **AppEUI** is the same as **JoinEUI**.  \n- The details under **End device ID** are dependent to what device you are using (e.g. **rak16002-application**, etc.).  \n> **Image:** Setting up your device  \n> **Image:** Setting up your device  \n> **Image:** Changing the End device ID  \n> **Image:** Register End Device  \n6. You should now be able to see the device on the TTN console after you fully register your device, as shown below.  \n> **TIP:** NOTE  \n- The **AppEUI**, **DevEUI**, and **AppKey** are the parameters that you will need to activate your LoRaWAN end-device via OTAA. The **AppKey** is hidden by default for security reasons, but you can easily show it by clicking the show button. You can also copy the parameters quickly using the copy button.  \n- These parameters are always accessible on the device console page, as highlighted in the figure below.  \n> **Image:** OTAA device successfully registered to TTN  \n> **TIP:** NOTE  \nAbove procedures are applicable to all applications you will be using.  \n- For **Battery Monitoring**, go to this [link](#lorawan-code-for-battery-monitoring) once done with the device registration.\n- For **Material Classifier**, go to this [link](#lorawan-code-for-material-classifier) once done with the device registration."}
{"id": "bae6d6e59b15f3cbbee4a5b23c85cb04", "product_family": "wisblock", "product_id": "kit4-industrial", "category": "How-To", "title": "WisBlock IoT Education Kit - Smart Industry Quick Start Guide > WisBlock IoT Education Kit - Smart Industry Quick Start Guide > Miscellaneous > Arduino IDE Installation + RAK4631 > Installing Arduino IDE and RAKwireless BSP for WisBlock Core", "content": "1. Download the [Arduino IDE](https://www.arduino.cc/en/software) and install it on your PC or laptop. You must choose the appropriate **Arduino IDE** depending on your operating system.  \n> **Image:** Download Options for the Arduino IDE", "keywords": ["Arduino IDE", "RAKwireless BSP", "WisBlock Core", "RAK4631", "Installation"], "source_file": "quickstart.md", "token_count": 250, "parent_content": "1. Download the [Arduino IDE](https://www.arduino.cc/en/software) and install it on your PC or laptop. You must choose the appropriate **Arduino IDE** depending on your operating system.  \n> **Image:** Download Options for the Arduino IDE  \n2. Open the **Arduino IDE** then install the [RAKwireless Arduino BSP](https://github.com/RAKWireless/RAKwireless-Arduino-BSP-Index) for WisBlock by using the `package_rakwireless_index.json` board installation package. The WisBlock Core should now be available on the Arduino IDE. Click on **File** > **Preference**. In the **Preference** window, look for **Additional Boards Manager URLs** then click the icon on the right side. Paste the link into it then click **OK** > **OK**.  \n> **Image:** Preference Set-Up  \n> **Image:** Preference Window  \n> **Image:** RAKwireless Arduino BSP  \n> **Image:** Completing the setup of the RAKwireless BSP support for the Arduino Board Manager  \n3. Then to your **Arduino IDE**, go to **Tools** > **Board:XXXXX** > **Boards Manager**. Then look for **RAKwireless Boards by RAKwireless** since we will be working on with the **RAK4631 WisBlock Core**. Choose the latest version then install it. Once done, close the **Board Manager**.  \n> **Image:** Opening the Boards Manager  \n> **Image:** Installing the RAKwireless nRF Boards  \n> **Image:** Successfully installed the RAKwireless nRF Boards  \n> **TIP:** NOTE  \nAbove procedures are applicable to all applications you will be using.  \n- For **Battery Monitoring**, go to this [link](#lorawan-code-for-battery-monitoring) once done with the installation.\n- For **Material Classifier**, go to this [link](#lorawan-code-for-material-classifier) once done with the installation."}
{"id": "ecf8c62832a3a792cf57fee54d688621", "product_family": "wisblock", "product_id": "kit4-industrial", "category": "How-To", "title": "WisBlock IoT Education Kit - Smart Industry Quick Start Guide > WisBlock IoT Education Kit - Smart Industry Quick Start Guide > Miscellaneous > Arduino IDE Installation + RAK4631 > Installing Arduino IDE and RAKwireless BSP for WisBlock Core", "content": "2. Open the **Arduino IDE** then install the [RAKwireless Arduino BSP](https://github.com/RAKWireless/RAKwireless-Arduino-BSP-Index) for WisBlock by using the `package_rakwireless_index.json` board installation package. The WisBlock Core should now be available on the Arduino IDE. Click on **File** > **Preference**. In the **Preference** window, look for **Additional Boards Manager URLs** then click the icon on the right side. Paste the link into it then click **OK** > **OK**.", "keywords": ["Arduino IDE", "RAKwireless BSP", "WisBlock Core", "RAK4631", "Installation"], "source_file": "quickstart.md", "token_count": 250, "parent_content": "1. Download the [Arduino IDE](https://www.arduino.cc/en/software) and install it on your PC or laptop. You must choose the appropriate **Arduino IDE** depending on your operating system.  \n> **Image:** Download Options for the Arduino IDE  \n2. Open the **Arduino IDE** then install the [RAKwireless Arduino BSP](https://github.com/RAKWireless/RAKwireless-Arduino-BSP-Index) for WisBlock by using the `package_rakwireless_index.json` board installation package. The WisBlock Core should now be available on the Arduino IDE. Click on **File** > **Preference**. In the **Preference** window, look for **Additional Boards Manager URLs** then click the icon on the right side. Paste the link into it then click **OK** > **OK**.  \n> **Image:** Preference Set-Up  \n> **Image:** Preference Window  \n> **Image:** RAKwireless Arduino BSP  \n> **Image:** Completing the setup of the RAKwireless BSP support for the Arduino Board Manager  \n3. Then to your **Arduino IDE**, go to **Tools** > **Board:XXXXX** > **Boards Manager**. Then look for **RAKwireless Boards by RAKwireless** since we will be working on with the **RAK4631 WisBlock Core**. Choose the latest version then install it. Once done, close the **Board Manager**.  \n> **Image:** Opening the Boards Manager  \n> **Image:** Installing the RAKwireless nRF Boards  \n> **Image:** Successfully installed the RAKwireless nRF Boards  \n> **TIP:** NOTE  \nAbove procedures are applicable to all applications you will be using.  \n- For **Battery Monitoring**, go to this [link](#lorawan-code-for-battery-monitoring) once done with the installation.\n- For **Material Classifier**, go to this [link](#lorawan-code-for-material-classifier) once done with the installation."}
{"id": "3b147a15f8040cd467fff37b8cceb3ef", "product_family": "wisblock", "product_id": "kit4-industrial", "category": "How-To", "title": "WisBlock IoT Education Kit - Smart Industry Quick Start Guide > WisBlock IoT Education Kit - Smart Industry Quick Start Guide > Miscellaneous > Arduino IDE Installation + RAK4631 > Installing Arduino IDE and RAKwireless BSP for WisBlock Core", "content": "> **Image:** Preference Set-Up  \n> **Image:** Preference Window  \n> **Image:** RAKwireless Arduino BSP  \n> **Image:** Completing the setup of the RAKwireless BSP support for the Arduino Board Manager  \n3. Then to your **Arduino IDE**, go to **Tools** > **Board:XXXXX** > **Boards Manager**. Then look for **RAKwireless Boards by RAKwireless** since we will be working on with the **RAK4631 WisBlock Core**. Choose the latest version then install it. Once done, close the **Board Manager**.", "keywords": ["Arduino IDE", "RAKwireless BSP", "WisBlock Core", "RAK4631", "Installation"], "source_file": "quickstart.md", "token_count": 250, "parent_content": "1. Download the [Arduino IDE](https://www.arduino.cc/en/software) and install it on your PC or laptop. You must choose the appropriate **Arduino IDE** depending on your operating system.  \n> **Image:** Download Options for the Arduino IDE  \n2. Open the **Arduino IDE** then install the [RAKwireless Arduino BSP](https://github.com/RAKWireless/RAKwireless-Arduino-BSP-Index) for WisBlock by using the `package_rakwireless_index.json` board installation package. The WisBlock Core should now be available on the Arduino IDE. Click on **File** > **Preference**. In the **Preference** window, look for **Additional Boards Manager URLs** then click the icon on the right side. Paste the link into it then click **OK** > **OK**.  \n> **Image:** Preference Set-Up  \n> **Image:** Preference Window  \n> **Image:** RAKwireless Arduino BSP  \n> **Image:** Completing the setup of the RAKwireless BSP support for the Arduino Board Manager  \n3. Then to your **Arduino IDE**, go to **Tools** > **Board:XXXXX** > **Boards Manager**. Then look for **RAKwireless Boards by RAKwireless** since we will be working on with the **RAK4631 WisBlock Core**. Choose the latest version then install it. Once done, close the **Board Manager**.  \n> **Image:** Opening the Boards Manager  \n> **Image:** Installing the RAKwireless nRF Boards  \n> **Image:** Successfully installed the RAKwireless nRF Boards  \n> **TIP:** NOTE  \nAbove procedures are applicable to all applications you will be using.  \n- For **Battery Monitoring**, go to this [link](#lorawan-code-for-battery-monitoring) once done with the installation.\n- For **Material Classifier**, go to this [link](#lorawan-code-for-material-classifier) once done with the installation."}
{"id": "c2d73af4c27d01372c393d923841adff", "product_family": "wisblock", "product_id": "kit4-industrial", "category": "How-To", "title": "WisBlock IoT Education Kit - Smart Industry Quick Start Guide > WisBlock IoT Education Kit - Smart Industry Quick Start Guide > Miscellaneous > Arduino IDE Installation + RAK4631 > Installing Arduino IDE and RAKwireless BSP for WisBlock Core", "content": "> **Image:** Opening the Boards Manager  \n> **Image:** Installing the RAKwireless nRF Boards  \n> **Image:** Successfully installed the RAKwireless nRF Boards  \n> **TIP:** NOTE  \nAbove procedures are applicable to all applications you will be using.  \n- For **Battery Monitoring**, go to this [link](#lorawan-code-for-battery-monitoring) once done with the installation.\n- For **Material Classifier**, go to this [link](#lorawan-code-for-material-classifier) once done with the installation.", "keywords": ["Arduino IDE", "RAKwireless BSP", "WisBlock Core", "RAK4631", "Installation"], "source_file": "quickstart.md", "token_count": 250, "parent_content": "1. Download the [Arduino IDE](https://www.arduino.cc/en/software) and install it on your PC or laptop. You must choose the appropriate **Arduino IDE** depending on your operating system.  \n> **Image:** Download Options for the Arduino IDE  \n2. Open the **Arduino IDE** then install the [RAKwireless Arduino BSP](https://github.com/RAKWireless/RAKwireless-Arduino-BSP-Index) for WisBlock by using the `package_rakwireless_index.json` board installation package. The WisBlock Core should now be available on the Arduino IDE. Click on **File** > **Preference**. In the **Preference** window, look for **Additional Boards Manager URLs** then click the icon on the right side. Paste the link into it then click **OK** > **OK**.  \n> **Image:** Preference Set-Up  \n> **Image:** Preference Window  \n> **Image:** RAKwireless Arduino BSP  \n> **Image:** Completing the setup of the RAKwireless BSP support for the Arduino Board Manager  \n3. Then to your **Arduino IDE**, go to **Tools** > **Board:XXXXX** > **Boards Manager**. Then look for **RAKwireless Boards by RAKwireless** since we will be working on with the **RAK4631 WisBlock Core**. Choose the latest version then install it. Once done, close the **Board Manager**.  \n> **Image:** Opening the Boards Manager  \n> **Image:** Installing the RAKwireless nRF Boards  \n> **Image:** Successfully installed the RAKwireless nRF Boards  \n> **TIP:** NOTE  \nAbove procedures are applicable to all applications you will be using.  \n- For **Battery Monitoring**, go to this [link](#lorawan-code-for-battery-monitoring) once done with the installation.\n- For **Material Classifier**, go to this [link](#lorawan-code-for-material-classifier) once done with the installation."}
