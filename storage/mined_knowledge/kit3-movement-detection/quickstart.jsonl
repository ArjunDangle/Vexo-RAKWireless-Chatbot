{"id": "eac13310f1fd37cecef01c5cdc212db7", "product_family": "wisblock", "product_id": "kit3-movement-detection", "category": "Concept", "title": "WisBlock Movement Detection Kit Quick Start Guide > WisBlock IoT Education Kit - Movement Detection Quick Start Guide > Prerequisite > What Do You Need? > Introduction to WisBlock IoT Education Kit - Movement Detection", "content": "The **WisBlock IoT Education Kit - Movement Detection** comes with **RAK19007** and **RAK19003** **WisBlock Base boards**, two **RAK4631** **WisBlock Core modules**, and set of sensor modules to explore with. Before going through each and every step on using the **WisBlock IoT Education Kit - Movement Detection**, make sure to prepare the necessary items listed below:", "keywords": ["WisBlock", "IoT Education Kit", "Movement Detection", "RAK19007", "RAK19003", "RAK4631"], "source_file": "quickstart.md", "token_count": 70, "parent_content": "The **WisBlock IoT Education Kit - Movement Detection** comes with **RAK19007** and **RAK19003** **WisBlock Base boards**, two **RAK4631** **WisBlock Core modules**, and set of sensor modules to explore with. Before going through each and every step on using the **WisBlock IoT Education Kit - Movement Detection**, make sure to prepare the necessary items listed below:"}
{"id": "c6e99d26090b256640afb6e2b8a36653", "product_family": "wisblock", "product_id": "kit3-movement-detection", "category": "Reference", "title": "WisBlock Movement Detection Kit Quick Start Guide > WisBlock IoT Education Kit - Movement Detection Quick Start Guide > Prerequisite > What Do You Need? > Hardware > Components List for kit3-movement-detection", "content": "- [RAK4631 WisBlock Core](https://store.rakwireless.com/products/nordic-nrf52840-ble-core-module-for-lorawan-with-lora-sx1262-rak4631-rak4631-c?variant=42576992436422?utm_source=RAK4631WisBlockLPWANModule&utm_medium=Document&utm_campaign=BuyFromStore)\n- [RAK19007 WisBlock Base Board](https://store.rakwireless.com/products/rak19007-wisblock-base-board-2nd-gen?utm_source=RAK19007&utm_medium=Document&utm_campaign=BuyFromStore)", "keywords": ["RAK4631", "RAK19007", "RAK12006", "RAK12007", "RAK12013", "RAK12017", "components", "kit3-movement-detection"], "source_file": "quickstart.md", "token_count": 150, "parent_content": "- [RAK4631 WisBlock Core](https://store.rakwireless.com/products/nordic-nrf52840-ble-core-module-for-lorawan-with-lora-sx1262-rak4631-rak4631-c?variant=42576992436422?utm_source=RAK4631WisBlockLPWANModule&utm_medium=Document&utm_campaign=BuyFromStore)\n- [RAK19007 WisBlock Base Board](https://store.rakwireless.com/products/rak19007-wisblock-base-board-2nd-gen?utm_source=RAK19007&utm_medium=Document&utm_campaign=BuyFromStore)\n- [RAK12006 PIR Motion Sensor](https://store.rakwireless.com/products/wisblock-pir-module-rak12006?utm_source=RAK12006&utm_medium=Document&utm_campaign=BuyFromStore)\n- [RAK12007 Ultrasonic Sensor](https://store.rakwireless.com/products/ultrasonic-sensor-module-rak12007?utm_source=RAK12007&utm_medium=Document&utm_campaign=BuyFromStore)\n- [RAK12013 Radar Sensor](https://store.rakwireless.com/products/rak12013-wisblock-radar-sensor?utm_source=RAK12013&utm_medium=Document&utm_campaign=BuyFromStore)\n- [RAK12017 IR Proximity Sensor](https://store.rakwireless.com/products/rak12017-wisblock-ir-sensor?utm_source=RAK12017&utm_medium=Document&utm_campaign=BuyFromStore')\n- USB C Cable\n- [Li-Ion/LiPo battery (optional)](https://store.rakwireless.com/collections/wisblock-accessory/products/battery-connector-cable?utm_source=BatteryConnector&utm_medium=Document&utm_campaign=BuyFromStore)\n- [Solar charger (optional)](https://store.rakwireless.com/collections/wisblock-accessory/products/solar-panel-connector-cable?utm_source=SolarPanelConnector&utm_medium=Document&utm_campaign=BuyFromStore)"}
{"id": "d94e2272e78b8430f22c840e01213bef", "product_family": "wisblock", "product_id": "kit3-movement-detection", "category": "Reference", "title": "WisBlock Movement Detection Kit Quick Start Guide > WisBlock IoT Education Kit - Movement Detection Quick Start Guide > Prerequisite > What Do You Need? > Hardware > Components List for kit3-movement-detection", "content": "- [RAK12006 PIR Motion Sensor](https://store.rakwireless.com/products/wisblock-pir-module-rak12006?utm_source=RAK12006&utm_medium=Document&utm_campaign=BuyFromStore)\n- [RAK12007 Ultrasonic Sensor](https://store.rakwireless.com/products/ultrasonic-sensor-module-rak12007?utm_source=RAK12007&utm_medium=Document&utm_campaign=BuyFromStore)\n- [RAK12013 Radar Sensor](https://store.rakwireless.com/products/rak12013-wisblock-radar-sensor?utm_source=RAK12013&utm_medium=Document&utm_campaign=BuyFromStore)", "keywords": ["RAK4631", "RAK19007", "RAK12006", "RAK12007", "RAK12013", "RAK12017", "components", "kit3-movement-detection"], "source_file": "quickstart.md", "token_count": 150, "parent_content": "- [RAK4631 WisBlock Core](https://store.rakwireless.com/products/nordic-nrf52840-ble-core-module-for-lorawan-with-lora-sx1262-rak4631-rak4631-c?variant=42576992436422?utm_source=RAK4631WisBlockLPWANModule&utm_medium=Document&utm_campaign=BuyFromStore)\n- [RAK19007 WisBlock Base Board](https://store.rakwireless.com/products/rak19007-wisblock-base-board-2nd-gen?utm_source=RAK19007&utm_medium=Document&utm_campaign=BuyFromStore)\n- [RAK12006 PIR Motion Sensor](https://store.rakwireless.com/products/wisblock-pir-module-rak12006?utm_source=RAK12006&utm_medium=Document&utm_campaign=BuyFromStore)\n- [RAK12007 Ultrasonic Sensor](https://store.rakwireless.com/products/ultrasonic-sensor-module-rak12007?utm_source=RAK12007&utm_medium=Document&utm_campaign=BuyFromStore)\n- [RAK12013 Radar Sensor](https://store.rakwireless.com/products/rak12013-wisblock-radar-sensor?utm_source=RAK12013&utm_medium=Document&utm_campaign=BuyFromStore)\n- [RAK12017 IR Proximity Sensor](https://store.rakwireless.com/products/rak12017-wisblock-ir-sensor?utm_source=RAK12017&utm_medium=Document&utm_campaign=BuyFromStore')\n- USB C Cable\n- [Li-Ion/LiPo battery (optional)](https://store.rakwireless.com/collections/wisblock-accessory/products/battery-connector-cable?utm_source=BatteryConnector&utm_medium=Document&utm_campaign=BuyFromStore)\n- [Solar charger (optional)](https://store.rakwireless.com/collections/wisblock-accessory/products/solar-panel-connector-cable?utm_source=SolarPanelConnector&utm_medium=Document&utm_campaign=BuyFromStore)"}
{"id": "6ac076a901499b0b0fe2a670f50f0334", "product_family": "wisblock", "product_id": "kit3-movement-detection", "category": "Reference", "title": "WisBlock Movement Detection Kit Quick Start Guide > WisBlock IoT Education Kit - Movement Detection Quick Start Guide > Prerequisite > What Do You Need? > Hardware > Components List for kit3-movement-detection", "content": "- [RAK12017 IR Proximity Sensor](https://store.rakwireless.com/products/rak12017-wisblock-ir-sensor?utm_source=RAK12017&utm_medium=Document&utm_campaign=BuyFromStore')\n- USB C Cable\n- [Li-Ion/LiPo battery (optional)](https://store.rakwireless.com/collections/wisblock-accessory/products/battery-connector-cable?utm_source=BatteryConnector&utm_medium=Document&utm_campaign=BuyFromStore)", "keywords": ["RAK4631", "RAK19007", "RAK12006", "RAK12007", "RAK12013", "RAK12017", "components", "kit3-movement-detection"], "source_file": "quickstart.md", "token_count": 150, "parent_content": "- [RAK4631 WisBlock Core](https://store.rakwireless.com/products/nordic-nrf52840-ble-core-module-for-lorawan-with-lora-sx1262-rak4631-rak4631-c?variant=42576992436422?utm_source=RAK4631WisBlockLPWANModule&utm_medium=Document&utm_campaign=BuyFromStore)\n- [RAK19007 WisBlock Base Board](https://store.rakwireless.com/products/rak19007-wisblock-base-board-2nd-gen?utm_source=RAK19007&utm_medium=Document&utm_campaign=BuyFromStore)\n- [RAK12006 PIR Motion Sensor](https://store.rakwireless.com/products/wisblock-pir-module-rak12006?utm_source=RAK12006&utm_medium=Document&utm_campaign=BuyFromStore)\n- [RAK12007 Ultrasonic Sensor](https://store.rakwireless.com/products/ultrasonic-sensor-module-rak12007?utm_source=RAK12007&utm_medium=Document&utm_campaign=BuyFromStore)\n- [RAK12013 Radar Sensor](https://store.rakwireless.com/products/rak12013-wisblock-radar-sensor?utm_source=RAK12013&utm_medium=Document&utm_campaign=BuyFromStore)\n- [RAK12017 IR Proximity Sensor](https://store.rakwireless.com/products/rak12017-wisblock-ir-sensor?utm_source=RAK12017&utm_medium=Document&utm_campaign=BuyFromStore')\n- USB C Cable\n- [Li-Ion/LiPo battery (optional)](https://store.rakwireless.com/collections/wisblock-accessory/products/battery-connector-cable?utm_source=BatteryConnector&utm_medium=Document&utm_campaign=BuyFromStore)\n- [Solar charger (optional)](https://store.rakwireless.com/collections/wisblock-accessory/products/solar-panel-connector-cable?utm_source=SolarPanelConnector&utm_medium=Document&utm_campaign=BuyFromStore)"}
{"id": "1d2fcd1095cf8ddff5ea9a0868147ebd", "product_family": "wisblock", "product_id": "kit3-movement-detection", "category": "Reference", "title": "WisBlock Movement Detection Kit Quick Start Guide > WisBlock IoT Education Kit - Movement Detection Quick Start Guide > Prerequisite > What Do You Need? > Hardware > Components List for kit3-movement-detection", "content": "- [Solar charger (optional)](https://store.rakwireless.com/collections/wisblock-accessory/products/solar-panel-connector-cable?utm_source=SolarPanelConnector&utm_medium=Document&utm_campaign=BuyFromStore)", "keywords": ["RAK4631", "RAK19007", "RAK12006", "RAK12007", "RAK12013", "RAK12017", "components", "kit3-movement-detection"], "source_file": "quickstart.md", "token_count": 150, "parent_content": "- [RAK4631 WisBlock Core](https://store.rakwireless.com/products/nordic-nrf52840-ble-core-module-for-lorawan-with-lora-sx1262-rak4631-rak4631-c?variant=42576992436422?utm_source=RAK4631WisBlockLPWANModule&utm_medium=Document&utm_campaign=BuyFromStore)\n- [RAK19007 WisBlock Base Board](https://store.rakwireless.com/products/rak19007-wisblock-base-board-2nd-gen?utm_source=RAK19007&utm_medium=Document&utm_campaign=BuyFromStore)\n- [RAK12006 PIR Motion Sensor](https://store.rakwireless.com/products/wisblock-pir-module-rak12006?utm_source=RAK12006&utm_medium=Document&utm_campaign=BuyFromStore)\n- [RAK12007 Ultrasonic Sensor](https://store.rakwireless.com/products/ultrasonic-sensor-module-rak12007?utm_source=RAK12007&utm_medium=Document&utm_campaign=BuyFromStore)\n- [RAK12013 Radar Sensor](https://store.rakwireless.com/products/rak12013-wisblock-radar-sensor?utm_source=RAK12013&utm_medium=Document&utm_campaign=BuyFromStore)\n- [RAK12017 IR Proximity Sensor](https://store.rakwireless.com/products/rak12017-wisblock-ir-sensor?utm_source=RAK12017&utm_medium=Document&utm_campaign=BuyFromStore')\n- USB C Cable\n- [Li-Ion/LiPo battery (optional)](https://store.rakwireless.com/collections/wisblock-accessory/products/battery-connector-cable?utm_source=BatteryConnector&utm_medium=Document&utm_campaign=BuyFromStore)\n- [Solar charger (optional)](https://store.rakwireless.com/collections/wisblock-accessory/products/solar-panel-connector-cable?utm_source=SolarPanelConnector&utm_medium=Document&utm_campaign=BuyFromStore)"}
{"id": "8a92afe371135e73ec47bbd0437f9bd2", "product_family": "wisblock", "product_id": "kit3-movement-detection", "category": "How-To", "title": "WisBlock Movement Detection Kit Quick Start Guide > WisBlock IoT Education Kit - Movement Detection Quick Start Guide > Prerequisite > What Do You Need? > Software > Setting Up Arduino IDE for RAKwireless Core Boards", "content": "**Arduino**  \n- Download and install the [ArduinoIDE](https://www.arduino.cc/en/Main/Software).\n- To add the RAKwireless Core boards on your Arduino Boards Manager, install the [RAKwireless Arduino BSP](https://github.com/RAKWireless/RAKwireless-Arduino-BSP-Index).", "keywords": ["Arduino", "IDE", "RAKwireless", "BSP", "setup"], "source_file": "quickstart.md", "token_count": 50, "parent_content": "**Arduino**  \n- Download and install the [ArduinoIDE](https://www.arduino.cc/en/Main/Software).\n- To add the RAKwireless Core boards on your Arduino Boards Manager, install the [RAKwireless Arduino BSP](https://github.com/RAKWireless/RAKwireless-Arduino-BSP-Index)."}
{"id": "d6dea72ab9c3d7fa65cedcaf7f4086bf", "product_family": "wisblock", "product_id": "kit3-movement-detection", "category": "How-To", "title": "WisBlock Movement Detection Kit Quick Start Guide > WisBlock IoT Education Kit - Movement Detection Quick Start Guide > Product Configuration > Hardware Setup > Assembling WisBlock Movement Detection Modules with RAK19007 Base Board", "content": "**WisBlock IoT Education Kit - Movement Detection** includes several movement detection sensors that can be used with the **RAK19007** and **RAK19003 WisBlock Base Boards**, which you can choose from. They are used to monitor object movements or even for motion detection, which can be useful for different IoT applications. You can select from these movement detection sensors for your specific applications.  \n> **Image:** Set of WisBlock IoT Education Kit - Movement Detection", "keywords": ["WisBlock", "Movement Detection", "RAK19007", "RAK19003", "RAK4631", "RAK12006", "RAK12007", "RAK12013", "RAK12017"], "source_file": "quickstart.md", "token_count": 150, "parent_content": "**WisBlock IoT Education Kit - Movement Detection** includes several movement detection sensors that can be used with the **RAK19007** and **RAK19003 WisBlock Base Boards**, which you can choose from. They are used to monitor object movements or even for motion detection, which can be useful for different IoT applications. You can select from these movement detection sensors for your specific applications.  \n> **Image:** Set of WisBlock IoT Education Kit - Movement Detection  \nAssemble the WisBlock Movement Detection Modules with the RAK19007 WisBlock Base Board as shown in **Figures 2~5**:  \n**RAK4631 + RAK12006 Board**  \n> **Image:** RAK4631 + RAK12006 Board  \n**RAK4631 + RAK12007 Board**  \n> **Image:** RAK4631 + RAK12007 Board  \n**RAK4631 + RAK12013 Board**  \n> **Image:** RAK4631 + RAK12013 Board  \n**RAK4631 + RAK12017 Board**  \n> **Image:** RAK4631 + RAK12017 Board"}
{"id": "3e0af776b9fd58695d9e1990c878ac01", "product_family": "wisblock", "product_id": "kit3-movement-detection", "category": "How-To", "title": "WisBlock Movement Detection Kit Quick Start Guide > WisBlock IoT Education Kit - Movement Detection Quick Start Guide > Product Configuration > Hardware Setup > Assembling WisBlock Movement Detection Modules with RAK19007 Base Board", "content": "> **Image:** Set of WisBlock IoT Education Kit - Movement Detection  \nAssemble the WisBlock Movement Detection Modules with the RAK19007 WisBlock Base Board as shown in **Figures 2~5**:  \n**RAK4631 + RAK12006 Board**  \n> **Image:** RAK4631 + RAK12006 Board  \n**RAK4631 + RAK12007 Board**  \n> **Image:** RAK4631 + RAK12007 Board  \n**RAK4631 + RAK12013 Board**  \n> **Image:** RAK4631 + RAK12013 Board  \n**RAK4631 + RAK12017 Board**  \n> **Image:** RAK4631 + RAK12017 Board", "keywords": ["WisBlock", "Movement Detection", "RAK19007", "RAK19003", "RAK4631", "RAK12006", "RAK12007", "RAK12013", "RAK12017"], "source_file": "quickstart.md", "token_count": 150, "parent_content": "**WisBlock IoT Education Kit - Movement Detection** includes several movement detection sensors that can be used with the **RAK19007** and **RAK19003 WisBlock Base Boards**, which you can choose from. They are used to monitor object movements or even for motion detection, which can be useful for different IoT applications. You can select from these movement detection sensors for your specific applications.  \n> **Image:** Set of WisBlock IoT Education Kit - Movement Detection  \nAssemble the WisBlock Movement Detection Modules with the RAK19007 WisBlock Base Board as shown in **Figures 2~5**:  \n**RAK4631 + RAK12006 Board**  \n> **Image:** RAK4631 + RAK12006 Board  \n**RAK4631 + RAK12007 Board**  \n> **Image:** RAK4631 + RAK12007 Board  \n**RAK4631 + RAK12013 Board**  \n> **Image:** RAK4631 + RAK12013 Board  \n**RAK4631 + RAK12017 Board**  \n> **Image:** RAK4631 + RAK12017 Board"}
{"id": "3a920c2dcf86456696190c84b559f651", "product_family": "wisblock", "product_id": "kit3-movement-detection", "category": "Reference", "title": "WisBlock Movement Detection Kit Quick Start Guide > WisBlock IoT Education Kit - Movement Detection Quick Start Guide > Product Configuration > Hardware Setup > Assembly and Functionality Tests of WisBlock Movement Detection Modules > WisBlock Movement Detection Modules Overview", "content": "This kit makes use of the different WisBlock Movement Detection modules. Refer to the following list for more information on their assemblies and functionalities:  \n- [RAK12006 PIR Motion Sensor](https://docs.rakwireless.com/product-categories/wisblock/rak12006/quickstart/)\n- [RAK12007 Ultrasonic Sensor](https://docs.rakwireless.com/product-categories/wisblock/rak12007/quickstart/)\n- [RAK12013 Radar Sensor](https://docs.rakwireless.com/product-categories/wisblock/rak12013/quickstart/)", "keywords": ["WisBlock", "Movement Detection", "RAK12006", "RAK12007", "RAK12013", "RAK12017"], "source_file": "quickstart.md", "token_count": 0, "parent_content": "This kit makes use of the different WisBlock Movement Detection modules. Refer to the following list for more information on their assemblies and functionalities:  \n- [RAK12006 PIR Motion Sensor](https://docs.rakwireless.com/product-categories/wisblock/rak12006/quickstart/)\n- [RAK12007 Ultrasonic Sensor](https://docs.rakwireless.com/product-categories/wisblock/rak12007/quickstart/)\n- [RAK12013 Radar Sensor](https://docs.rakwireless.com/product-categories/wisblock/rak12013/quickstart/)\n- [RAK12017 IR Proximity Sensor](https://docs.rakwireless.com/product-categories/wisblock/rak12017/quickstart/)"}
{"id": "3333a5946cf323923a5c0896e1aa0fe5", "product_family": "wisblock", "product_id": "kit3-movement-detection", "category": "Reference", "title": "WisBlock Movement Detection Kit Quick Start Guide > WisBlock IoT Education Kit - Movement Detection Quick Start Guide > Product Configuration > Hardware Setup > Assembly and Functionality Tests of WisBlock Movement Detection Modules > WisBlock Movement Detection Modules Overview", "content": "- [RAK12017 IR Proximity Sensor](https://docs.rakwireless.com/product-categories/wisblock/rak12017/quickstart/)", "keywords": ["WisBlock", "Movement Detection", "RAK12006", "RAK12007", "RAK12013", "RAK12017"], "source_file": "quickstart.md", "token_count": 0, "parent_content": "This kit makes use of the different WisBlock Movement Detection modules. Refer to the following list for more information on their assemblies and functionalities:  \n- [RAK12006 PIR Motion Sensor](https://docs.rakwireless.com/product-categories/wisblock/rak12006/quickstart/)\n- [RAK12007 Ultrasonic Sensor](https://docs.rakwireless.com/product-categories/wisblock/rak12007/quickstart/)\n- [RAK12013 Radar Sensor](https://docs.rakwireless.com/product-categories/wisblock/rak12013/quickstart/)\n- [RAK12017 IR Proximity Sensor](https://docs.rakwireless.com/product-categories/wisblock/rak12017/quickstart/)"}
{"id": "60dea4557a8e3123663956f0166b23fe", "product_family": "wisblock", "product_id": "kit3-movement-detection", "category": "How-To", "title": "WisBlock Movement Detection Kit Quick Start Guide > WisBlock IoT Education Kit - Movement Detection Quick Start Guide > Product Configuration > Software Configuration and Examples > RAK12006 PIR Motion Sensor LoRaWAN Application > Connect to The Things Network (TTN) > TTN Account Setup and OTAA Device Registration", "content": "- If you already have an existing TTN account, you may proceed to the [OTAA Device Registration](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#otaa-device-registration) section.\n- If you do not already have an account, go to the [The Things Network Configuration](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#the-things-network-configuration) section and create one, then register your end-device.", "keywords": ["TTN", "OTAA", "device registration", "account setup"], "source_file": "quickstart.md", "token_count": 50, "parent_content": "- If you already have an existing TTN account, you may proceed to the [OTAA Device Registration](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#otaa-device-registration) section.\n- If you do not already have an account, go to the [The Things Network Configuration](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#the-things-network-configuration) section and create one, then register your end-device."}
{"id": "003e1aed9e37f7b57175a4c36031ace7", "product_family": "wisblock", "product_id": "kit3-movement-detection", "category": "How-To", "title": "WisBlock Movement Detection Kit Quick Start Guide > WisBlock IoT Education Kit - Movement Detection Quick Start Guide > Product Configuration > Software Configuration and Examples > RAK12006 PIR Motion Sensor LoRaWAN Application > LoRaWAN Code for RAK12006 > Programming RAK12006 Module with LoRaWAN Application Code [CODE]", "content": "1. If you already have **Arduino IDE** installed on your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you have not yet installed the **Arduino IDE**, go to the [RAK4631 Installation](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#arduino-ide-installation-rak4631) section and execute the following steps.", "keywords": ["Arduino IDE", "RAK4631", "RAK12006", "LoRaWAN", "programming"], "source_file": "quickstart.md", "token_count": 150, "parent_content": "1. If you already have **Arduino IDE** installed on your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you have not yet installed the **Arduino IDE**, go to the [RAK4631 Installation](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#arduino-ide-installation-rak4631) section and execute the following steps.  \n2. After the installation, you can now proceed with programming your **RAK12006** module. Simply copy the **RAK12006 LoRaWAN Application** code below and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n```c\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h> //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n// Section to add include libraries, declarations and variables.\n\n#define SENSOR_PIN  WB_IO6   // Attach AM312 sensor to Arduino Digital Pin WB_IO6\n\nint gCurrentStatus = 0;         // variable for reading the pin current status\n\nint sensor_val;\n\nbool doOTAA = true;   // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                     /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                   /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5             /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                      /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                      /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = {LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF};\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = {BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler\n};\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x3F, 0xC4, 0x80, 0x0D, 0x4A, 0xE7, 0xAD, 0x9F, 0xDC, 0x27, 0x5D, 0x37, 0x2C, 0x4C, 0xD3, 0xF8};\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = {0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23};\nuint8_t nodeAppsKey[16] = {0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C};\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                     /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];            //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = {m_lora_app_data_buffer, 0, 0, 0, 0}; //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup()\n{\npinMode(SENSOR_PIN, INPUT);        // PIR Sensor as an INPUT\npinMode(LED_GREEN, OUTPUT);\npinMode(LED_BLUE, OUTPUT);\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial)\n{\nif ((millis() - timeout) < 5000)\n{\ndelay(100);\n}\nelse\n{\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA)\n{\nSerial.println(\"Type: OTAA\");\n}\nelse\n{\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion)\n{\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA)\n{\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n}\nelse\n{\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0)\n{\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"========================\");\nSerial.println(\"    RAK12006 LoRaWAN test\");\nSerial.println(\"========================\");\n\n}\n\n// Default void loop\n\nvoid loop()\n{\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\ngCurrentStatus = digitalRead(SENSOR_PIN);\n\nif (gCurrentStatus == 0)\n// \"0\" for Detected; \"1\" for Undetected\n{\ndigitalWrite(LED_GREEN, HIGH); // Turn ON LED\ndigitalWrite(LED_BLUE, HIGH);\nsensor_val = 1;\nsend_lora_frame();\ndelay(2000);\n}\n\nelse if (gCurrentStatus == 1)\n{\n// do nothing\ndigitalWrite(LED_GREEN, LOW); // Turn OFF LED\ndigitalWrite(LED_BLUE, LOW);\nsensor_val = 0;\nsend_lora_frame();\ndelay(2000);\n}\n\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void)\n{\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void)\n{\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data)\n{\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class)\n{\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\n// void send_lora_frame for RAK12006 Application\nvoid send_lora_frame(void)\n{\nif (lmh_join_status_get() != LMH_SET)\n{\n//Not joined, try again later\nreturn;\n}\n\n//int sensor_val;\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\nm_lora_app_data.buffer[i++] = sensor_val;\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS)\n{\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n}\nelse\n{\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The following steps will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired regions to work with. You can change this to a region that is applicable to you, like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc.  \nThe following table lists the LoRaWAN regions and the countries where they are used:  \n| LoRaWAN Region         | Usage                                                             |\n| ---------------------- | ----------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1 | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan          |\n| LORAMAC_REGION_AS923-2 | Vietnam                                                           |\n| LORAMAC_REGION_AS923-3 | Philippines, Albania, Algeria, Denmark, Greenland, Jordan         |\n| LORAMAC_REGION_AS923-4 | Israel                                                            |\n| LORAMAC_REGION_AU915   | Australia, Anguilla, Argentina, and other parts of South America  |\n| LORAMAC_REGION_CN470   | China                                                             |\n| LORAMAC_REGION_EU433   | EU, UK, Brazil, Costa Rica, Cuba, and other parts of Africa       |\n| LORAMAC_REGION_IN865   | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger |\n| LORAMAC_REGION_EU868   | EU, UK and other parts of Africa                                  |\n| LORAMAC_REGION_KR920   | Republic of Korea                                                 |\n| LORAMAC_REGION_US915   | USA                                                               |\n| LORAMAC_REGION_RU864   | Russia                                                            |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n\n```  \n- Set up the LoRaWAN activation method. In this case, you will use the **OTAA** configuration, which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change it to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n\n```  \n- Set up the EUIs and KEY. The **DeviceEUI**, **AppEUI**, and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x3F, 0xC4, 0x80, 0x0D, 0x4A, 0xE7, 0xAD, 0x9F, 0xDC, 0x27, 0x5D, 0x37, 0x2C, 0x4C, 0xD3, 0xF8};\n\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once you're done with the code, you can now proceed with uploading it to your device. You must first choose your RAK4631 board on your desktop or laptop. To do so, navigate to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** and select **WisBlock RAK4631**.  \n> **Image:** Selecting the RAK4631 board  \n4. After you have selected your board, go to **Tools** > **Port** and then select the specific port of your board.  \n> **Image:** Selecting the port of RAK4631 board  \n5. You can then upload your code by clicking the Upload button (the right arrow sign). Once completed, the **Device programmed** notification will appear in the console at the bottom of the Arduino IDE.  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board  \n> **TIP:** NOTE  \nThe steps outlined above apply to the **RAK12013** and **RAK12017** applications. Once you have finished uploading the code, proceed to the next step:  \n- **RAK12013**: [Setting up RAK12013 Radar Sensor Dashboard Using ThingSpeak](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#setting-up-rak12013-radar-sensor-dashboard-using-thingspeak)\n- **RAK12017**: [Setting up RAK12017 IR Proximity Sensor Dashboard Using ThingSpeak](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#setting-up-rak12017-ir-proximity-sensor-dashboard-using-thingspeak)"}
{"id": "e9a0ade00f2b8ba35b476bb1b547b877", "product_family": "wisblock", "product_id": "kit3-movement-detection", "category": "How-To", "title": "WisBlock Movement Detection Kit Quick Start Guide > WisBlock IoT Education Kit - Movement Detection Quick Start Guide > Product Configuration > Software Configuration and Examples > RAK12006 PIR Motion Sensor LoRaWAN Application > LoRaWAN Code for RAK12006 > Programming RAK12006 Module with LoRaWAN Application Code [CODE]", "content": "2. After the installation, you can now proceed with programming your **RAK12006** module. Simply copy the **RAK12006 LoRaWAN Application** code below and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n```c\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h> //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>", "keywords": ["Arduino IDE", "RAK4631", "RAK12006", "LoRaWAN", "programming"], "source_file": "quickstart.md", "token_count": 150, "parent_content": "1. If you already have **Arduino IDE** installed on your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you have not yet installed the **Arduino IDE**, go to the [RAK4631 Installation](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#arduino-ide-installation-rak4631) section and execute the following steps.  \n2. After the installation, you can now proceed with programming your **RAK12006** module. Simply copy the **RAK12006 LoRaWAN Application** code below and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n```c\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h> //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n// Section to add include libraries, declarations and variables.\n\n#define SENSOR_PIN  WB_IO6   // Attach AM312 sensor to Arduino Digital Pin WB_IO6\n\nint gCurrentStatus = 0;         // variable for reading the pin current status\n\nint sensor_val;\n\nbool doOTAA = true;   // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                     /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                   /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5             /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                      /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                      /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = {LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF};\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = {BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler\n};\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x3F, 0xC4, 0x80, 0x0D, 0x4A, 0xE7, 0xAD, 0x9F, 0xDC, 0x27, 0x5D, 0x37, 0x2C, 0x4C, 0xD3, 0xF8};\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = {0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23};\nuint8_t nodeAppsKey[16] = {0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C};\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                     /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];            //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = {m_lora_app_data_buffer, 0, 0, 0, 0}; //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup()\n{\npinMode(SENSOR_PIN, INPUT);        // PIR Sensor as an INPUT\npinMode(LED_GREEN, OUTPUT);\npinMode(LED_BLUE, OUTPUT);\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial)\n{\nif ((millis() - timeout) < 5000)\n{\ndelay(100);\n}\nelse\n{\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA)\n{\nSerial.println(\"Type: OTAA\");\n}\nelse\n{\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion)\n{\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA)\n{\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n}\nelse\n{\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0)\n{\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"========================\");\nSerial.println(\"    RAK12006 LoRaWAN test\");\nSerial.println(\"========================\");\n\n}\n\n// Default void loop\n\nvoid loop()\n{\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\ngCurrentStatus = digitalRead(SENSOR_PIN);\n\nif (gCurrentStatus == 0)\n// \"0\" for Detected; \"1\" for Undetected\n{\ndigitalWrite(LED_GREEN, HIGH); // Turn ON LED\ndigitalWrite(LED_BLUE, HIGH);\nsensor_val = 1;\nsend_lora_frame();\ndelay(2000);\n}\n\nelse if (gCurrentStatus == 1)\n{\n// do nothing\ndigitalWrite(LED_GREEN, LOW); // Turn OFF LED\ndigitalWrite(LED_BLUE, LOW);\nsensor_val = 0;\nsend_lora_frame();\ndelay(2000);\n}\n\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void)\n{\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void)\n{\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data)\n{\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class)\n{\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\n// void send_lora_frame for RAK12006 Application\nvoid send_lora_frame(void)\n{\nif (lmh_join_status_get() != LMH_SET)\n{\n//Not joined, try again later\nreturn;\n}\n\n//int sensor_val;\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\nm_lora_app_data.buffer[i++] = sensor_val;\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS)\n{\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n}\nelse\n{\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The following steps will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired regions to work with. You can change this to a region that is applicable to you, like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc.  \nThe following table lists the LoRaWAN regions and the countries where they are used:  \n| LoRaWAN Region         | Usage                                                             |\n| ---------------------- | ----------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1 | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan          |\n| LORAMAC_REGION_AS923-2 | Vietnam                                                           |\n| LORAMAC_REGION_AS923-3 | Philippines, Albania, Algeria, Denmark, Greenland, Jordan         |\n| LORAMAC_REGION_AS923-4 | Israel                                                            |\n| LORAMAC_REGION_AU915   | Australia, Anguilla, Argentina, and other parts of South America  |\n| LORAMAC_REGION_CN470   | China                                                             |\n| LORAMAC_REGION_EU433   | EU, UK, Brazil, Costa Rica, Cuba, and other parts of Africa       |\n| LORAMAC_REGION_IN865   | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger |\n| LORAMAC_REGION_EU868   | EU, UK and other parts of Africa                                  |\n| LORAMAC_REGION_KR920   | Republic of Korea                                                 |\n| LORAMAC_REGION_US915   | USA                                                               |\n| LORAMAC_REGION_RU864   | Russia                                                            |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n\n```  \n- Set up the LoRaWAN activation method. In this case, you will use the **OTAA** configuration, which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change it to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n\n```  \n- Set up the EUIs and KEY. The **DeviceEUI**, **AppEUI**, and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x3F, 0xC4, 0x80, 0x0D, 0x4A, 0xE7, 0xAD, 0x9F, 0xDC, 0x27, 0x5D, 0x37, 0x2C, 0x4C, 0xD3, 0xF8};\n\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once you're done with the code, you can now proceed with uploading it to your device. You must first choose your RAK4631 board on your desktop or laptop. To do so, navigate to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** and select **WisBlock RAK4631**.  \n> **Image:** Selecting the RAK4631 board  \n4. After you have selected your board, go to **Tools** > **Port** and then select the specific port of your board.  \n> **Image:** Selecting the port of RAK4631 board  \n5. You can then upload your code by clicking the Upload button (the right arrow sign). Once completed, the **Device programmed** notification will appear in the console at the bottom of the Arduino IDE.  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board  \n> **TIP:** NOTE  \nThe steps outlined above apply to the **RAK12013** and **RAK12017** applications. Once you have finished uploading the code, proceed to the next step:  \n- **RAK12013**: [Setting up RAK12013 Radar Sensor Dashboard Using ThingSpeak](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#setting-up-rak12013-radar-sensor-dashboard-using-thingspeak)\n- **RAK12017**: [Setting up RAK12017 IR Proximity Sensor Dashboard Using ThingSpeak](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#setting-up-rak12017-ir-proximity-sensor-dashboard-using-thingspeak)"}
{"id": "965f1c91796510a7ec35c8a8e369704f", "product_family": "wisblock", "product_id": "kit3-movement-detection", "category": "How-To", "title": "WisBlock Movement Detection Kit Quick Start Guide > WisBlock IoT Education Kit - Movement Detection Quick Start Guide > Product Configuration > Software Configuration and Examples > RAK12006 PIR Motion Sensor LoRaWAN Application > LoRaWAN Code for RAK12006 > Programming RAK12006 Module with LoRaWAN Application Code [CODE]", "content": "// Section to add include libraries, declarations and variables.\n\n#define SENSOR_PIN  WB_IO6   // Attach AM312 sensor to Arduino Digital Pin WB_IO6\n\nint gCurrentStatus = 0;         // variable for reading the pin current status\n\nint sensor_val;", "keywords": ["Arduino IDE", "RAK4631", "RAK12006", "LoRaWAN", "programming"], "source_file": "quickstart.md", "token_count": 150, "parent_content": "1. If you already have **Arduino IDE** installed on your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you have not yet installed the **Arduino IDE**, go to the [RAK4631 Installation](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#arduino-ide-installation-rak4631) section and execute the following steps.  \n2. After the installation, you can now proceed with programming your **RAK12006** module. Simply copy the **RAK12006 LoRaWAN Application** code below and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n```c\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h> //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n// Section to add include libraries, declarations and variables.\n\n#define SENSOR_PIN  WB_IO6   // Attach AM312 sensor to Arduino Digital Pin WB_IO6\n\nint gCurrentStatus = 0;         // variable for reading the pin current status\n\nint sensor_val;\n\nbool doOTAA = true;   // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                     /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                   /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5             /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                      /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                      /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = {LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF};\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = {BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler\n};\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x3F, 0xC4, 0x80, 0x0D, 0x4A, 0xE7, 0xAD, 0x9F, 0xDC, 0x27, 0x5D, 0x37, 0x2C, 0x4C, 0xD3, 0xF8};\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = {0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23};\nuint8_t nodeAppsKey[16] = {0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C};\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                     /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];            //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = {m_lora_app_data_buffer, 0, 0, 0, 0}; //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup()\n{\npinMode(SENSOR_PIN, INPUT);        // PIR Sensor as an INPUT\npinMode(LED_GREEN, OUTPUT);\npinMode(LED_BLUE, OUTPUT);\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial)\n{\nif ((millis() - timeout) < 5000)\n{\ndelay(100);\n}\nelse\n{\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA)\n{\nSerial.println(\"Type: OTAA\");\n}\nelse\n{\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion)\n{\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA)\n{\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n}\nelse\n{\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0)\n{\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"========================\");\nSerial.println(\"    RAK12006 LoRaWAN test\");\nSerial.println(\"========================\");\n\n}\n\n// Default void loop\n\nvoid loop()\n{\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\ngCurrentStatus = digitalRead(SENSOR_PIN);\n\nif (gCurrentStatus == 0)\n// \"0\" for Detected; \"1\" for Undetected\n{\ndigitalWrite(LED_GREEN, HIGH); // Turn ON LED\ndigitalWrite(LED_BLUE, HIGH);\nsensor_val = 1;\nsend_lora_frame();\ndelay(2000);\n}\n\nelse if (gCurrentStatus == 1)\n{\n// do nothing\ndigitalWrite(LED_GREEN, LOW); // Turn OFF LED\ndigitalWrite(LED_BLUE, LOW);\nsensor_val = 0;\nsend_lora_frame();\ndelay(2000);\n}\n\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void)\n{\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void)\n{\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data)\n{\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class)\n{\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\n// void send_lora_frame for RAK12006 Application\nvoid send_lora_frame(void)\n{\nif (lmh_join_status_get() != LMH_SET)\n{\n//Not joined, try again later\nreturn;\n}\n\n//int sensor_val;\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\nm_lora_app_data.buffer[i++] = sensor_val;\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS)\n{\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n}\nelse\n{\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The following steps will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired regions to work with. You can change this to a region that is applicable to you, like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc.  \nThe following table lists the LoRaWAN regions and the countries where they are used:  \n| LoRaWAN Region         | Usage                                                             |\n| ---------------------- | ----------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1 | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan          |\n| LORAMAC_REGION_AS923-2 | Vietnam                                                           |\n| LORAMAC_REGION_AS923-3 | Philippines, Albania, Algeria, Denmark, Greenland, Jordan         |\n| LORAMAC_REGION_AS923-4 | Israel                                                            |\n| LORAMAC_REGION_AU915   | Australia, Anguilla, Argentina, and other parts of South America  |\n| LORAMAC_REGION_CN470   | China                                                             |\n| LORAMAC_REGION_EU433   | EU, UK, Brazil, Costa Rica, Cuba, and other parts of Africa       |\n| LORAMAC_REGION_IN865   | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger |\n| LORAMAC_REGION_EU868   | EU, UK and other parts of Africa                                  |\n| LORAMAC_REGION_KR920   | Republic of Korea                                                 |\n| LORAMAC_REGION_US915   | USA                                                               |\n| LORAMAC_REGION_RU864   | Russia                                                            |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n\n```  \n- Set up the LoRaWAN activation method. In this case, you will use the **OTAA** configuration, which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change it to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n\n```  \n- Set up the EUIs and KEY. The **DeviceEUI**, **AppEUI**, and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x3F, 0xC4, 0x80, 0x0D, 0x4A, 0xE7, 0xAD, 0x9F, 0xDC, 0x27, 0x5D, 0x37, 0x2C, 0x4C, 0xD3, 0xF8};\n\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once you're done with the code, you can now proceed with uploading it to your device. You must first choose your RAK4631 board on your desktop or laptop. To do so, navigate to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** and select **WisBlock RAK4631**.  \n> **Image:** Selecting the RAK4631 board  \n4. After you have selected your board, go to **Tools** > **Port** and then select the specific port of your board.  \n> **Image:** Selecting the port of RAK4631 board  \n5. You can then upload your code by clicking the Upload button (the right arrow sign). Once completed, the **Device programmed** notification will appear in the console at the bottom of the Arduino IDE.  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board  \n> **TIP:** NOTE  \nThe steps outlined above apply to the **RAK12013** and **RAK12017** applications. Once you have finished uploading the code, proceed to the next step:  \n- **RAK12013**: [Setting up RAK12013 Radar Sensor Dashboard Using ThingSpeak](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#setting-up-rak12013-radar-sensor-dashboard-using-thingspeak)\n- **RAK12017**: [Setting up RAK12017 IR Proximity Sensor Dashboard Using ThingSpeak](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#setting-up-rak12017-ir-proximity-sensor-dashboard-using-thingspeak)"}
{"id": "0a6f995f1e26f530fdf9ca69a9933880", "product_family": "wisblock", "product_id": "kit3-movement-detection", "category": "How-To", "title": "WisBlock Movement Detection Kit Quick Start Guide > WisBlock IoT Education Kit - Movement Detection Quick Start Guide > Product Configuration > Software Configuration and Examples > RAK12006 PIR Motion Sensor LoRaWAN Application > LoRaWAN Code for RAK12006 > Programming RAK12006 Module with LoRaWAN Application Code [CODE]", "content": "bool doOTAA = true;   // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                     /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                   /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5             /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/", "keywords": ["Arduino IDE", "RAK4631", "RAK12006", "LoRaWAN", "programming"], "source_file": "quickstart.md", "token_count": 150, "parent_content": "1. If you already have **Arduino IDE** installed on your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you have not yet installed the **Arduino IDE**, go to the [RAK4631 Installation](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#arduino-ide-installation-rak4631) section and execute the following steps.  \n2. After the installation, you can now proceed with programming your **RAK12006** module. Simply copy the **RAK12006 LoRaWAN Application** code below and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n```c\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h> //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n// Section to add include libraries, declarations and variables.\n\n#define SENSOR_PIN  WB_IO6   // Attach AM312 sensor to Arduino Digital Pin WB_IO6\n\nint gCurrentStatus = 0;         // variable for reading the pin current status\n\nint sensor_val;\n\nbool doOTAA = true;   // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                     /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                   /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5             /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                      /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                      /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = {LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF};\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = {BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler\n};\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x3F, 0xC4, 0x80, 0x0D, 0x4A, 0xE7, 0xAD, 0x9F, 0xDC, 0x27, 0x5D, 0x37, 0x2C, 0x4C, 0xD3, 0xF8};\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = {0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23};\nuint8_t nodeAppsKey[16] = {0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C};\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                     /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];            //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = {m_lora_app_data_buffer, 0, 0, 0, 0}; //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup()\n{\npinMode(SENSOR_PIN, INPUT);        // PIR Sensor as an INPUT\npinMode(LED_GREEN, OUTPUT);\npinMode(LED_BLUE, OUTPUT);\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial)\n{\nif ((millis() - timeout) < 5000)\n{\ndelay(100);\n}\nelse\n{\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA)\n{\nSerial.println(\"Type: OTAA\");\n}\nelse\n{\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion)\n{\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA)\n{\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n}\nelse\n{\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0)\n{\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"========================\");\nSerial.println(\"    RAK12006 LoRaWAN test\");\nSerial.println(\"========================\");\n\n}\n\n// Default void loop\n\nvoid loop()\n{\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\ngCurrentStatus = digitalRead(SENSOR_PIN);\n\nif (gCurrentStatus == 0)\n// \"0\" for Detected; \"1\" for Undetected\n{\ndigitalWrite(LED_GREEN, HIGH); // Turn ON LED\ndigitalWrite(LED_BLUE, HIGH);\nsensor_val = 1;\nsend_lora_frame();\ndelay(2000);\n}\n\nelse if (gCurrentStatus == 1)\n{\n// do nothing\ndigitalWrite(LED_GREEN, LOW); // Turn OFF LED\ndigitalWrite(LED_BLUE, LOW);\nsensor_val = 0;\nsend_lora_frame();\ndelay(2000);\n}\n\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void)\n{\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void)\n{\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data)\n{\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class)\n{\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\n// void send_lora_frame for RAK12006 Application\nvoid send_lora_frame(void)\n{\nif (lmh_join_status_get() != LMH_SET)\n{\n//Not joined, try again later\nreturn;\n}\n\n//int sensor_val;\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\nm_lora_app_data.buffer[i++] = sensor_val;\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS)\n{\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n}\nelse\n{\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The following steps will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired regions to work with. You can change this to a region that is applicable to you, like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc.  \nThe following table lists the LoRaWAN regions and the countries where they are used:  \n| LoRaWAN Region         | Usage                                                             |\n| ---------------------- | ----------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1 | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan          |\n| LORAMAC_REGION_AS923-2 | Vietnam                                                           |\n| LORAMAC_REGION_AS923-3 | Philippines, Albania, Algeria, Denmark, Greenland, Jordan         |\n| LORAMAC_REGION_AS923-4 | Israel                                                            |\n| LORAMAC_REGION_AU915   | Australia, Anguilla, Argentina, and other parts of South America  |\n| LORAMAC_REGION_CN470   | China                                                             |\n| LORAMAC_REGION_EU433   | EU, UK, Brazil, Costa Rica, Cuba, and other parts of Africa       |\n| LORAMAC_REGION_IN865   | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger |\n| LORAMAC_REGION_EU868   | EU, UK and other parts of Africa                                  |\n| LORAMAC_REGION_KR920   | Republic of Korea                                                 |\n| LORAMAC_REGION_US915   | USA                                                               |\n| LORAMAC_REGION_RU864   | Russia                                                            |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n\n```  \n- Set up the LoRaWAN activation method. In this case, you will use the **OTAA** configuration, which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change it to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n\n```  \n- Set up the EUIs and KEY. The **DeviceEUI**, **AppEUI**, and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x3F, 0xC4, 0x80, 0x0D, 0x4A, 0xE7, 0xAD, 0x9F, 0xDC, 0x27, 0x5D, 0x37, 0x2C, 0x4C, 0xD3, 0xF8};\n\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once you're done with the code, you can now proceed with uploading it to your device. You must first choose your RAK4631 board on your desktop or laptop. To do so, navigate to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** and select **WisBlock RAK4631**.  \n> **Image:** Selecting the RAK4631 board  \n4. After you have selected your board, go to **Tools** > **Port** and then select the specific port of your board.  \n> **Image:** Selecting the port of RAK4631 board  \n5. You can then upload your code by clicking the Upload button (the right arrow sign). Once completed, the **Device programmed** notification will appear in the console at the bottom of the Arduino IDE.  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board  \n> **TIP:** NOTE  \nThe steps outlined above apply to the **RAK12013** and **RAK12017** applications. Once you have finished uploading the code, proceed to the next step:  \n- **RAK12013**: [Setting up RAK12013 Radar Sensor Dashboard Using ThingSpeak](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#setting-up-rak12013-radar-sensor-dashboard-using-thingspeak)\n- **RAK12017**: [Setting up RAK12017 IR Proximity Sensor Dashboard Using ThingSpeak](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#setting-up-rak12017-ir-proximity-sensor-dashboard-using-thingspeak)"}
{"id": "25d4f77f1c6151a71dbcf1d163a37d48", "product_family": "wisblock", "product_id": "kit3-movement-detection", "category": "How-To", "title": "WisBlock Movement Detection Kit Quick Start Guide > WisBlock IoT Education Kit - Movement Detection Quick Start Guide > Product Configuration > Software Configuration and Examples > RAK12006 PIR Motion Sensor LoRaWAN Application > LoRaWAN Code for RAK12006 > Programming RAK12006 Module with LoRaWAN Application Code [CODE]", "content": "#define JOINREQ_NBTRIALS 3                      /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                      /* data port*/", "keywords": ["Arduino IDE", "RAK4631", "RAK12006", "LoRaWAN", "programming"], "source_file": "quickstart.md", "token_count": 150, "parent_content": "1. If you already have **Arduino IDE** installed on your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you have not yet installed the **Arduino IDE**, go to the [RAK4631 Installation](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#arduino-ide-installation-rak4631) section and execute the following steps.  \n2. After the installation, you can now proceed with programming your **RAK12006** module. Simply copy the **RAK12006 LoRaWAN Application** code below and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n```c\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h> //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n// Section to add include libraries, declarations and variables.\n\n#define SENSOR_PIN  WB_IO6   // Attach AM312 sensor to Arduino Digital Pin WB_IO6\n\nint gCurrentStatus = 0;         // variable for reading the pin current status\n\nint sensor_val;\n\nbool doOTAA = true;   // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                     /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                   /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5             /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                      /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                      /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = {LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF};\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = {BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler\n};\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x3F, 0xC4, 0x80, 0x0D, 0x4A, 0xE7, 0xAD, 0x9F, 0xDC, 0x27, 0x5D, 0x37, 0x2C, 0x4C, 0xD3, 0xF8};\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = {0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23};\nuint8_t nodeAppsKey[16] = {0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C};\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                     /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];            //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = {m_lora_app_data_buffer, 0, 0, 0, 0}; //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup()\n{\npinMode(SENSOR_PIN, INPUT);        // PIR Sensor as an INPUT\npinMode(LED_GREEN, OUTPUT);\npinMode(LED_BLUE, OUTPUT);\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial)\n{\nif ((millis() - timeout) < 5000)\n{\ndelay(100);\n}\nelse\n{\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA)\n{\nSerial.println(\"Type: OTAA\");\n}\nelse\n{\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion)\n{\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA)\n{\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n}\nelse\n{\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0)\n{\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"========================\");\nSerial.println(\"    RAK12006 LoRaWAN test\");\nSerial.println(\"========================\");\n\n}\n\n// Default void loop\n\nvoid loop()\n{\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\ngCurrentStatus = digitalRead(SENSOR_PIN);\n\nif (gCurrentStatus == 0)\n// \"0\" for Detected; \"1\" for Undetected\n{\ndigitalWrite(LED_GREEN, HIGH); // Turn ON LED\ndigitalWrite(LED_BLUE, HIGH);\nsensor_val = 1;\nsend_lora_frame();\ndelay(2000);\n}\n\nelse if (gCurrentStatus == 1)\n{\n// do nothing\ndigitalWrite(LED_GREEN, LOW); // Turn OFF LED\ndigitalWrite(LED_BLUE, LOW);\nsensor_val = 0;\nsend_lora_frame();\ndelay(2000);\n}\n\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void)\n{\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void)\n{\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data)\n{\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class)\n{\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\n// void send_lora_frame for RAK12006 Application\nvoid send_lora_frame(void)\n{\nif (lmh_join_status_get() != LMH_SET)\n{\n//Not joined, try again later\nreturn;\n}\n\n//int sensor_val;\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\nm_lora_app_data.buffer[i++] = sensor_val;\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS)\n{\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n}\nelse\n{\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The following steps will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired regions to work with. You can change this to a region that is applicable to you, like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc.  \nThe following table lists the LoRaWAN regions and the countries where they are used:  \n| LoRaWAN Region         | Usage                                                             |\n| ---------------------- | ----------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1 | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan          |\n| LORAMAC_REGION_AS923-2 | Vietnam                                                           |\n| LORAMAC_REGION_AS923-3 | Philippines, Albania, Algeria, Denmark, Greenland, Jordan         |\n| LORAMAC_REGION_AS923-4 | Israel                                                            |\n| LORAMAC_REGION_AU915   | Australia, Anguilla, Argentina, and other parts of South America  |\n| LORAMAC_REGION_CN470   | China                                                             |\n| LORAMAC_REGION_EU433   | EU, UK, Brazil, Costa Rica, Cuba, and other parts of Africa       |\n| LORAMAC_REGION_IN865   | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger |\n| LORAMAC_REGION_EU868   | EU, UK and other parts of Africa                                  |\n| LORAMAC_REGION_KR920   | Republic of Korea                                                 |\n| LORAMAC_REGION_US915   | USA                                                               |\n| LORAMAC_REGION_RU864   | Russia                                                            |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n\n```  \n- Set up the LoRaWAN activation method. In this case, you will use the **OTAA** configuration, which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change it to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n\n```  \n- Set up the EUIs and KEY. The **DeviceEUI**, **AppEUI**, and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x3F, 0xC4, 0x80, 0x0D, 0x4A, 0xE7, 0xAD, 0x9F, 0xDC, 0x27, 0x5D, 0x37, 0x2C, 0x4C, 0xD3, 0xF8};\n\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once you're done with the code, you can now proceed with uploading it to your device. You must first choose your RAK4631 board on your desktop or laptop. To do so, navigate to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** and select **WisBlock RAK4631**.  \n> **Image:** Selecting the RAK4631 board  \n4. After you have selected your board, go to **Tools** > **Port** and then select the specific port of your board.  \n> **Image:** Selecting the port of RAK4631 board  \n5. You can then upload your code by clicking the Upload button (the right arrow sign). Once completed, the **Device programmed** notification will appear in the console at the bottom of the Arduino IDE.  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board  \n> **TIP:** NOTE  \nThe steps outlined above apply to the **RAK12013** and **RAK12017** applications. Once you have finished uploading the code, proceed to the next step:  \n- **RAK12013**: [Setting up RAK12013 Radar Sensor Dashboard Using ThingSpeak](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#setting-up-rak12013-radar-sensor-dashboard-using-thingspeak)\n- **RAK12017**: [Setting up RAK12017 IR Proximity Sensor Dashboard Using ThingSpeak](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#setting-up-rak12017-ir-proximity-sensor-dashboard-using-thingspeak)"}
{"id": "67a1b9ed03346027ce48af169d1e0ba1", "product_family": "wisblock", "product_id": "kit3-movement-detection", "category": "How-To", "title": "WisBlock Movement Detection Kit Quick Start Guide > WisBlock IoT Education Kit - Movement Detection Quick Start Guide > Product Configuration > Software Configuration and Examples > RAK12006 PIR Motion Sensor LoRaWAN Application > LoRaWAN Code for RAK12006 > Programming RAK12006 Module with LoRaWAN Application Code [CODE]", "content": "/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = {LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF};", "keywords": ["Arduino IDE", "RAK4631", "RAK12006", "LoRaWAN", "programming"], "source_file": "quickstart.md", "token_count": 150, "parent_content": "1. If you already have **Arduino IDE** installed on your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you have not yet installed the **Arduino IDE**, go to the [RAK4631 Installation](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#arduino-ide-installation-rak4631) section and execute the following steps.  \n2. After the installation, you can now proceed with programming your **RAK12006** module. Simply copy the **RAK12006 LoRaWAN Application** code below and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n```c\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h> //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n// Section to add include libraries, declarations and variables.\n\n#define SENSOR_PIN  WB_IO6   // Attach AM312 sensor to Arduino Digital Pin WB_IO6\n\nint gCurrentStatus = 0;         // variable for reading the pin current status\n\nint sensor_val;\n\nbool doOTAA = true;   // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                     /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                   /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5             /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                      /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                      /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = {LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF};\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = {BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler\n};\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x3F, 0xC4, 0x80, 0x0D, 0x4A, 0xE7, 0xAD, 0x9F, 0xDC, 0x27, 0x5D, 0x37, 0x2C, 0x4C, 0xD3, 0xF8};\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = {0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23};\nuint8_t nodeAppsKey[16] = {0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C};\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                     /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];            //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = {m_lora_app_data_buffer, 0, 0, 0, 0}; //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup()\n{\npinMode(SENSOR_PIN, INPUT);        // PIR Sensor as an INPUT\npinMode(LED_GREEN, OUTPUT);\npinMode(LED_BLUE, OUTPUT);\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial)\n{\nif ((millis() - timeout) < 5000)\n{\ndelay(100);\n}\nelse\n{\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA)\n{\nSerial.println(\"Type: OTAA\");\n}\nelse\n{\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion)\n{\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA)\n{\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n}\nelse\n{\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0)\n{\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"========================\");\nSerial.println(\"    RAK12006 LoRaWAN test\");\nSerial.println(\"========================\");\n\n}\n\n// Default void loop\n\nvoid loop()\n{\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\ngCurrentStatus = digitalRead(SENSOR_PIN);\n\nif (gCurrentStatus == 0)\n// \"0\" for Detected; \"1\" for Undetected\n{\ndigitalWrite(LED_GREEN, HIGH); // Turn ON LED\ndigitalWrite(LED_BLUE, HIGH);\nsensor_val = 1;\nsend_lora_frame();\ndelay(2000);\n}\n\nelse if (gCurrentStatus == 1)\n{\n// do nothing\ndigitalWrite(LED_GREEN, LOW); // Turn OFF LED\ndigitalWrite(LED_BLUE, LOW);\nsensor_val = 0;\nsend_lora_frame();\ndelay(2000);\n}\n\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void)\n{\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void)\n{\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data)\n{\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class)\n{\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\n// void send_lora_frame for RAK12006 Application\nvoid send_lora_frame(void)\n{\nif (lmh_join_status_get() != LMH_SET)\n{\n//Not joined, try again later\nreturn;\n}\n\n//int sensor_val;\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\nm_lora_app_data.buffer[i++] = sensor_val;\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS)\n{\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n}\nelse\n{\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The following steps will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired regions to work with. You can change this to a region that is applicable to you, like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc.  \nThe following table lists the LoRaWAN regions and the countries where they are used:  \n| LoRaWAN Region         | Usage                                                             |\n| ---------------------- | ----------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1 | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan          |\n| LORAMAC_REGION_AS923-2 | Vietnam                                                           |\n| LORAMAC_REGION_AS923-3 | Philippines, Albania, Algeria, Denmark, Greenland, Jordan         |\n| LORAMAC_REGION_AS923-4 | Israel                                                            |\n| LORAMAC_REGION_AU915   | Australia, Anguilla, Argentina, and other parts of South America  |\n| LORAMAC_REGION_CN470   | China                                                             |\n| LORAMAC_REGION_EU433   | EU, UK, Brazil, Costa Rica, Cuba, and other parts of Africa       |\n| LORAMAC_REGION_IN865   | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger |\n| LORAMAC_REGION_EU868   | EU, UK and other parts of Africa                                  |\n| LORAMAC_REGION_KR920   | Republic of Korea                                                 |\n| LORAMAC_REGION_US915   | USA                                                               |\n| LORAMAC_REGION_RU864   | Russia                                                            |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n\n```  \n- Set up the LoRaWAN activation method. In this case, you will use the **OTAA** configuration, which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change it to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n\n```  \n- Set up the EUIs and KEY. The **DeviceEUI**, **AppEUI**, and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x3F, 0xC4, 0x80, 0x0D, 0x4A, 0xE7, 0xAD, 0x9F, 0xDC, 0x27, 0x5D, 0x37, 0x2C, 0x4C, 0xD3, 0xF8};\n\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once you're done with the code, you can now proceed with uploading it to your device. You must first choose your RAK4631 board on your desktop or laptop. To do so, navigate to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** and select **WisBlock RAK4631**.  \n> **Image:** Selecting the RAK4631 board  \n4. After you have selected your board, go to **Tools** > **Port** and then select the specific port of your board.  \n> **Image:** Selecting the port of RAK4631 board  \n5. You can then upload your code by clicking the Upload button (the right arrow sign). Once completed, the **Device programmed** notification will appear in the console at the bottom of the Arduino IDE.  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board  \n> **TIP:** NOTE  \nThe steps outlined above apply to the **RAK12013** and **RAK12017** applications. Once you have finished uploading the code, proceed to the next step:  \n- **RAK12013**: [Setting up RAK12013 Radar Sensor Dashboard Using ThingSpeak](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#setting-up-rak12013-radar-sensor-dashboard-using-thingspeak)\n- **RAK12017**: [Setting up RAK12017 IR Proximity Sensor Dashboard Using ThingSpeak](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#setting-up-rak12017-ir-proximity-sensor-dashboard-using-thingspeak)"}
{"id": "8ced821f1592e483b8b732a64437cae5", "product_family": "wisblock", "product_id": "kit3-movement-detection", "category": "How-To", "title": "WisBlock Movement Detection Kit Quick Start Guide > WisBlock IoT Education Kit - Movement Detection Quick Start Guide > Product Configuration > Software Configuration and Examples > RAK12006 PIR Motion Sensor LoRaWAN Application > LoRaWAN Code for RAK12006 > Programming RAK12006 Module with LoRaWAN Application Code [CODE]", "content": "// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);", "keywords": ["Arduino IDE", "RAK4631", "RAK12006", "LoRaWAN", "programming"], "source_file": "quickstart.md", "token_count": 150, "parent_content": "1. If you already have **Arduino IDE** installed on your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you have not yet installed the **Arduino IDE**, go to the [RAK4631 Installation](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#arduino-ide-installation-rak4631) section and execute the following steps.  \n2. After the installation, you can now proceed with programming your **RAK12006** module. Simply copy the **RAK12006 LoRaWAN Application** code below and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n```c\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h> //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n// Section to add include libraries, declarations and variables.\n\n#define SENSOR_PIN  WB_IO6   // Attach AM312 sensor to Arduino Digital Pin WB_IO6\n\nint gCurrentStatus = 0;         // variable for reading the pin current status\n\nint sensor_val;\n\nbool doOTAA = true;   // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                     /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                   /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5             /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                      /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                      /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = {LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF};\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = {BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler\n};\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x3F, 0xC4, 0x80, 0x0D, 0x4A, 0xE7, 0xAD, 0x9F, 0xDC, 0x27, 0x5D, 0x37, 0x2C, 0x4C, 0xD3, 0xF8};\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = {0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23};\nuint8_t nodeAppsKey[16] = {0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C};\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                     /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];            //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = {m_lora_app_data_buffer, 0, 0, 0, 0}; //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup()\n{\npinMode(SENSOR_PIN, INPUT);        // PIR Sensor as an INPUT\npinMode(LED_GREEN, OUTPUT);\npinMode(LED_BLUE, OUTPUT);\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial)\n{\nif ((millis() - timeout) < 5000)\n{\ndelay(100);\n}\nelse\n{\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA)\n{\nSerial.println(\"Type: OTAA\");\n}\nelse\n{\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion)\n{\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA)\n{\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n}\nelse\n{\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0)\n{\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"========================\");\nSerial.println(\"    RAK12006 LoRaWAN test\");\nSerial.println(\"========================\");\n\n}\n\n// Default void loop\n\nvoid loop()\n{\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\ngCurrentStatus = digitalRead(SENSOR_PIN);\n\nif (gCurrentStatus == 0)\n// \"0\" for Detected; \"1\" for Undetected\n{\ndigitalWrite(LED_GREEN, HIGH); // Turn ON LED\ndigitalWrite(LED_BLUE, HIGH);\nsensor_val = 1;\nsend_lora_frame();\ndelay(2000);\n}\n\nelse if (gCurrentStatus == 1)\n{\n// do nothing\ndigitalWrite(LED_GREEN, LOW); // Turn OFF LED\ndigitalWrite(LED_BLUE, LOW);\nsensor_val = 0;\nsend_lora_frame();\ndelay(2000);\n}\n\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void)\n{\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void)\n{\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data)\n{\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class)\n{\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\n// void send_lora_frame for RAK12006 Application\nvoid send_lora_frame(void)\n{\nif (lmh_join_status_get() != LMH_SET)\n{\n//Not joined, try again later\nreturn;\n}\n\n//int sensor_val;\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\nm_lora_app_data.buffer[i++] = sensor_val;\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS)\n{\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n}\nelse\n{\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The following steps will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired regions to work with. You can change this to a region that is applicable to you, like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc.  \nThe following table lists the LoRaWAN regions and the countries where they are used:  \n| LoRaWAN Region         | Usage                                                             |\n| ---------------------- | ----------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1 | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan          |\n| LORAMAC_REGION_AS923-2 | Vietnam                                                           |\n| LORAMAC_REGION_AS923-3 | Philippines, Albania, Algeria, Denmark, Greenland, Jordan         |\n| LORAMAC_REGION_AS923-4 | Israel                                                            |\n| LORAMAC_REGION_AU915   | Australia, Anguilla, Argentina, and other parts of South America  |\n| LORAMAC_REGION_CN470   | China                                                             |\n| LORAMAC_REGION_EU433   | EU, UK, Brazil, Costa Rica, Cuba, and other parts of Africa       |\n| LORAMAC_REGION_IN865   | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger |\n| LORAMAC_REGION_EU868   | EU, UK and other parts of Africa                                  |\n| LORAMAC_REGION_KR920   | Republic of Korea                                                 |\n| LORAMAC_REGION_US915   | USA                                                               |\n| LORAMAC_REGION_RU864   | Russia                                                            |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n\n```  \n- Set up the LoRaWAN activation method. In this case, you will use the **OTAA** configuration, which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change it to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n\n```  \n- Set up the EUIs and KEY. The **DeviceEUI**, **AppEUI**, and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x3F, 0xC4, 0x80, 0x0D, 0x4A, 0xE7, 0xAD, 0x9F, 0xDC, 0x27, 0x5D, 0x37, 0x2C, 0x4C, 0xD3, 0xF8};\n\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once you're done with the code, you can now proceed with uploading it to your device. You must first choose your RAK4631 board on your desktop or laptop. To do so, navigate to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** and select **WisBlock RAK4631**.  \n> **Image:** Selecting the RAK4631 board  \n4. After you have selected your board, go to **Tools** > **Port** and then select the specific port of your board.  \n> **Image:** Selecting the port of RAK4631 board  \n5. You can then upload your code by clicking the Upload button (the right arrow sign). Once completed, the **Device programmed** notification will appear in the console at the bottom of the Arduino IDE.  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board  \n> **TIP:** NOTE  \nThe steps outlined above apply to the **RAK12013** and **RAK12017** applications. Once you have finished uploading the code, proceed to the next step:  \n- **RAK12013**: [Setting up RAK12013 Radar Sensor Dashboard Using ThingSpeak](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#setting-up-rak12013-radar-sensor-dashboard-using-thingspeak)\n- **RAK12017**: [Setting up RAK12017 IR Proximity Sensor Dashboard Using ThingSpeak](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#setting-up-rak12017-ir-proximity-sensor-dashboard-using-thingspeak)"}
{"id": "be73b8d6dc51123bf2018ebba72672b0", "product_family": "wisblock", "product_id": "kit3-movement-detection", "category": "How-To", "title": "WisBlock Movement Detection Kit Quick Start Guide > WisBlock IoT Education Kit - Movement Detection Quick Start Guide > Product Configuration > Software Configuration and Examples > RAK12006 PIR Motion Sensor LoRaWAN Application > LoRaWAN Code for RAK12006 > Programming RAK12006 Module with LoRaWAN Application Code [CODE]", "content": "/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = {BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler\n};\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};", "keywords": ["Arduino IDE", "RAK4631", "RAK12006", "LoRaWAN", "programming"], "source_file": "quickstart.md", "token_count": 150, "parent_content": "1. If you already have **Arduino IDE** installed on your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you have not yet installed the **Arduino IDE**, go to the [RAK4631 Installation](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#arduino-ide-installation-rak4631) section and execute the following steps.  \n2. After the installation, you can now proceed with programming your **RAK12006** module. Simply copy the **RAK12006 LoRaWAN Application** code below and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n```c\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h> //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n// Section to add include libraries, declarations and variables.\n\n#define SENSOR_PIN  WB_IO6   // Attach AM312 sensor to Arduino Digital Pin WB_IO6\n\nint gCurrentStatus = 0;         // variable for reading the pin current status\n\nint sensor_val;\n\nbool doOTAA = true;   // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                     /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                   /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5             /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                      /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                      /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = {LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF};\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = {BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler\n};\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x3F, 0xC4, 0x80, 0x0D, 0x4A, 0xE7, 0xAD, 0x9F, 0xDC, 0x27, 0x5D, 0x37, 0x2C, 0x4C, 0xD3, 0xF8};\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = {0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23};\nuint8_t nodeAppsKey[16] = {0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C};\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                     /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];            //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = {m_lora_app_data_buffer, 0, 0, 0, 0}; //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup()\n{\npinMode(SENSOR_PIN, INPUT);        // PIR Sensor as an INPUT\npinMode(LED_GREEN, OUTPUT);\npinMode(LED_BLUE, OUTPUT);\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial)\n{\nif ((millis() - timeout) < 5000)\n{\ndelay(100);\n}\nelse\n{\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA)\n{\nSerial.println(\"Type: OTAA\");\n}\nelse\n{\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion)\n{\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA)\n{\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n}\nelse\n{\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0)\n{\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"========================\");\nSerial.println(\"    RAK12006 LoRaWAN test\");\nSerial.println(\"========================\");\n\n}\n\n// Default void loop\n\nvoid loop()\n{\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\ngCurrentStatus = digitalRead(SENSOR_PIN);\n\nif (gCurrentStatus == 0)\n// \"0\" for Detected; \"1\" for Undetected\n{\ndigitalWrite(LED_GREEN, HIGH); // Turn ON LED\ndigitalWrite(LED_BLUE, HIGH);\nsensor_val = 1;\nsend_lora_frame();\ndelay(2000);\n}\n\nelse if (gCurrentStatus == 1)\n{\n// do nothing\ndigitalWrite(LED_GREEN, LOW); // Turn OFF LED\ndigitalWrite(LED_BLUE, LOW);\nsensor_val = 0;\nsend_lora_frame();\ndelay(2000);\n}\n\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void)\n{\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void)\n{\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data)\n{\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class)\n{\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\n// void send_lora_frame for RAK12006 Application\nvoid send_lora_frame(void)\n{\nif (lmh_join_status_get() != LMH_SET)\n{\n//Not joined, try again later\nreturn;\n}\n\n//int sensor_val;\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\nm_lora_app_data.buffer[i++] = sensor_val;\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS)\n{\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n}\nelse\n{\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The following steps will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired regions to work with. You can change this to a region that is applicable to you, like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc.  \nThe following table lists the LoRaWAN regions and the countries where they are used:  \n| LoRaWAN Region         | Usage                                                             |\n| ---------------------- | ----------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1 | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan          |\n| LORAMAC_REGION_AS923-2 | Vietnam                                                           |\n| LORAMAC_REGION_AS923-3 | Philippines, Albania, Algeria, Denmark, Greenland, Jordan         |\n| LORAMAC_REGION_AS923-4 | Israel                                                            |\n| LORAMAC_REGION_AU915   | Australia, Anguilla, Argentina, and other parts of South America  |\n| LORAMAC_REGION_CN470   | China                                                             |\n| LORAMAC_REGION_EU433   | EU, UK, Brazil, Costa Rica, Cuba, and other parts of Africa       |\n| LORAMAC_REGION_IN865   | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger |\n| LORAMAC_REGION_EU868   | EU, UK and other parts of Africa                                  |\n| LORAMAC_REGION_KR920   | Republic of Korea                                                 |\n| LORAMAC_REGION_US915   | USA                                                               |\n| LORAMAC_REGION_RU864   | Russia                                                            |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n\n```  \n- Set up the LoRaWAN activation method. In this case, you will use the **OTAA** configuration, which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change it to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n\n```  \n- Set up the EUIs and KEY. The **DeviceEUI**, **AppEUI**, and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x3F, 0xC4, 0x80, 0x0D, 0x4A, 0xE7, 0xAD, 0x9F, 0xDC, 0x27, 0x5D, 0x37, 0x2C, 0x4C, 0xD3, 0xF8};\n\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once you're done with the code, you can now proceed with uploading it to your device. You must first choose your RAK4631 board on your desktop or laptop. To do so, navigate to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** and select **WisBlock RAK4631**.  \n> **Image:** Selecting the RAK4631 board  \n4. After you have selected your board, go to **Tools** > **Port** and then select the specific port of your board.  \n> **Image:** Selecting the port of RAK4631 board  \n5. You can then upload your code by clicking the Upload button (the right arrow sign). Once completed, the **Device programmed** notification will appear in the console at the bottom of the Arduino IDE.  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board  \n> **TIP:** NOTE  \nThe steps outlined above apply to the **RAK12013** and **RAK12017** applications. Once you have finished uploading the code, proceed to the next step:  \n- **RAK12013**: [Setting up RAK12013 Radar Sensor Dashboard Using ThingSpeak](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#setting-up-rak12013-radar-sensor-dashboard-using-thingspeak)\n- **RAK12017**: [Setting up RAK12017 IR Proximity Sensor Dashboard Using ThingSpeak](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#setting-up-rak12017-ir-proximity-sensor-dashboard-using-thingspeak)"}
{"id": "b767b5390a291baa0a95b3df210633d1", "product_family": "wisblock", "product_id": "kit3-movement-detection", "category": "How-To", "title": "WisBlock Movement Detection Kit Quick Start Guide > WisBlock IoT Education Kit - Movement Detection Quick Start Guide > Product Configuration > Software Configuration and Examples > RAK12006 PIR Motion Sensor LoRaWAN Application > LoRaWAN Code for RAK12006 > Programming RAK12006 Module with LoRaWAN Application Code [CODE]", "content": "uint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x3F, 0xC4, 0x80, 0x0D, 0x4A, 0xE7, 0xAD, 0x9F, 0xDC, 0x27, 0x5D, 0x37, 0x2C, 0x4C, 0xD3, 0xF8};", "keywords": ["Arduino IDE", "RAK4631", "RAK12006", "LoRaWAN", "programming"], "source_file": "quickstart.md", "token_count": 150, "parent_content": "1. If you already have **Arduino IDE** installed on your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you have not yet installed the **Arduino IDE**, go to the [RAK4631 Installation](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#arduino-ide-installation-rak4631) section and execute the following steps.  \n2. After the installation, you can now proceed with programming your **RAK12006** module. Simply copy the **RAK12006 LoRaWAN Application** code below and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n```c\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h> //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n// Section to add include libraries, declarations and variables.\n\n#define SENSOR_PIN  WB_IO6   // Attach AM312 sensor to Arduino Digital Pin WB_IO6\n\nint gCurrentStatus = 0;         // variable for reading the pin current status\n\nint sensor_val;\n\nbool doOTAA = true;   // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                     /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                   /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5             /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                      /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                      /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = {LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF};\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = {BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler\n};\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x3F, 0xC4, 0x80, 0x0D, 0x4A, 0xE7, 0xAD, 0x9F, 0xDC, 0x27, 0x5D, 0x37, 0x2C, 0x4C, 0xD3, 0xF8};\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = {0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23};\nuint8_t nodeAppsKey[16] = {0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C};\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                     /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];            //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = {m_lora_app_data_buffer, 0, 0, 0, 0}; //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup()\n{\npinMode(SENSOR_PIN, INPUT);        // PIR Sensor as an INPUT\npinMode(LED_GREEN, OUTPUT);\npinMode(LED_BLUE, OUTPUT);\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial)\n{\nif ((millis() - timeout) < 5000)\n{\ndelay(100);\n}\nelse\n{\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA)\n{\nSerial.println(\"Type: OTAA\");\n}\nelse\n{\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion)\n{\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA)\n{\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n}\nelse\n{\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0)\n{\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"========================\");\nSerial.println(\"    RAK12006 LoRaWAN test\");\nSerial.println(\"========================\");\n\n}\n\n// Default void loop\n\nvoid loop()\n{\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\ngCurrentStatus = digitalRead(SENSOR_PIN);\n\nif (gCurrentStatus == 0)\n// \"0\" for Detected; \"1\" for Undetected\n{\ndigitalWrite(LED_GREEN, HIGH); // Turn ON LED\ndigitalWrite(LED_BLUE, HIGH);\nsensor_val = 1;\nsend_lora_frame();\ndelay(2000);\n}\n\nelse if (gCurrentStatus == 1)\n{\n// do nothing\ndigitalWrite(LED_GREEN, LOW); // Turn OFF LED\ndigitalWrite(LED_BLUE, LOW);\nsensor_val = 0;\nsend_lora_frame();\ndelay(2000);\n}\n\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void)\n{\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void)\n{\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data)\n{\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class)\n{\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\n// void send_lora_frame for RAK12006 Application\nvoid send_lora_frame(void)\n{\nif (lmh_join_status_get() != LMH_SET)\n{\n//Not joined, try again later\nreturn;\n}\n\n//int sensor_val;\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\nm_lora_app_data.buffer[i++] = sensor_val;\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS)\n{\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n}\nelse\n{\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The following steps will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired regions to work with. You can change this to a region that is applicable to you, like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc.  \nThe following table lists the LoRaWAN regions and the countries where they are used:  \n| LoRaWAN Region         | Usage                                                             |\n| ---------------------- | ----------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1 | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan          |\n| LORAMAC_REGION_AS923-2 | Vietnam                                                           |\n| LORAMAC_REGION_AS923-3 | Philippines, Albania, Algeria, Denmark, Greenland, Jordan         |\n| LORAMAC_REGION_AS923-4 | Israel                                                            |\n| LORAMAC_REGION_AU915   | Australia, Anguilla, Argentina, and other parts of South America  |\n| LORAMAC_REGION_CN470   | China                                                             |\n| LORAMAC_REGION_EU433   | EU, UK, Brazil, Costa Rica, Cuba, and other parts of Africa       |\n| LORAMAC_REGION_IN865   | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger |\n| LORAMAC_REGION_EU868   | EU, UK and other parts of Africa                                  |\n| LORAMAC_REGION_KR920   | Republic of Korea                                                 |\n| LORAMAC_REGION_US915   | USA                                                               |\n| LORAMAC_REGION_RU864   | Russia                                                            |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n\n```  \n- Set up the LoRaWAN activation method. In this case, you will use the **OTAA** configuration, which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change it to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n\n```  \n- Set up the EUIs and KEY. The **DeviceEUI**, **AppEUI**, and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x3F, 0xC4, 0x80, 0x0D, 0x4A, 0xE7, 0xAD, 0x9F, 0xDC, 0x27, 0x5D, 0x37, 0x2C, 0x4C, 0xD3, 0xF8};\n\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once you're done with the code, you can now proceed with uploading it to your device. You must first choose your RAK4631 board on your desktop or laptop. To do so, navigate to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** and select **WisBlock RAK4631**.  \n> **Image:** Selecting the RAK4631 board  \n4. After you have selected your board, go to **Tools** > **Port** and then select the specific port of your board.  \n> **Image:** Selecting the port of RAK4631 board  \n5. You can then upload your code by clicking the Upload button (the right arrow sign). Once completed, the **Device programmed** notification will appear in the console at the bottom of the Arduino IDE.  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board  \n> **TIP:** NOTE  \nThe steps outlined above apply to the **RAK12013** and **RAK12017** applications. Once you have finished uploading the code, proceed to the next step:  \n- **RAK12013**: [Setting up RAK12013 Radar Sensor Dashboard Using ThingSpeak](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#setting-up-rak12013-radar-sensor-dashboard-using-thingspeak)\n- **RAK12017**: [Setting up RAK12017 IR Proximity Sensor Dashboard Using ThingSpeak](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#setting-up-rak12017-ir-proximity-sensor-dashboard-using-thingspeak)"}
{"id": "95930c1455a41e3310738d6377a8694c", "product_family": "wisblock", "product_id": "kit3-movement-detection", "category": "How-To", "title": "WisBlock Movement Detection Kit Quick Start Guide > WisBlock IoT Education Kit - Movement Detection Quick Start Guide > Product Configuration > Software Configuration and Examples > RAK12006 PIR Motion Sensor LoRaWAN Application > LoRaWAN Code for RAK12006 > Programming RAK12006 Module with LoRaWAN Application Code [CODE]", "content": "// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = {0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23};\nuint8_t nodeAppsKey[16] = {0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C};", "keywords": ["Arduino IDE", "RAK4631", "RAK12006", "LoRaWAN", "programming"], "source_file": "quickstart.md", "token_count": 150, "parent_content": "1. If you already have **Arduino IDE** installed on your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you have not yet installed the **Arduino IDE**, go to the [RAK4631 Installation](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#arduino-ide-installation-rak4631) section and execute the following steps.  \n2. After the installation, you can now proceed with programming your **RAK12006** module. Simply copy the **RAK12006 LoRaWAN Application** code below and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n```c\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h> //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n// Section to add include libraries, declarations and variables.\n\n#define SENSOR_PIN  WB_IO6   // Attach AM312 sensor to Arduino Digital Pin WB_IO6\n\nint gCurrentStatus = 0;         // variable for reading the pin current status\n\nint sensor_val;\n\nbool doOTAA = true;   // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                     /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                   /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5             /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                      /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                      /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = {LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF};\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = {BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler\n};\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x3F, 0xC4, 0x80, 0x0D, 0x4A, 0xE7, 0xAD, 0x9F, 0xDC, 0x27, 0x5D, 0x37, 0x2C, 0x4C, 0xD3, 0xF8};\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = {0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23};\nuint8_t nodeAppsKey[16] = {0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C};\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                     /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];            //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = {m_lora_app_data_buffer, 0, 0, 0, 0}; //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup()\n{\npinMode(SENSOR_PIN, INPUT);        // PIR Sensor as an INPUT\npinMode(LED_GREEN, OUTPUT);\npinMode(LED_BLUE, OUTPUT);\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial)\n{\nif ((millis() - timeout) < 5000)\n{\ndelay(100);\n}\nelse\n{\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA)\n{\nSerial.println(\"Type: OTAA\");\n}\nelse\n{\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion)\n{\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA)\n{\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n}\nelse\n{\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0)\n{\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"========================\");\nSerial.println(\"    RAK12006 LoRaWAN test\");\nSerial.println(\"========================\");\n\n}\n\n// Default void loop\n\nvoid loop()\n{\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\ngCurrentStatus = digitalRead(SENSOR_PIN);\n\nif (gCurrentStatus == 0)\n// \"0\" for Detected; \"1\" for Undetected\n{\ndigitalWrite(LED_GREEN, HIGH); // Turn ON LED\ndigitalWrite(LED_BLUE, HIGH);\nsensor_val = 1;\nsend_lora_frame();\ndelay(2000);\n}\n\nelse if (gCurrentStatus == 1)\n{\n// do nothing\ndigitalWrite(LED_GREEN, LOW); // Turn OFF LED\ndigitalWrite(LED_BLUE, LOW);\nsensor_val = 0;\nsend_lora_frame();\ndelay(2000);\n}\n\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void)\n{\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void)\n{\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data)\n{\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class)\n{\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\n// void send_lora_frame for RAK12006 Application\nvoid send_lora_frame(void)\n{\nif (lmh_join_status_get() != LMH_SET)\n{\n//Not joined, try again later\nreturn;\n}\n\n//int sensor_val;\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\nm_lora_app_data.buffer[i++] = sensor_val;\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS)\n{\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n}\nelse\n{\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The following steps will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired regions to work with. You can change this to a region that is applicable to you, like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc.  \nThe following table lists the LoRaWAN regions and the countries where they are used:  \n| LoRaWAN Region         | Usage                                                             |\n| ---------------------- | ----------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1 | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan          |\n| LORAMAC_REGION_AS923-2 | Vietnam                                                           |\n| LORAMAC_REGION_AS923-3 | Philippines, Albania, Algeria, Denmark, Greenland, Jordan         |\n| LORAMAC_REGION_AS923-4 | Israel                                                            |\n| LORAMAC_REGION_AU915   | Australia, Anguilla, Argentina, and other parts of South America  |\n| LORAMAC_REGION_CN470   | China                                                             |\n| LORAMAC_REGION_EU433   | EU, UK, Brazil, Costa Rica, Cuba, and other parts of Africa       |\n| LORAMAC_REGION_IN865   | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger |\n| LORAMAC_REGION_EU868   | EU, UK and other parts of Africa                                  |\n| LORAMAC_REGION_KR920   | Republic of Korea                                                 |\n| LORAMAC_REGION_US915   | USA                                                               |\n| LORAMAC_REGION_RU864   | Russia                                                            |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n\n```  \n- Set up the LoRaWAN activation method. In this case, you will use the **OTAA** configuration, which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change it to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n\n```  \n- Set up the EUIs and KEY. The **DeviceEUI**, **AppEUI**, and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x3F, 0xC4, 0x80, 0x0D, 0x4A, 0xE7, 0xAD, 0x9F, 0xDC, 0x27, 0x5D, 0x37, 0x2C, 0x4C, 0xD3, 0xF8};\n\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once you're done with the code, you can now proceed with uploading it to your device. You must first choose your RAK4631 board on your desktop or laptop. To do so, navigate to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** and select **WisBlock RAK4631**.  \n> **Image:** Selecting the RAK4631 board  \n4. After you have selected your board, go to **Tools** > **Port** and then select the specific port of your board.  \n> **Image:** Selecting the port of RAK4631 board  \n5. You can then upload your code by clicking the Upload button (the right arrow sign). Once completed, the **Device programmed** notification will appear in the console at the bottom of the Arduino IDE.  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board  \n> **TIP:** NOTE  \nThe steps outlined above apply to the **RAK12013** and **RAK12017** applications. Once you have finished uploading the code, proceed to the next step:  \n- **RAK12013**: [Setting up RAK12013 Radar Sensor Dashboard Using ThingSpeak](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#setting-up-rak12013-radar-sensor-dashboard-using-thingspeak)\n- **RAK12017**: [Setting up RAK12017 IR Proximity Sensor Dashboard Using ThingSpeak](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#setting-up-rak12017-ir-proximity-sensor-dashboard-using-thingspeak)"}
{"id": "1080fb593ce90bd10ab833bf7db5ff73", "product_family": "wisblock", "product_id": "kit3-movement-detection", "category": "How-To", "title": "WisBlock Movement Detection Kit Quick Start Guide > WisBlock IoT Education Kit - Movement Detection Quick Start Guide > Product Configuration > Software Configuration and Examples > RAK12006 PIR Motion Sensor LoRaWAN Application > LoRaWAN Code for RAK12006 > Programming RAK12006 Module with LoRaWAN Application Code [CODE]", "content": "// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                     /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];            //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = {m_lora_app_data_buffer, 0, 0, 0, 0}; //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;", "keywords": ["Arduino IDE", "RAK4631", "RAK12006", "LoRaWAN", "programming"], "source_file": "quickstart.md", "token_count": 150, "parent_content": "1. If you already have **Arduino IDE** installed on your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you have not yet installed the **Arduino IDE**, go to the [RAK4631 Installation](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#arduino-ide-installation-rak4631) section and execute the following steps.  \n2. After the installation, you can now proceed with programming your **RAK12006** module. Simply copy the **RAK12006 LoRaWAN Application** code below and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n```c\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h> //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n// Section to add include libraries, declarations and variables.\n\n#define SENSOR_PIN  WB_IO6   // Attach AM312 sensor to Arduino Digital Pin WB_IO6\n\nint gCurrentStatus = 0;         // variable for reading the pin current status\n\nint sensor_val;\n\nbool doOTAA = true;   // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                     /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                   /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5             /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                      /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                      /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = {LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF};\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = {BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler\n};\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x3F, 0xC4, 0x80, 0x0D, 0x4A, 0xE7, 0xAD, 0x9F, 0xDC, 0x27, 0x5D, 0x37, 0x2C, 0x4C, 0xD3, 0xF8};\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = {0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23};\nuint8_t nodeAppsKey[16] = {0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C};\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                     /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];            //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = {m_lora_app_data_buffer, 0, 0, 0, 0}; //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup()\n{\npinMode(SENSOR_PIN, INPUT);        // PIR Sensor as an INPUT\npinMode(LED_GREEN, OUTPUT);\npinMode(LED_BLUE, OUTPUT);\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial)\n{\nif ((millis() - timeout) < 5000)\n{\ndelay(100);\n}\nelse\n{\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA)\n{\nSerial.println(\"Type: OTAA\");\n}\nelse\n{\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion)\n{\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA)\n{\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n}\nelse\n{\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0)\n{\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"========================\");\nSerial.println(\"    RAK12006 LoRaWAN test\");\nSerial.println(\"========================\");\n\n}\n\n// Default void loop\n\nvoid loop()\n{\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\ngCurrentStatus = digitalRead(SENSOR_PIN);\n\nif (gCurrentStatus == 0)\n// \"0\" for Detected; \"1\" for Undetected\n{\ndigitalWrite(LED_GREEN, HIGH); // Turn ON LED\ndigitalWrite(LED_BLUE, HIGH);\nsensor_val = 1;\nsend_lora_frame();\ndelay(2000);\n}\n\nelse if (gCurrentStatus == 1)\n{\n// do nothing\ndigitalWrite(LED_GREEN, LOW); // Turn OFF LED\ndigitalWrite(LED_BLUE, LOW);\nsensor_val = 0;\nsend_lora_frame();\ndelay(2000);\n}\n\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void)\n{\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void)\n{\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data)\n{\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class)\n{\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\n// void send_lora_frame for RAK12006 Application\nvoid send_lora_frame(void)\n{\nif (lmh_join_status_get() != LMH_SET)\n{\n//Not joined, try again later\nreturn;\n}\n\n//int sensor_val;\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\nm_lora_app_data.buffer[i++] = sensor_val;\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS)\n{\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n}\nelse\n{\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The following steps will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired regions to work with. You can change this to a region that is applicable to you, like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc.  \nThe following table lists the LoRaWAN regions and the countries where they are used:  \n| LoRaWAN Region         | Usage                                                             |\n| ---------------------- | ----------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1 | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan          |\n| LORAMAC_REGION_AS923-2 | Vietnam                                                           |\n| LORAMAC_REGION_AS923-3 | Philippines, Albania, Algeria, Denmark, Greenland, Jordan         |\n| LORAMAC_REGION_AS923-4 | Israel                                                            |\n| LORAMAC_REGION_AU915   | Australia, Anguilla, Argentina, and other parts of South America  |\n| LORAMAC_REGION_CN470   | China                                                             |\n| LORAMAC_REGION_EU433   | EU, UK, Brazil, Costa Rica, Cuba, and other parts of Africa       |\n| LORAMAC_REGION_IN865   | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger |\n| LORAMAC_REGION_EU868   | EU, UK and other parts of Africa                                  |\n| LORAMAC_REGION_KR920   | Republic of Korea                                                 |\n| LORAMAC_REGION_US915   | USA                                                               |\n| LORAMAC_REGION_RU864   | Russia                                                            |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n\n```  \n- Set up the LoRaWAN activation method. In this case, you will use the **OTAA** configuration, which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change it to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n\n```  \n- Set up the EUIs and KEY. The **DeviceEUI**, **AppEUI**, and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x3F, 0xC4, 0x80, 0x0D, 0x4A, 0xE7, 0xAD, 0x9F, 0xDC, 0x27, 0x5D, 0x37, 0x2C, 0x4C, 0xD3, 0xF8};\n\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once you're done with the code, you can now proceed with uploading it to your device. You must first choose your RAK4631 board on your desktop or laptop. To do so, navigate to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** and select **WisBlock RAK4631**.  \n> **Image:** Selecting the RAK4631 board  \n4. After you have selected your board, go to **Tools** > **Port** and then select the specific port of your board.  \n> **Image:** Selecting the port of RAK4631 board  \n5. You can then upload your code by clicking the Upload button (the right arrow sign). Once completed, the **Device programmed** notification will appear in the console at the bottom of the Arduino IDE.  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board  \n> **TIP:** NOTE  \nThe steps outlined above apply to the **RAK12013** and **RAK12017** applications. Once you have finished uploading the code, proceed to the next step:  \n- **RAK12013**: [Setting up RAK12013 Radar Sensor Dashboard Using ThingSpeak](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#setting-up-rak12013-radar-sensor-dashboard-using-thingspeak)\n- **RAK12017**: [Setting up RAK12017 IR Proximity Sensor Dashboard Using ThingSpeak](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#setting-up-rak12017-ir-proximity-sensor-dashboard-using-thingspeak)"}
{"id": "17f66c888ea1e6295884ff64d26f9cbd", "product_family": "wisblock", "product_id": "kit3-movement-detection", "category": "How-To", "title": "WisBlock Movement Detection Kit Quick Start Guide > WisBlock IoT Education Kit - Movement Detection Quick Start Guide > Product Configuration > Software Configuration and Examples > RAK12006 PIR Motion Sensor LoRaWAN Application > LoRaWAN Code for RAK12006 > Programming RAK12006 Module with LoRaWAN Application Code [CODE]", "content": "static uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup()\n{\npinMode(SENSOR_PIN, INPUT);        // PIR Sensor as an INPUT\npinMode(LED_GREEN, OUTPUT);\npinMode(LED_BLUE, OUTPUT);\n\n// Initialize LoRa chip.\nlora_rak4630_init();", "keywords": ["Arduino IDE", "RAK4631", "RAK12006", "LoRaWAN", "programming"], "source_file": "quickstart.md", "token_count": 150, "parent_content": "1. If you already have **Arduino IDE** installed on your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you have not yet installed the **Arduino IDE**, go to the [RAK4631 Installation](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#arduino-ide-installation-rak4631) section and execute the following steps.  \n2. After the installation, you can now proceed with programming your **RAK12006** module. Simply copy the **RAK12006 LoRaWAN Application** code below and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n```c\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h> //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n// Section to add include libraries, declarations and variables.\n\n#define SENSOR_PIN  WB_IO6   // Attach AM312 sensor to Arduino Digital Pin WB_IO6\n\nint gCurrentStatus = 0;         // variable for reading the pin current status\n\nint sensor_val;\n\nbool doOTAA = true;   // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                     /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                   /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5             /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                      /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                      /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = {LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF};\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = {BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler\n};\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x3F, 0xC4, 0x80, 0x0D, 0x4A, 0xE7, 0xAD, 0x9F, 0xDC, 0x27, 0x5D, 0x37, 0x2C, 0x4C, 0xD3, 0xF8};\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = {0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23};\nuint8_t nodeAppsKey[16] = {0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C};\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                     /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];            //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = {m_lora_app_data_buffer, 0, 0, 0, 0}; //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup()\n{\npinMode(SENSOR_PIN, INPUT);        // PIR Sensor as an INPUT\npinMode(LED_GREEN, OUTPUT);\npinMode(LED_BLUE, OUTPUT);\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial)\n{\nif ((millis() - timeout) < 5000)\n{\ndelay(100);\n}\nelse\n{\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA)\n{\nSerial.println(\"Type: OTAA\");\n}\nelse\n{\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion)\n{\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA)\n{\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n}\nelse\n{\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0)\n{\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"========================\");\nSerial.println(\"    RAK12006 LoRaWAN test\");\nSerial.println(\"========================\");\n\n}\n\n// Default void loop\n\nvoid loop()\n{\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\ngCurrentStatus = digitalRead(SENSOR_PIN);\n\nif (gCurrentStatus == 0)\n// \"0\" for Detected; \"1\" for Undetected\n{\ndigitalWrite(LED_GREEN, HIGH); // Turn ON LED\ndigitalWrite(LED_BLUE, HIGH);\nsensor_val = 1;\nsend_lora_frame();\ndelay(2000);\n}\n\nelse if (gCurrentStatus == 1)\n{\n// do nothing\ndigitalWrite(LED_GREEN, LOW); // Turn OFF LED\ndigitalWrite(LED_BLUE, LOW);\nsensor_val = 0;\nsend_lora_frame();\ndelay(2000);\n}\n\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void)\n{\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void)\n{\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data)\n{\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class)\n{\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\n// void send_lora_frame for RAK12006 Application\nvoid send_lora_frame(void)\n{\nif (lmh_join_status_get() != LMH_SET)\n{\n//Not joined, try again later\nreturn;\n}\n\n//int sensor_val;\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\nm_lora_app_data.buffer[i++] = sensor_val;\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS)\n{\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n}\nelse\n{\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The following steps will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired regions to work with. You can change this to a region that is applicable to you, like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc.  \nThe following table lists the LoRaWAN regions and the countries where they are used:  \n| LoRaWAN Region         | Usage                                                             |\n| ---------------------- | ----------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1 | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan          |\n| LORAMAC_REGION_AS923-2 | Vietnam                                                           |\n| LORAMAC_REGION_AS923-3 | Philippines, Albania, Algeria, Denmark, Greenland, Jordan         |\n| LORAMAC_REGION_AS923-4 | Israel                                                            |\n| LORAMAC_REGION_AU915   | Australia, Anguilla, Argentina, and other parts of South America  |\n| LORAMAC_REGION_CN470   | China                                                             |\n| LORAMAC_REGION_EU433   | EU, UK, Brazil, Costa Rica, Cuba, and other parts of Africa       |\n| LORAMAC_REGION_IN865   | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger |\n| LORAMAC_REGION_EU868   | EU, UK and other parts of Africa                                  |\n| LORAMAC_REGION_KR920   | Republic of Korea                                                 |\n| LORAMAC_REGION_US915   | USA                                                               |\n| LORAMAC_REGION_RU864   | Russia                                                            |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n\n```  \n- Set up the LoRaWAN activation method. In this case, you will use the **OTAA** configuration, which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change it to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n\n```  \n- Set up the EUIs and KEY. The **DeviceEUI**, **AppEUI**, and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x3F, 0xC4, 0x80, 0x0D, 0x4A, 0xE7, 0xAD, 0x9F, 0xDC, 0x27, 0x5D, 0x37, 0x2C, 0x4C, 0xD3, 0xF8};\n\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once you're done with the code, you can now proceed with uploading it to your device. You must first choose your RAK4631 board on your desktop or laptop. To do so, navigate to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** and select **WisBlock RAK4631**.  \n> **Image:** Selecting the RAK4631 board  \n4. After you have selected your board, go to **Tools** > **Port** and then select the specific port of your board.  \n> **Image:** Selecting the port of RAK4631 board  \n5. You can then upload your code by clicking the Upload button (the right arrow sign). Once completed, the **Device programmed** notification will appear in the console at the bottom of the Arduino IDE.  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board  \n> **TIP:** NOTE  \nThe steps outlined above apply to the **RAK12013** and **RAK12017** applications. Once you have finished uploading the code, proceed to the next step:  \n- **RAK12013**: [Setting up RAK12013 Radar Sensor Dashboard Using ThingSpeak](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#setting-up-rak12013-radar-sensor-dashboard-using-thingspeak)\n- **RAK12017**: [Setting up RAK12017 IR Proximity Sensor Dashboard Using ThingSpeak](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#setting-up-rak12017-ir-proximity-sensor-dashboard-using-thingspeak)"}
{"id": "3f946c8c9677b5656cf8be579e84a6a3", "product_family": "wisblock", "product_id": "kit3-movement-detection", "category": "How-To", "title": "WisBlock Movement Detection Kit Quick Start Guide > WisBlock IoT Education Kit - Movement Detection Quick Start Guide > Product Configuration > Software Configuration and Examples > RAK12006 PIR Motion Sensor LoRaWAN Application > LoRaWAN Code for RAK12006 > Programming RAK12006 Module with LoRaWAN Application Code [CODE]", "content": "// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial)\n{\nif ((millis() - timeout) < 5000)\n{\ndelay(100);\n}\nelse\n{\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA)\n{\nSerial.println(\"Type: OTAA\");\n}\nelse\n{\nSerial.println(\"Type: ABP\");\n}", "keywords": ["Arduino IDE", "RAK4631", "RAK12006", "LoRaWAN", "programming"], "source_file": "quickstart.md", "token_count": 150, "parent_content": "1. If you already have **Arduino IDE** installed on your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you have not yet installed the **Arduino IDE**, go to the [RAK4631 Installation](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#arduino-ide-installation-rak4631) section and execute the following steps.  \n2. After the installation, you can now proceed with programming your **RAK12006** module. Simply copy the **RAK12006 LoRaWAN Application** code below and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n```c\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h> //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n// Section to add include libraries, declarations and variables.\n\n#define SENSOR_PIN  WB_IO6   // Attach AM312 sensor to Arduino Digital Pin WB_IO6\n\nint gCurrentStatus = 0;         // variable for reading the pin current status\n\nint sensor_val;\n\nbool doOTAA = true;   // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                     /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                   /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5             /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                      /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                      /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = {LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF};\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = {BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler\n};\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x3F, 0xC4, 0x80, 0x0D, 0x4A, 0xE7, 0xAD, 0x9F, 0xDC, 0x27, 0x5D, 0x37, 0x2C, 0x4C, 0xD3, 0xF8};\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = {0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23};\nuint8_t nodeAppsKey[16] = {0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C};\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                     /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];            //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = {m_lora_app_data_buffer, 0, 0, 0, 0}; //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup()\n{\npinMode(SENSOR_PIN, INPUT);        // PIR Sensor as an INPUT\npinMode(LED_GREEN, OUTPUT);\npinMode(LED_BLUE, OUTPUT);\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial)\n{\nif ((millis() - timeout) < 5000)\n{\ndelay(100);\n}\nelse\n{\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA)\n{\nSerial.println(\"Type: OTAA\");\n}\nelse\n{\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion)\n{\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA)\n{\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n}\nelse\n{\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0)\n{\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"========================\");\nSerial.println(\"    RAK12006 LoRaWAN test\");\nSerial.println(\"========================\");\n\n}\n\n// Default void loop\n\nvoid loop()\n{\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\ngCurrentStatus = digitalRead(SENSOR_PIN);\n\nif (gCurrentStatus == 0)\n// \"0\" for Detected; \"1\" for Undetected\n{\ndigitalWrite(LED_GREEN, HIGH); // Turn ON LED\ndigitalWrite(LED_BLUE, HIGH);\nsensor_val = 1;\nsend_lora_frame();\ndelay(2000);\n}\n\nelse if (gCurrentStatus == 1)\n{\n// do nothing\ndigitalWrite(LED_GREEN, LOW); // Turn OFF LED\ndigitalWrite(LED_BLUE, LOW);\nsensor_val = 0;\nsend_lora_frame();\ndelay(2000);\n}\n\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void)\n{\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void)\n{\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data)\n{\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class)\n{\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\n// void send_lora_frame for RAK12006 Application\nvoid send_lora_frame(void)\n{\nif (lmh_join_status_get() != LMH_SET)\n{\n//Not joined, try again later\nreturn;\n}\n\n//int sensor_val;\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\nm_lora_app_data.buffer[i++] = sensor_val;\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS)\n{\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n}\nelse\n{\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The following steps will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired regions to work with. You can change this to a region that is applicable to you, like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc.  \nThe following table lists the LoRaWAN regions and the countries where they are used:  \n| LoRaWAN Region         | Usage                                                             |\n| ---------------------- | ----------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1 | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan          |\n| LORAMAC_REGION_AS923-2 | Vietnam                                                           |\n| LORAMAC_REGION_AS923-3 | Philippines, Albania, Algeria, Denmark, Greenland, Jordan         |\n| LORAMAC_REGION_AS923-4 | Israel                                                            |\n| LORAMAC_REGION_AU915   | Australia, Anguilla, Argentina, and other parts of South America  |\n| LORAMAC_REGION_CN470   | China                                                             |\n| LORAMAC_REGION_EU433   | EU, UK, Brazil, Costa Rica, Cuba, and other parts of Africa       |\n| LORAMAC_REGION_IN865   | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger |\n| LORAMAC_REGION_EU868   | EU, UK and other parts of Africa                                  |\n| LORAMAC_REGION_KR920   | Republic of Korea                                                 |\n| LORAMAC_REGION_US915   | USA                                                               |\n| LORAMAC_REGION_RU864   | Russia                                                            |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n\n```  \n- Set up the LoRaWAN activation method. In this case, you will use the **OTAA** configuration, which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change it to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n\n```  \n- Set up the EUIs and KEY. The **DeviceEUI**, **AppEUI**, and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x3F, 0xC4, 0x80, 0x0D, 0x4A, 0xE7, 0xAD, 0x9F, 0xDC, 0x27, 0x5D, 0x37, 0x2C, 0x4C, 0xD3, 0xF8};\n\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once you're done with the code, you can now proceed with uploading it to your device. You must first choose your RAK4631 board on your desktop or laptop. To do so, navigate to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** and select **WisBlock RAK4631**.  \n> **Image:** Selecting the RAK4631 board  \n4. After you have selected your board, go to **Tools** > **Port** and then select the specific port of your board.  \n> **Image:** Selecting the port of RAK4631 board  \n5. You can then upload your code by clicking the Upload button (the right arrow sign). Once completed, the **Device programmed** notification will appear in the console at the bottom of the Arduino IDE.  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board  \n> **TIP:** NOTE  \nThe steps outlined above apply to the **RAK12013** and **RAK12017** applications. Once you have finished uploading the code, proceed to the next step:  \n- **RAK12013**: [Setting up RAK12013 Radar Sensor Dashboard Using ThingSpeak](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#setting-up-rak12013-radar-sensor-dashboard-using-thingspeak)\n- **RAK12017**: [Setting up RAK12017 IR Proximity Sensor Dashboard Using ThingSpeak](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#setting-up-rak12017-ir-proximity-sensor-dashboard-using-thingspeak)"}
{"id": "8b4f392eac91d0b057fb5b84312fde25", "product_family": "wisblock", "product_id": "kit3-movement-detection", "category": "How-To", "title": "WisBlock Movement Detection Kit Quick Start Guide > WisBlock IoT Education Kit - Movement Detection Quick Start Guide > Product Configuration > Software Configuration and Examples > RAK12006 PIR Motion Sensor LoRaWAN Application > LoRaWAN Code for RAK12006 > Programming RAK12006 Module with LoRaWAN Application Code [CODE]", "content": "switch (g_CurrentRegion)\n{\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;", "keywords": ["Arduino IDE", "RAK4631", "RAK12006", "LoRaWAN", "programming"], "source_file": "quickstart.md", "token_count": 150, "parent_content": "1. If you already have **Arduino IDE** installed on your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you have not yet installed the **Arduino IDE**, go to the [RAK4631 Installation](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#arduino-ide-installation-rak4631) section and execute the following steps.  \n2. After the installation, you can now proceed with programming your **RAK12006** module. Simply copy the **RAK12006 LoRaWAN Application** code below and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n```c\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h> //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n// Section to add include libraries, declarations and variables.\n\n#define SENSOR_PIN  WB_IO6   // Attach AM312 sensor to Arduino Digital Pin WB_IO6\n\nint gCurrentStatus = 0;         // variable for reading the pin current status\n\nint sensor_val;\n\nbool doOTAA = true;   // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                     /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                   /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5             /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                      /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                      /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = {LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF};\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = {BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler\n};\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x3F, 0xC4, 0x80, 0x0D, 0x4A, 0xE7, 0xAD, 0x9F, 0xDC, 0x27, 0x5D, 0x37, 0x2C, 0x4C, 0xD3, 0xF8};\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = {0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23};\nuint8_t nodeAppsKey[16] = {0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C};\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                     /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];            //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = {m_lora_app_data_buffer, 0, 0, 0, 0}; //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup()\n{\npinMode(SENSOR_PIN, INPUT);        // PIR Sensor as an INPUT\npinMode(LED_GREEN, OUTPUT);\npinMode(LED_BLUE, OUTPUT);\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial)\n{\nif ((millis() - timeout) < 5000)\n{\ndelay(100);\n}\nelse\n{\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA)\n{\nSerial.println(\"Type: OTAA\");\n}\nelse\n{\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion)\n{\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA)\n{\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n}\nelse\n{\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0)\n{\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"========================\");\nSerial.println(\"    RAK12006 LoRaWAN test\");\nSerial.println(\"========================\");\n\n}\n\n// Default void loop\n\nvoid loop()\n{\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\ngCurrentStatus = digitalRead(SENSOR_PIN);\n\nif (gCurrentStatus == 0)\n// \"0\" for Detected; \"1\" for Undetected\n{\ndigitalWrite(LED_GREEN, HIGH); // Turn ON LED\ndigitalWrite(LED_BLUE, HIGH);\nsensor_val = 1;\nsend_lora_frame();\ndelay(2000);\n}\n\nelse if (gCurrentStatus == 1)\n{\n// do nothing\ndigitalWrite(LED_GREEN, LOW); // Turn OFF LED\ndigitalWrite(LED_BLUE, LOW);\nsensor_val = 0;\nsend_lora_frame();\ndelay(2000);\n}\n\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void)\n{\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void)\n{\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data)\n{\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class)\n{\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\n// void send_lora_frame for RAK12006 Application\nvoid send_lora_frame(void)\n{\nif (lmh_join_status_get() != LMH_SET)\n{\n//Not joined, try again later\nreturn;\n}\n\n//int sensor_val;\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\nm_lora_app_data.buffer[i++] = sensor_val;\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS)\n{\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n}\nelse\n{\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The following steps will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired regions to work with. You can change this to a region that is applicable to you, like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc.  \nThe following table lists the LoRaWAN regions and the countries where they are used:  \n| LoRaWAN Region         | Usage                                                             |\n| ---------------------- | ----------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1 | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan          |\n| LORAMAC_REGION_AS923-2 | Vietnam                                                           |\n| LORAMAC_REGION_AS923-3 | Philippines, Albania, Algeria, Denmark, Greenland, Jordan         |\n| LORAMAC_REGION_AS923-4 | Israel                                                            |\n| LORAMAC_REGION_AU915   | Australia, Anguilla, Argentina, and other parts of South America  |\n| LORAMAC_REGION_CN470   | China                                                             |\n| LORAMAC_REGION_EU433   | EU, UK, Brazil, Costa Rica, Cuba, and other parts of Africa       |\n| LORAMAC_REGION_IN865   | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger |\n| LORAMAC_REGION_EU868   | EU, UK and other parts of Africa                                  |\n| LORAMAC_REGION_KR920   | Republic of Korea                                                 |\n| LORAMAC_REGION_US915   | USA                                                               |\n| LORAMAC_REGION_RU864   | Russia                                                            |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n\n```  \n- Set up the LoRaWAN activation method. In this case, you will use the **OTAA** configuration, which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change it to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n\n```  \n- Set up the EUIs and KEY. The **DeviceEUI**, **AppEUI**, and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x3F, 0xC4, 0x80, 0x0D, 0x4A, 0xE7, 0xAD, 0x9F, 0xDC, 0x27, 0x5D, 0x37, 0x2C, 0x4C, 0xD3, 0xF8};\n\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once you're done with the code, you can now proceed with uploading it to your device. You must first choose your RAK4631 board on your desktop or laptop. To do so, navigate to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** and select **WisBlock RAK4631**.  \n> **Image:** Selecting the RAK4631 board  \n4. After you have selected your board, go to **Tools** > **Port** and then select the specific port of your board.  \n> **Image:** Selecting the port of RAK4631 board  \n5. You can then upload your code by clicking the Upload button (the right arrow sign). Once completed, the **Device programmed** notification will appear in the console at the bottom of the Arduino IDE.  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board  \n> **TIP:** NOTE  \nThe steps outlined above apply to the **RAK12013** and **RAK12017** applications. Once you have finished uploading the code, proceed to the next step:  \n- **RAK12013**: [Setting up RAK12013 Radar Sensor Dashboard Using ThingSpeak](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#setting-up-rak12013-radar-sensor-dashboard-using-thingspeak)\n- **RAK12017**: [Setting up RAK12017 IR Proximity Sensor Dashboard Using ThingSpeak](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#setting-up-rak12017-ir-proximity-sensor-dashboard-using-thingspeak)"}
{"id": "c8700bd3e1e555f3b97098715e888277", "product_family": "wisblock", "product_id": "kit3-movement-detection", "category": "How-To", "title": "WisBlock Movement Detection Kit Quick Start Guide > WisBlock IoT Education Kit - Movement Detection Quick Start Guide > Product Configuration > Software Configuration and Examples > RAK12006 PIR Motion Sensor LoRaWAN Application > LoRaWAN Code for RAK12006 > Programming RAK12006 Module with LoRaWAN Application Code [CODE]", "content": "break;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");", "keywords": ["Arduino IDE", "RAK4631", "RAK12006", "LoRaWAN", "programming"], "source_file": "quickstart.md", "token_count": 150, "parent_content": "1. If you already have **Arduino IDE** installed on your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you have not yet installed the **Arduino IDE**, go to the [RAK4631 Installation](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#arduino-ide-installation-rak4631) section and execute the following steps.  \n2. After the installation, you can now proceed with programming your **RAK12006** module. Simply copy the **RAK12006 LoRaWAN Application** code below and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n```c\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h> //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n// Section to add include libraries, declarations and variables.\n\n#define SENSOR_PIN  WB_IO6   // Attach AM312 sensor to Arduino Digital Pin WB_IO6\n\nint gCurrentStatus = 0;         // variable for reading the pin current status\n\nint sensor_val;\n\nbool doOTAA = true;   // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                     /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                   /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5             /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                      /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                      /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = {LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF};\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = {BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler\n};\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x3F, 0xC4, 0x80, 0x0D, 0x4A, 0xE7, 0xAD, 0x9F, 0xDC, 0x27, 0x5D, 0x37, 0x2C, 0x4C, 0xD3, 0xF8};\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = {0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23};\nuint8_t nodeAppsKey[16] = {0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C};\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                     /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];            //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = {m_lora_app_data_buffer, 0, 0, 0, 0}; //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup()\n{\npinMode(SENSOR_PIN, INPUT);        // PIR Sensor as an INPUT\npinMode(LED_GREEN, OUTPUT);\npinMode(LED_BLUE, OUTPUT);\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial)\n{\nif ((millis() - timeout) < 5000)\n{\ndelay(100);\n}\nelse\n{\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA)\n{\nSerial.println(\"Type: OTAA\");\n}\nelse\n{\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion)\n{\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA)\n{\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n}\nelse\n{\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0)\n{\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"========================\");\nSerial.println(\"    RAK12006 LoRaWAN test\");\nSerial.println(\"========================\");\n\n}\n\n// Default void loop\n\nvoid loop()\n{\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\ngCurrentStatus = digitalRead(SENSOR_PIN);\n\nif (gCurrentStatus == 0)\n// \"0\" for Detected; \"1\" for Undetected\n{\ndigitalWrite(LED_GREEN, HIGH); // Turn ON LED\ndigitalWrite(LED_BLUE, HIGH);\nsensor_val = 1;\nsend_lora_frame();\ndelay(2000);\n}\n\nelse if (gCurrentStatus == 1)\n{\n// do nothing\ndigitalWrite(LED_GREEN, LOW); // Turn OFF LED\ndigitalWrite(LED_BLUE, LOW);\nsensor_val = 0;\nsend_lora_frame();\ndelay(2000);\n}\n\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void)\n{\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void)\n{\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data)\n{\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class)\n{\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\n// void send_lora_frame for RAK12006 Application\nvoid send_lora_frame(void)\n{\nif (lmh_join_status_get() != LMH_SET)\n{\n//Not joined, try again later\nreturn;\n}\n\n//int sensor_val;\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\nm_lora_app_data.buffer[i++] = sensor_val;\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS)\n{\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n}\nelse\n{\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The following steps will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired regions to work with. You can change this to a region that is applicable to you, like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc.  \nThe following table lists the LoRaWAN regions and the countries where they are used:  \n| LoRaWAN Region         | Usage                                                             |\n| ---------------------- | ----------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1 | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan          |\n| LORAMAC_REGION_AS923-2 | Vietnam                                                           |\n| LORAMAC_REGION_AS923-3 | Philippines, Albania, Algeria, Denmark, Greenland, Jordan         |\n| LORAMAC_REGION_AS923-4 | Israel                                                            |\n| LORAMAC_REGION_AU915   | Australia, Anguilla, Argentina, and other parts of South America  |\n| LORAMAC_REGION_CN470   | China                                                             |\n| LORAMAC_REGION_EU433   | EU, UK, Brazil, Costa Rica, Cuba, and other parts of Africa       |\n| LORAMAC_REGION_IN865   | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger |\n| LORAMAC_REGION_EU868   | EU, UK and other parts of Africa                                  |\n| LORAMAC_REGION_KR920   | Republic of Korea                                                 |\n| LORAMAC_REGION_US915   | USA                                                               |\n| LORAMAC_REGION_RU864   | Russia                                                            |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n\n```  \n- Set up the LoRaWAN activation method. In this case, you will use the **OTAA** configuration, which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change it to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n\n```  \n- Set up the EUIs and KEY. The **DeviceEUI**, **AppEUI**, and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x3F, 0xC4, 0x80, 0x0D, 0x4A, 0xE7, 0xAD, 0x9F, 0xDC, 0x27, 0x5D, 0x37, 0x2C, 0x4C, 0xD3, 0xF8};\n\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once you're done with the code, you can now proceed with uploading it to your device. You must first choose your RAK4631 board on your desktop or laptop. To do so, navigate to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** and select **WisBlock RAK4631**.  \n> **Image:** Selecting the RAK4631 board  \n4. After you have selected your board, go to **Tools** > **Port** and then select the specific port of your board.  \n> **Image:** Selecting the port of RAK4631 board  \n5. You can then upload your code by clicking the Upload button (the right arrow sign). Once completed, the **Device programmed** notification will appear in the console at the bottom of the Arduino IDE.  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board  \n> **TIP:** NOTE  \nThe steps outlined above apply to the **RAK12013** and **RAK12017** applications. Once you have finished uploading the code, proceed to the next step:  \n- **RAK12013**: [Setting up RAK12013 Radar Sensor Dashboard Using ThingSpeak](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#setting-up-rak12013-radar-sensor-dashboard-using-thingspeak)\n- **RAK12017**: [Setting up RAK12017 IR Proximity Sensor Dashboard Using ThingSpeak](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#setting-up-rak12017-ir-proximity-sensor-dashboard-using-thingspeak)"}
{"id": "53cd31d1a08e93d2184d78313cf3baae", "product_family": "wisblock", "product_id": "kit3-movement-detection", "category": "How-To", "title": "WisBlock Movement Detection Kit Quick Start Guide > WisBlock IoT Education Kit - Movement Detection Quick Start Guide > Product Configuration > Software Configuration and Examples > RAK12006 PIR Motion Sensor LoRaWAN Application > LoRaWAN Code for RAK12006 > Programming RAK12006 Module with LoRaWAN Application Code [CODE]", "content": "// Setup the EUIs and Keys\nif (doOTAA)\n{\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n}\nelse\n{\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0)\n{\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();", "keywords": ["Arduino IDE", "RAK4631", "RAK12006", "LoRaWAN", "programming"], "source_file": "quickstart.md", "token_count": 150, "parent_content": "1. If you already have **Arduino IDE** installed on your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you have not yet installed the **Arduino IDE**, go to the [RAK4631 Installation](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#arduino-ide-installation-rak4631) section and execute the following steps.  \n2. After the installation, you can now proceed with programming your **RAK12006** module. Simply copy the **RAK12006 LoRaWAN Application** code below and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n```c\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h> //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n// Section to add include libraries, declarations and variables.\n\n#define SENSOR_PIN  WB_IO6   // Attach AM312 sensor to Arduino Digital Pin WB_IO6\n\nint gCurrentStatus = 0;         // variable for reading the pin current status\n\nint sensor_val;\n\nbool doOTAA = true;   // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                     /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                   /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5             /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                      /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                      /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = {LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF};\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = {BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler\n};\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x3F, 0xC4, 0x80, 0x0D, 0x4A, 0xE7, 0xAD, 0x9F, 0xDC, 0x27, 0x5D, 0x37, 0x2C, 0x4C, 0xD3, 0xF8};\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = {0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23};\nuint8_t nodeAppsKey[16] = {0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C};\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                     /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];            //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = {m_lora_app_data_buffer, 0, 0, 0, 0}; //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup()\n{\npinMode(SENSOR_PIN, INPUT);        // PIR Sensor as an INPUT\npinMode(LED_GREEN, OUTPUT);\npinMode(LED_BLUE, OUTPUT);\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial)\n{\nif ((millis() - timeout) < 5000)\n{\ndelay(100);\n}\nelse\n{\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA)\n{\nSerial.println(\"Type: OTAA\");\n}\nelse\n{\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion)\n{\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA)\n{\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n}\nelse\n{\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0)\n{\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"========================\");\nSerial.println(\"    RAK12006 LoRaWAN test\");\nSerial.println(\"========================\");\n\n}\n\n// Default void loop\n\nvoid loop()\n{\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\ngCurrentStatus = digitalRead(SENSOR_PIN);\n\nif (gCurrentStatus == 0)\n// \"0\" for Detected; \"1\" for Undetected\n{\ndigitalWrite(LED_GREEN, HIGH); // Turn ON LED\ndigitalWrite(LED_BLUE, HIGH);\nsensor_val = 1;\nsend_lora_frame();\ndelay(2000);\n}\n\nelse if (gCurrentStatus == 1)\n{\n// do nothing\ndigitalWrite(LED_GREEN, LOW); // Turn OFF LED\ndigitalWrite(LED_BLUE, LOW);\nsensor_val = 0;\nsend_lora_frame();\ndelay(2000);\n}\n\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void)\n{\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void)\n{\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data)\n{\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class)\n{\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\n// void send_lora_frame for RAK12006 Application\nvoid send_lora_frame(void)\n{\nif (lmh_join_status_get() != LMH_SET)\n{\n//Not joined, try again later\nreturn;\n}\n\n//int sensor_val;\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\nm_lora_app_data.buffer[i++] = sensor_val;\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS)\n{\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n}\nelse\n{\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The following steps will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired regions to work with. You can change this to a region that is applicable to you, like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc.  \nThe following table lists the LoRaWAN regions and the countries where they are used:  \n| LoRaWAN Region         | Usage                                                             |\n| ---------------------- | ----------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1 | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan          |\n| LORAMAC_REGION_AS923-2 | Vietnam                                                           |\n| LORAMAC_REGION_AS923-3 | Philippines, Albania, Algeria, Denmark, Greenland, Jordan         |\n| LORAMAC_REGION_AS923-4 | Israel                                                            |\n| LORAMAC_REGION_AU915   | Australia, Anguilla, Argentina, and other parts of South America  |\n| LORAMAC_REGION_CN470   | China                                                             |\n| LORAMAC_REGION_EU433   | EU, UK, Brazil, Costa Rica, Cuba, and other parts of Africa       |\n| LORAMAC_REGION_IN865   | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger |\n| LORAMAC_REGION_EU868   | EU, UK and other parts of Africa                                  |\n| LORAMAC_REGION_KR920   | Republic of Korea                                                 |\n| LORAMAC_REGION_US915   | USA                                                               |\n| LORAMAC_REGION_RU864   | Russia                                                            |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n\n```  \n- Set up the LoRaWAN activation method. In this case, you will use the **OTAA** configuration, which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change it to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n\n```  \n- Set up the EUIs and KEY. The **DeviceEUI**, **AppEUI**, and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x3F, 0xC4, 0x80, 0x0D, 0x4A, 0xE7, 0xAD, 0x9F, 0xDC, 0x27, 0x5D, 0x37, 0x2C, 0x4C, 0xD3, 0xF8};\n\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once you're done with the code, you can now proceed with uploading it to your device. You must first choose your RAK4631 board on your desktop or laptop. To do so, navigate to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** and select **WisBlock RAK4631**.  \n> **Image:** Selecting the RAK4631 board  \n4. After you have selected your board, go to **Tools** > **Port** and then select the specific port of your board.  \n> **Image:** Selecting the port of RAK4631 board  \n5. You can then upload your code by clicking the Upload button (the right arrow sign). Once completed, the **Device programmed** notification will appear in the console at the bottom of the Arduino IDE.  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board  \n> **TIP:** NOTE  \nThe steps outlined above apply to the **RAK12013** and **RAK12017** applications. Once you have finished uploading the code, proceed to the next step:  \n- **RAK12013**: [Setting up RAK12013 Radar Sensor Dashboard Using ThingSpeak](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#setting-up-rak12013-radar-sensor-dashboard-using-thingspeak)\n- **RAK12017**: [Setting up RAK12017 IR Proximity Sensor Dashboard Using ThingSpeak](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#setting-up-rak12017-ir-proximity-sensor-dashboard-using-thingspeak)"}
{"id": "3eea2f33094ec272fd722b0ee50abefe", "product_family": "wisblock", "product_id": "kit3-movement-detection", "category": "How-To", "title": "WisBlock Movement Detection Kit Quick Start Guide > WisBlock IoT Education Kit - Movement Detection Quick Start Guide > Product Configuration > Software Configuration and Examples > RAK12006 PIR Motion Sensor LoRaWAN Application > LoRaWAN Code for RAK12006 > Programming RAK12006 Module with LoRaWAN Application Code [CODE]", "content": "// Start Join procedure\nlmh_join();\n\nSerial.println(\"========================\");\nSerial.println(\"    RAK12006 LoRaWAN test\");\nSerial.println(\"========================\");\n\n}\n\n// Default void loop\n\nvoid loop()\n{\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\ngCurrentStatus = digitalRead(SENSOR_PIN);", "keywords": ["Arduino IDE", "RAK4631", "RAK12006", "LoRaWAN", "programming"], "source_file": "quickstart.md", "token_count": 150, "parent_content": "1. If you already have **Arduino IDE** installed on your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you have not yet installed the **Arduino IDE**, go to the [RAK4631 Installation](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#arduino-ide-installation-rak4631) section and execute the following steps.  \n2. After the installation, you can now proceed with programming your **RAK12006** module. Simply copy the **RAK12006 LoRaWAN Application** code below and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n```c\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h> //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n// Section to add include libraries, declarations and variables.\n\n#define SENSOR_PIN  WB_IO6   // Attach AM312 sensor to Arduino Digital Pin WB_IO6\n\nint gCurrentStatus = 0;         // variable for reading the pin current status\n\nint sensor_val;\n\nbool doOTAA = true;   // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                     /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                   /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5             /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                      /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                      /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = {LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF};\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = {BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler\n};\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x3F, 0xC4, 0x80, 0x0D, 0x4A, 0xE7, 0xAD, 0x9F, 0xDC, 0x27, 0x5D, 0x37, 0x2C, 0x4C, 0xD3, 0xF8};\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = {0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23};\nuint8_t nodeAppsKey[16] = {0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C};\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                     /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];            //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = {m_lora_app_data_buffer, 0, 0, 0, 0}; //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup()\n{\npinMode(SENSOR_PIN, INPUT);        // PIR Sensor as an INPUT\npinMode(LED_GREEN, OUTPUT);\npinMode(LED_BLUE, OUTPUT);\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial)\n{\nif ((millis() - timeout) < 5000)\n{\ndelay(100);\n}\nelse\n{\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA)\n{\nSerial.println(\"Type: OTAA\");\n}\nelse\n{\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion)\n{\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA)\n{\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n}\nelse\n{\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0)\n{\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"========================\");\nSerial.println(\"    RAK12006 LoRaWAN test\");\nSerial.println(\"========================\");\n\n}\n\n// Default void loop\n\nvoid loop()\n{\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\ngCurrentStatus = digitalRead(SENSOR_PIN);\n\nif (gCurrentStatus == 0)\n// \"0\" for Detected; \"1\" for Undetected\n{\ndigitalWrite(LED_GREEN, HIGH); // Turn ON LED\ndigitalWrite(LED_BLUE, HIGH);\nsensor_val = 1;\nsend_lora_frame();\ndelay(2000);\n}\n\nelse if (gCurrentStatus == 1)\n{\n// do nothing\ndigitalWrite(LED_GREEN, LOW); // Turn OFF LED\ndigitalWrite(LED_BLUE, LOW);\nsensor_val = 0;\nsend_lora_frame();\ndelay(2000);\n}\n\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void)\n{\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void)\n{\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data)\n{\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class)\n{\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\n// void send_lora_frame for RAK12006 Application\nvoid send_lora_frame(void)\n{\nif (lmh_join_status_get() != LMH_SET)\n{\n//Not joined, try again later\nreturn;\n}\n\n//int sensor_val;\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\nm_lora_app_data.buffer[i++] = sensor_val;\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS)\n{\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n}\nelse\n{\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The following steps will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired regions to work with. You can change this to a region that is applicable to you, like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc.  \nThe following table lists the LoRaWAN regions and the countries where they are used:  \n| LoRaWAN Region         | Usage                                                             |\n| ---------------------- | ----------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1 | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan          |\n| LORAMAC_REGION_AS923-2 | Vietnam                                                           |\n| LORAMAC_REGION_AS923-3 | Philippines, Albania, Algeria, Denmark, Greenland, Jordan         |\n| LORAMAC_REGION_AS923-4 | Israel                                                            |\n| LORAMAC_REGION_AU915   | Australia, Anguilla, Argentina, and other parts of South America  |\n| LORAMAC_REGION_CN470   | China                                                             |\n| LORAMAC_REGION_EU433   | EU, UK, Brazil, Costa Rica, Cuba, and other parts of Africa       |\n| LORAMAC_REGION_IN865   | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger |\n| LORAMAC_REGION_EU868   | EU, UK and other parts of Africa                                  |\n| LORAMAC_REGION_KR920   | Republic of Korea                                                 |\n| LORAMAC_REGION_US915   | USA                                                               |\n| LORAMAC_REGION_RU864   | Russia                                                            |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n\n```  \n- Set up the LoRaWAN activation method. In this case, you will use the **OTAA** configuration, which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change it to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n\n```  \n- Set up the EUIs and KEY. The **DeviceEUI**, **AppEUI**, and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x3F, 0xC4, 0x80, 0x0D, 0x4A, 0xE7, 0xAD, 0x9F, 0xDC, 0x27, 0x5D, 0x37, 0x2C, 0x4C, 0xD3, 0xF8};\n\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once you're done with the code, you can now proceed with uploading it to your device. You must first choose your RAK4631 board on your desktop or laptop. To do so, navigate to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** and select **WisBlock RAK4631**.  \n> **Image:** Selecting the RAK4631 board  \n4. After you have selected your board, go to **Tools** > **Port** and then select the specific port of your board.  \n> **Image:** Selecting the port of RAK4631 board  \n5. You can then upload your code by clicking the Upload button (the right arrow sign). Once completed, the **Device programmed** notification will appear in the console at the bottom of the Arduino IDE.  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board  \n> **TIP:** NOTE  \nThe steps outlined above apply to the **RAK12013** and **RAK12017** applications. Once you have finished uploading the code, proceed to the next step:  \n- **RAK12013**: [Setting up RAK12013 Radar Sensor Dashboard Using ThingSpeak](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#setting-up-rak12013-radar-sensor-dashboard-using-thingspeak)\n- **RAK12017**: [Setting up RAK12017 IR Proximity Sensor Dashboard Using ThingSpeak](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#setting-up-rak12017-ir-proximity-sensor-dashboard-using-thingspeak)"}
{"id": "2740abd1e311a17803c15a3e69460168", "product_family": "wisblock", "product_id": "kit3-movement-detection", "category": "How-To", "title": "WisBlock Movement Detection Kit Quick Start Guide > WisBlock IoT Education Kit - Movement Detection Quick Start Guide > Product Configuration > Software Configuration and Examples > RAK12006 PIR Motion Sensor LoRaWAN Application > LoRaWAN Code for RAK12006 > Programming RAK12006 Module with LoRaWAN Application Code [CODE]", "content": "if (gCurrentStatus == 0)\n// \"0\" for Detected; \"1\" for Undetected\n{\ndigitalWrite(LED_GREEN, HIGH); // Turn ON LED\ndigitalWrite(LED_BLUE, HIGH);\nsensor_val = 1;\nsend_lora_frame();\ndelay(2000);\n}\n\nelse if (gCurrentStatus == 1)\n{\n// do nothing\ndigitalWrite(LED_GREEN, LOW); // Turn OFF LED\ndigitalWrite(LED_BLUE, LOW);\nsensor_val = 0;\nsend_lora_frame();\ndelay(2000);\n}\n\n}", "keywords": ["Arduino IDE", "RAK4631", "RAK12006", "LoRaWAN", "programming"], "source_file": "quickstart.md", "token_count": 150, "parent_content": "1. If you already have **Arduino IDE** installed on your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you have not yet installed the **Arduino IDE**, go to the [RAK4631 Installation](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#arduino-ide-installation-rak4631) section and execute the following steps.  \n2. After the installation, you can now proceed with programming your **RAK12006** module. Simply copy the **RAK12006 LoRaWAN Application** code below and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n```c\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h> //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n// Section to add include libraries, declarations and variables.\n\n#define SENSOR_PIN  WB_IO6   // Attach AM312 sensor to Arduino Digital Pin WB_IO6\n\nint gCurrentStatus = 0;         // variable for reading the pin current status\n\nint sensor_val;\n\nbool doOTAA = true;   // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                     /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                   /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5             /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                      /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                      /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = {LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF};\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = {BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler\n};\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x3F, 0xC4, 0x80, 0x0D, 0x4A, 0xE7, 0xAD, 0x9F, 0xDC, 0x27, 0x5D, 0x37, 0x2C, 0x4C, 0xD3, 0xF8};\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = {0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23};\nuint8_t nodeAppsKey[16] = {0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C};\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                     /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];            //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = {m_lora_app_data_buffer, 0, 0, 0, 0}; //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup()\n{\npinMode(SENSOR_PIN, INPUT);        // PIR Sensor as an INPUT\npinMode(LED_GREEN, OUTPUT);\npinMode(LED_BLUE, OUTPUT);\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial)\n{\nif ((millis() - timeout) < 5000)\n{\ndelay(100);\n}\nelse\n{\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA)\n{\nSerial.println(\"Type: OTAA\");\n}\nelse\n{\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion)\n{\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA)\n{\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n}\nelse\n{\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0)\n{\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"========================\");\nSerial.println(\"    RAK12006 LoRaWAN test\");\nSerial.println(\"========================\");\n\n}\n\n// Default void loop\n\nvoid loop()\n{\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\ngCurrentStatus = digitalRead(SENSOR_PIN);\n\nif (gCurrentStatus == 0)\n// \"0\" for Detected; \"1\" for Undetected\n{\ndigitalWrite(LED_GREEN, HIGH); // Turn ON LED\ndigitalWrite(LED_BLUE, HIGH);\nsensor_val = 1;\nsend_lora_frame();\ndelay(2000);\n}\n\nelse if (gCurrentStatus == 1)\n{\n// do nothing\ndigitalWrite(LED_GREEN, LOW); // Turn OFF LED\ndigitalWrite(LED_BLUE, LOW);\nsensor_val = 0;\nsend_lora_frame();\ndelay(2000);\n}\n\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void)\n{\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void)\n{\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data)\n{\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class)\n{\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\n// void send_lora_frame for RAK12006 Application\nvoid send_lora_frame(void)\n{\nif (lmh_join_status_get() != LMH_SET)\n{\n//Not joined, try again later\nreturn;\n}\n\n//int sensor_val;\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\nm_lora_app_data.buffer[i++] = sensor_val;\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS)\n{\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n}\nelse\n{\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The following steps will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired regions to work with. You can change this to a region that is applicable to you, like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc.  \nThe following table lists the LoRaWAN regions and the countries where they are used:  \n| LoRaWAN Region         | Usage                                                             |\n| ---------------------- | ----------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1 | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan          |\n| LORAMAC_REGION_AS923-2 | Vietnam                                                           |\n| LORAMAC_REGION_AS923-3 | Philippines, Albania, Algeria, Denmark, Greenland, Jordan         |\n| LORAMAC_REGION_AS923-4 | Israel                                                            |\n| LORAMAC_REGION_AU915   | Australia, Anguilla, Argentina, and other parts of South America  |\n| LORAMAC_REGION_CN470   | China                                                             |\n| LORAMAC_REGION_EU433   | EU, UK, Brazil, Costa Rica, Cuba, and other parts of Africa       |\n| LORAMAC_REGION_IN865   | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger |\n| LORAMAC_REGION_EU868   | EU, UK and other parts of Africa                                  |\n| LORAMAC_REGION_KR920   | Republic of Korea                                                 |\n| LORAMAC_REGION_US915   | USA                                                               |\n| LORAMAC_REGION_RU864   | Russia                                                            |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n\n```  \n- Set up the LoRaWAN activation method. In this case, you will use the **OTAA** configuration, which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change it to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n\n```  \n- Set up the EUIs and KEY. The **DeviceEUI**, **AppEUI**, and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x3F, 0xC4, 0x80, 0x0D, 0x4A, 0xE7, 0xAD, 0x9F, 0xDC, 0x27, 0x5D, 0x37, 0x2C, 0x4C, 0xD3, 0xF8};\n\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once you're done with the code, you can now proceed with uploading it to your device. You must first choose your RAK4631 board on your desktop or laptop. To do so, navigate to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** and select **WisBlock RAK4631**.  \n> **Image:** Selecting the RAK4631 board  \n4. After you have selected your board, go to **Tools** > **Port** and then select the specific port of your board.  \n> **Image:** Selecting the port of RAK4631 board  \n5. You can then upload your code by clicking the Upload button (the right arrow sign). Once completed, the **Device programmed** notification will appear in the console at the bottom of the Arduino IDE.  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board  \n> **TIP:** NOTE  \nThe steps outlined above apply to the **RAK12013** and **RAK12017** applications. Once you have finished uploading the code, proceed to the next step:  \n- **RAK12013**: [Setting up RAK12013 Radar Sensor Dashboard Using ThingSpeak](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#setting-up-rak12013-radar-sensor-dashboard-using-thingspeak)\n- **RAK12017**: [Setting up RAK12017 IR Proximity Sensor Dashboard Using ThingSpeak](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#setting-up-rak12017-ir-proximity-sensor-dashboard-using-thingspeak)"}
{"id": "93c87bb5d132e0059da093b357911f61", "product_family": "wisblock", "product_id": "kit3-movement-detection", "category": "How-To", "title": "WisBlock Movement Detection Kit Quick Start Guide > WisBlock IoT Education Kit - Movement Detection Quick Start Guide > Product Configuration > Software Configuration and Examples > RAK12006 PIR Motion Sensor LoRaWAN Application > LoRaWAN Code for RAK12006 > Programming RAK12006 Module with LoRaWAN Application Code [CODE]", "content": "}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void)\n{\nSerial.println(\"OTAA Mode, Network Joined!\");\n}", "keywords": ["Arduino IDE", "RAK4631", "RAK12006", "LoRaWAN", "programming"], "source_file": "quickstart.md", "token_count": 150, "parent_content": "1. If you already have **Arduino IDE** installed on your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you have not yet installed the **Arduino IDE**, go to the [RAK4631 Installation](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#arduino-ide-installation-rak4631) section and execute the following steps.  \n2. After the installation, you can now proceed with programming your **RAK12006** module. Simply copy the **RAK12006 LoRaWAN Application** code below and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n```c\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h> //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n// Section to add include libraries, declarations and variables.\n\n#define SENSOR_PIN  WB_IO6   // Attach AM312 sensor to Arduino Digital Pin WB_IO6\n\nint gCurrentStatus = 0;         // variable for reading the pin current status\n\nint sensor_val;\n\nbool doOTAA = true;   // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                     /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                   /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5             /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                      /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                      /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = {LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF};\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = {BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler\n};\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x3F, 0xC4, 0x80, 0x0D, 0x4A, 0xE7, 0xAD, 0x9F, 0xDC, 0x27, 0x5D, 0x37, 0x2C, 0x4C, 0xD3, 0xF8};\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = {0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23};\nuint8_t nodeAppsKey[16] = {0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C};\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                     /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];            //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = {m_lora_app_data_buffer, 0, 0, 0, 0}; //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup()\n{\npinMode(SENSOR_PIN, INPUT);        // PIR Sensor as an INPUT\npinMode(LED_GREEN, OUTPUT);\npinMode(LED_BLUE, OUTPUT);\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial)\n{\nif ((millis() - timeout) < 5000)\n{\ndelay(100);\n}\nelse\n{\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA)\n{\nSerial.println(\"Type: OTAA\");\n}\nelse\n{\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion)\n{\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA)\n{\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n}\nelse\n{\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0)\n{\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"========================\");\nSerial.println(\"    RAK12006 LoRaWAN test\");\nSerial.println(\"========================\");\n\n}\n\n// Default void loop\n\nvoid loop()\n{\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\ngCurrentStatus = digitalRead(SENSOR_PIN);\n\nif (gCurrentStatus == 0)\n// \"0\" for Detected; \"1\" for Undetected\n{\ndigitalWrite(LED_GREEN, HIGH); // Turn ON LED\ndigitalWrite(LED_BLUE, HIGH);\nsensor_val = 1;\nsend_lora_frame();\ndelay(2000);\n}\n\nelse if (gCurrentStatus == 1)\n{\n// do nothing\ndigitalWrite(LED_GREEN, LOW); // Turn OFF LED\ndigitalWrite(LED_BLUE, LOW);\nsensor_val = 0;\nsend_lora_frame();\ndelay(2000);\n}\n\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void)\n{\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void)\n{\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data)\n{\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class)\n{\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\n// void send_lora_frame for RAK12006 Application\nvoid send_lora_frame(void)\n{\nif (lmh_join_status_get() != LMH_SET)\n{\n//Not joined, try again later\nreturn;\n}\n\n//int sensor_val;\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\nm_lora_app_data.buffer[i++] = sensor_val;\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS)\n{\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n}\nelse\n{\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The following steps will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired regions to work with. You can change this to a region that is applicable to you, like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc.  \nThe following table lists the LoRaWAN regions and the countries where they are used:  \n| LoRaWAN Region         | Usage                                                             |\n| ---------------------- | ----------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1 | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan          |\n| LORAMAC_REGION_AS923-2 | Vietnam                                                           |\n| LORAMAC_REGION_AS923-3 | Philippines, Albania, Algeria, Denmark, Greenland, Jordan         |\n| LORAMAC_REGION_AS923-4 | Israel                                                            |\n| LORAMAC_REGION_AU915   | Australia, Anguilla, Argentina, and other parts of South America  |\n| LORAMAC_REGION_CN470   | China                                                             |\n| LORAMAC_REGION_EU433   | EU, UK, Brazil, Costa Rica, Cuba, and other parts of Africa       |\n| LORAMAC_REGION_IN865   | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger |\n| LORAMAC_REGION_EU868   | EU, UK and other parts of Africa                                  |\n| LORAMAC_REGION_KR920   | Republic of Korea                                                 |\n| LORAMAC_REGION_US915   | USA                                                               |\n| LORAMAC_REGION_RU864   | Russia                                                            |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n\n```  \n- Set up the LoRaWAN activation method. In this case, you will use the **OTAA** configuration, which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change it to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n\n```  \n- Set up the EUIs and KEY. The **DeviceEUI**, **AppEUI**, and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x3F, 0xC4, 0x80, 0x0D, 0x4A, 0xE7, 0xAD, 0x9F, 0xDC, 0x27, 0x5D, 0x37, 0x2C, 0x4C, 0xD3, 0xF8};\n\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once you're done with the code, you can now proceed with uploading it to your device. You must first choose your RAK4631 board on your desktop or laptop. To do so, navigate to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** and select **WisBlock RAK4631**.  \n> **Image:** Selecting the RAK4631 board  \n4. After you have selected your board, go to **Tools** > **Port** and then select the specific port of your board.  \n> **Image:** Selecting the port of RAK4631 board  \n5. You can then upload your code by clicking the Upload button (the right arrow sign). Once completed, the **Device programmed** notification will appear in the console at the bottom of the Arduino IDE.  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board  \n> **TIP:** NOTE  \nThe steps outlined above apply to the **RAK12013** and **RAK12017** applications. Once you have finished uploading the code, proceed to the next step:  \n- **RAK12013**: [Setting up RAK12013 Radar Sensor Dashboard Using ThingSpeak](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#setting-up-rak12013-radar-sensor-dashboard-using-thingspeak)\n- **RAK12017**: [Setting up RAK12017 IR Proximity Sensor Dashboard Using ThingSpeak](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#setting-up-rak12017-ir-proximity-sensor-dashboard-using-thingspeak)"}
{"id": "ca7853870834d11a798872c34eb946e3", "product_family": "wisblock", "product_id": "kit3-movement-detection", "category": "How-To", "title": "WisBlock Movement Detection Kit Quick Start Guide > WisBlock IoT Education Kit - Movement Detection Quick Start Guide > Product Configuration > Software Configuration and Examples > RAK12006 PIR Motion Sensor LoRaWAN Application > LoRaWAN Code for RAK12006 > Programming RAK12006 Module with LoRaWAN Application Code [CODE]", "content": "/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void)\n{\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data)\n{\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",", "keywords": ["Arduino IDE", "RAK4631", "RAK12006", "LoRaWAN", "programming"], "source_file": "quickstart.md", "token_count": 150, "parent_content": "1. If you already have **Arduino IDE** installed on your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you have not yet installed the **Arduino IDE**, go to the [RAK4631 Installation](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#arduino-ide-installation-rak4631) section and execute the following steps.  \n2. After the installation, you can now proceed with programming your **RAK12006** module. Simply copy the **RAK12006 LoRaWAN Application** code below and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n```c\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h> //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n// Section to add include libraries, declarations and variables.\n\n#define SENSOR_PIN  WB_IO6   // Attach AM312 sensor to Arduino Digital Pin WB_IO6\n\nint gCurrentStatus = 0;         // variable for reading the pin current status\n\nint sensor_val;\n\nbool doOTAA = true;   // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                     /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                   /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5             /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                      /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                      /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = {LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF};\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = {BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler\n};\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x3F, 0xC4, 0x80, 0x0D, 0x4A, 0xE7, 0xAD, 0x9F, 0xDC, 0x27, 0x5D, 0x37, 0x2C, 0x4C, 0xD3, 0xF8};\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = {0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23};\nuint8_t nodeAppsKey[16] = {0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C};\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                     /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];            //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = {m_lora_app_data_buffer, 0, 0, 0, 0}; //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup()\n{\npinMode(SENSOR_PIN, INPUT);        // PIR Sensor as an INPUT\npinMode(LED_GREEN, OUTPUT);\npinMode(LED_BLUE, OUTPUT);\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial)\n{\nif ((millis() - timeout) < 5000)\n{\ndelay(100);\n}\nelse\n{\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA)\n{\nSerial.println(\"Type: OTAA\");\n}\nelse\n{\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion)\n{\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA)\n{\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n}\nelse\n{\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0)\n{\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"========================\");\nSerial.println(\"    RAK12006 LoRaWAN test\");\nSerial.println(\"========================\");\n\n}\n\n// Default void loop\n\nvoid loop()\n{\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\ngCurrentStatus = digitalRead(SENSOR_PIN);\n\nif (gCurrentStatus == 0)\n// \"0\" for Detected; \"1\" for Undetected\n{\ndigitalWrite(LED_GREEN, HIGH); // Turn ON LED\ndigitalWrite(LED_BLUE, HIGH);\nsensor_val = 1;\nsend_lora_frame();\ndelay(2000);\n}\n\nelse if (gCurrentStatus == 1)\n{\n// do nothing\ndigitalWrite(LED_GREEN, LOW); // Turn OFF LED\ndigitalWrite(LED_BLUE, LOW);\nsensor_val = 0;\nsend_lora_frame();\ndelay(2000);\n}\n\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void)\n{\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void)\n{\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data)\n{\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class)\n{\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\n// void send_lora_frame for RAK12006 Application\nvoid send_lora_frame(void)\n{\nif (lmh_join_status_get() != LMH_SET)\n{\n//Not joined, try again later\nreturn;\n}\n\n//int sensor_val;\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\nm_lora_app_data.buffer[i++] = sensor_val;\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS)\n{\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n}\nelse\n{\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The following steps will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired regions to work with. You can change this to a region that is applicable to you, like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc.  \nThe following table lists the LoRaWAN regions and the countries where they are used:  \n| LoRaWAN Region         | Usage                                                             |\n| ---------------------- | ----------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1 | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan          |\n| LORAMAC_REGION_AS923-2 | Vietnam                                                           |\n| LORAMAC_REGION_AS923-3 | Philippines, Albania, Algeria, Denmark, Greenland, Jordan         |\n| LORAMAC_REGION_AS923-4 | Israel                                                            |\n| LORAMAC_REGION_AU915   | Australia, Anguilla, Argentina, and other parts of South America  |\n| LORAMAC_REGION_CN470   | China                                                             |\n| LORAMAC_REGION_EU433   | EU, UK, Brazil, Costa Rica, Cuba, and other parts of Africa       |\n| LORAMAC_REGION_IN865   | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger |\n| LORAMAC_REGION_EU868   | EU, UK and other parts of Africa                                  |\n| LORAMAC_REGION_KR920   | Republic of Korea                                                 |\n| LORAMAC_REGION_US915   | USA                                                               |\n| LORAMAC_REGION_RU864   | Russia                                                            |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n\n```  \n- Set up the LoRaWAN activation method. In this case, you will use the **OTAA** configuration, which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change it to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n\n```  \n- Set up the EUIs and KEY. The **DeviceEUI**, **AppEUI**, and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x3F, 0xC4, 0x80, 0x0D, 0x4A, 0xE7, 0xAD, 0x9F, 0xDC, 0x27, 0x5D, 0x37, 0x2C, 0x4C, 0xD3, 0xF8};\n\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once you're done with the code, you can now proceed with uploading it to your device. You must first choose your RAK4631 board on your desktop or laptop. To do so, navigate to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** and select **WisBlock RAK4631**.  \n> **Image:** Selecting the RAK4631 board  \n4. After you have selected your board, go to **Tools** > **Port** and then select the specific port of your board.  \n> **Image:** Selecting the port of RAK4631 board  \n5. You can then upload your code by clicking the Upload button (the right arrow sign). Once completed, the **Device programmed** notification will appear in the console at the bottom of the Arduino IDE.  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board  \n> **TIP:** NOTE  \nThe steps outlined above apply to the **RAK12013** and **RAK12017** applications. Once you have finished uploading the code, proceed to the next step:  \n- **RAK12013**: [Setting up RAK12013 Radar Sensor Dashboard Using ThingSpeak](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#setting-up-rak12013-radar-sensor-dashboard-using-thingspeak)\n- **RAK12017**: [Setting up RAK12017 IR Proximity Sensor Dashboard Using ThingSpeak](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#setting-up-rak12017-ir-proximity-sensor-dashboard-using-thingspeak)"}
{"id": "e23cbae802e27d5c35709106bc67982b", "product_family": "wisblock", "product_id": "kit3-movement-detection", "category": "How-To", "title": "WisBlock Movement Detection Kit Quick Start Guide > WisBlock IoT Education Kit - Movement Detection Quick Start Guide > Product Configuration > Software Configuration and Examples > RAK12006 PIR Motion Sensor LoRaWAN Application > LoRaWAN Code for RAK12006 > Programming RAK12006 Module with LoRaWAN Application Code [CODE]", "content": "{\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}", "keywords": ["Arduino IDE", "RAK4631", "RAK12006", "LoRaWAN", "programming"], "source_file": "quickstart.md", "token_count": 150, "parent_content": "1. If you already have **Arduino IDE** installed on your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you have not yet installed the **Arduino IDE**, go to the [RAK4631 Installation](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#arduino-ide-installation-rak4631) section and execute the following steps.  \n2. After the installation, you can now proceed with programming your **RAK12006** module. Simply copy the **RAK12006 LoRaWAN Application** code below and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n```c\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h> //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n// Section to add include libraries, declarations and variables.\n\n#define SENSOR_PIN  WB_IO6   // Attach AM312 sensor to Arduino Digital Pin WB_IO6\n\nint gCurrentStatus = 0;         // variable for reading the pin current status\n\nint sensor_val;\n\nbool doOTAA = true;   // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                     /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                   /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5             /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                      /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                      /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = {LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF};\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = {BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler\n};\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x3F, 0xC4, 0x80, 0x0D, 0x4A, 0xE7, 0xAD, 0x9F, 0xDC, 0x27, 0x5D, 0x37, 0x2C, 0x4C, 0xD3, 0xF8};\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = {0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23};\nuint8_t nodeAppsKey[16] = {0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C};\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                     /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];            //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = {m_lora_app_data_buffer, 0, 0, 0, 0}; //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup()\n{\npinMode(SENSOR_PIN, INPUT);        // PIR Sensor as an INPUT\npinMode(LED_GREEN, OUTPUT);\npinMode(LED_BLUE, OUTPUT);\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial)\n{\nif ((millis() - timeout) < 5000)\n{\ndelay(100);\n}\nelse\n{\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA)\n{\nSerial.println(\"Type: OTAA\");\n}\nelse\n{\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion)\n{\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA)\n{\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n}\nelse\n{\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0)\n{\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"========================\");\nSerial.println(\"    RAK12006 LoRaWAN test\");\nSerial.println(\"========================\");\n\n}\n\n// Default void loop\n\nvoid loop()\n{\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\ngCurrentStatus = digitalRead(SENSOR_PIN);\n\nif (gCurrentStatus == 0)\n// \"0\" for Detected; \"1\" for Undetected\n{\ndigitalWrite(LED_GREEN, HIGH); // Turn ON LED\ndigitalWrite(LED_BLUE, HIGH);\nsensor_val = 1;\nsend_lora_frame();\ndelay(2000);\n}\n\nelse if (gCurrentStatus == 1)\n{\n// do nothing\ndigitalWrite(LED_GREEN, LOW); // Turn OFF LED\ndigitalWrite(LED_BLUE, LOW);\nsensor_val = 0;\nsend_lora_frame();\ndelay(2000);\n}\n\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void)\n{\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void)\n{\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data)\n{\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class)\n{\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\n// void send_lora_frame for RAK12006 Application\nvoid send_lora_frame(void)\n{\nif (lmh_join_status_get() != LMH_SET)\n{\n//Not joined, try again later\nreturn;\n}\n\n//int sensor_val;\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\nm_lora_app_data.buffer[i++] = sensor_val;\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS)\n{\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n}\nelse\n{\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The following steps will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired regions to work with. You can change this to a region that is applicable to you, like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc.  \nThe following table lists the LoRaWAN regions and the countries where they are used:  \n| LoRaWAN Region         | Usage                                                             |\n| ---------------------- | ----------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1 | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan          |\n| LORAMAC_REGION_AS923-2 | Vietnam                                                           |\n| LORAMAC_REGION_AS923-3 | Philippines, Albania, Algeria, Denmark, Greenland, Jordan         |\n| LORAMAC_REGION_AS923-4 | Israel                                                            |\n| LORAMAC_REGION_AU915   | Australia, Anguilla, Argentina, and other parts of South America  |\n| LORAMAC_REGION_CN470   | China                                                             |\n| LORAMAC_REGION_EU433   | EU, UK, Brazil, Costa Rica, Cuba, and other parts of Africa       |\n| LORAMAC_REGION_IN865   | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger |\n| LORAMAC_REGION_EU868   | EU, UK and other parts of Africa                                  |\n| LORAMAC_REGION_KR920   | Republic of Korea                                                 |\n| LORAMAC_REGION_US915   | USA                                                               |\n| LORAMAC_REGION_RU864   | Russia                                                            |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n\n```  \n- Set up the LoRaWAN activation method. In this case, you will use the **OTAA** configuration, which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change it to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n\n```  \n- Set up the EUIs and KEY. The **DeviceEUI**, **AppEUI**, and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x3F, 0xC4, 0x80, 0x0D, 0x4A, 0xE7, 0xAD, 0x9F, 0xDC, 0x27, 0x5D, 0x37, 0x2C, 0x4C, 0xD3, 0xF8};\n\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once you're done with the code, you can now proceed with uploading it to your device. You must first choose your RAK4631 board on your desktop or laptop. To do so, navigate to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** and select **WisBlock RAK4631**.  \n> **Image:** Selecting the RAK4631 board  \n4. After you have selected your board, go to **Tools** > **Port** and then select the specific port of your board.  \n> **Image:** Selecting the port of RAK4631 board  \n5. You can then upload your code by clicking the Upload button (the right arrow sign). Once completed, the **Device programmed** notification will appear in the console at the bottom of the Arduino IDE.  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board  \n> **TIP:** NOTE  \nThe steps outlined above apply to the **RAK12013** and **RAK12017** applications. Once you have finished uploading the code, proceed to the next step:  \n- **RAK12013**: [Setting up RAK12013 Radar Sensor Dashboard Using ThingSpeak](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#setting-up-rak12013-radar-sensor-dashboard-using-thingspeak)\n- **RAK12017**: [Setting up RAK12017 IR Proximity Sensor Dashboard Using ThingSpeak](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#setting-up-rak12017-ir-proximity-sensor-dashboard-using-thingspeak)"}
{"id": "4aa5183c8252abfed6202d6d1a9a0f7e", "product_family": "wisblock", "product_id": "kit3-movement-detection", "category": "How-To", "title": "WisBlock Movement Detection Kit Quick Start Guide > WisBlock IoT Education Kit - Movement Detection Quick Start Guide > Product Configuration > Software Configuration and Examples > RAK12006 PIR Motion Sensor LoRaWAN Application > LoRaWAN Code for RAK12006 > Programming RAK12006 Module with LoRaWAN Application Code [CODE]", "content": "void lorawan_confirm_class_handler(DeviceClass_t Class)\n{\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\n// void send_lora_frame for RAK12006 Application\nvoid send_lora_frame(void)\n{\nif (lmh_join_status_get() != LMH_SET)\n{\n//Not joined, try again later\nreturn;\n}", "keywords": ["Arduino IDE", "RAK4631", "RAK12006", "LoRaWAN", "programming"], "source_file": "quickstart.md", "token_count": 150, "parent_content": "1. If you already have **Arduino IDE** installed on your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you have not yet installed the **Arduino IDE**, go to the [RAK4631 Installation](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#arduino-ide-installation-rak4631) section and execute the following steps.  \n2. After the installation, you can now proceed with programming your **RAK12006** module. Simply copy the **RAK12006 LoRaWAN Application** code below and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n```c\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h> //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n// Section to add include libraries, declarations and variables.\n\n#define SENSOR_PIN  WB_IO6   // Attach AM312 sensor to Arduino Digital Pin WB_IO6\n\nint gCurrentStatus = 0;         // variable for reading the pin current status\n\nint sensor_val;\n\nbool doOTAA = true;   // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                     /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                   /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5             /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                      /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                      /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = {LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF};\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = {BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler\n};\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x3F, 0xC4, 0x80, 0x0D, 0x4A, 0xE7, 0xAD, 0x9F, 0xDC, 0x27, 0x5D, 0x37, 0x2C, 0x4C, 0xD3, 0xF8};\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = {0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23};\nuint8_t nodeAppsKey[16] = {0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C};\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                     /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];            //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = {m_lora_app_data_buffer, 0, 0, 0, 0}; //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup()\n{\npinMode(SENSOR_PIN, INPUT);        // PIR Sensor as an INPUT\npinMode(LED_GREEN, OUTPUT);\npinMode(LED_BLUE, OUTPUT);\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial)\n{\nif ((millis() - timeout) < 5000)\n{\ndelay(100);\n}\nelse\n{\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA)\n{\nSerial.println(\"Type: OTAA\");\n}\nelse\n{\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion)\n{\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA)\n{\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n}\nelse\n{\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0)\n{\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"========================\");\nSerial.println(\"    RAK12006 LoRaWAN test\");\nSerial.println(\"========================\");\n\n}\n\n// Default void loop\n\nvoid loop()\n{\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\ngCurrentStatus = digitalRead(SENSOR_PIN);\n\nif (gCurrentStatus == 0)\n// \"0\" for Detected; \"1\" for Undetected\n{\ndigitalWrite(LED_GREEN, HIGH); // Turn ON LED\ndigitalWrite(LED_BLUE, HIGH);\nsensor_val = 1;\nsend_lora_frame();\ndelay(2000);\n}\n\nelse if (gCurrentStatus == 1)\n{\n// do nothing\ndigitalWrite(LED_GREEN, LOW); // Turn OFF LED\ndigitalWrite(LED_BLUE, LOW);\nsensor_val = 0;\nsend_lora_frame();\ndelay(2000);\n}\n\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void)\n{\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void)\n{\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data)\n{\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class)\n{\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\n// void send_lora_frame for RAK12006 Application\nvoid send_lora_frame(void)\n{\nif (lmh_join_status_get() != LMH_SET)\n{\n//Not joined, try again later\nreturn;\n}\n\n//int sensor_val;\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\nm_lora_app_data.buffer[i++] = sensor_val;\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS)\n{\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n}\nelse\n{\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The following steps will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired regions to work with. You can change this to a region that is applicable to you, like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc.  \nThe following table lists the LoRaWAN regions and the countries where they are used:  \n| LoRaWAN Region         | Usage                                                             |\n| ---------------------- | ----------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1 | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan          |\n| LORAMAC_REGION_AS923-2 | Vietnam                                                           |\n| LORAMAC_REGION_AS923-3 | Philippines, Albania, Algeria, Denmark, Greenland, Jordan         |\n| LORAMAC_REGION_AS923-4 | Israel                                                            |\n| LORAMAC_REGION_AU915   | Australia, Anguilla, Argentina, and other parts of South America  |\n| LORAMAC_REGION_CN470   | China                                                             |\n| LORAMAC_REGION_EU433   | EU, UK, Brazil, Costa Rica, Cuba, and other parts of Africa       |\n| LORAMAC_REGION_IN865   | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger |\n| LORAMAC_REGION_EU868   | EU, UK and other parts of Africa                                  |\n| LORAMAC_REGION_KR920   | Republic of Korea                                                 |\n| LORAMAC_REGION_US915   | USA                                                               |\n| LORAMAC_REGION_RU864   | Russia                                                            |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n\n```  \n- Set up the LoRaWAN activation method. In this case, you will use the **OTAA** configuration, which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change it to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n\n```  \n- Set up the EUIs and KEY. The **DeviceEUI**, **AppEUI**, and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x3F, 0xC4, 0x80, 0x0D, 0x4A, 0xE7, 0xAD, 0x9F, 0xDC, 0x27, 0x5D, 0x37, 0x2C, 0x4C, 0xD3, 0xF8};\n\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once you're done with the code, you can now proceed with uploading it to your device. You must first choose your RAK4631 board on your desktop or laptop. To do so, navigate to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** and select **WisBlock RAK4631**.  \n> **Image:** Selecting the RAK4631 board  \n4. After you have selected your board, go to **Tools** > **Port** and then select the specific port of your board.  \n> **Image:** Selecting the port of RAK4631 board  \n5. You can then upload your code by clicking the Upload button (the right arrow sign). Once completed, the **Device programmed** notification will appear in the console at the bottom of the Arduino IDE.  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board  \n> **TIP:** NOTE  \nThe steps outlined above apply to the **RAK12013** and **RAK12017** applications. Once you have finished uploading the code, proceed to the next step:  \n- **RAK12013**: [Setting up RAK12013 Radar Sensor Dashboard Using ThingSpeak](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#setting-up-rak12013-radar-sensor-dashboard-using-thingspeak)\n- **RAK12017**: [Setting up RAK12017 IR Proximity Sensor Dashboard Using ThingSpeak](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#setting-up-rak12017-ir-proximity-sensor-dashboard-using-thingspeak)"}
{"id": "ee57e6be3712466cba0a7a849f89c3ee", "product_family": "wisblock", "product_id": "kit3-movement-detection", "category": "How-To", "title": "WisBlock Movement Detection Kit Quick Start Guide > WisBlock IoT Education Kit - Movement Detection Quick Start Guide > Product Configuration > Software Configuration and Examples > RAK12006 PIR Motion Sensor LoRaWAN Application > LoRaWAN Code for RAK12006 > Programming RAK12006 Module with LoRaWAN Application Code [CODE]", "content": "//int sensor_val;\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\nm_lora_app_data.buffer[i++] = sensor_val;\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS)\n{\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n}\nelse\n{\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}", "keywords": ["Arduino IDE", "RAK4631", "RAK12006", "LoRaWAN", "programming"], "source_file": "quickstart.md", "token_count": 150, "parent_content": "1. If you already have **Arduino IDE** installed on your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you have not yet installed the **Arduino IDE**, go to the [RAK4631 Installation](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#arduino-ide-installation-rak4631) section and execute the following steps.  \n2. After the installation, you can now proceed with programming your **RAK12006** module. Simply copy the **RAK12006 LoRaWAN Application** code below and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n```c\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h> //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n// Section to add include libraries, declarations and variables.\n\n#define SENSOR_PIN  WB_IO6   // Attach AM312 sensor to Arduino Digital Pin WB_IO6\n\nint gCurrentStatus = 0;         // variable for reading the pin current status\n\nint sensor_val;\n\nbool doOTAA = true;   // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                     /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                   /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5             /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                      /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                      /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = {LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF};\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = {BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler\n};\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x3F, 0xC4, 0x80, 0x0D, 0x4A, 0xE7, 0xAD, 0x9F, 0xDC, 0x27, 0x5D, 0x37, 0x2C, 0x4C, 0xD3, 0xF8};\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = {0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23};\nuint8_t nodeAppsKey[16] = {0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C};\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                     /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];            //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = {m_lora_app_data_buffer, 0, 0, 0, 0}; //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup()\n{\npinMode(SENSOR_PIN, INPUT);        // PIR Sensor as an INPUT\npinMode(LED_GREEN, OUTPUT);\npinMode(LED_BLUE, OUTPUT);\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial)\n{\nif ((millis() - timeout) < 5000)\n{\ndelay(100);\n}\nelse\n{\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA)\n{\nSerial.println(\"Type: OTAA\");\n}\nelse\n{\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion)\n{\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA)\n{\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n}\nelse\n{\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0)\n{\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"========================\");\nSerial.println(\"    RAK12006 LoRaWAN test\");\nSerial.println(\"========================\");\n\n}\n\n// Default void loop\n\nvoid loop()\n{\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\ngCurrentStatus = digitalRead(SENSOR_PIN);\n\nif (gCurrentStatus == 0)\n// \"0\" for Detected; \"1\" for Undetected\n{\ndigitalWrite(LED_GREEN, HIGH); // Turn ON LED\ndigitalWrite(LED_BLUE, HIGH);\nsensor_val = 1;\nsend_lora_frame();\ndelay(2000);\n}\n\nelse if (gCurrentStatus == 1)\n{\n// do nothing\ndigitalWrite(LED_GREEN, LOW); // Turn OFF LED\ndigitalWrite(LED_BLUE, LOW);\nsensor_val = 0;\nsend_lora_frame();\ndelay(2000);\n}\n\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void)\n{\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void)\n{\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data)\n{\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class)\n{\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\n// void send_lora_frame for RAK12006 Application\nvoid send_lora_frame(void)\n{\nif (lmh_join_status_get() != LMH_SET)\n{\n//Not joined, try again later\nreturn;\n}\n\n//int sensor_val;\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\nm_lora_app_data.buffer[i++] = sensor_val;\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS)\n{\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n}\nelse\n{\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The following steps will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired regions to work with. You can change this to a region that is applicable to you, like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc.  \nThe following table lists the LoRaWAN regions and the countries where they are used:  \n| LoRaWAN Region         | Usage                                                             |\n| ---------------------- | ----------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1 | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan          |\n| LORAMAC_REGION_AS923-2 | Vietnam                                                           |\n| LORAMAC_REGION_AS923-3 | Philippines, Albania, Algeria, Denmark, Greenland, Jordan         |\n| LORAMAC_REGION_AS923-4 | Israel                                                            |\n| LORAMAC_REGION_AU915   | Australia, Anguilla, Argentina, and other parts of South America  |\n| LORAMAC_REGION_CN470   | China                                                             |\n| LORAMAC_REGION_EU433   | EU, UK, Brazil, Costa Rica, Cuba, and other parts of Africa       |\n| LORAMAC_REGION_IN865   | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger |\n| LORAMAC_REGION_EU868   | EU, UK and other parts of Africa                                  |\n| LORAMAC_REGION_KR920   | Republic of Korea                                                 |\n| LORAMAC_REGION_US915   | USA                                                               |\n| LORAMAC_REGION_RU864   | Russia                                                            |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n\n```  \n- Set up the LoRaWAN activation method. In this case, you will use the **OTAA** configuration, which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change it to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n\n```  \n- Set up the EUIs and KEY. The **DeviceEUI**, **AppEUI**, and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x3F, 0xC4, 0x80, 0x0D, 0x4A, 0xE7, 0xAD, 0x9F, 0xDC, 0x27, 0x5D, 0x37, 0x2C, 0x4C, 0xD3, 0xF8};\n\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once you're done with the code, you can now proceed with uploading it to your device. You must first choose your RAK4631 board on your desktop or laptop. To do so, navigate to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** and select **WisBlock RAK4631**.  \n> **Image:** Selecting the RAK4631 board  \n4. After you have selected your board, go to **Tools** > **Port** and then select the specific port of your board.  \n> **Image:** Selecting the port of RAK4631 board  \n5. You can then upload your code by clicking the Upload button (the right arrow sign). Once completed, the **Device programmed** notification will appear in the console at the bottom of the Arduino IDE.  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board  \n> **TIP:** NOTE  \nThe steps outlined above apply to the **RAK12013** and **RAK12017** applications. Once you have finished uploading the code, proceed to the next step:  \n- **RAK12013**: [Setting up RAK12013 Radar Sensor Dashboard Using ThingSpeak](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#setting-up-rak12013-radar-sensor-dashboard-using-thingspeak)\n- **RAK12017**: [Setting up RAK12017 IR Proximity Sensor Dashboard Using ThingSpeak](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#setting-up-rak12017-ir-proximity-sensor-dashboard-using-thingspeak)"}
{"id": "7a21d997c33a308c302b1407fc808cc7", "product_family": "wisblock", "product_id": "kit3-movement-detection", "category": "How-To", "title": "WisBlock Movement Detection Kit Quick Start Guide > WisBlock IoT Education Kit - Movement Detection Quick Start Guide > Product Configuration > Software Configuration and Examples > RAK12006 PIR Motion Sensor LoRaWAN Application > LoRaWAN Code for RAK12006 > Programming RAK12006 Module with LoRaWAN Application Code [CODE]", "content": "```  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The following steps will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired regions to work with. You can change this to a region that is applicable to you, like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc.", "keywords": ["Arduino IDE", "RAK4631", "RAK12006", "LoRaWAN", "programming"], "source_file": "quickstart.md", "token_count": 150, "parent_content": "1. If you already have **Arduino IDE** installed on your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you have not yet installed the **Arduino IDE**, go to the [RAK4631 Installation](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#arduino-ide-installation-rak4631) section and execute the following steps.  \n2. After the installation, you can now proceed with programming your **RAK12006** module. Simply copy the **RAK12006 LoRaWAN Application** code below and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n```c\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h> //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n// Section to add include libraries, declarations and variables.\n\n#define SENSOR_PIN  WB_IO6   // Attach AM312 sensor to Arduino Digital Pin WB_IO6\n\nint gCurrentStatus = 0;         // variable for reading the pin current status\n\nint sensor_val;\n\nbool doOTAA = true;   // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                     /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                   /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5             /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                      /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                      /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = {LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF};\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = {BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler\n};\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x3F, 0xC4, 0x80, 0x0D, 0x4A, 0xE7, 0xAD, 0x9F, 0xDC, 0x27, 0x5D, 0x37, 0x2C, 0x4C, 0xD3, 0xF8};\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = {0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23};\nuint8_t nodeAppsKey[16] = {0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C};\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                     /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];            //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = {m_lora_app_data_buffer, 0, 0, 0, 0}; //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup()\n{\npinMode(SENSOR_PIN, INPUT);        // PIR Sensor as an INPUT\npinMode(LED_GREEN, OUTPUT);\npinMode(LED_BLUE, OUTPUT);\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial)\n{\nif ((millis() - timeout) < 5000)\n{\ndelay(100);\n}\nelse\n{\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA)\n{\nSerial.println(\"Type: OTAA\");\n}\nelse\n{\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion)\n{\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA)\n{\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n}\nelse\n{\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0)\n{\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"========================\");\nSerial.println(\"    RAK12006 LoRaWAN test\");\nSerial.println(\"========================\");\n\n}\n\n// Default void loop\n\nvoid loop()\n{\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\ngCurrentStatus = digitalRead(SENSOR_PIN);\n\nif (gCurrentStatus == 0)\n// \"0\" for Detected; \"1\" for Undetected\n{\ndigitalWrite(LED_GREEN, HIGH); // Turn ON LED\ndigitalWrite(LED_BLUE, HIGH);\nsensor_val = 1;\nsend_lora_frame();\ndelay(2000);\n}\n\nelse if (gCurrentStatus == 1)\n{\n// do nothing\ndigitalWrite(LED_GREEN, LOW); // Turn OFF LED\ndigitalWrite(LED_BLUE, LOW);\nsensor_val = 0;\nsend_lora_frame();\ndelay(2000);\n}\n\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void)\n{\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void)\n{\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data)\n{\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class)\n{\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\n// void send_lora_frame for RAK12006 Application\nvoid send_lora_frame(void)\n{\nif (lmh_join_status_get() != LMH_SET)\n{\n//Not joined, try again later\nreturn;\n}\n\n//int sensor_val;\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\nm_lora_app_data.buffer[i++] = sensor_val;\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS)\n{\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n}\nelse\n{\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The following steps will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired regions to work with. You can change this to a region that is applicable to you, like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc.  \nThe following table lists the LoRaWAN regions and the countries where they are used:  \n| LoRaWAN Region         | Usage                                                             |\n| ---------------------- | ----------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1 | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan          |\n| LORAMAC_REGION_AS923-2 | Vietnam                                                           |\n| LORAMAC_REGION_AS923-3 | Philippines, Albania, Algeria, Denmark, Greenland, Jordan         |\n| LORAMAC_REGION_AS923-4 | Israel                                                            |\n| LORAMAC_REGION_AU915   | Australia, Anguilla, Argentina, and other parts of South America  |\n| LORAMAC_REGION_CN470   | China                                                             |\n| LORAMAC_REGION_EU433   | EU, UK, Brazil, Costa Rica, Cuba, and other parts of Africa       |\n| LORAMAC_REGION_IN865   | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger |\n| LORAMAC_REGION_EU868   | EU, UK and other parts of Africa                                  |\n| LORAMAC_REGION_KR920   | Republic of Korea                                                 |\n| LORAMAC_REGION_US915   | USA                                                               |\n| LORAMAC_REGION_RU864   | Russia                                                            |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n\n```  \n- Set up the LoRaWAN activation method. In this case, you will use the **OTAA** configuration, which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change it to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n\n```  \n- Set up the EUIs and KEY. The **DeviceEUI**, **AppEUI**, and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x3F, 0xC4, 0x80, 0x0D, 0x4A, 0xE7, 0xAD, 0x9F, 0xDC, 0x27, 0x5D, 0x37, 0x2C, 0x4C, 0xD3, 0xF8};\n\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once you're done with the code, you can now proceed with uploading it to your device. You must first choose your RAK4631 board on your desktop or laptop. To do so, navigate to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** and select **WisBlock RAK4631**.  \n> **Image:** Selecting the RAK4631 board  \n4. After you have selected your board, go to **Tools** > **Port** and then select the specific port of your board.  \n> **Image:** Selecting the port of RAK4631 board  \n5. You can then upload your code by clicking the Upload button (the right arrow sign). Once completed, the **Device programmed** notification will appear in the console at the bottom of the Arduino IDE.  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board  \n> **TIP:** NOTE  \nThe steps outlined above apply to the **RAK12013** and **RAK12017** applications. Once you have finished uploading the code, proceed to the next step:  \n- **RAK12013**: [Setting up RAK12013 Radar Sensor Dashboard Using ThingSpeak](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#setting-up-rak12013-radar-sensor-dashboard-using-thingspeak)\n- **RAK12017**: [Setting up RAK12017 IR Proximity Sensor Dashboard Using ThingSpeak](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#setting-up-rak12017-ir-proximity-sensor-dashboard-using-thingspeak)"}
{"id": "06fa4bb5fac6448ac75514853270c049", "product_family": "wisblock", "product_id": "kit3-movement-detection", "category": "How-To", "title": "WisBlock Movement Detection Kit Quick Start Guide > WisBlock IoT Education Kit - Movement Detection Quick Start Guide > Product Configuration > Software Configuration and Examples > RAK12006 PIR Motion Sensor LoRaWAN Application > LoRaWAN Code for RAK12006 > Programming RAK12006 Module with LoRaWAN Application Code [CODE]", "content": "The following table lists the LoRaWAN regions and the countries where they are used:  \n| LoRaWAN Region         | Usage                                                             |\n| ---------------------- | ----------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1 | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan          |\n| LORAMAC_REGION_AS923-2 | Vietnam                                                           |", "keywords": ["Arduino IDE", "RAK4631", "RAK12006", "LoRaWAN", "programming"], "source_file": "quickstart.md", "token_count": 150, "parent_content": "1. If you already have **Arduino IDE** installed on your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you have not yet installed the **Arduino IDE**, go to the [RAK4631 Installation](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#arduino-ide-installation-rak4631) section and execute the following steps.  \n2. After the installation, you can now proceed with programming your **RAK12006** module. Simply copy the **RAK12006 LoRaWAN Application** code below and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n```c\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h> //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n// Section to add include libraries, declarations and variables.\n\n#define SENSOR_PIN  WB_IO6   // Attach AM312 sensor to Arduino Digital Pin WB_IO6\n\nint gCurrentStatus = 0;         // variable for reading the pin current status\n\nint sensor_val;\n\nbool doOTAA = true;   // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                     /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                   /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5             /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                      /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                      /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = {LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF};\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = {BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler\n};\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x3F, 0xC4, 0x80, 0x0D, 0x4A, 0xE7, 0xAD, 0x9F, 0xDC, 0x27, 0x5D, 0x37, 0x2C, 0x4C, 0xD3, 0xF8};\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = {0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23};\nuint8_t nodeAppsKey[16] = {0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C};\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                     /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];            //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = {m_lora_app_data_buffer, 0, 0, 0, 0}; //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup()\n{\npinMode(SENSOR_PIN, INPUT);        // PIR Sensor as an INPUT\npinMode(LED_GREEN, OUTPUT);\npinMode(LED_BLUE, OUTPUT);\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial)\n{\nif ((millis() - timeout) < 5000)\n{\ndelay(100);\n}\nelse\n{\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA)\n{\nSerial.println(\"Type: OTAA\");\n}\nelse\n{\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion)\n{\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA)\n{\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n}\nelse\n{\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0)\n{\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"========================\");\nSerial.println(\"    RAK12006 LoRaWAN test\");\nSerial.println(\"========================\");\n\n}\n\n// Default void loop\n\nvoid loop()\n{\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\ngCurrentStatus = digitalRead(SENSOR_PIN);\n\nif (gCurrentStatus == 0)\n// \"0\" for Detected; \"1\" for Undetected\n{\ndigitalWrite(LED_GREEN, HIGH); // Turn ON LED\ndigitalWrite(LED_BLUE, HIGH);\nsensor_val = 1;\nsend_lora_frame();\ndelay(2000);\n}\n\nelse if (gCurrentStatus == 1)\n{\n// do nothing\ndigitalWrite(LED_GREEN, LOW); // Turn OFF LED\ndigitalWrite(LED_BLUE, LOW);\nsensor_val = 0;\nsend_lora_frame();\ndelay(2000);\n}\n\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void)\n{\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void)\n{\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data)\n{\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class)\n{\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\n// void send_lora_frame for RAK12006 Application\nvoid send_lora_frame(void)\n{\nif (lmh_join_status_get() != LMH_SET)\n{\n//Not joined, try again later\nreturn;\n}\n\n//int sensor_val;\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\nm_lora_app_data.buffer[i++] = sensor_val;\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS)\n{\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n}\nelse\n{\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The following steps will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired regions to work with. You can change this to a region that is applicable to you, like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc.  \nThe following table lists the LoRaWAN regions and the countries where they are used:  \n| LoRaWAN Region         | Usage                                                             |\n| ---------------------- | ----------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1 | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan          |\n| LORAMAC_REGION_AS923-2 | Vietnam                                                           |\n| LORAMAC_REGION_AS923-3 | Philippines, Albania, Algeria, Denmark, Greenland, Jordan         |\n| LORAMAC_REGION_AS923-4 | Israel                                                            |\n| LORAMAC_REGION_AU915   | Australia, Anguilla, Argentina, and other parts of South America  |\n| LORAMAC_REGION_CN470   | China                                                             |\n| LORAMAC_REGION_EU433   | EU, UK, Brazil, Costa Rica, Cuba, and other parts of Africa       |\n| LORAMAC_REGION_IN865   | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger |\n| LORAMAC_REGION_EU868   | EU, UK and other parts of Africa                                  |\n| LORAMAC_REGION_KR920   | Republic of Korea                                                 |\n| LORAMAC_REGION_US915   | USA                                                               |\n| LORAMAC_REGION_RU864   | Russia                                                            |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n\n```  \n- Set up the LoRaWAN activation method. In this case, you will use the **OTAA** configuration, which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change it to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n\n```  \n- Set up the EUIs and KEY. The **DeviceEUI**, **AppEUI**, and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x3F, 0xC4, 0x80, 0x0D, 0x4A, 0xE7, 0xAD, 0x9F, 0xDC, 0x27, 0x5D, 0x37, 0x2C, 0x4C, 0xD3, 0xF8};\n\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once you're done with the code, you can now proceed with uploading it to your device. You must first choose your RAK4631 board on your desktop or laptop. To do so, navigate to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** and select **WisBlock RAK4631**.  \n> **Image:** Selecting the RAK4631 board  \n4. After you have selected your board, go to **Tools** > **Port** and then select the specific port of your board.  \n> **Image:** Selecting the port of RAK4631 board  \n5. You can then upload your code by clicking the Upload button (the right arrow sign). Once completed, the **Device programmed** notification will appear in the console at the bottom of the Arduino IDE.  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board  \n> **TIP:** NOTE  \nThe steps outlined above apply to the **RAK12013** and **RAK12017** applications. Once you have finished uploading the code, proceed to the next step:  \n- **RAK12013**: [Setting up RAK12013 Radar Sensor Dashboard Using ThingSpeak](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#setting-up-rak12013-radar-sensor-dashboard-using-thingspeak)\n- **RAK12017**: [Setting up RAK12017 IR Proximity Sensor Dashboard Using ThingSpeak](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#setting-up-rak12017-ir-proximity-sensor-dashboard-using-thingspeak)"}
{"id": "12b7c16b350e78017168fe5d331d6aee", "product_family": "wisblock", "product_id": "kit3-movement-detection", "category": "How-To", "title": "WisBlock Movement Detection Kit Quick Start Guide > WisBlock IoT Education Kit - Movement Detection Quick Start Guide > Product Configuration > Software Configuration and Examples > RAK12006 PIR Motion Sensor LoRaWAN Application > LoRaWAN Code for RAK12006 > Programming RAK12006 Module with LoRaWAN Application Code [CODE]", "content": "| LoRaWAN Region         | Usage                                                             |\n| ---------------------- | ----------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-2 | Vietnam                                                           |\n| LORAMAC_REGION_AS923-3 | Philippines, Albania, Algeria, Denmark, Greenland, Jordan         |\n| LORAMAC_REGION_AS923-4 | Israel                                                            |\n| LORAMAC_REGION_AU915   | Australia, Anguilla, Argentina, and other parts of South America  |\n| LORAMAC_REGION_CN470   | China                                                             |", "keywords": ["Arduino IDE", "RAK4631", "RAK12006", "LoRaWAN", "programming"], "source_file": "quickstart.md", "token_count": 150, "parent_content": "1. If you already have **Arduino IDE** installed on your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you have not yet installed the **Arduino IDE**, go to the [RAK4631 Installation](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#arduino-ide-installation-rak4631) section and execute the following steps.  \n2. After the installation, you can now proceed with programming your **RAK12006** module. Simply copy the **RAK12006 LoRaWAN Application** code below and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n```c\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h> //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n// Section to add include libraries, declarations and variables.\n\n#define SENSOR_PIN  WB_IO6   // Attach AM312 sensor to Arduino Digital Pin WB_IO6\n\nint gCurrentStatus = 0;         // variable for reading the pin current status\n\nint sensor_val;\n\nbool doOTAA = true;   // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                     /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                   /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5             /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                      /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                      /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = {LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF};\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = {BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler\n};\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x3F, 0xC4, 0x80, 0x0D, 0x4A, 0xE7, 0xAD, 0x9F, 0xDC, 0x27, 0x5D, 0x37, 0x2C, 0x4C, 0xD3, 0xF8};\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = {0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23};\nuint8_t nodeAppsKey[16] = {0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C};\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                     /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];            //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = {m_lora_app_data_buffer, 0, 0, 0, 0}; //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup()\n{\npinMode(SENSOR_PIN, INPUT);        // PIR Sensor as an INPUT\npinMode(LED_GREEN, OUTPUT);\npinMode(LED_BLUE, OUTPUT);\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial)\n{\nif ((millis() - timeout) < 5000)\n{\ndelay(100);\n}\nelse\n{\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA)\n{\nSerial.println(\"Type: OTAA\");\n}\nelse\n{\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion)\n{\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA)\n{\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n}\nelse\n{\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0)\n{\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"========================\");\nSerial.println(\"    RAK12006 LoRaWAN test\");\nSerial.println(\"========================\");\n\n}\n\n// Default void loop\n\nvoid loop()\n{\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\ngCurrentStatus = digitalRead(SENSOR_PIN);\n\nif (gCurrentStatus == 0)\n// \"0\" for Detected; \"1\" for Undetected\n{\ndigitalWrite(LED_GREEN, HIGH); // Turn ON LED\ndigitalWrite(LED_BLUE, HIGH);\nsensor_val = 1;\nsend_lora_frame();\ndelay(2000);\n}\n\nelse if (gCurrentStatus == 1)\n{\n// do nothing\ndigitalWrite(LED_GREEN, LOW); // Turn OFF LED\ndigitalWrite(LED_BLUE, LOW);\nsensor_val = 0;\nsend_lora_frame();\ndelay(2000);\n}\n\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void)\n{\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void)\n{\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data)\n{\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class)\n{\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\n// void send_lora_frame for RAK12006 Application\nvoid send_lora_frame(void)\n{\nif (lmh_join_status_get() != LMH_SET)\n{\n//Not joined, try again later\nreturn;\n}\n\n//int sensor_val;\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\nm_lora_app_data.buffer[i++] = sensor_val;\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS)\n{\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n}\nelse\n{\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The following steps will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired regions to work with. You can change this to a region that is applicable to you, like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc.  \nThe following table lists the LoRaWAN regions and the countries where they are used:  \n| LoRaWAN Region         | Usage                                                             |\n| ---------------------- | ----------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1 | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan          |\n| LORAMAC_REGION_AS923-2 | Vietnam                                                           |\n| LORAMAC_REGION_AS923-3 | Philippines, Albania, Algeria, Denmark, Greenland, Jordan         |\n| LORAMAC_REGION_AS923-4 | Israel                                                            |\n| LORAMAC_REGION_AU915   | Australia, Anguilla, Argentina, and other parts of South America  |\n| LORAMAC_REGION_CN470   | China                                                             |\n| LORAMAC_REGION_EU433   | EU, UK, Brazil, Costa Rica, Cuba, and other parts of Africa       |\n| LORAMAC_REGION_IN865   | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger |\n| LORAMAC_REGION_EU868   | EU, UK and other parts of Africa                                  |\n| LORAMAC_REGION_KR920   | Republic of Korea                                                 |\n| LORAMAC_REGION_US915   | USA                                                               |\n| LORAMAC_REGION_RU864   | Russia                                                            |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n\n```  \n- Set up the LoRaWAN activation method. In this case, you will use the **OTAA** configuration, which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change it to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n\n```  \n- Set up the EUIs and KEY. The **DeviceEUI**, **AppEUI**, and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x3F, 0xC4, 0x80, 0x0D, 0x4A, 0xE7, 0xAD, 0x9F, 0xDC, 0x27, 0x5D, 0x37, 0x2C, 0x4C, 0xD3, 0xF8};\n\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once you're done with the code, you can now proceed with uploading it to your device. You must first choose your RAK4631 board on your desktop or laptop. To do so, navigate to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** and select **WisBlock RAK4631**.  \n> **Image:** Selecting the RAK4631 board  \n4. After you have selected your board, go to **Tools** > **Port** and then select the specific port of your board.  \n> **Image:** Selecting the port of RAK4631 board  \n5. You can then upload your code by clicking the Upload button (the right arrow sign). Once completed, the **Device programmed** notification will appear in the console at the bottom of the Arduino IDE.  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board  \n> **TIP:** NOTE  \nThe steps outlined above apply to the **RAK12013** and **RAK12017** applications. Once you have finished uploading the code, proceed to the next step:  \n- **RAK12013**: [Setting up RAK12013 Radar Sensor Dashboard Using ThingSpeak](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#setting-up-rak12013-radar-sensor-dashboard-using-thingspeak)\n- **RAK12017**: [Setting up RAK12017 IR Proximity Sensor Dashboard Using ThingSpeak](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#setting-up-rak12017-ir-proximity-sensor-dashboard-using-thingspeak)"}
{"id": "e07b6b1a3767763567a60cdf44f3f647", "product_family": "wisblock", "product_id": "kit3-movement-detection", "category": "How-To", "title": "WisBlock Movement Detection Kit Quick Start Guide > WisBlock IoT Education Kit - Movement Detection Quick Start Guide > Product Configuration > Software Configuration and Examples > RAK12006 PIR Motion Sensor LoRaWAN Application > LoRaWAN Code for RAK12006 > Programming RAK12006 Module with LoRaWAN Application Code [CODE]", "content": "| LoRaWAN Region         | Usage                                                             |\n| ---------------------- | ----------------------------------------------------------------- |\n| LORAMAC_REGION_CN470   | China                                                             |\n| LORAMAC_REGION_EU433   | EU, UK, Brazil, Costa Rica, Cuba, and other parts of Africa       |\n| LORAMAC_REGION_IN865   | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger |\n| LORAMAC_REGION_EU868   | EU, UK and other parts of Africa                                  |\n| LORAMAC_REGION_KR920   | Republic of Korea                                                 |", "keywords": ["Arduino IDE", "RAK4631", "RAK12006", "LoRaWAN", "programming"], "source_file": "quickstart.md", "token_count": 150, "parent_content": "1. If you already have **Arduino IDE** installed on your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you have not yet installed the **Arduino IDE**, go to the [RAK4631 Installation](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#arduino-ide-installation-rak4631) section and execute the following steps.  \n2. After the installation, you can now proceed with programming your **RAK12006** module. Simply copy the **RAK12006 LoRaWAN Application** code below and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n```c\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h> //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n// Section to add include libraries, declarations and variables.\n\n#define SENSOR_PIN  WB_IO6   // Attach AM312 sensor to Arduino Digital Pin WB_IO6\n\nint gCurrentStatus = 0;         // variable for reading the pin current status\n\nint sensor_val;\n\nbool doOTAA = true;   // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                     /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                   /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5             /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                      /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                      /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = {LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF};\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = {BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler\n};\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x3F, 0xC4, 0x80, 0x0D, 0x4A, 0xE7, 0xAD, 0x9F, 0xDC, 0x27, 0x5D, 0x37, 0x2C, 0x4C, 0xD3, 0xF8};\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = {0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23};\nuint8_t nodeAppsKey[16] = {0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C};\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                     /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];            //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = {m_lora_app_data_buffer, 0, 0, 0, 0}; //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup()\n{\npinMode(SENSOR_PIN, INPUT);        // PIR Sensor as an INPUT\npinMode(LED_GREEN, OUTPUT);\npinMode(LED_BLUE, OUTPUT);\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial)\n{\nif ((millis() - timeout) < 5000)\n{\ndelay(100);\n}\nelse\n{\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA)\n{\nSerial.println(\"Type: OTAA\");\n}\nelse\n{\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion)\n{\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA)\n{\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n}\nelse\n{\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0)\n{\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"========================\");\nSerial.println(\"    RAK12006 LoRaWAN test\");\nSerial.println(\"========================\");\n\n}\n\n// Default void loop\n\nvoid loop()\n{\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\ngCurrentStatus = digitalRead(SENSOR_PIN);\n\nif (gCurrentStatus == 0)\n// \"0\" for Detected; \"1\" for Undetected\n{\ndigitalWrite(LED_GREEN, HIGH); // Turn ON LED\ndigitalWrite(LED_BLUE, HIGH);\nsensor_val = 1;\nsend_lora_frame();\ndelay(2000);\n}\n\nelse if (gCurrentStatus == 1)\n{\n// do nothing\ndigitalWrite(LED_GREEN, LOW); // Turn OFF LED\ndigitalWrite(LED_BLUE, LOW);\nsensor_val = 0;\nsend_lora_frame();\ndelay(2000);\n}\n\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void)\n{\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void)\n{\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data)\n{\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class)\n{\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\n// void send_lora_frame for RAK12006 Application\nvoid send_lora_frame(void)\n{\nif (lmh_join_status_get() != LMH_SET)\n{\n//Not joined, try again later\nreturn;\n}\n\n//int sensor_val;\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\nm_lora_app_data.buffer[i++] = sensor_val;\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS)\n{\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n}\nelse\n{\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The following steps will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired regions to work with. You can change this to a region that is applicable to you, like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc.  \nThe following table lists the LoRaWAN regions and the countries where they are used:  \n| LoRaWAN Region         | Usage                                                             |\n| ---------------------- | ----------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1 | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan          |\n| LORAMAC_REGION_AS923-2 | Vietnam                                                           |\n| LORAMAC_REGION_AS923-3 | Philippines, Albania, Algeria, Denmark, Greenland, Jordan         |\n| LORAMAC_REGION_AS923-4 | Israel                                                            |\n| LORAMAC_REGION_AU915   | Australia, Anguilla, Argentina, and other parts of South America  |\n| LORAMAC_REGION_CN470   | China                                                             |\n| LORAMAC_REGION_EU433   | EU, UK, Brazil, Costa Rica, Cuba, and other parts of Africa       |\n| LORAMAC_REGION_IN865   | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger |\n| LORAMAC_REGION_EU868   | EU, UK and other parts of Africa                                  |\n| LORAMAC_REGION_KR920   | Republic of Korea                                                 |\n| LORAMAC_REGION_US915   | USA                                                               |\n| LORAMAC_REGION_RU864   | Russia                                                            |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n\n```  \n- Set up the LoRaWAN activation method. In this case, you will use the **OTAA** configuration, which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change it to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n\n```  \n- Set up the EUIs and KEY. The **DeviceEUI**, **AppEUI**, and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x3F, 0xC4, 0x80, 0x0D, 0x4A, 0xE7, 0xAD, 0x9F, 0xDC, 0x27, 0x5D, 0x37, 0x2C, 0x4C, 0xD3, 0xF8};\n\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once you're done with the code, you can now proceed with uploading it to your device. You must first choose your RAK4631 board on your desktop or laptop. To do so, navigate to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** and select **WisBlock RAK4631**.  \n> **Image:** Selecting the RAK4631 board  \n4. After you have selected your board, go to **Tools** > **Port** and then select the specific port of your board.  \n> **Image:** Selecting the port of RAK4631 board  \n5. You can then upload your code by clicking the Upload button (the right arrow sign). Once completed, the **Device programmed** notification will appear in the console at the bottom of the Arduino IDE.  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board  \n> **TIP:** NOTE  \nThe steps outlined above apply to the **RAK12013** and **RAK12017** applications. Once you have finished uploading the code, proceed to the next step:  \n- **RAK12013**: [Setting up RAK12013 Radar Sensor Dashboard Using ThingSpeak](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#setting-up-rak12013-radar-sensor-dashboard-using-thingspeak)\n- **RAK12017**: [Setting up RAK12017 IR Proximity Sensor Dashboard Using ThingSpeak](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#setting-up-rak12017-ir-proximity-sensor-dashboard-using-thingspeak)"}
{"id": "f2923fcf734609ad4815cdf9bba92dcb", "product_family": "wisblock", "product_id": "kit3-movement-detection", "category": "How-To", "title": "WisBlock Movement Detection Kit Quick Start Guide > WisBlock IoT Education Kit - Movement Detection Quick Start Guide > Product Configuration > Software Configuration and Examples > RAK12006 PIR Motion Sensor LoRaWAN Application > LoRaWAN Code for RAK12006 > Programming RAK12006 Module with LoRaWAN Application Code [CODE]", "content": "| LoRaWAN Region         | Usage                                                             |\n| ---------------------- | ----------------------------------------------------------------- |\n| LORAMAC_REGION_KR920   | Republic of Korea                                                 |\n| LORAMAC_REGION_US915   | USA                                                               |\n| LORAMAC_REGION_RU864   | Russia                                                            |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/", "keywords": ["Arduino IDE", "RAK4631", "RAK12006", "LoRaWAN", "programming"], "source_file": "quickstart.md", "token_count": 150, "parent_content": "1. If you already have **Arduino IDE** installed on your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you have not yet installed the **Arduino IDE**, go to the [RAK4631 Installation](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#arduino-ide-installation-rak4631) section and execute the following steps.  \n2. After the installation, you can now proceed with programming your **RAK12006** module. Simply copy the **RAK12006 LoRaWAN Application** code below and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n```c\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h> //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n// Section to add include libraries, declarations and variables.\n\n#define SENSOR_PIN  WB_IO6   // Attach AM312 sensor to Arduino Digital Pin WB_IO6\n\nint gCurrentStatus = 0;         // variable for reading the pin current status\n\nint sensor_val;\n\nbool doOTAA = true;   // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                     /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                   /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5             /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                      /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                      /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = {LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF};\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = {BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler\n};\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x3F, 0xC4, 0x80, 0x0D, 0x4A, 0xE7, 0xAD, 0x9F, 0xDC, 0x27, 0x5D, 0x37, 0x2C, 0x4C, 0xD3, 0xF8};\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = {0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23};\nuint8_t nodeAppsKey[16] = {0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C};\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                     /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];            //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = {m_lora_app_data_buffer, 0, 0, 0, 0}; //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup()\n{\npinMode(SENSOR_PIN, INPUT);        // PIR Sensor as an INPUT\npinMode(LED_GREEN, OUTPUT);\npinMode(LED_BLUE, OUTPUT);\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial)\n{\nif ((millis() - timeout) < 5000)\n{\ndelay(100);\n}\nelse\n{\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA)\n{\nSerial.println(\"Type: OTAA\");\n}\nelse\n{\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion)\n{\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA)\n{\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n}\nelse\n{\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0)\n{\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"========================\");\nSerial.println(\"    RAK12006 LoRaWAN test\");\nSerial.println(\"========================\");\n\n}\n\n// Default void loop\n\nvoid loop()\n{\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\ngCurrentStatus = digitalRead(SENSOR_PIN);\n\nif (gCurrentStatus == 0)\n// \"0\" for Detected; \"1\" for Undetected\n{\ndigitalWrite(LED_GREEN, HIGH); // Turn ON LED\ndigitalWrite(LED_BLUE, HIGH);\nsensor_val = 1;\nsend_lora_frame();\ndelay(2000);\n}\n\nelse if (gCurrentStatus == 1)\n{\n// do nothing\ndigitalWrite(LED_GREEN, LOW); // Turn OFF LED\ndigitalWrite(LED_BLUE, LOW);\nsensor_val = 0;\nsend_lora_frame();\ndelay(2000);\n}\n\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void)\n{\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void)\n{\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data)\n{\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class)\n{\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\n// void send_lora_frame for RAK12006 Application\nvoid send_lora_frame(void)\n{\nif (lmh_join_status_get() != LMH_SET)\n{\n//Not joined, try again later\nreturn;\n}\n\n//int sensor_val;\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\nm_lora_app_data.buffer[i++] = sensor_val;\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS)\n{\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n}\nelse\n{\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The following steps will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired regions to work with. You can change this to a region that is applicable to you, like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc.  \nThe following table lists the LoRaWAN regions and the countries where they are used:  \n| LoRaWAN Region         | Usage                                                             |\n| ---------------------- | ----------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1 | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan          |\n| LORAMAC_REGION_AS923-2 | Vietnam                                                           |\n| LORAMAC_REGION_AS923-3 | Philippines, Albania, Algeria, Denmark, Greenland, Jordan         |\n| LORAMAC_REGION_AS923-4 | Israel                                                            |\n| LORAMAC_REGION_AU915   | Australia, Anguilla, Argentina, and other parts of South America  |\n| LORAMAC_REGION_CN470   | China                                                             |\n| LORAMAC_REGION_EU433   | EU, UK, Brazil, Costa Rica, Cuba, and other parts of Africa       |\n| LORAMAC_REGION_IN865   | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger |\n| LORAMAC_REGION_EU868   | EU, UK and other parts of Africa                                  |\n| LORAMAC_REGION_KR920   | Republic of Korea                                                 |\n| LORAMAC_REGION_US915   | USA                                                               |\n| LORAMAC_REGION_RU864   | Russia                                                            |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n\n```  \n- Set up the LoRaWAN activation method. In this case, you will use the **OTAA** configuration, which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change it to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n\n```  \n- Set up the EUIs and KEY. The **DeviceEUI**, **AppEUI**, and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x3F, 0xC4, 0x80, 0x0D, 0x4A, 0xE7, 0xAD, 0x9F, 0xDC, 0x27, 0x5D, 0x37, 0x2C, 0x4C, 0xD3, 0xF8};\n\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once you're done with the code, you can now proceed with uploading it to your device. You must first choose your RAK4631 board on your desktop or laptop. To do so, navigate to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** and select **WisBlock RAK4631**.  \n> **Image:** Selecting the RAK4631 board  \n4. After you have selected your board, go to **Tools** > **Port** and then select the specific port of your board.  \n> **Image:** Selecting the port of RAK4631 board  \n5. You can then upload your code by clicking the Upload button (the right arrow sign). Once completed, the **Device programmed** notification will appear in the console at the bottom of the Arduino IDE.  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board  \n> **TIP:** NOTE  \nThe steps outlined above apply to the **RAK12013** and **RAK12017** applications. Once you have finished uploading the code, proceed to the next step:  \n- **RAK12013**: [Setting up RAK12013 Radar Sensor Dashboard Using ThingSpeak](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#setting-up-rak12013-radar-sensor-dashboard-using-thingspeak)\n- **RAK12017**: [Setting up RAK12017 IR Proximity Sensor Dashboard Using ThingSpeak](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#setting-up-rak12017-ir-proximity-sensor-dashboard-using-thingspeak)"}
{"id": "e940eec3a333bf960f4a7072321bb4db", "product_family": "wisblock", "product_id": "kit3-movement-detection", "category": "How-To", "title": "WisBlock Movement Detection Kit Quick Start Guide > WisBlock IoT Education Kit - Movement Detection Quick Start Guide > Product Configuration > Software Configuration and Examples > RAK12006 PIR Motion Sensor LoRaWAN Application > LoRaWAN Code for RAK12006 > Programming RAK12006 Module with LoRaWAN Application Code [CODE]", "content": "```  \n- Set up the LoRaWAN activation method. In this case, you will use the **OTAA** configuration, which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.", "keywords": ["Arduino IDE", "RAK4631", "RAK12006", "LoRaWAN", "programming"], "source_file": "quickstart.md", "token_count": 150, "parent_content": "1. If you already have **Arduino IDE** installed on your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you have not yet installed the **Arduino IDE**, go to the [RAK4631 Installation](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#arduino-ide-installation-rak4631) section and execute the following steps.  \n2. After the installation, you can now proceed with programming your **RAK12006** module. Simply copy the **RAK12006 LoRaWAN Application** code below and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n```c\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h> //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n// Section to add include libraries, declarations and variables.\n\n#define SENSOR_PIN  WB_IO6   // Attach AM312 sensor to Arduino Digital Pin WB_IO6\n\nint gCurrentStatus = 0;         // variable for reading the pin current status\n\nint sensor_val;\n\nbool doOTAA = true;   // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                     /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                   /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5             /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                      /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                      /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = {LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF};\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = {BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler\n};\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x3F, 0xC4, 0x80, 0x0D, 0x4A, 0xE7, 0xAD, 0x9F, 0xDC, 0x27, 0x5D, 0x37, 0x2C, 0x4C, 0xD3, 0xF8};\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = {0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23};\nuint8_t nodeAppsKey[16] = {0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C};\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                     /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];            //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = {m_lora_app_data_buffer, 0, 0, 0, 0}; //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup()\n{\npinMode(SENSOR_PIN, INPUT);        // PIR Sensor as an INPUT\npinMode(LED_GREEN, OUTPUT);\npinMode(LED_BLUE, OUTPUT);\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial)\n{\nif ((millis() - timeout) < 5000)\n{\ndelay(100);\n}\nelse\n{\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA)\n{\nSerial.println(\"Type: OTAA\");\n}\nelse\n{\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion)\n{\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA)\n{\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n}\nelse\n{\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0)\n{\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"========================\");\nSerial.println(\"    RAK12006 LoRaWAN test\");\nSerial.println(\"========================\");\n\n}\n\n// Default void loop\n\nvoid loop()\n{\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\ngCurrentStatus = digitalRead(SENSOR_PIN);\n\nif (gCurrentStatus == 0)\n// \"0\" for Detected; \"1\" for Undetected\n{\ndigitalWrite(LED_GREEN, HIGH); // Turn ON LED\ndigitalWrite(LED_BLUE, HIGH);\nsensor_val = 1;\nsend_lora_frame();\ndelay(2000);\n}\n\nelse if (gCurrentStatus == 1)\n{\n// do nothing\ndigitalWrite(LED_GREEN, LOW); // Turn OFF LED\ndigitalWrite(LED_BLUE, LOW);\nsensor_val = 0;\nsend_lora_frame();\ndelay(2000);\n}\n\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void)\n{\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void)\n{\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data)\n{\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class)\n{\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\n// void send_lora_frame for RAK12006 Application\nvoid send_lora_frame(void)\n{\nif (lmh_join_status_get() != LMH_SET)\n{\n//Not joined, try again later\nreturn;\n}\n\n//int sensor_val;\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\nm_lora_app_data.buffer[i++] = sensor_val;\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS)\n{\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n}\nelse\n{\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The following steps will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired regions to work with. You can change this to a region that is applicable to you, like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc.  \nThe following table lists the LoRaWAN regions and the countries where they are used:  \n| LoRaWAN Region         | Usage                                                             |\n| ---------------------- | ----------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1 | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan          |\n| LORAMAC_REGION_AS923-2 | Vietnam                                                           |\n| LORAMAC_REGION_AS923-3 | Philippines, Albania, Algeria, Denmark, Greenland, Jordan         |\n| LORAMAC_REGION_AS923-4 | Israel                                                            |\n| LORAMAC_REGION_AU915   | Australia, Anguilla, Argentina, and other parts of South America  |\n| LORAMAC_REGION_CN470   | China                                                             |\n| LORAMAC_REGION_EU433   | EU, UK, Brazil, Costa Rica, Cuba, and other parts of Africa       |\n| LORAMAC_REGION_IN865   | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger |\n| LORAMAC_REGION_EU868   | EU, UK and other parts of Africa                                  |\n| LORAMAC_REGION_KR920   | Republic of Korea                                                 |\n| LORAMAC_REGION_US915   | USA                                                               |\n| LORAMAC_REGION_RU864   | Russia                                                            |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n\n```  \n- Set up the LoRaWAN activation method. In this case, you will use the **OTAA** configuration, which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change it to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n\n```  \n- Set up the EUIs and KEY. The **DeviceEUI**, **AppEUI**, and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x3F, 0xC4, 0x80, 0x0D, 0x4A, 0xE7, 0xAD, 0x9F, 0xDC, 0x27, 0x5D, 0x37, 0x2C, 0x4C, 0xD3, 0xF8};\n\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once you're done with the code, you can now proceed with uploading it to your device. You must first choose your RAK4631 board on your desktop or laptop. To do so, navigate to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** and select **WisBlock RAK4631**.  \n> **Image:** Selecting the RAK4631 board  \n4. After you have selected your board, go to **Tools** > **Port** and then select the specific port of your board.  \n> **Image:** Selecting the port of RAK4631 board  \n5. You can then upload your code by clicking the Upload button (the right arrow sign). Once completed, the **Device programmed** notification will appear in the console at the bottom of the Arduino IDE.  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board  \n> **TIP:** NOTE  \nThe steps outlined above apply to the **RAK12013** and **RAK12017** applications. Once you have finished uploading the code, proceed to the next step:  \n- **RAK12013**: [Setting up RAK12013 Radar Sensor Dashboard Using ThingSpeak](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#setting-up-rak12013-radar-sensor-dashboard-using-thingspeak)\n- **RAK12017**: [Setting up RAK12017 IR Proximity Sensor Dashboard Using ThingSpeak](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#setting-up-rak12017-ir-proximity-sensor-dashboard-using-thingspeak)"}
{"id": "bfe00af24dab41b758c79a818bf2b288", "product_family": "wisblock", "product_id": "kit3-movement-detection", "category": "How-To", "title": "WisBlock Movement Detection Kit Quick Start Guide > WisBlock IoT Education Kit - Movement Detection Quick Start Guide > Product Configuration > Software Configuration and Examples > RAK12006 PIR Motion Sensor LoRaWAN Application > LoRaWAN Code for RAK12006 > Programming RAK12006 Module with LoRaWAN Application Code [CODE]", "content": "```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change it to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/", "keywords": ["Arduino IDE", "RAK4631", "RAK12006", "LoRaWAN", "programming"], "source_file": "quickstart.md", "token_count": 150, "parent_content": "1. If you already have **Arduino IDE** installed on your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you have not yet installed the **Arduino IDE**, go to the [RAK4631 Installation](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#arduino-ide-installation-rak4631) section and execute the following steps.  \n2. After the installation, you can now proceed with programming your **RAK12006** module. Simply copy the **RAK12006 LoRaWAN Application** code below and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n```c\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h> //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n// Section to add include libraries, declarations and variables.\n\n#define SENSOR_PIN  WB_IO6   // Attach AM312 sensor to Arduino Digital Pin WB_IO6\n\nint gCurrentStatus = 0;         // variable for reading the pin current status\n\nint sensor_val;\n\nbool doOTAA = true;   // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                     /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                   /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5             /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                      /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                      /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = {LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF};\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = {BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler\n};\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x3F, 0xC4, 0x80, 0x0D, 0x4A, 0xE7, 0xAD, 0x9F, 0xDC, 0x27, 0x5D, 0x37, 0x2C, 0x4C, 0xD3, 0xF8};\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = {0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23};\nuint8_t nodeAppsKey[16] = {0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C};\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                     /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];            //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = {m_lora_app_data_buffer, 0, 0, 0, 0}; //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup()\n{\npinMode(SENSOR_PIN, INPUT);        // PIR Sensor as an INPUT\npinMode(LED_GREEN, OUTPUT);\npinMode(LED_BLUE, OUTPUT);\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial)\n{\nif ((millis() - timeout) < 5000)\n{\ndelay(100);\n}\nelse\n{\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA)\n{\nSerial.println(\"Type: OTAA\");\n}\nelse\n{\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion)\n{\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA)\n{\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n}\nelse\n{\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0)\n{\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"========================\");\nSerial.println(\"    RAK12006 LoRaWAN test\");\nSerial.println(\"========================\");\n\n}\n\n// Default void loop\n\nvoid loop()\n{\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\ngCurrentStatus = digitalRead(SENSOR_PIN);\n\nif (gCurrentStatus == 0)\n// \"0\" for Detected; \"1\" for Undetected\n{\ndigitalWrite(LED_GREEN, HIGH); // Turn ON LED\ndigitalWrite(LED_BLUE, HIGH);\nsensor_val = 1;\nsend_lora_frame();\ndelay(2000);\n}\n\nelse if (gCurrentStatus == 1)\n{\n// do nothing\ndigitalWrite(LED_GREEN, LOW); // Turn OFF LED\ndigitalWrite(LED_BLUE, LOW);\nsensor_val = 0;\nsend_lora_frame();\ndelay(2000);\n}\n\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void)\n{\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void)\n{\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data)\n{\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class)\n{\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\n// void send_lora_frame for RAK12006 Application\nvoid send_lora_frame(void)\n{\nif (lmh_join_status_get() != LMH_SET)\n{\n//Not joined, try again later\nreturn;\n}\n\n//int sensor_val;\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\nm_lora_app_data.buffer[i++] = sensor_val;\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS)\n{\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n}\nelse\n{\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The following steps will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired regions to work with. You can change this to a region that is applicable to you, like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc.  \nThe following table lists the LoRaWAN regions and the countries where they are used:  \n| LoRaWAN Region         | Usage                                                             |\n| ---------------------- | ----------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1 | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan          |\n| LORAMAC_REGION_AS923-2 | Vietnam                                                           |\n| LORAMAC_REGION_AS923-3 | Philippines, Albania, Algeria, Denmark, Greenland, Jordan         |\n| LORAMAC_REGION_AS923-4 | Israel                                                            |\n| LORAMAC_REGION_AU915   | Australia, Anguilla, Argentina, and other parts of South America  |\n| LORAMAC_REGION_CN470   | China                                                             |\n| LORAMAC_REGION_EU433   | EU, UK, Brazil, Costa Rica, Cuba, and other parts of Africa       |\n| LORAMAC_REGION_IN865   | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger |\n| LORAMAC_REGION_EU868   | EU, UK and other parts of Africa                                  |\n| LORAMAC_REGION_KR920   | Republic of Korea                                                 |\n| LORAMAC_REGION_US915   | USA                                                               |\n| LORAMAC_REGION_RU864   | Russia                                                            |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n\n```  \n- Set up the LoRaWAN activation method. In this case, you will use the **OTAA** configuration, which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change it to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n\n```  \n- Set up the EUIs and KEY. The **DeviceEUI**, **AppEUI**, and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x3F, 0xC4, 0x80, 0x0D, 0x4A, 0xE7, 0xAD, 0x9F, 0xDC, 0x27, 0x5D, 0x37, 0x2C, 0x4C, 0xD3, 0xF8};\n\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once you're done with the code, you can now proceed with uploading it to your device. You must first choose your RAK4631 board on your desktop or laptop. To do so, navigate to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** and select **WisBlock RAK4631**.  \n> **Image:** Selecting the RAK4631 board  \n4. After you have selected your board, go to **Tools** > **Port** and then select the specific port of your board.  \n> **Image:** Selecting the port of RAK4631 board  \n5. You can then upload your code by clicking the Upload button (the right arrow sign). Once completed, the **Device programmed** notification will appear in the console at the bottom of the Arduino IDE.  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board  \n> **TIP:** NOTE  \nThe steps outlined above apply to the **RAK12013** and **RAK12017** applications. Once you have finished uploading the code, proceed to the next step:  \n- **RAK12013**: [Setting up RAK12013 Radar Sensor Dashboard Using ThingSpeak](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#setting-up-rak12013-radar-sensor-dashboard-using-thingspeak)\n- **RAK12017**: [Setting up RAK12017 IR Proximity Sensor Dashboard Using ThingSpeak](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#setting-up-rak12017-ir-proximity-sensor-dashboard-using-thingspeak)"}
{"id": "1293735352a6e0cb748f04954ef69b50", "product_family": "wisblock", "product_id": "kit3-movement-detection", "category": "How-To", "title": "WisBlock Movement Detection Kit Quick Start Guide > WisBlock IoT Education Kit - Movement Detection Quick Start Guide > Product Configuration > Software Configuration and Examples > RAK12006 PIR Motion Sensor LoRaWAN Application > LoRaWAN Code for RAK12006 > Programming RAK12006 Module with LoRaWAN Application Code [CODE]", "content": "```  \n- Set up the EUIs and KEY. The **DeviceEUI**, **AppEUI**, and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};", "keywords": ["Arduino IDE", "RAK4631", "RAK12006", "LoRaWAN", "programming"], "source_file": "quickstart.md", "token_count": 150, "parent_content": "1. If you already have **Arduino IDE** installed on your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you have not yet installed the **Arduino IDE**, go to the [RAK4631 Installation](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#arduino-ide-installation-rak4631) section and execute the following steps.  \n2. After the installation, you can now proceed with programming your **RAK12006** module. Simply copy the **RAK12006 LoRaWAN Application** code below and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n```c\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h> //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n// Section to add include libraries, declarations and variables.\n\n#define SENSOR_PIN  WB_IO6   // Attach AM312 sensor to Arduino Digital Pin WB_IO6\n\nint gCurrentStatus = 0;         // variable for reading the pin current status\n\nint sensor_val;\n\nbool doOTAA = true;   // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                     /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                   /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5             /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                      /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                      /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = {LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF};\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = {BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler\n};\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x3F, 0xC4, 0x80, 0x0D, 0x4A, 0xE7, 0xAD, 0x9F, 0xDC, 0x27, 0x5D, 0x37, 0x2C, 0x4C, 0xD3, 0xF8};\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = {0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23};\nuint8_t nodeAppsKey[16] = {0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C};\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                     /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];            //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = {m_lora_app_data_buffer, 0, 0, 0, 0}; //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup()\n{\npinMode(SENSOR_PIN, INPUT);        // PIR Sensor as an INPUT\npinMode(LED_GREEN, OUTPUT);\npinMode(LED_BLUE, OUTPUT);\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial)\n{\nif ((millis() - timeout) < 5000)\n{\ndelay(100);\n}\nelse\n{\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA)\n{\nSerial.println(\"Type: OTAA\");\n}\nelse\n{\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion)\n{\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA)\n{\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n}\nelse\n{\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0)\n{\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"========================\");\nSerial.println(\"    RAK12006 LoRaWAN test\");\nSerial.println(\"========================\");\n\n}\n\n// Default void loop\n\nvoid loop()\n{\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\ngCurrentStatus = digitalRead(SENSOR_PIN);\n\nif (gCurrentStatus == 0)\n// \"0\" for Detected; \"1\" for Undetected\n{\ndigitalWrite(LED_GREEN, HIGH); // Turn ON LED\ndigitalWrite(LED_BLUE, HIGH);\nsensor_val = 1;\nsend_lora_frame();\ndelay(2000);\n}\n\nelse if (gCurrentStatus == 1)\n{\n// do nothing\ndigitalWrite(LED_GREEN, LOW); // Turn OFF LED\ndigitalWrite(LED_BLUE, LOW);\nsensor_val = 0;\nsend_lora_frame();\ndelay(2000);\n}\n\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void)\n{\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void)\n{\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data)\n{\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class)\n{\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\n// void send_lora_frame for RAK12006 Application\nvoid send_lora_frame(void)\n{\nif (lmh_join_status_get() != LMH_SET)\n{\n//Not joined, try again later\nreturn;\n}\n\n//int sensor_val;\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\nm_lora_app_data.buffer[i++] = sensor_val;\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS)\n{\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n}\nelse\n{\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The following steps will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired regions to work with. You can change this to a region that is applicable to you, like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc.  \nThe following table lists the LoRaWAN regions and the countries where they are used:  \n| LoRaWAN Region         | Usage                                                             |\n| ---------------------- | ----------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1 | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan          |\n| LORAMAC_REGION_AS923-2 | Vietnam                                                           |\n| LORAMAC_REGION_AS923-3 | Philippines, Albania, Algeria, Denmark, Greenland, Jordan         |\n| LORAMAC_REGION_AS923-4 | Israel                                                            |\n| LORAMAC_REGION_AU915   | Australia, Anguilla, Argentina, and other parts of South America  |\n| LORAMAC_REGION_CN470   | China                                                             |\n| LORAMAC_REGION_EU433   | EU, UK, Brazil, Costa Rica, Cuba, and other parts of Africa       |\n| LORAMAC_REGION_IN865   | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger |\n| LORAMAC_REGION_EU868   | EU, UK and other parts of Africa                                  |\n| LORAMAC_REGION_KR920   | Republic of Korea                                                 |\n| LORAMAC_REGION_US915   | USA                                                               |\n| LORAMAC_REGION_RU864   | Russia                                                            |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n\n```  \n- Set up the LoRaWAN activation method. In this case, you will use the **OTAA** configuration, which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change it to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n\n```  \n- Set up the EUIs and KEY. The **DeviceEUI**, **AppEUI**, and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x3F, 0xC4, 0x80, 0x0D, 0x4A, 0xE7, 0xAD, 0x9F, 0xDC, 0x27, 0x5D, 0x37, 0x2C, 0x4C, 0xD3, 0xF8};\n\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once you're done with the code, you can now proceed with uploading it to your device. You must first choose your RAK4631 board on your desktop or laptop. To do so, navigate to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** and select **WisBlock RAK4631**.  \n> **Image:** Selecting the RAK4631 board  \n4. After you have selected your board, go to **Tools** > **Port** and then select the specific port of your board.  \n> **Image:** Selecting the port of RAK4631 board  \n5. You can then upload your code by clicking the Upload button (the right arrow sign). Once completed, the **Device programmed** notification will appear in the console at the bottom of the Arduino IDE.  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board  \n> **TIP:** NOTE  \nThe steps outlined above apply to the **RAK12013** and **RAK12017** applications. Once you have finished uploading the code, proceed to the next step:  \n- **RAK12013**: [Setting up RAK12013 Radar Sensor Dashboard Using ThingSpeak](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#setting-up-rak12013-radar-sensor-dashboard-using-thingspeak)\n- **RAK12017**: [Setting up RAK12017 IR Proximity Sensor Dashboard Using ThingSpeak](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#setting-up-rak12017-ir-proximity-sensor-dashboard-using-thingspeak)"}
{"id": "22c5ae4ea8b43a3392081cad3c288689", "product_family": "wisblock", "product_id": "kit3-movement-detection", "category": "How-To", "title": "WisBlock Movement Detection Kit Quick Start Guide > WisBlock IoT Education Kit - Movement Detection Quick Start Guide > Product Configuration > Software Configuration and Examples > RAK12006 PIR Motion Sensor LoRaWAN Application > LoRaWAN Code for RAK12006 > Programming RAK12006 Module with LoRaWAN Application Code [CODE]", "content": "uint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x3F, 0xC4, 0x80, 0x0D, 0x4A, 0xE7, 0xAD, 0x9F, 0xDC, 0x27, 0x5D, 0x37, 0x2C, 0x4C, 0xD3, 0xF8};", "keywords": ["Arduino IDE", "RAK4631", "RAK12006", "LoRaWAN", "programming"], "source_file": "quickstart.md", "token_count": 150, "parent_content": "1. If you already have **Arduino IDE** installed on your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you have not yet installed the **Arduino IDE**, go to the [RAK4631 Installation](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#arduino-ide-installation-rak4631) section and execute the following steps.  \n2. After the installation, you can now proceed with programming your **RAK12006** module. Simply copy the **RAK12006 LoRaWAN Application** code below and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n```c\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h> //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n// Section to add include libraries, declarations and variables.\n\n#define SENSOR_PIN  WB_IO6   // Attach AM312 sensor to Arduino Digital Pin WB_IO6\n\nint gCurrentStatus = 0;         // variable for reading the pin current status\n\nint sensor_val;\n\nbool doOTAA = true;   // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                     /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                   /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5             /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                      /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                      /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = {LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF};\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = {BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler\n};\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x3F, 0xC4, 0x80, 0x0D, 0x4A, 0xE7, 0xAD, 0x9F, 0xDC, 0x27, 0x5D, 0x37, 0x2C, 0x4C, 0xD3, 0xF8};\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = {0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23};\nuint8_t nodeAppsKey[16] = {0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C};\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                     /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];            //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = {m_lora_app_data_buffer, 0, 0, 0, 0}; //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup()\n{\npinMode(SENSOR_PIN, INPUT);        // PIR Sensor as an INPUT\npinMode(LED_GREEN, OUTPUT);\npinMode(LED_BLUE, OUTPUT);\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial)\n{\nif ((millis() - timeout) < 5000)\n{\ndelay(100);\n}\nelse\n{\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA)\n{\nSerial.println(\"Type: OTAA\");\n}\nelse\n{\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion)\n{\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA)\n{\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n}\nelse\n{\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0)\n{\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"========================\");\nSerial.println(\"    RAK12006 LoRaWAN test\");\nSerial.println(\"========================\");\n\n}\n\n// Default void loop\n\nvoid loop()\n{\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\ngCurrentStatus = digitalRead(SENSOR_PIN);\n\nif (gCurrentStatus == 0)\n// \"0\" for Detected; \"1\" for Undetected\n{\ndigitalWrite(LED_GREEN, HIGH); // Turn ON LED\ndigitalWrite(LED_BLUE, HIGH);\nsensor_val = 1;\nsend_lora_frame();\ndelay(2000);\n}\n\nelse if (gCurrentStatus == 1)\n{\n// do nothing\ndigitalWrite(LED_GREEN, LOW); // Turn OFF LED\ndigitalWrite(LED_BLUE, LOW);\nsensor_val = 0;\nsend_lora_frame();\ndelay(2000);\n}\n\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void)\n{\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void)\n{\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data)\n{\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class)\n{\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\n// void send_lora_frame for RAK12006 Application\nvoid send_lora_frame(void)\n{\nif (lmh_join_status_get() != LMH_SET)\n{\n//Not joined, try again later\nreturn;\n}\n\n//int sensor_val;\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\nm_lora_app_data.buffer[i++] = sensor_val;\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS)\n{\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n}\nelse\n{\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The following steps will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired regions to work with. You can change this to a region that is applicable to you, like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc.  \nThe following table lists the LoRaWAN regions and the countries where they are used:  \n| LoRaWAN Region         | Usage                                                             |\n| ---------------------- | ----------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1 | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan          |\n| LORAMAC_REGION_AS923-2 | Vietnam                                                           |\n| LORAMAC_REGION_AS923-3 | Philippines, Albania, Algeria, Denmark, Greenland, Jordan         |\n| LORAMAC_REGION_AS923-4 | Israel                                                            |\n| LORAMAC_REGION_AU915   | Australia, Anguilla, Argentina, and other parts of South America  |\n| LORAMAC_REGION_CN470   | China                                                             |\n| LORAMAC_REGION_EU433   | EU, UK, Brazil, Costa Rica, Cuba, and other parts of Africa       |\n| LORAMAC_REGION_IN865   | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger |\n| LORAMAC_REGION_EU868   | EU, UK and other parts of Africa                                  |\n| LORAMAC_REGION_KR920   | Republic of Korea                                                 |\n| LORAMAC_REGION_US915   | USA                                                               |\n| LORAMAC_REGION_RU864   | Russia                                                            |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n\n```  \n- Set up the LoRaWAN activation method. In this case, you will use the **OTAA** configuration, which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change it to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n\n```  \n- Set up the EUIs and KEY. The **DeviceEUI**, **AppEUI**, and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x3F, 0xC4, 0x80, 0x0D, 0x4A, 0xE7, 0xAD, 0x9F, 0xDC, 0x27, 0x5D, 0x37, 0x2C, 0x4C, 0xD3, 0xF8};\n\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once you're done with the code, you can now proceed with uploading it to your device. You must first choose your RAK4631 board on your desktop or laptop. To do so, navigate to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** and select **WisBlock RAK4631**.  \n> **Image:** Selecting the RAK4631 board  \n4. After you have selected your board, go to **Tools** > **Port** and then select the specific port of your board.  \n> **Image:** Selecting the port of RAK4631 board  \n5. You can then upload your code by clicking the Upload button (the right arrow sign). Once completed, the **Device programmed** notification will appear in the console at the bottom of the Arduino IDE.  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board  \n> **TIP:** NOTE  \nThe steps outlined above apply to the **RAK12013** and **RAK12017** applications. Once you have finished uploading the code, proceed to the next step:  \n- **RAK12013**: [Setting up RAK12013 Radar Sensor Dashboard Using ThingSpeak](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#setting-up-rak12013-radar-sensor-dashboard-using-thingspeak)\n- **RAK12017**: [Setting up RAK12017 IR Proximity Sensor Dashboard Using ThingSpeak](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#setting-up-rak12017-ir-proximity-sensor-dashboard-using-thingspeak)"}
{"id": "1cf68bdb05db932aace4ac2d07962407", "product_family": "wisblock", "product_id": "kit3-movement-detection", "category": "How-To", "title": "WisBlock Movement Detection Kit Quick Start Guide > WisBlock IoT Education Kit - Movement Detection Quick Start Guide > Product Configuration > Software Configuration and Examples > RAK12006 PIR Motion Sensor LoRaWAN Application > LoRaWAN Code for RAK12006 > Programming RAK12006 Module with LoRaWAN Application Code [CODE]", "content": "```  \n> **Image:** Device's credentials registered in TTN  \n3. Once you're done with the code, you can now proceed with uploading it to your device. You must first choose your RAK4631 board on your desktop or laptop. To do so, navigate to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** and select **WisBlock RAK4631**.  \n> **Image:** Selecting the RAK4631 board  \n4. After you have selected your board, go to **Tools** > **Port** and then select the specific port of your board.", "keywords": ["Arduino IDE", "RAK4631", "RAK12006", "LoRaWAN", "programming"], "source_file": "quickstart.md", "token_count": 150, "parent_content": "1. If you already have **Arduino IDE** installed on your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you have not yet installed the **Arduino IDE**, go to the [RAK4631 Installation](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#arduino-ide-installation-rak4631) section and execute the following steps.  \n2. After the installation, you can now proceed with programming your **RAK12006** module. Simply copy the **RAK12006 LoRaWAN Application** code below and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n```c\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h> //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n// Section to add include libraries, declarations and variables.\n\n#define SENSOR_PIN  WB_IO6   // Attach AM312 sensor to Arduino Digital Pin WB_IO6\n\nint gCurrentStatus = 0;         // variable for reading the pin current status\n\nint sensor_val;\n\nbool doOTAA = true;   // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                     /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                   /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5             /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                      /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                      /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = {LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF};\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = {BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler\n};\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x3F, 0xC4, 0x80, 0x0D, 0x4A, 0xE7, 0xAD, 0x9F, 0xDC, 0x27, 0x5D, 0x37, 0x2C, 0x4C, 0xD3, 0xF8};\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = {0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23};\nuint8_t nodeAppsKey[16] = {0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C};\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                     /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];            //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = {m_lora_app_data_buffer, 0, 0, 0, 0}; //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup()\n{\npinMode(SENSOR_PIN, INPUT);        // PIR Sensor as an INPUT\npinMode(LED_GREEN, OUTPUT);\npinMode(LED_BLUE, OUTPUT);\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial)\n{\nif ((millis() - timeout) < 5000)\n{\ndelay(100);\n}\nelse\n{\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA)\n{\nSerial.println(\"Type: OTAA\");\n}\nelse\n{\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion)\n{\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA)\n{\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n}\nelse\n{\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0)\n{\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"========================\");\nSerial.println(\"    RAK12006 LoRaWAN test\");\nSerial.println(\"========================\");\n\n}\n\n// Default void loop\n\nvoid loop()\n{\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\ngCurrentStatus = digitalRead(SENSOR_PIN);\n\nif (gCurrentStatus == 0)\n// \"0\" for Detected; \"1\" for Undetected\n{\ndigitalWrite(LED_GREEN, HIGH); // Turn ON LED\ndigitalWrite(LED_BLUE, HIGH);\nsensor_val = 1;\nsend_lora_frame();\ndelay(2000);\n}\n\nelse if (gCurrentStatus == 1)\n{\n// do nothing\ndigitalWrite(LED_GREEN, LOW); // Turn OFF LED\ndigitalWrite(LED_BLUE, LOW);\nsensor_val = 0;\nsend_lora_frame();\ndelay(2000);\n}\n\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void)\n{\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void)\n{\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data)\n{\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class)\n{\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\n// void send_lora_frame for RAK12006 Application\nvoid send_lora_frame(void)\n{\nif (lmh_join_status_get() != LMH_SET)\n{\n//Not joined, try again later\nreturn;\n}\n\n//int sensor_val;\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\nm_lora_app_data.buffer[i++] = sensor_val;\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS)\n{\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n}\nelse\n{\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The following steps will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired regions to work with. You can change this to a region that is applicable to you, like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc.  \nThe following table lists the LoRaWAN regions and the countries where they are used:  \n| LoRaWAN Region         | Usage                                                             |\n| ---------------------- | ----------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1 | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan          |\n| LORAMAC_REGION_AS923-2 | Vietnam                                                           |\n| LORAMAC_REGION_AS923-3 | Philippines, Albania, Algeria, Denmark, Greenland, Jordan         |\n| LORAMAC_REGION_AS923-4 | Israel                                                            |\n| LORAMAC_REGION_AU915   | Australia, Anguilla, Argentina, and other parts of South America  |\n| LORAMAC_REGION_CN470   | China                                                             |\n| LORAMAC_REGION_EU433   | EU, UK, Brazil, Costa Rica, Cuba, and other parts of Africa       |\n| LORAMAC_REGION_IN865   | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger |\n| LORAMAC_REGION_EU868   | EU, UK and other parts of Africa                                  |\n| LORAMAC_REGION_KR920   | Republic of Korea                                                 |\n| LORAMAC_REGION_US915   | USA                                                               |\n| LORAMAC_REGION_RU864   | Russia                                                            |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n\n```  \n- Set up the LoRaWAN activation method. In this case, you will use the **OTAA** configuration, which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change it to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n\n```  \n- Set up the EUIs and KEY. The **DeviceEUI**, **AppEUI**, and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x3F, 0xC4, 0x80, 0x0D, 0x4A, 0xE7, 0xAD, 0x9F, 0xDC, 0x27, 0x5D, 0x37, 0x2C, 0x4C, 0xD3, 0xF8};\n\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once you're done with the code, you can now proceed with uploading it to your device. You must first choose your RAK4631 board on your desktop or laptop. To do so, navigate to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** and select **WisBlock RAK4631**.  \n> **Image:** Selecting the RAK4631 board  \n4. After you have selected your board, go to **Tools** > **Port** and then select the specific port of your board.  \n> **Image:** Selecting the port of RAK4631 board  \n5. You can then upload your code by clicking the Upload button (the right arrow sign). Once completed, the **Device programmed** notification will appear in the console at the bottom of the Arduino IDE.  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board  \n> **TIP:** NOTE  \nThe steps outlined above apply to the **RAK12013** and **RAK12017** applications. Once you have finished uploading the code, proceed to the next step:  \n- **RAK12013**: [Setting up RAK12013 Radar Sensor Dashboard Using ThingSpeak](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#setting-up-rak12013-radar-sensor-dashboard-using-thingspeak)\n- **RAK12017**: [Setting up RAK12017 IR Proximity Sensor Dashboard Using ThingSpeak](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#setting-up-rak12017-ir-proximity-sensor-dashboard-using-thingspeak)"}
{"id": "f211dfb9be7ca49131f4a18c1294ad21", "product_family": "wisblock", "product_id": "kit3-movement-detection", "category": "How-To", "title": "WisBlock Movement Detection Kit Quick Start Guide > WisBlock IoT Education Kit - Movement Detection Quick Start Guide > Product Configuration > Software Configuration and Examples > RAK12006 PIR Motion Sensor LoRaWAN Application > LoRaWAN Code for RAK12006 > Programming RAK12006 Module with LoRaWAN Application Code [CODE]", "content": "> **Image:** Selecting the port of RAK4631 board  \n5. You can then upload your code by clicking the Upload button (the right arrow sign). Once completed, the **Device programmed** notification will appear in the console at the bottom of the Arduino IDE.  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board  \n> **TIP:** NOTE", "keywords": ["Arduino IDE", "RAK4631", "RAK12006", "LoRaWAN", "programming"], "source_file": "quickstart.md", "token_count": 150, "parent_content": "1. If you already have **Arduino IDE** installed on your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you have not yet installed the **Arduino IDE**, go to the [RAK4631 Installation](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#arduino-ide-installation-rak4631) section and execute the following steps.  \n2. After the installation, you can now proceed with programming your **RAK12006** module. Simply copy the **RAK12006 LoRaWAN Application** code below and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n```c\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h> //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n// Section to add include libraries, declarations and variables.\n\n#define SENSOR_PIN  WB_IO6   // Attach AM312 sensor to Arduino Digital Pin WB_IO6\n\nint gCurrentStatus = 0;         // variable for reading the pin current status\n\nint sensor_val;\n\nbool doOTAA = true;   // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                     /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                   /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5             /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                      /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                      /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = {LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF};\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = {BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler\n};\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x3F, 0xC4, 0x80, 0x0D, 0x4A, 0xE7, 0xAD, 0x9F, 0xDC, 0x27, 0x5D, 0x37, 0x2C, 0x4C, 0xD3, 0xF8};\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = {0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23};\nuint8_t nodeAppsKey[16] = {0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C};\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                     /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];            //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = {m_lora_app_data_buffer, 0, 0, 0, 0}; //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup()\n{\npinMode(SENSOR_PIN, INPUT);        // PIR Sensor as an INPUT\npinMode(LED_GREEN, OUTPUT);\npinMode(LED_BLUE, OUTPUT);\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial)\n{\nif ((millis() - timeout) < 5000)\n{\ndelay(100);\n}\nelse\n{\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA)\n{\nSerial.println(\"Type: OTAA\");\n}\nelse\n{\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion)\n{\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA)\n{\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n}\nelse\n{\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0)\n{\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"========================\");\nSerial.println(\"    RAK12006 LoRaWAN test\");\nSerial.println(\"========================\");\n\n}\n\n// Default void loop\n\nvoid loop()\n{\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\ngCurrentStatus = digitalRead(SENSOR_PIN);\n\nif (gCurrentStatus == 0)\n// \"0\" for Detected; \"1\" for Undetected\n{\ndigitalWrite(LED_GREEN, HIGH); // Turn ON LED\ndigitalWrite(LED_BLUE, HIGH);\nsensor_val = 1;\nsend_lora_frame();\ndelay(2000);\n}\n\nelse if (gCurrentStatus == 1)\n{\n// do nothing\ndigitalWrite(LED_GREEN, LOW); // Turn OFF LED\ndigitalWrite(LED_BLUE, LOW);\nsensor_val = 0;\nsend_lora_frame();\ndelay(2000);\n}\n\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void)\n{\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void)\n{\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data)\n{\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class)\n{\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\n// void send_lora_frame for RAK12006 Application\nvoid send_lora_frame(void)\n{\nif (lmh_join_status_get() != LMH_SET)\n{\n//Not joined, try again later\nreturn;\n}\n\n//int sensor_val;\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\nm_lora_app_data.buffer[i++] = sensor_val;\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS)\n{\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n}\nelse\n{\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The following steps will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired regions to work with. You can change this to a region that is applicable to you, like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc.  \nThe following table lists the LoRaWAN regions and the countries where they are used:  \n| LoRaWAN Region         | Usage                                                             |\n| ---------------------- | ----------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1 | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan          |\n| LORAMAC_REGION_AS923-2 | Vietnam                                                           |\n| LORAMAC_REGION_AS923-3 | Philippines, Albania, Algeria, Denmark, Greenland, Jordan         |\n| LORAMAC_REGION_AS923-4 | Israel                                                            |\n| LORAMAC_REGION_AU915   | Australia, Anguilla, Argentina, and other parts of South America  |\n| LORAMAC_REGION_CN470   | China                                                             |\n| LORAMAC_REGION_EU433   | EU, UK, Brazil, Costa Rica, Cuba, and other parts of Africa       |\n| LORAMAC_REGION_IN865   | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger |\n| LORAMAC_REGION_EU868   | EU, UK and other parts of Africa                                  |\n| LORAMAC_REGION_KR920   | Republic of Korea                                                 |\n| LORAMAC_REGION_US915   | USA                                                               |\n| LORAMAC_REGION_RU864   | Russia                                                            |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n\n```  \n- Set up the LoRaWAN activation method. In this case, you will use the **OTAA** configuration, which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change it to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n\n```  \n- Set up the EUIs and KEY. The **DeviceEUI**, **AppEUI**, and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x3F, 0xC4, 0x80, 0x0D, 0x4A, 0xE7, 0xAD, 0x9F, 0xDC, 0x27, 0x5D, 0x37, 0x2C, 0x4C, 0xD3, 0xF8};\n\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once you're done with the code, you can now proceed with uploading it to your device. You must first choose your RAK4631 board on your desktop or laptop. To do so, navigate to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** and select **WisBlock RAK4631**.  \n> **Image:** Selecting the RAK4631 board  \n4. After you have selected your board, go to **Tools** > **Port** and then select the specific port of your board.  \n> **Image:** Selecting the port of RAK4631 board  \n5. You can then upload your code by clicking the Upload button (the right arrow sign). Once completed, the **Device programmed** notification will appear in the console at the bottom of the Arduino IDE.  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board  \n> **TIP:** NOTE  \nThe steps outlined above apply to the **RAK12013** and **RAK12017** applications. Once you have finished uploading the code, proceed to the next step:  \n- **RAK12013**: [Setting up RAK12013 Radar Sensor Dashboard Using ThingSpeak](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#setting-up-rak12013-radar-sensor-dashboard-using-thingspeak)\n- **RAK12017**: [Setting up RAK12017 IR Proximity Sensor Dashboard Using ThingSpeak](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#setting-up-rak12017-ir-proximity-sensor-dashboard-using-thingspeak)"}
{"id": "c8a4e73b490dd9d4cb97db84e42f7433", "product_family": "wisblock", "product_id": "kit3-movement-detection", "category": "How-To", "title": "WisBlock Movement Detection Kit Quick Start Guide > WisBlock IoT Education Kit - Movement Detection Quick Start Guide > Product Configuration > Software Configuration and Examples > RAK12006 PIR Motion Sensor LoRaWAN Application > LoRaWAN Code for RAK12006 > Programming RAK12006 Module with LoRaWAN Application Code [CODE]", "content": "> **Image:** Arduino code is successfully uploaded into your RAK4631 board  \n> **TIP:** NOTE  \nThe steps outlined above apply to the **RAK12013** and **RAK12017** applications. Once you have finished uploading the code, proceed to the next step:  \n- **RAK12013**: [Setting up RAK12013 Radar Sensor Dashboard Using ThingSpeak](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#setting-up-rak12013-radar-sensor-dashboard-using-thingspeak)", "keywords": ["Arduino IDE", "RAK4631", "RAK12006", "LoRaWAN", "programming"], "source_file": "quickstart.md", "token_count": 150, "parent_content": "1. If you already have **Arduino IDE** installed on your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you have not yet installed the **Arduino IDE**, go to the [RAK4631 Installation](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#arduino-ide-installation-rak4631) section and execute the following steps.  \n2. After the installation, you can now proceed with programming your **RAK12006** module. Simply copy the **RAK12006 LoRaWAN Application** code below and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n```c\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h> //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n// Section to add include libraries, declarations and variables.\n\n#define SENSOR_PIN  WB_IO6   // Attach AM312 sensor to Arduino Digital Pin WB_IO6\n\nint gCurrentStatus = 0;         // variable for reading the pin current status\n\nint sensor_val;\n\nbool doOTAA = true;   // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                     /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                   /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5             /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                      /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                      /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = {LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF};\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = {BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler\n};\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x3F, 0xC4, 0x80, 0x0D, 0x4A, 0xE7, 0xAD, 0x9F, 0xDC, 0x27, 0x5D, 0x37, 0x2C, 0x4C, 0xD3, 0xF8};\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = {0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23};\nuint8_t nodeAppsKey[16] = {0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C};\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                     /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];            //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = {m_lora_app_data_buffer, 0, 0, 0, 0}; //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup()\n{\npinMode(SENSOR_PIN, INPUT);        // PIR Sensor as an INPUT\npinMode(LED_GREEN, OUTPUT);\npinMode(LED_BLUE, OUTPUT);\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial)\n{\nif ((millis() - timeout) < 5000)\n{\ndelay(100);\n}\nelse\n{\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA)\n{\nSerial.println(\"Type: OTAA\");\n}\nelse\n{\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion)\n{\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA)\n{\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n}\nelse\n{\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0)\n{\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"========================\");\nSerial.println(\"    RAK12006 LoRaWAN test\");\nSerial.println(\"========================\");\n\n}\n\n// Default void loop\n\nvoid loop()\n{\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\ngCurrentStatus = digitalRead(SENSOR_PIN);\n\nif (gCurrentStatus == 0)\n// \"0\" for Detected; \"1\" for Undetected\n{\ndigitalWrite(LED_GREEN, HIGH); // Turn ON LED\ndigitalWrite(LED_BLUE, HIGH);\nsensor_val = 1;\nsend_lora_frame();\ndelay(2000);\n}\n\nelse if (gCurrentStatus == 1)\n{\n// do nothing\ndigitalWrite(LED_GREEN, LOW); // Turn OFF LED\ndigitalWrite(LED_BLUE, LOW);\nsensor_val = 0;\nsend_lora_frame();\ndelay(2000);\n}\n\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void)\n{\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void)\n{\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data)\n{\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class)\n{\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\n// void send_lora_frame for RAK12006 Application\nvoid send_lora_frame(void)\n{\nif (lmh_join_status_get() != LMH_SET)\n{\n//Not joined, try again later\nreturn;\n}\n\n//int sensor_val;\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\nm_lora_app_data.buffer[i++] = sensor_val;\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS)\n{\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n}\nelse\n{\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The following steps will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired regions to work with. You can change this to a region that is applicable to you, like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc.  \nThe following table lists the LoRaWAN regions and the countries where they are used:  \n| LoRaWAN Region         | Usage                                                             |\n| ---------------------- | ----------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1 | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan          |\n| LORAMAC_REGION_AS923-2 | Vietnam                                                           |\n| LORAMAC_REGION_AS923-3 | Philippines, Albania, Algeria, Denmark, Greenland, Jordan         |\n| LORAMAC_REGION_AS923-4 | Israel                                                            |\n| LORAMAC_REGION_AU915   | Australia, Anguilla, Argentina, and other parts of South America  |\n| LORAMAC_REGION_CN470   | China                                                             |\n| LORAMAC_REGION_EU433   | EU, UK, Brazil, Costa Rica, Cuba, and other parts of Africa       |\n| LORAMAC_REGION_IN865   | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger |\n| LORAMAC_REGION_EU868   | EU, UK and other parts of Africa                                  |\n| LORAMAC_REGION_KR920   | Republic of Korea                                                 |\n| LORAMAC_REGION_US915   | USA                                                               |\n| LORAMAC_REGION_RU864   | Russia                                                            |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n\n```  \n- Set up the LoRaWAN activation method. In this case, you will use the **OTAA** configuration, which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change it to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n\n```  \n- Set up the EUIs and KEY. The **DeviceEUI**, **AppEUI**, and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x3F, 0xC4, 0x80, 0x0D, 0x4A, 0xE7, 0xAD, 0x9F, 0xDC, 0x27, 0x5D, 0x37, 0x2C, 0x4C, 0xD3, 0xF8};\n\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once you're done with the code, you can now proceed with uploading it to your device. You must first choose your RAK4631 board on your desktop or laptop. To do so, navigate to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** and select **WisBlock RAK4631**.  \n> **Image:** Selecting the RAK4631 board  \n4. After you have selected your board, go to **Tools** > **Port** and then select the specific port of your board.  \n> **Image:** Selecting the port of RAK4631 board  \n5. You can then upload your code by clicking the Upload button (the right arrow sign). Once completed, the **Device programmed** notification will appear in the console at the bottom of the Arduino IDE.  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board  \n> **TIP:** NOTE  \nThe steps outlined above apply to the **RAK12013** and **RAK12017** applications. Once you have finished uploading the code, proceed to the next step:  \n- **RAK12013**: [Setting up RAK12013 Radar Sensor Dashboard Using ThingSpeak](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#setting-up-rak12013-radar-sensor-dashboard-using-thingspeak)\n- **RAK12017**: [Setting up RAK12017 IR Proximity Sensor Dashboard Using ThingSpeak](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#setting-up-rak12017-ir-proximity-sensor-dashboard-using-thingspeak)"}
{"id": "b5aa6775546ae79461164fc633a7cede", "product_family": "wisblock", "product_id": "kit3-movement-detection", "category": "How-To", "title": "WisBlock Movement Detection Kit Quick Start Guide > WisBlock IoT Education Kit - Movement Detection Quick Start Guide > Product Configuration > Software Configuration and Examples > RAK12006 PIR Motion Sensor LoRaWAN Application > LoRaWAN Code for RAK12006 > Programming RAK12006 Module with LoRaWAN Application Code [CODE]", "content": "- **RAK12017**: [Setting up RAK12017 IR Proximity Sensor Dashboard Using ThingSpeak](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#setting-up-rak12017-ir-proximity-sensor-dashboard-using-thingspeak)", "keywords": ["Arduino IDE", "RAK4631", "RAK12006", "LoRaWAN", "programming"], "source_file": "quickstart.md", "token_count": 150, "parent_content": "1. If you already have **Arduino IDE** installed on your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you have not yet installed the **Arduino IDE**, go to the [RAK4631 Installation](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#arduino-ide-installation-rak4631) section and execute the following steps.  \n2. After the installation, you can now proceed with programming your **RAK12006** module. Simply copy the **RAK12006 LoRaWAN Application** code below and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE  \nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n```c\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h> //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n// Section to add include libraries, declarations and variables.\n\n#define SENSOR_PIN  WB_IO6   // Attach AM312 sensor to Arduino Digital Pin WB_IO6\n\nint gCurrentStatus = 0;         // variable for reading the pin current status\n\nint sensor_val;\n\nbool doOTAA = true;   // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                     /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                   /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5             /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                      /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:EU868*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                      /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = {LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF};\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = {BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler\n};\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x3F, 0xC4, 0x80, 0x0D, 0x4A, 0xE7, 0xAD, 0x9F, 0xDC, 0x27, 0x5D, 0x37, 0x2C, 0x4C, 0xD3, 0xF8};\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = {0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23};\nuint8_t nodeAppsKey[16] = {0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C};\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                     /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];            //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = {m_lora_app_data_buffer, 0, 0, 0, 0}; //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup()\n{\npinMode(SENSOR_PIN, INPUT);        // PIR Sensor as an INPUT\npinMode(LED_GREEN, OUTPUT);\npinMode(LED_BLUE, OUTPUT);\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial)\n{\nif ((millis() - timeout) < 5000)\n{\ndelay(100);\n}\nelse\n{\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA)\n{\nSerial.println(\"Type: OTAA\");\n}\nelse\n{\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion)\n{\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA)\n{\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n}\nelse\n{\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0)\n{\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"========================\");\nSerial.println(\"    RAK12006 LoRaWAN test\");\nSerial.println(\"========================\");\n\n}\n\n// Default void loop\n\nvoid loop()\n{\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\ngCurrentStatus = digitalRead(SENSOR_PIN);\n\nif (gCurrentStatus == 0)\n// \"0\" for Detected; \"1\" for Undetected\n{\ndigitalWrite(LED_GREEN, HIGH); // Turn ON LED\ndigitalWrite(LED_BLUE, HIGH);\nsensor_val = 1;\nsend_lora_frame();\ndelay(2000);\n}\n\nelse if (gCurrentStatus == 1)\n{\n// do nothing\ndigitalWrite(LED_GREEN, LOW); // Turn OFF LED\ndigitalWrite(LED_BLUE, LOW);\nsensor_val = 0;\nsend_lora_frame();\ndelay(2000);\n}\n\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void)\n{\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void)\n{\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data)\n{\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class)\n{\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\n// void send_lora_frame for RAK12006 Application\nvoid send_lora_frame(void)\n{\nif (lmh_join_status_get() != LMH_SET)\n{\n//Not joined, try again later\nreturn;\n}\n\n//int sensor_val;\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\nm_lora_app_data.buffer[i++] = sensor_val;\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS)\n{\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n}\nelse\n{\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The following steps will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired regions to work with. You can change this to a region that is applicable to you, like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc.  \nThe following table lists the LoRaWAN regions and the countries where they are used:  \n| LoRaWAN Region         | Usage                                                             |\n| ---------------------- | ----------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1 | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan          |\n| LORAMAC_REGION_AS923-2 | Vietnam                                                           |\n| LORAMAC_REGION_AS923-3 | Philippines, Albania, Algeria, Denmark, Greenland, Jordan         |\n| LORAMAC_REGION_AS923-4 | Israel                                                            |\n| LORAMAC_REGION_AU915   | Australia, Anguilla, Argentina, and other parts of South America  |\n| LORAMAC_REGION_CN470   | China                                                             |\n| LORAMAC_REGION_EU433   | EU, UK, Brazil, Costa Rica, Cuba, and other parts of Africa       |\n| LORAMAC_REGION_IN865   | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger |\n| LORAMAC_REGION_EU868   | EU, UK and other parts of Africa                                  |\n| LORAMAC_REGION_KR920   | Republic of Korea                                                 |\n| LORAMAC_REGION_US915   | USA                                                               |\n| LORAMAC_REGION_RU864   | Russia                                                            |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n\n```  \n- Set up the LoRaWAN activation method. In this case, you will use the **OTAA** configuration, which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change it to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n\n```  \n- Set up the EUIs and KEY. The **DeviceEUI**, **AppEUI**, and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x3F, 0xC4, 0x80, 0x0D, 0x4A, 0xE7, 0xAD, 0x9F, 0xDC, 0x27, 0x5D, 0x37, 0x2C, 0x4C, 0xD3, 0xF8};\n\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once you're done with the code, you can now proceed with uploading it to your device. You must first choose your RAK4631 board on your desktop or laptop. To do so, navigate to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** and select **WisBlock RAK4631**.  \n> **Image:** Selecting the RAK4631 board  \n4. After you have selected your board, go to **Tools** > **Port** and then select the specific port of your board.  \n> **Image:** Selecting the port of RAK4631 board  \n5. You can then upload your code by clicking the Upload button (the right arrow sign). Once completed, the **Device programmed** notification will appear in the console at the bottom of the Arduino IDE.  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board  \n> **TIP:** NOTE  \nThe steps outlined above apply to the **RAK12013** and **RAK12017** applications. Once you have finished uploading the code, proceed to the next step:  \n- **RAK12013**: [Setting up RAK12013 Radar Sensor Dashboard Using ThingSpeak](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#setting-up-rak12013-radar-sensor-dashboard-using-thingspeak)\n- **RAK12017**: [Setting up RAK12017 IR Proximity Sensor Dashboard Using ThingSpeak](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#setting-up-rak12017-ir-proximity-sensor-dashboard-using-thingspeak)"}
{"id": "e69abc4c95bd307e9f8ca75c3e48dc9c", "product_family": "wisblock", "product_id": "kit3-movement-detection", "category": "How-To", "title": "WisBlock Movement Detection Kit Quick Start Guide > WisBlock IoT Education Kit - Movement Detection Quick Start Guide > Product Configuration > Software Configuration and Examples > RAK12007 Ultrasonic Sensor LoRaWAN Application > Connect to The Things Network (TTN) > TTN Account Setup and OTAA Device Registration", "content": "- If you already have an existing TTN account, you may proceed to the [OTAA Device Registration](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#otaa-device-registration) section.\n- If you do not already have an account, go to the [The Things Network Configuration](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#the-things-network-configuration) section and create one, then register your end-device.", "keywords": ["TTN", "OTAA", "device registration", "account setup"], "source_file": "quickstart.md", "token_count": 50, "parent_content": "- If you already have an existing TTN account, you may proceed to the [OTAA Device Registration](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#otaa-device-registration) section.\n- If you do not already have an account, go to the [The Things Network Configuration](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#the-things-network-configuration) section and create one, then register your end-device."}
{"id": "be9d09fa2715ba58594738d874023075", "product_family": "wisblock", "product_id": "kit3-movement-detection", "category": "How-To", "title": "WisBlock Movement Detection Kit Quick Start Guide > WisBlock IoT Education Kit - Movement Detection Quick Start Guide > Product Configuration > Software Configuration and Examples > RAK12007 Ultrasonic Sensor LoRaWAN Application > LoRaWAN Code for RAK12007 > Programming RAK12007 Module with Arduino IDE [CODE]", "content": "1. If you already have **Arduino IDE** installed on your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you have not yet installed the **Arduino IDE**, go to the [RAK4631 Installation](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#arduino-ide-installation-rak4631) section and execute the following steps.", "keywords": ["Arduino IDE", "RAK4631", "RAK12007", "LoRaWAN", "programming"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed on your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you have not yet installed the **Arduino IDE**, go to the [RAK4631 Installation](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#arduino-ide-installation-rak4631) section and execute the following steps.  \n2. After the installation, you can now proceed with programming your **RAK12007** module. Simply copy the **RAK12007 LoRaWAN Application** code below and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE\nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n```c\n\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h> //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define  RAK4631_BOARD true\n#else\n#define  RAK4631_BOARD false\n#endif\n\n// Section to add include libraries, declarations and variables.\n\n#define Enable WB_IO2\n#define TRIG WB_IO6\n#define ECHO WB_IO4\n#define PD   WB_IO5   //power done control \uff08=1 power done\uff0c=0 power on\uff09\n\n#define TIME_OUT  24125 //max measure distance is 4m,the velocity of sound is 331.6m/s in 0\u2103,TIME_OUT=4*2/331.6*1000000=24215us\n\nfloat ratio = 346.6/1000/2;   //velocity of sound =331.6+0.6*25\u2103(m/s),(Indoor temperature about 25\u2103)\n\nlong int duration_time();  //measure high level time\n\nlong int duration, mm;\n\nbool doOTAA = true;   // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                     /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                   /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5             /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                      /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                      /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = {LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF};\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = {BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler\n};\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x8B, 0x0E, 0x96, 0x86, 0xE8, 0x4E, 0xA3, 0xB5, 0x31, 0x42, 0xB3, 0x65, 0x75, 0xB1, 0xD3, 0xED};\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = {0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23};\nuint8_t nodeAppsKey[16] = {0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C};\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                     /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];            //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = {m_lora_app_data_buffer, 0, 0, 0, 0}; //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup()\n{\npinMode(Enable, OUTPUT);\ndigitalWrite(Enable, HIGH);\npinMode(ECHO, INPUT);   // Echo Pin of Ultrasonic Sensor is an Input\npinMode(TRIG, OUTPUT);  // Trigger Pin of Ultrasonic Sensor is an Output\npinMode(PD, OUTPUT);    // power done control pin is an Output\ndigitalWrite(TRIG,LOW);\ndigitalWrite(PD,LOW);\n\npinMode(LED_GREEN, OUTPUT);  // Output LED\npinMode(LED_BLUE, OUTPUT);   // Output LED\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial)\n{\nif ((millis() - timeout) < 5000)\n{\ndelay(100);\n}\nelse\n{\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA)\n{\nSerial.println(\"Type: OTAA\");\n}\nelse\n{\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion)\n{\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA)\n{\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n}\nelse\n{\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0)\n{\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"========================\");\nSerial.println(\"  RAK12007 LoRaWAN test \");\nSerial.println(\"========================\");\n\n}\n\nvoid loop()\n{\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\n// long int duration, mm;\ndigitalWrite(LED_BLUE,HIGH);\ndigitalWrite(LED_GREEN, HIGH);\nduration = duration_time();\nif(duration > 0)\n{\nmm = duration*ratio; //Test distance = (high level time\u00d7velocity of sound (340M/S) / 2,\ndigitalWrite(LED_BLUE,LOW);\ndigitalWrite(LED_GREEN, LOW);\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\nSerial.print(mm);\nSerial.print(\"mm\");\nSerial.println();\ndelay(15000);\n}\nelse\n{\nSerial.println(\"Out of range\");\n}\ndelay(50);\n\n}\n\nlong int duration_time()\n{\nlong int respondTime;\npinMode(TRIG, OUTPUT);\ndigitalWrite(TRIG, HIGH);\ndelayMicroseconds(12);   //pull high time need over 10us\ndigitalWrite(TRIG, LOW);\npinMode(ECHO, INPUT);\nrespondTime = pulseIn(ECHO, HIGH); // microseconds\ndelay(33);\nif(RAK4631_BOARD)\n{\nrespondTime = respondTime*0.7726; // Time calibration factor is 0.7726,to get real time microseconds for 4631board\n}\nSerial.printf(\"respond time is %d\\r\\n\",respondTime);\n\nif((respondTime>0)&&(respondTime < TIME_OUT))  //ECHO pin max timeout is 33000us according it's datasheet\n{\nreturn respondTime;\n}\nelse\n{\nreturn -1;\n}\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void)\n{\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void)\n{\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data)\n{\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class)\n{\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void)\n{\nif (lmh_join_status_get() != LMH_SET)\n{\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\ndata = \"Distance:\" + String(mm) + \"mm\";\nSerial.println(data);\n\nuint32_t mm_data = mm;\n\nm_lora_app_data.buffer[i++] = 0x0A;\nm_lora_app_data.buffer[i++] = (uint8_t)((mm_data & 0xFF000000) >> 24);\nm_lora_app_data.buffer[i++] = (uint8_t)((mm_data & 0x00FF0000) >> 16);\nm_lora_app_data.buffer[i++] = (uint8_t)((mm_data & 0x0000FF00) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(mm_data & 0x000000FF);\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS)\n{\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n}\nelse\n{\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The following steps will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired regions to work with. You can change this to a region that is applicable to you, like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc.  \nThe following table lists the LoRaWAN regions and the countries where they are used:  \n| LoRaWAN Region         | Usage                                                             |\n| ---------------------- | ----------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1 | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan          |\n| LORAMAC_REGION_AS923-2 | Vietnam                                                           |\n| LORAMAC_REGION_AS923-3 | Philippines, Albania, Algeria, Denmark, Greenland, Jordan         |\n| LORAMAC_REGION_AS923-4 | Israel                                                            |\n| LORAMAC_REGION_AU915   | Australia, Anguilla, Argentina, and other parts of South America  |\n| LORAMAC_REGION_CN470   | China                                                             |\n| LORAMAC_REGION_EU433   | EU, UK, Brazil, Costa Rica, Cuba, and other parts of Africa       |\n| LORAMAC_REGION_IN865   | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger |\n| LORAMAC_REGION_EU868   | EU, UK and other parts of Africa                                  |\n| LORAMAC_REGION_KR920   | Republic of Korea                                                 |\n| LORAMAC_REGION_US915   | USA                                                               |\n| LORAMAC_REGION_RU864   | Russia                                                            |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n\n```\n- Set up the LoRaWAN activation method. In this case, you will use the **OTAA** configuration, which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change it to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n\n```  \n- Set up the EUIs and KEY. The **DeviceEUI**, **AppEUI**, and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x8B, 0x0E, 0x96, 0x86, 0xE8, 0x4E, 0xA3, 0xB5, 0x31, 0x42, 0xB3, 0x65, 0x75, 0xB1, 0xD3, 0xED};\n\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once you're done with the code, you can now proceed with uploading it to your device. You must first choose your RAK4631 board on your desktop or laptop. To do so, navigate to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** and select **WisBlock RAK4631**.  \n> **Image:** Selecting the RAK4631 board  \n4. After you have selected your board, go to **Tools** > **Port** and then select the specific port of your board.  \n> **Image:** Selecting the port of RAK4631 board  \n5. You can then upload your code by clicking the Upload button (the right arrow sign). Once completed, the **Device programmed** notification will appear in the console at the bottom of the Arduino IDE.  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "d446d0970d9e287d93f8766d8efb85a7", "product_family": "wisblock", "product_id": "kit3-movement-detection", "category": "How-To", "title": "WisBlock Movement Detection Kit Quick Start Guide > WisBlock IoT Education Kit - Movement Detection Quick Start Guide > Product Configuration > Software Configuration and Examples > RAK12007 Ultrasonic Sensor LoRaWAN Application > LoRaWAN Code for RAK12007 > Programming RAK12007 Module with Arduino IDE [CODE]", "content": "2. After the installation, you can now proceed with programming your **RAK12007** module. Simply copy the **RAK12007 LoRaWAN Application** code below and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE\nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n```c", "keywords": ["Arduino IDE", "RAK4631", "RAK12007", "LoRaWAN", "programming"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed on your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you have not yet installed the **Arduino IDE**, go to the [RAK4631 Installation](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#arduino-ide-installation-rak4631) section and execute the following steps.  \n2. After the installation, you can now proceed with programming your **RAK12007** module. Simply copy the **RAK12007 LoRaWAN Application** code below and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE\nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n```c\n\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h> //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define  RAK4631_BOARD true\n#else\n#define  RAK4631_BOARD false\n#endif\n\n// Section to add include libraries, declarations and variables.\n\n#define Enable WB_IO2\n#define TRIG WB_IO6\n#define ECHO WB_IO4\n#define PD   WB_IO5   //power done control \uff08=1 power done\uff0c=0 power on\uff09\n\n#define TIME_OUT  24125 //max measure distance is 4m,the velocity of sound is 331.6m/s in 0\u2103,TIME_OUT=4*2/331.6*1000000=24215us\n\nfloat ratio = 346.6/1000/2;   //velocity of sound =331.6+0.6*25\u2103(m/s),(Indoor temperature about 25\u2103)\n\nlong int duration_time();  //measure high level time\n\nlong int duration, mm;\n\nbool doOTAA = true;   // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                     /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                   /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5             /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                      /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                      /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = {LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF};\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = {BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler\n};\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x8B, 0x0E, 0x96, 0x86, 0xE8, 0x4E, 0xA3, 0xB5, 0x31, 0x42, 0xB3, 0x65, 0x75, 0xB1, 0xD3, 0xED};\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = {0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23};\nuint8_t nodeAppsKey[16] = {0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C};\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                     /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];            //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = {m_lora_app_data_buffer, 0, 0, 0, 0}; //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup()\n{\npinMode(Enable, OUTPUT);\ndigitalWrite(Enable, HIGH);\npinMode(ECHO, INPUT);   // Echo Pin of Ultrasonic Sensor is an Input\npinMode(TRIG, OUTPUT);  // Trigger Pin of Ultrasonic Sensor is an Output\npinMode(PD, OUTPUT);    // power done control pin is an Output\ndigitalWrite(TRIG,LOW);\ndigitalWrite(PD,LOW);\n\npinMode(LED_GREEN, OUTPUT);  // Output LED\npinMode(LED_BLUE, OUTPUT);   // Output LED\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial)\n{\nif ((millis() - timeout) < 5000)\n{\ndelay(100);\n}\nelse\n{\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA)\n{\nSerial.println(\"Type: OTAA\");\n}\nelse\n{\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion)\n{\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA)\n{\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n}\nelse\n{\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0)\n{\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"========================\");\nSerial.println(\"  RAK12007 LoRaWAN test \");\nSerial.println(\"========================\");\n\n}\n\nvoid loop()\n{\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\n// long int duration, mm;\ndigitalWrite(LED_BLUE,HIGH);\ndigitalWrite(LED_GREEN, HIGH);\nduration = duration_time();\nif(duration > 0)\n{\nmm = duration*ratio; //Test distance = (high level time\u00d7velocity of sound (340M/S) / 2,\ndigitalWrite(LED_BLUE,LOW);\ndigitalWrite(LED_GREEN, LOW);\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\nSerial.print(mm);\nSerial.print(\"mm\");\nSerial.println();\ndelay(15000);\n}\nelse\n{\nSerial.println(\"Out of range\");\n}\ndelay(50);\n\n}\n\nlong int duration_time()\n{\nlong int respondTime;\npinMode(TRIG, OUTPUT);\ndigitalWrite(TRIG, HIGH);\ndelayMicroseconds(12);   //pull high time need over 10us\ndigitalWrite(TRIG, LOW);\npinMode(ECHO, INPUT);\nrespondTime = pulseIn(ECHO, HIGH); // microseconds\ndelay(33);\nif(RAK4631_BOARD)\n{\nrespondTime = respondTime*0.7726; // Time calibration factor is 0.7726,to get real time microseconds for 4631board\n}\nSerial.printf(\"respond time is %d\\r\\n\",respondTime);\n\nif((respondTime>0)&&(respondTime < TIME_OUT))  //ECHO pin max timeout is 33000us according it's datasheet\n{\nreturn respondTime;\n}\nelse\n{\nreturn -1;\n}\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void)\n{\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void)\n{\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data)\n{\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class)\n{\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void)\n{\nif (lmh_join_status_get() != LMH_SET)\n{\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\ndata = \"Distance:\" + String(mm) + \"mm\";\nSerial.println(data);\n\nuint32_t mm_data = mm;\n\nm_lora_app_data.buffer[i++] = 0x0A;\nm_lora_app_data.buffer[i++] = (uint8_t)((mm_data & 0xFF000000) >> 24);\nm_lora_app_data.buffer[i++] = (uint8_t)((mm_data & 0x00FF0000) >> 16);\nm_lora_app_data.buffer[i++] = (uint8_t)((mm_data & 0x0000FF00) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(mm_data & 0x000000FF);\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS)\n{\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n}\nelse\n{\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The following steps will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired regions to work with. You can change this to a region that is applicable to you, like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc.  \nThe following table lists the LoRaWAN regions and the countries where they are used:  \n| LoRaWAN Region         | Usage                                                             |\n| ---------------------- | ----------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1 | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan          |\n| LORAMAC_REGION_AS923-2 | Vietnam                                                           |\n| LORAMAC_REGION_AS923-3 | Philippines, Albania, Algeria, Denmark, Greenland, Jordan         |\n| LORAMAC_REGION_AS923-4 | Israel                                                            |\n| LORAMAC_REGION_AU915   | Australia, Anguilla, Argentina, and other parts of South America  |\n| LORAMAC_REGION_CN470   | China                                                             |\n| LORAMAC_REGION_EU433   | EU, UK, Brazil, Costa Rica, Cuba, and other parts of Africa       |\n| LORAMAC_REGION_IN865   | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger |\n| LORAMAC_REGION_EU868   | EU, UK and other parts of Africa                                  |\n| LORAMAC_REGION_KR920   | Republic of Korea                                                 |\n| LORAMAC_REGION_US915   | USA                                                               |\n| LORAMAC_REGION_RU864   | Russia                                                            |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n\n```\n- Set up the LoRaWAN activation method. In this case, you will use the **OTAA** configuration, which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change it to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n\n```  \n- Set up the EUIs and KEY. The **DeviceEUI**, **AppEUI**, and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x8B, 0x0E, 0x96, 0x86, 0xE8, 0x4E, 0xA3, 0xB5, 0x31, 0x42, 0xB3, 0x65, 0x75, 0xB1, 0xD3, 0xED};\n\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once you're done with the code, you can now proceed with uploading it to your device. You must first choose your RAK4631 board on your desktop or laptop. To do so, navigate to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** and select **WisBlock RAK4631**.  \n> **Image:** Selecting the RAK4631 board  \n4. After you have selected your board, go to **Tools** > **Port** and then select the specific port of your board.  \n> **Image:** Selecting the port of RAK4631 board  \n5. You can then upload your code by clicking the Upload button (the right arrow sign). Once completed, the **Device programmed** notification will appear in the console at the bottom of the Arduino IDE.  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "e2fd7edb6da06ef3e6dc1dd62cc785ec", "product_family": "wisblock", "product_id": "kit3-movement-detection", "category": "How-To", "title": "WisBlock Movement Detection Kit Quick Start Guide > WisBlock IoT Education Kit - Movement Detection Quick Start Guide > Product Configuration > Software Configuration and Examples > RAK12007 Ultrasonic Sensor LoRaWAN Application > LoRaWAN Code for RAK12007 > Programming RAK12007 Module with Arduino IDE [CODE]", "content": "#include <Arduino.h>\n#include <LoRaWan-RAK4630.h> //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define  RAK4631_BOARD true\n#else\n#define  RAK4631_BOARD false\n#endif\n\n// Section to add include libraries, declarations and variables.\n\n#define Enable WB_IO2\n#define TRIG WB_IO6\n#define ECHO WB_IO4\n#define PD   WB_IO5   //power done control \uff08=1 power done\uff0c=0 power on\uff09", "keywords": ["Arduino IDE", "RAK4631", "RAK12007", "LoRaWAN", "programming"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed on your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you have not yet installed the **Arduino IDE**, go to the [RAK4631 Installation](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#arduino-ide-installation-rak4631) section and execute the following steps.  \n2. After the installation, you can now proceed with programming your **RAK12007** module. Simply copy the **RAK12007 LoRaWAN Application** code below and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE\nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n```c\n\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h> //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define  RAK4631_BOARD true\n#else\n#define  RAK4631_BOARD false\n#endif\n\n// Section to add include libraries, declarations and variables.\n\n#define Enable WB_IO2\n#define TRIG WB_IO6\n#define ECHO WB_IO4\n#define PD   WB_IO5   //power done control \uff08=1 power done\uff0c=0 power on\uff09\n\n#define TIME_OUT  24125 //max measure distance is 4m,the velocity of sound is 331.6m/s in 0\u2103,TIME_OUT=4*2/331.6*1000000=24215us\n\nfloat ratio = 346.6/1000/2;   //velocity of sound =331.6+0.6*25\u2103(m/s),(Indoor temperature about 25\u2103)\n\nlong int duration_time();  //measure high level time\n\nlong int duration, mm;\n\nbool doOTAA = true;   // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                     /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                   /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5             /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                      /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                      /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = {LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF};\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = {BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler\n};\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x8B, 0x0E, 0x96, 0x86, 0xE8, 0x4E, 0xA3, 0xB5, 0x31, 0x42, 0xB3, 0x65, 0x75, 0xB1, 0xD3, 0xED};\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = {0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23};\nuint8_t nodeAppsKey[16] = {0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C};\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                     /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];            //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = {m_lora_app_data_buffer, 0, 0, 0, 0}; //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup()\n{\npinMode(Enable, OUTPUT);\ndigitalWrite(Enable, HIGH);\npinMode(ECHO, INPUT);   // Echo Pin of Ultrasonic Sensor is an Input\npinMode(TRIG, OUTPUT);  // Trigger Pin of Ultrasonic Sensor is an Output\npinMode(PD, OUTPUT);    // power done control pin is an Output\ndigitalWrite(TRIG,LOW);\ndigitalWrite(PD,LOW);\n\npinMode(LED_GREEN, OUTPUT);  // Output LED\npinMode(LED_BLUE, OUTPUT);   // Output LED\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial)\n{\nif ((millis() - timeout) < 5000)\n{\ndelay(100);\n}\nelse\n{\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA)\n{\nSerial.println(\"Type: OTAA\");\n}\nelse\n{\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion)\n{\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA)\n{\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n}\nelse\n{\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0)\n{\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"========================\");\nSerial.println(\"  RAK12007 LoRaWAN test \");\nSerial.println(\"========================\");\n\n}\n\nvoid loop()\n{\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\n// long int duration, mm;\ndigitalWrite(LED_BLUE,HIGH);\ndigitalWrite(LED_GREEN, HIGH);\nduration = duration_time();\nif(duration > 0)\n{\nmm = duration*ratio; //Test distance = (high level time\u00d7velocity of sound (340M/S) / 2,\ndigitalWrite(LED_BLUE,LOW);\ndigitalWrite(LED_GREEN, LOW);\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\nSerial.print(mm);\nSerial.print(\"mm\");\nSerial.println();\ndelay(15000);\n}\nelse\n{\nSerial.println(\"Out of range\");\n}\ndelay(50);\n\n}\n\nlong int duration_time()\n{\nlong int respondTime;\npinMode(TRIG, OUTPUT);\ndigitalWrite(TRIG, HIGH);\ndelayMicroseconds(12);   //pull high time need over 10us\ndigitalWrite(TRIG, LOW);\npinMode(ECHO, INPUT);\nrespondTime = pulseIn(ECHO, HIGH); // microseconds\ndelay(33);\nif(RAK4631_BOARD)\n{\nrespondTime = respondTime*0.7726; // Time calibration factor is 0.7726,to get real time microseconds for 4631board\n}\nSerial.printf(\"respond time is %d\\r\\n\",respondTime);\n\nif((respondTime>0)&&(respondTime < TIME_OUT))  //ECHO pin max timeout is 33000us according it's datasheet\n{\nreturn respondTime;\n}\nelse\n{\nreturn -1;\n}\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void)\n{\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void)\n{\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data)\n{\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class)\n{\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void)\n{\nif (lmh_join_status_get() != LMH_SET)\n{\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\ndata = \"Distance:\" + String(mm) + \"mm\";\nSerial.println(data);\n\nuint32_t mm_data = mm;\n\nm_lora_app_data.buffer[i++] = 0x0A;\nm_lora_app_data.buffer[i++] = (uint8_t)((mm_data & 0xFF000000) >> 24);\nm_lora_app_data.buffer[i++] = (uint8_t)((mm_data & 0x00FF0000) >> 16);\nm_lora_app_data.buffer[i++] = (uint8_t)((mm_data & 0x0000FF00) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(mm_data & 0x000000FF);\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS)\n{\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n}\nelse\n{\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The following steps will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired regions to work with. You can change this to a region that is applicable to you, like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc.  \nThe following table lists the LoRaWAN regions and the countries where they are used:  \n| LoRaWAN Region         | Usage                                                             |\n| ---------------------- | ----------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1 | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan          |\n| LORAMAC_REGION_AS923-2 | Vietnam                                                           |\n| LORAMAC_REGION_AS923-3 | Philippines, Albania, Algeria, Denmark, Greenland, Jordan         |\n| LORAMAC_REGION_AS923-4 | Israel                                                            |\n| LORAMAC_REGION_AU915   | Australia, Anguilla, Argentina, and other parts of South America  |\n| LORAMAC_REGION_CN470   | China                                                             |\n| LORAMAC_REGION_EU433   | EU, UK, Brazil, Costa Rica, Cuba, and other parts of Africa       |\n| LORAMAC_REGION_IN865   | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger |\n| LORAMAC_REGION_EU868   | EU, UK and other parts of Africa                                  |\n| LORAMAC_REGION_KR920   | Republic of Korea                                                 |\n| LORAMAC_REGION_US915   | USA                                                               |\n| LORAMAC_REGION_RU864   | Russia                                                            |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n\n```\n- Set up the LoRaWAN activation method. In this case, you will use the **OTAA** configuration, which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change it to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n\n```  \n- Set up the EUIs and KEY. The **DeviceEUI**, **AppEUI**, and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x8B, 0x0E, 0x96, 0x86, 0xE8, 0x4E, 0xA3, 0xB5, 0x31, 0x42, 0xB3, 0x65, 0x75, 0xB1, 0xD3, 0xED};\n\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once you're done with the code, you can now proceed with uploading it to your device. You must first choose your RAK4631 board on your desktop or laptop. To do so, navigate to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** and select **WisBlock RAK4631**.  \n> **Image:** Selecting the RAK4631 board  \n4. After you have selected your board, go to **Tools** > **Port** and then select the specific port of your board.  \n> **Image:** Selecting the port of RAK4631 board  \n5. You can then upload your code by clicking the Upload button (the right arrow sign). Once completed, the **Device programmed** notification will appear in the console at the bottom of the Arduino IDE.  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "340c8109dfa4a8c7fe4eb9f129e930a8", "product_family": "wisblock", "product_id": "kit3-movement-detection", "category": "How-To", "title": "WisBlock Movement Detection Kit Quick Start Guide > WisBlock IoT Education Kit - Movement Detection Quick Start Guide > Product Configuration > Software Configuration and Examples > RAK12007 Ultrasonic Sensor LoRaWAN Application > LoRaWAN Code for RAK12007 > Programming RAK12007 Module with Arduino IDE [CODE]", "content": "#define TIME_OUT  24125 //max measure distance is 4m,the velocity of sound is 331.6m/s in 0\u2103,TIME_OUT=4*2/331.6*1000000=24215us\n\nfloat ratio = 346.6/1000/2;   //velocity of sound =331.6+0.6*25\u2103(m/s),(Indoor temperature about 25\u2103)\n\nlong int duration_time();  //measure high level time\n\nlong int duration, mm;", "keywords": ["Arduino IDE", "RAK4631", "RAK12007", "LoRaWAN", "programming"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed on your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you have not yet installed the **Arduino IDE**, go to the [RAK4631 Installation](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#arduino-ide-installation-rak4631) section and execute the following steps.  \n2. After the installation, you can now proceed with programming your **RAK12007** module. Simply copy the **RAK12007 LoRaWAN Application** code below and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE\nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n```c\n\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h> //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define  RAK4631_BOARD true\n#else\n#define  RAK4631_BOARD false\n#endif\n\n// Section to add include libraries, declarations and variables.\n\n#define Enable WB_IO2\n#define TRIG WB_IO6\n#define ECHO WB_IO4\n#define PD   WB_IO5   //power done control \uff08=1 power done\uff0c=0 power on\uff09\n\n#define TIME_OUT  24125 //max measure distance is 4m,the velocity of sound is 331.6m/s in 0\u2103,TIME_OUT=4*2/331.6*1000000=24215us\n\nfloat ratio = 346.6/1000/2;   //velocity of sound =331.6+0.6*25\u2103(m/s),(Indoor temperature about 25\u2103)\n\nlong int duration_time();  //measure high level time\n\nlong int duration, mm;\n\nbool doOTAA = true;   // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                     /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                   /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5             /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                      /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                      /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = {LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF};\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = {BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler\n};\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x8B, 0x0E, 0x96, 0x86, 0xE8, 0x4E, 0xA3, 0xB5, 0x31, 0x42, 0xB3, 0x65, 0x75, 0xB1, 0xD3, 0xED};\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = {0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23};\nuint8_t nodeAppsKey[16] = {0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C};\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                     /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];            //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = {m_lora_app_data_buffer, 0, 0, 0, 0}; //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup()\n{\npinMode(Enable, OUTPUT);\ndigitalWrite(Enable, HIGH);\npinMode(ECHO, INPUT);   // Echo Pin of Ultrasonic Sensor is an Input\npinMode(TRIG, OUTPUT);  // Trigger Pin of Ultrasonic Sensor is an Output\npinMode(PD, OUTPUT);    // power done control pin is an Output\ndigitalWrite(TRIG,LOW);\ndigitalWrite(PD,LOW);\n\npinMode(LED_GREEN, OUTPUT);  // Output LED\npinMode(LED_BLUE, OUTPUT);   // Output LED\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial)\n{\nif ((millis() - timeout) < 5000)\n{\ndelay(100);\n}\nelse\n{\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA)\n{\nSerial.println(\"Type: OTAA\");\n}\nelse\n{\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion)\n{\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA)\n{\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n}\nelse\n{\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0)\n{\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"========================\");\nSerial.println(\"  RAK12007 LoRaWAN test \");\nSerial.println(\"========================\");\n\n}\n\nvoid loop()\n{\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\n// long int duration, mm;\ndigitalWrite(LED_BLUE,HIGH);\ndigitalWrite(LED_GREEN, HIGH);\nduration = duration_time();\nif(duration > 0)\n{\nmm = duration*ratio; //Test distance = (high level time\u00d7velocity of sound (340M/S) / 2,\ndigitalWrite(LED_BLUE,LOW);\ndigitalWrite(LED_GREEN, LOW);\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\nSerial.print(mm);\nSerial.print(\"mm\");\nSerial.println();\ndelay(15000);\n}\nelse\n{\nSerial.println(\"Out of range\");\n}\ndelay(50);\n\n}\n\nlong int duration_time()\n{\nlong int respondTime;\npinMode(TRIG, OUTPUT);\ndigitalWrite(TRIG, HIGH);\ndelayMicroseconds(12);   //pull high time need over 10us\ndigitalWrite(TRIG, LOW);\npinMode(ECHO, INPUT);\nrespondTime = pulseIn(ECHO, HIGH); // microseconds\ndelay(33);\nif(RAK4631_BOARD)\n{\nrespondTime = respondTime*0.7726; // Time calibration factor is 0.7726,to get real time microseconds for 4631board\n}\nSerial.printf(\"respond time is %d\\r\\n\",respondTime);\n\nif((respondTime>0)&&(respondTime < TIME_OUT))  //ECHO pin max timeout is 33000us according it's datasheet\n{\nreturn respondTime;\n}\nelse\n{\nreturn -1;\n}\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void)\n{\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void)\n{\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data)\n{\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class)\n{\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void)\n{\nif (lmh_join_status_get() != LMH_SET)\n{\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\ndata = \"Distance:\" + String(mm) + \"mm\";\nSerial.println(data);\n\nuint32_t mm_data = mm;\n\nm_lora_app_data.buffer[i++] = 0x0A;\nm_lora_app_data.buffer[i++] = (uint8_t)((mm_data & 0xFF000000) >> 24);\nm_lora_app_data.buffer[i++] = (uint8_t)((mm_data & 0x00FF0000) >> 16);\nm_lora_app_data.buffer[i++] = (uint8_t)((mm_data & 0x0000FF00) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(mm_data & 0x000000FF);\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS)\n{\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n}\nelse\n{\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The following steps will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired regions to work with. You can change this to a region that is applicable to you, like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc.  \nThe following table lists the LoRaWAN regions and the countries where they are used:  \n| LoRaWAN Region         | Usage                                                             |\n| ---------------------- | ----------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1 | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan          |\n| LORAMAC_REGION_AS923-2 | Vietnam                                                           |\n| LORAMAC_REGION_AS923-3 | Philippines, Albania, Algeria, Denmark, Greenland, Jordan         |\n| LORAMAC_REGION_AS923-4 | Israel                                                            |\n| LORAMAC_REGION_AU915   | Australia, Anguilla, Argentina, and other parts of South America  |\n| LORAMAC_REGION_CN470   | China                                                             |\n| LORAMAC_REGION_EU433   | EU, UK, Brazil, Costa Rica, Cuba, and other parts of Africa       |\n| LORAMAC_REGION_IN865   | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger |\n| LORAMAC_REGION_EU868   | EU, UK and other parts of Africa                                  |\n| LORAMAC_REGION_KR920   | Republic of Korea                                                 |\n| LORAMAC_REGION_US915   | USA                                                               |\n| LORAMAC_REGION_RU864   | Russia                                                            |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n\n```\n- Set up the LoRaWAN activation method. In this case, you will use the **OTAA** configuration, which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change it to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n\n```  \n- Set up the EUIs and KEY. The **DeviceEUI**, **AppEUI**, and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x8B, 0x0E, 0x96, 0x86, 0xE8, 0x4E, 0xA3, 0xB5, 0x31, 0x42, 0xB3, 0x65, 0x75, 0xB1, 0xD3, 0xED};\n\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once you're done with the code, you can now proceed with uploading it to your device. You must first choose your RAK4631 board on your desktop or laptop. To do so, navigate to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** and select **WisBlock RAK4631**.  \n> **Image:** Selecting the RAK4631 board  \n4. After you have selected your board, go to **Tools** > **Port** and then select the specific port of your board.  \n> **Image:** Selecting the port of RAK4631 board  \n5. You can then upload your code by clicking the Upload button (the right arrow sign). Once completed, the **Device programmed** notification will appear in the console at the bottom of the Arduino IDE.  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "2ced632df266499632567a2dbb82cc15", "product_family": "wisblock", "product_id": "kit3-movement-detection", "category": "How-To", "title": "WisBlock Movement Detection Kit Quick Start Guide > WisBlock IoT Education Kit - Movement Detection Quick Start Guide > Product Configuration > Software Configuration and Examples > RAK12007 Ultrasonic Sensor LoRaWAN Application > LoRaWAN Code for RAK12007 > Programming RAK12007 Module with Arduino IDE [CODE]", "content": "bool doOTAA = true;   // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                     /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                   /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5             /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/", "keywords": ["Arduino IDE", "RAK4631", "RAK12007", "LoRaWAN", "programming"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed on your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you have not yet installed the **Arduino IDE**, go to the [RAK4631 Installation](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#arduino-ide-installation-rak4631) section and execute the following steps.  \n2. After the installation, you can now proceed with programming your **RAK12007** module. Simply copy the **RAK12007 LoRaWAN Application** code below and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE\nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n```c\n\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h> //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define  RAK4631_BOARD true\n#else\n#define  RAK4631_BOARD false\n#endif\n\n// Section to add include libraries, declarations and variables.\n\n#define Enable WB_IO2\n#define TRIG WB_IO6\n#define ECHO WB_IO4\n#define PD   WB_IO5   //power done control \uff08=1 power done\uff0c=0 power on\uff09\n\n#define TIME_OUT  24125 //max measure distance is 4m,the velocity of sound is 331.6m/s in 0\u2103,TIME_OUT=4*2/331.6*1000000=24215us\n\nfloat ratio = 346.6/1000/2;   //velocity of sound =331.6+0.6*25\u2103(m/s),(Indoor temperature about 25\u2103)\n\nlong int duration_time();  //measure high level time\n\nlong int duration, mm;\n\nbool doOTAA = true;   // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                     /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                   /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5             /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                      /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                      /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = {LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF};\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = {BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler\n};\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x8B, 0x0E, 0x96, 0x86, 0xE8, 0x4E, 0xA3, 0xB5, 0x31, 0x42, 0xB3, 0x65, 0x75, 0xB1, 0xD3, 0xED};\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = {0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23};\nuint8_t nodeAppsKey[16] = {0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C};\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                     /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];            //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = {m_lora_app_data_buffer, 0, 0, 0, 0}; //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup()\n{\npinMode(Enable, OUTPUT);\ndigitalWrite(Enable, HIGH);\npinMode(ECHO, INPUT);   // Echo Pin of Ultrasonic Sensor is an Input\npinMode(TRIG, OUTPUT);  // Trigger Pin of Ultrasonic Sensor is an Output\npinMode(PD, OUTPUT);    // power done control pin is an Output\ndigitalWrite(TRIG,LOW);\ndigitalWrite(PD,LOW);\n\npinMode(LED_GREEN, OUTPUT);  // Output LED\npinMode(LED_BLUE, OUTPUT);   // Output LED\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial)\n{\nif ((millis() - timeout) < 5000)\n{\ndelay(100);\n}\nelse\n{\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA)\n{\nSerial.println(\"Type: OTAA\");\n}\nelse\n{\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion)\n{\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA)\n{\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n}\nelse\n{\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0)\n{\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"========================\");\nSerial.println(\"  RAK12007 LoRaWAN test \");\nSerial.println(\"========================\");\n\n}\n\nvoid loop()\n{\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\n// long int duration, mm;\ndigitalWrite(LED_BLUE,HIGH);\ndigitalWrite(LED_GREEN, HIGH);\nduration = duration_time();\nif(duration > 0)\n{\nmm = duration*ratio; //Test distance = (high level time\u00d7velocity of sound (340M/S) / 2,\ndigitalWrite(LED_BLUE,LOW);\ndigitalWrite(LED_GREEN, LOW);\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\nSerial.print(mm);\nSerial.print(\"mm\");\nSerial.println();\ndelay(15000);\n}\nelse\n{\nSerial.println(\"Out of range\");\n}\ndelay(50);\n\n}\n\nlong int duration_time()\n{\nlong int respondTime;\npinMode(TRIG, OUTPUT);\ndigitalWrite(TRIG, HIGH);\ndelayMicroseconds(12);   //pull high time need over 10us\ndigitalWrite(TRIG, LOW);\npinMode(ECHO, INPUT);\nrespondTime = pulseIn(ECHO, HIGH); // microseconds\ndelay(33);\nif(RAK4631_BOARD)\n{\nrespondTime = respondTime*0.7726; // Time calibration factor is 0.7726,to get real time microseconds for 4631board\n}\nSerial.printf(\"respond time is %d\\r\\n\",respondTime);\n\nif((respondTime>0)&&(respondTime < TIME_OUT))  //ECHO pin max timeout is 33000us according it's datasheet\n{\nreturn respondTime;\n}\nelse\n{\nreturn -1;\n}\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void)\n{\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void)\n{\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data)\n{\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class)\n{\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void)\n{\nif (lmh_join_status_get() != LMH_SET)\n{\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\ndata = \"Distance:\" + String(mm) + \"mm\";\nSerial.println(data);\n\nuint32_t mm_data = mm;\n\nm_lora_app_data.buffer[i++] = 0x0A;\nm_lora_app_data.buffer[i++] = (uint8_t)((mm_data & 0xFF000000) >> 24);\nm_lora_app_data.buffer[i++] = (uint8_t)((mm_data & 0x00FF0000) >> 16);\nm_lora_app_data.buffer[i++] = (uint8_t)((mm_data & 0x0000FF00) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(mm_data & 0x000000FF);\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS)\n{\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n}\nelse\n{\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The following steps will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired regions to work with. You can change this to a region that is applicable to you, like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc.  \nThe following table lists the LoRaWAN regions and the countries where they are used:  \n| LoRaWAN Region         | Usage                                                             |\n| ---------------------- | ----------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1 | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan          |\n| LORAMAC_REGION_AS923-2 | Vietnam                                                           |\n| LORAMAC_REGION_AS923-3 | Philippines, Albania, Algeria, Denmark, Greenland, Jordan         |\n| LORAMAC_REGION_AS923-4 | Israel                                                            |\n| LORAMAC_REGION_AU915   | Australia, Anguilla, Argentina, and other parts of South America  |\n| LORAMAC_REGION_CN470   | China                                                             |\n| LORAMAC_REGION_EU433   | EU, UK, Brazil, Costa Rica, Cuba, and other parts of Africa       |\n| LORAMAC_REGION_IN865   | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger |\n| LORAMAC_REGION_EU868   | EU, UK and other parts of Africa                                  |\n| LORAMAC_REGION_KR920   | Republic of Korea                                                 |\n| LORAMAC_REGION_US915   | USA                                                               |\n| LORAMAC_REGION_RU864   | Russia                                                            |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n\n```\n- Set up the LoRaWAN activation method. In this case, you will use the **OTAA** configuration, which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change it to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n\n```  \n- Set up the EUIs and KEY. The **DeviceEUI**, **AppEUI**, and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x8B, 0x0E, 0x96, 0x86, 0xE8, 0x4E, 0xA3, 0xB5, 0x31, 0x42, 0xB3, 0x65, 0x75, 0xB1, 0xD3, 0xED};\n\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once you're done with the code, you can now proceed with uploading it to your device. You must first choose your RAK4631 board on your desktop or laptop. To do so, navigate to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** and select **WisBlock RAK4631**.  \n> **Image:** Selecting the RAK4631 board  \n4. After you have selected your board, go to **Tools** > **Port** and then select the specific port of your board.  \n> **Image:** Selecting the port of RAK4631 board  \n5. You can then upload your code by clicking the Upload button (the right arrow sign). Once completed, the **Device programmed** notification will appear in the console at the bottom of the Arduino IDE.  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "14a132dc200158815ff1a58cf5ea3a9e", "product_family": "wisblock", "product_id": "kit3-movement-detection", "category": "How-To", "title": "WisBlock Movement Detection Kit Quick Start Guide > WisBlock IoT Education Kit - Movement Detection Quick Start Guide > Product Configuration > Software Configuration and Examples > RAK12007 Ultrasonic Sensor LoRaWAN Application > LoRaWAN Code for RAK12007 > Programming RAK12007 Module with Arduino IDE [CODE]", "content": "#define JOINREQ_NBTRIALS 3                      /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                      /* data port*/", "keywords": ["Arduino IDE", "RAK4631", "RAK12007", "LoRaWAN", "programming"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed on your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you have not yet installed the **Arduino IDE**, go to the [RAK4631 Installation](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#arduino-ide-installation-rak4631) section and execute the following steps.  \n2. After the installation, you can now proceed with programming your **RAK12007** module. Simply copy the **RAK12007 LoRaWAN Application** code below and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE\nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n```c\n\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h> //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define  RAK4631_BOARD true\n#else\n#define  RAK4631_BOARD false\n#endif\n\n// Section to add include libraries, declarations and variables.\n\n#define Enable WB_IO2\n#define TRIG WB_IO6\n#define ECHO WB_IO4\n#define PD   WB_IO5   //power done control \uff08=1 power done\uff0c=0 power on\uff09\n\n#define TIME_OUT  24125 //max measure distance is 4m,the velocity of sound is 331.6m/s in 0\u2103,TIME_OUT=4*2/331.6*1000000=24215us\n\nfloat ratio = 346.6/1000/2;   //velocity of sound =331.6+0.6*25\u2103(m/s),(Indoor temperature about 25\u2103)\n\nlong int duration_time();  //measure high level time\n\nlong int duration, mm;\n\nbool doOTAA = true;   // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                     /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                   /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5             /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                      /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                      /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = {LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF};\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = {BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler\n};\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x8B, 0x0E, 0x96, 0x86, 0xE8, 0x4E, 0xA3, 0xB5, 0x31, 0x42, 0xB3, 0x65, 0x75, 0xB1, 0xD3, 0xED};\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = {0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23};\nuint8_t nodeAppsKey[16] = {0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C};\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                     /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];            //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = {m_lora_app_data_buffer, 0, 0, 0, 0}; //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup()\n{\npinMode(Enable, OUTPUT);\ndigitalWrite(Enable, HIGH);\npinMode(ECHO, INPUT);   // Echo Pin of Ultrasonic Sensor is an Input\npinMode(TRIG, OUTPUT);  // Trigger Pin of Ultrasonic Sensor is an Output\npinMode(PD, OUTPUT);    // power done control pin is an Output\ndigitalWrite(TRIG,LOW);\ndigitalWrite(PD,LOW);\n\npinMode(LED_GREEN, OUTPUT);  // Output LED\npinMode(LED_BLUE, OUTPUT);   // Output LED\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial)\n{\nif ((millis() - timeout) < 5000)\n{\ndelay(100);\n}\nelse\n{\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA)\n{\nSerial.println(\"Type: OTAA\");\n}\nelse\n{\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion)\n{\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA)\n{\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n}\nelse\n{\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0)\n{\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"========================\");\nSerial.println(\"  RAK12007 LoRaWAN test \");\nSerial.println(\"========================\");\n\n}\n\nvoid loop()\n{\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\n// long int duration, mm;\ndigitalWrite(LED_BLUE,HIGH);\ndigitalWrite(LED_GREEN, HIGH);\nduration = duration_time();\nif(duration > 0)\n{\nmm = duration*ratio; //Test distance = (high level time\u00d7velocity of sound (340M/S) / 2,\ndigitalWrite(LED_BLUE,LOW);\ndigitalWrite(LED_GREEN, LOW);\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\nSerial.print(mm);\nSerial.print(\"mm\");\nSerial.println();\ndelay(15000);\n}\nelse\n{\nSerial.println(\"Out of range\");\n}\ndelay(50);\n\n}\n\nlong int duration_time()\n{\nlong int respondTime;\npinMode(TRIG, OUTPUT);\ndigitalWrite(TRIG, HIGH);\ndelayMicroseconds(12);   //pull high time need over 10us\ndigitalWrite(TRIG, LOW);\npinMode(ECHO, INPUT);\nrespondTime = pulseIn(ECHO, HIGH); // microseconds\ndelay(33);\nif(RAK4631_BOARD)\n{\nrespondTime = respondTime*0.7726; // Time calibration factor is 0.7726,to get real time microseconds for 4631board\n}\nSerial.printf(\"respond time is %d\\r\\n\",respondTime);\n\nif((respondTime>0)&&(respondTime < TIME_OUT))  //ECHO pin max timeout is 33000us according it's datasheet\n{\nreturn respondTime;\n}\nelse\n{\nreturn -1;\n}\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void)\n{\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void)\n{\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data)\n{\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class)\n{\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void)\n{\nif (lmh_join_status_get() != LMH_SET)\n{\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\ndata = \"Distance:\" + String(mm) + \"mm\";\nSerial.println(data);\n\nuint32_t mm_data = mm;\n\nm_lora_app_data.buffer[i++] = 0x0A;\nm_lora_app_data.buffer[i++] = (uint8_t)((mm_data & 0xFF000000) >> 24);\nm_lora_app_data.buffer[i++] = (uint8_t)((mm_data & 0x00FF0000) >> 16);\nm_lora_app_data.buffer[i++] = (uint8_t)((mm_data & 0x0000FF00) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(mm_data & 0x000000FF);\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS)\n{\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n}\nelse\n{\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The following steps will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired regions to work with. You can change this to a region that is applicable to you, like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc.  \nThe following table lists the LoRaWAN regions and the countries where they are used:  \n| LoRaWAN Region         | Usage                                                             |\n| ---------------------- | ----------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1 | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan          |\n| LORAMAC_REGION_AS923-2 | Vietnam                                                           |\n| LORAMAC_REGION_AS923-3 | Philippines, Albania, Algeria, Denmark, Greenland, Jordan         |\n| LORAMAC_REGION_AS923-4 | Israel                                                            |\n| LORAMAC_REGION_AU915   | Australia, Anguilla, Argentina, and other parts of South America  |\n| LORAMAC_REGION_CN470   | China                                                             |\n| LORAMAC_REGION_EU433   | EU, UK, Brazil, Costa Rica, Cuba, and other parts of Africa       |\n| LORAMAC_REGION_IN865   | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger |\n| LORAMAC_REGION_EU868   | EU, UK and other parts of Africa                                  |\n| LORAMAC_REGION_KR920   | Republic of Korea                                                 |\n| LORAMAC_REGION_US915   | USA                                                               |\n| LORAMAC_REGION_RU864   | Russia                                                            |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n\n```\n- Set up the LoRaWAN activation method. In this case, you will use the **OTAA** configuration, which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change it to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n\n```  \n- Set up the EUIs and KEY. The **DeviceEUI**, **AppEUI**, and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x8B, 0x0E, 0x96, 0x86, 0xE8, 0x4E, 0xA3, 0xB5, 0x31, 0x42, 0xB3, 0x65, 0x75, 0xB1, 0xD3, 0xED};\n\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once you're done with the code, you can now proceed with uploading it to your device. You must first choose your RAK4631 board on your desktop or laptop. To do so, navigate to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** and select **WisBlock RAK4631**.  \n> **Image:** Selecting the RAK4631 board  \n4. After you have selected your board, go to **Tools** > **Port** and then select the specific port of your board.  \n> **Image:** Selecting the port of RAK4631 board  \n5. You can then upload your code by clicking the Upload button (the right arrow sign). Once completed, the **Device programmed** notification will appear in the console at the bottom of the Arduino IDE.  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "378acf51780665434f11b3c6ecc9f45d", "product_family": "wisblock", "product_id": "kit3-movement-detection", "category": "How-To", "title": "WisBlock Movement Detection Kit Quick Start Guide > WisBlock IoT Education Kit - Movement Detection Quick Start Guide > Product Configuration > Software Configuration and Examples > RAK12007 Ultrasonic Sensor LoRaWAN Application > LoRaWAN Code for RAK12007 > Programming RAK12007 Module with Arduino IDE [CODE]", "content": "/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = {LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF};", "keywords": ["Arduino IDE", "RAK4631", "RAK12007", "LoRaWAN", "programming"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed on your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you have not yet installed the **Arduino IDE**, go to the [RAK4631 Installation](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#arduino-ide-installation-rak4631) section and execute the following steps.  \n2. After the installation, you can now proceed with programming your **RAK12007** module. Simply copy the **RAK12007 LoRaWAN Application** code below and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE\nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n```c\n\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h> //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define  RAK4631_BOARD true\n#else\n#define  RAK4631_BOARD false\n#endif\n\n// Section to add include libraries, declarations and variables.\n\n#define Enable WB_IO2\n#define TRIG WB_IO6\n#define ECHO WB_IO4\n#define PD   WB_IO5   //power done control \uff08=1 power done\uff0c=0 power on\uff09\n\n#define TIME_OUT  24125 //max measure distance is 4m,the velocity of sound is 331.6m/s in 0\u2103,TIME_OUT=4*2/331.6*1000000=24215us\n\nfloat ratio = 346.6/1000/2;   //velocity of sound =331.6+0.6*25\u2103(m/s),(Indoor temperature about 25\u2103)\n\nlong int duration_time();  //measure high level time\n\nlong int duration, mm;\n\nbool doOTAA = true;   // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                     /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                   /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5             /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                      /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                      /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = {LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF};\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = {BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler\n};\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x8B, 0x0E, 0x96, 0x86, 0xE8, 0x4E, 0xA3, 0xB5, 0x31, 0x42, 0xB3, 0x65, 0x75, 0xB1, 0xD3, 0xED};\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = {0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23};\nuint8_t nodeAppsKey[16] = {0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C};\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                     /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];            //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = {m_lora_app_data_buffer, 0, 0, 0, 0}; //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup()\n{\npinMode(Enable, OUTPUT);\ndigitalWrite(Enable, HIGH);\npinMode(ECHO, INPUT);   // Echo Pin of Ultrasonic Sensor is an Input\npinMode(TRIG, OUTPUT);  // Trigger Pin of Ultrasonic Sensor is an Output\npinMode(PD, OUTPUT);    // power done control pin is an Output\ndigitalWrite(TRIG,LOW);\ndigitalWrite(PD,LOW);\n\npinMode(LED_GREEN, OUTPUT);  // Output LED\npinMode(LED_BLUE, OUTPUT);   // Output LED\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial)\n{\nif ((millis() - timeout) < 5000)\n{\ndelay(100);\n}\nelse\n{\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA)\n{\nSerial.println(\"Type: OTAA\");\n}\nelse\n{\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion)\n{\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA)\n{\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n}\nelse\n{\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0)\n{\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"========================\");\nSerial.println(\"  RAK12007 LoRaWAN test \");\nSerial.println(\"========================\");\n\n}\n\nvoid loop()\n{\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\n// long int duration, mm;\ndigitalWrite(LED_BLUE,HIGH);\ndigitalWrite(LED_GREEN, HIGH);\nduration = duration_time();\nif(duration > 0)\n{\nmm = duration*ratio; //Test distance = (high level time\u00d7velocity of sound (340M/S) / 2,\ndigitalWrite(LED_BLUE,LOW);\ndigitalWrite(LED_GREEN, LOW);\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\nSerial.print(mm);\nSerial.print(\"mm\");\nSerial.println();\ndelay(15000);\n}\nelse\n{\nSerial.println(\"Out of range\");\n}\ndelay(50);\n\n}\n\nlong int duration_time()\n{\nlong int respondTime;\npinMode(TRIG, OUTPUT);\ndigitalWrite(TRIG, HIGH);\ndelayMicroseconds(12);   //pull high time need over 10us\ndigitalWrite(TRIG, LOW);\npinMode(ECHO, INPUT);\nrespondTime = pulseIn(ECHO, HIGH); // microseconds\ndelay(33);\nif(RAK4631_BOARD)\n{\nrespondTime = respondTime*0.7726; // Time calibration factor is 0.7726,to get real time microseconds for 4631board\n}\nSerial.printf(\"respond time is %d\\r\\n\",respondTime);\n\nif((respondTime>0)&&(respondTime < TIME_OUT))  //ECHO pin max timeout is 33000us according it's datasheet\n{\nreturn respondTime;\n}\nelse\n{\nreturn -1;\n}\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void)\n{\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void)\n{\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data)\n{\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class)\n{\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void)\n{\nif (lmh_join_status_get() != LMH_SET)\n{\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\ndata = \"Distance:\" + String(mm) + \"mm\";\nSerial.println(data);\n\nuint32_t mm_data = mm;\n\nm_lora_app_data.buffer[i++] = 0x0A;\nm_lora_app_data.buffer[i++] = (uint8_t)((mm_data & 0xFF000000) >> 24);\nm_lora_app_data.buffer[i++] = (uint8_t)((mm_data & 0x00FF0000) >> 16);\nm_lora_app_data.buffer[i++] = (uint8_t)((mm_data & 0x0000FF00) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(mm_data & 0x000000FF);\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS)\n{\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n}\nelse\n{\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The following steps will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired regions to work with. You can change this to a region that is applicable to you, like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc.  \nThe following table lists the LoRaWAN regions and the countries where they are used:  \n| LoRaWAN Region         | Usage                                                             |\n| ---------------------- | ----------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1 | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan          |\n| LORAMAC_REGION_AS923-2 | Vietnam                                                           |\n| LORAMAC_REGION_AS923-3 | Philippines, Albania, Algeria, Denmark, Greenland, Jordan         |\n| LORAMAC_REGION_AS923-4 | Israel                                                            |\n| LORAMAC_REGION_AU915   | Australia, Anguilla, Argentina, and other parts of South America  |\n| LORAMAC_REGION_CN470   | China                                                             |\n| LORAMAC_REGION_EU433   | EU, UK, Brazil, Costa Rica, Cuba, and other parts of Africa       |\n| LORAMAC_REGION_IN865   | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger |\n| LORAMAC_REGION_EU868   | EU, UK and other parts of Africa                                  |\n| LORAMAC_REGION_KR920   | Republic of Korea                                                 |\n| LORAMAC_REGION_US915   | USA                                                               |\n| LORAMAC_REGION_RU864   | Russia                                                            |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n\n```\n- Set up the LoRaWAN activation method. In this case, you will use the **OTAA** configuration, which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change it to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n\n```  \n- Set up the EUIs and KEY. The **DeviceEUI**, **AppEUI**, and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x8B, 0x0E, 0x96, 0x86, 0xE8, 0x4E, 0xA3, 0xB5, 0x31, 0x42, 0xB3, 0x65, 0x75, 0xB1, 0xD3, 0xED};\n\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once you're done with the code, you can now proceed with uploading it to your device. You must first choose your RAK4631 board on your desktop or laptop. To do so, navigate to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** and select **WisBlock RAK4631**.  \n> **Image:** Selecting the RAK4631 board  \n4. After you have selected your board, go to **Tools** > **Port** and then select the specific port of your board.  \n> **Image:** Selecting the port of RAK4631 board  \n5. You can then upload your code by clicking the Upload button (the right arrow sign). Once completed, the **Device programmed** notification will appear in the console at the bottom of the Arduino IDE.  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "212fd6e2688ae134a4349488bdf2f37e", "product_family": "wisblock", "product_id": "kit3-movement-detection", "category": "How-To", "title": "WisBlock Movement Detection Kit Quick Start Guide > WisBlock IoT Education Kit - Movement Detection Quick Start Guide > Product Configuration > Software Configuration and Examples > RAK12007 Ultrasonic Sensor LoRaWAN Application > LoRaWAN Code for RAK12007 > Programming RAK12007 Module with Arduino IDE [CODE]", "content": "// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);", "keywords": ["Arduino IDE", "RAK4631", "RAK12007", "LoRaWAN", "programming"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed on your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you have not yet installed the **Arduino IDE**, go to the [RAK4631 Installation](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#arduino-ide-installation-rak4631) section and execute the following steps.  \n2. After the installation, you can now proceed with programming your **RAK12007** module. Simply copy the **RAK12007 LoRaWAN Application** code below and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE\nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n```c\n\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h> //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define  RAK4631_BOARD true\n#else\n#define  RAK4631_BOARD false\n#endif\n\n// Section to add include libraries, declarations and variables.\n\n#define Enable WB_IO2\n#define TRIG WB_IO6\n#define ECHO WB_IO4\n#define PD   WB_IO5   //power done control \uff08=1 power done\uff0c=0 power on\uff09\n\n#define TIME_OUT  24125 //max measure distance is 4m,the velocity of sound is 331.6m/s in 0\u2103,TIME_OUT=4*2/331.6*1000000=24215us\n\nfloat ratio = 346.6/1000/2;   //velocity of sound =331.6+0.6*25\u2103(m/s),(Indoor temperature about 25\u2103)\n\nlong int duration_time();  //measure high level time\n\nlong int duration, mm;\n\nbool doOTAA = true;   // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                     /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                   /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5             /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                      /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                      /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = {LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF};\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = {BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler\n};\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x8B, 0x0E, 0x96, 0x86, 0xE8, 0x4E, 0xA3, 0xB5, 0x31, 0x42, 0xB3, 0x65, 0x75, 0xB1, 0xD3, 0xED};\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = {0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23};\nuint8_t nodeAppsKey[16] = {0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C};\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                     /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];            //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = {m_lora_app_data_buffer, 0, 0, 0, 0}; //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup()\n{\npinMode(Enable, OUTPUT);\ndigitalWrite(Enable, HIGH);\npinMode(ECHO, INPUT);   // Echo Pin of Ultrasonic Sensor is an Input\npinMode(TRIG, OUTPUT);  // Trigger Pin of Ultrasonic Sensor is an Output\npinMode(PD, OUTPUT);    // power done control pin is an Output\ndigitalWrite(TRIG,LOW);\ndigitalWrite(PD,LOW);\n\npinMode(LED_GREEN, OUTPUT);  // Output LED\npinMode(LED_BLUE, OUTPUT);   // Output LED\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial)\n{\nif ((millis() - timeout) < 5000)\n{\ndelay(100);\n}\nelse\n{\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA)\n{\nSerial.println(\"Type: OTAA\");\n}\nelse\n{\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion)\n{\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA)\n{\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n}\nelse\n{\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0)\n{\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"========================\");\nSerial.println(\"  RAK12007 LoRaWAN test \");\nSerial.println(\"========================\");\n\n}\n\nvoid loop()\n{\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\n// long int duration, mm;\ndigitalWrite(LED_BLUE,HIGH);\ndigitalWrite(LED_GREEN, HIGH);\nduration = duration_time();\nif(duration > 0)\n{\nmm = duration*ratio; //Test distance = (high level time\u00d7velocity of sound (340M/S) / 2,\ndigitalWrite(LED_BLUE,LOW);\ndigitalWrite(LED_GREEN, LOW);\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\nSerial.print(mm);\nSerial.print(\"mm\");\nSerial.println();\ndelay(15000);\n}\nelse\n{\nSerial.println(\"Out of range\");\n}\ndelay(50);\n\n}\n\nlong int duration_time()\n{\nlong int respondTime;\npinMode(TRIG, OUTPUT);\ndigitalWrite(TRIG, HIGH);\ndelayMicroseconds(12);   //pull high time need over 10us\ndigitalWrite(TRIG, LOW);\npinMode(ECHO, INPUT);\nrespondTime = pulseIn(ECHO, HIGH); // microseconds\ndelay(33);\nif(RAK4631_BOARD)\n{\nrespondTime = respondTime*0.7726; // Time calibration factor is 0.7726,to get real time microseconds for 4631board\n}\nSerial.printf(\"respond time is %d\\r\\n\",respondTime);\n\nif((respondTime>0)&&(respondTime < TIME_OUT))  //ECHO pin max timeout is 33000us according it's datasheet\n{\nreturn respondTime;\n}\nelse\n{\nreturn -1;\n}\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void)\n{\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void)\n{\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data)\n{\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class)\n{\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void)\n{\nif (lmh_join_status_get() != LMH_SET)\n{\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\ndata = \"Distance:\" + String(mm) + \"mm\";\nSerial.println(data);\n\nuint32_t mm_data = mm;\n\nm_lora_app_data.buffer[i++] = 0x0A;\nm_lora_app_data.buffer[i++] = (uint8_t)((mm_data & 0xFF000000) >> 24);\nm_lora_app_data.buffer[i++] = (uint8_t)((mm_data & 0x00FF0000) >> 16);\nm_lora_app_data.buffer[i++] = (uint8_t)((mm_data & 0x0000FF00) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(mm_data & 0x000000FF);\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS)\n{\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n}\nelse\n{\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The following steps will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired regions to work with. You can change this to a region that is applicable to you, like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc.  \nThe following table lists the LoRaWAN regions and the countries where they are used:  \n| LoRaWAN Region         | Usage                                                             |\n| ---------------------- | ----------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1 | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan          |\n| LORAMAC_REGION_AS923-2 | Vietnam                                                           |\n| LORAMAC_REGION_AS923-3 | Philippines, Albania, Algeria, Denmark, Greenland, Jordan         |\n| LORAMAC_REGION_AS923-4 | Israel                                                            |\n| LORAMAC_REGION_AU915   | Australia, Anguilla, Argentina, and other parts of South America  |\n| LORAMAC_REGION_CN470   | China                                                             |\n| LORAMAC_REGION_EU433   | EU, UK, Brazil, Costa Rica, Cuba, and other parts of Africa       |\n| LORAMAC_REGION_IN865   | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger |\n| LORAMAC_REGION_EU868   | EU, UK and other parts of Africa                                  |\n| LORAMAC_REGION_KR920   | Republic of Korea                                                 |\n| LORAMAC_REGION_US915   | USA                                                               |\n| LORAMAC_REGION_RU864   | Russia                                                            |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n\n```\n- Set up the LoRaWAN activation method. In this case, you will use the **OTAA** configuration, which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change it to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n\n```  \n- Set up the EUIs and KEY. The **DeviceEUI**, **AppEUI**, and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x8B, 0x0E, 0x96, 0x86, 0xE8, 0x4E, 0xA3, 0xB5, 0x31, 0x42, 0xB3, 0x65, 0x75, 0xB1, 0xD3, 0xED};\n\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once you're done with the code, you can now proceed with uploading it to your device. You must first choose your RAK4631 board on your desktop or laptop. To do so, navigate to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** and select **WisBlock RAK4631**.  \n> **Image:** Selecting the RAK4631 board  \n4. After you have selected your board, go to **Tools** > **Port** and then select the specific port of your board.  \n> **Image:** Selecting the port of RAK4631 board  \n5. You can then upload your code by clicking the Upload button (the right arrow sign). Once completed, the **Device programmed** notification will appear in the console at the bottom of the Arduino IDE.  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "e306cab03f48d1287f01b836f0ceeb6f", "product_family": "wisblock", "product_id": "kit3-movement-detection", "category": "How-To", "title": "WisBlock Movement Detection Kit Quick Start Guide > WisBlock IoT Education Kit - Movement Detection Quick Start Guide > Product Configuration > Software Configuration and Examples > RAK12007 Ultrasonic Sensor LoRaWAN Application > LoRaWAN Code for RAK12007 > Programming RAK12007 Module with Arduino IDE [CODE]", "content": "/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = {BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler\n};\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};", "keywords": ["Arduino IDE", "RAK4631", "RAK12007", "LoRaWAN", "programming"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed on your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you have not yet installed the **Arduino IDE**, go to the [RAK4631 Installation](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#arduino-ide-installation-rak4631) section and execute the following steps.  \n2. After the installation, you can now proceed with programming your **RAK12007** module. Simply copy the **RAK12007 LoRaWAN Application** code below and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE\nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n```c\n\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h> //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define  RAK4631_BOARD true\n#else\n#define  RAK4631_BOARD false\n#endif\n\n// Section to add include libraries, declarations and variables.\n\n#define Enable WB_IO2\n#define TRIG WB_IO6\n#define ECHO WB_IO4\n#define PD   WB_IO5   //power done control \uff08=1 power done\uff0c=0 power on\uff09\n\n#define TIME_OUT  24125 //max measure distance is 4m,the velocity of sound is 331.6m/s in 0\u2103,TIME_OUT=4*2/331.6*1000000=24215us\n\nfloat ratio = 346.6/1000/2;   //velocity of sound =331.6+0.6*25\u2103(m/s),(Indoor temperature about 25\u2103)\n\nlong int duration_time();  //measure high level time\n\nlong int duration, mm;\n\nbool doOTAA = true;   // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                     /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                   /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5             /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                      /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                      /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = {LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF};\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = {BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler\n};\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x8B, 0x0E, 0x96, 0x86, 0xE8, 0x4E, 0xA3, 0xB5, 0x31, 0x42, 0xB3, 0x65, 0x75, 0xB1, 0xD3, 0xED};\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = {0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23};\nuint8_t nodeAppsKey[16] = {0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C};\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                     /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];            //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = {m_lora_app_data_buffer, 0, 0, 0, 0}; //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup()\n{\npinMode(Enable, OUTPUT);\ndigitalWrite(Enable, HIGH);\npinMode(ECHO, INPUT);   // Echo Pin of Ultrasonic Sensor is an Input\npinMode(TRIG, OUTPUT);  // Trigger Pin of Ultrasonic Sensor is an Output\npinMode(PD, OUTPUT);    // power done control pin is an Output\ndigitalWrite(TRIG,LOW);\ndigitalWrite(PD,LOW);\n\npinMode(LED_GREEN, OUTPUT);  // Output LED\npinMode(LED_BLUE, OUTPUT);   // Output LED\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial)\n{\nif ((millis() - timeout) < 5000)\n{\ndelay(100);\n}\nelse\n{\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA)\n{\nSerial.println(\"Type: OTAA\");\n}\nelse\n{\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion)\n{\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA)\n{\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n}\nelse\n{\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0)\n{\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"========================\");\nSerial.println(\"  RAK12007 LoRaWAN test \");\nSerial.println(\"========================\");\n\n}\n\nvoid loop()\n{\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\n// long int duration, mm;\ndigitalWrite(LED_BLUE,HIGH);\ndigitalWrite(LED_GREEN, HIGH);\nduration = duration_time();\nif(duration > 0)\n{\nmm = duration*ratio; //Test distance = (high level time\u00d7velocity of sound (340M/S) / 2,\ndigitalWrite(LED_BLUE,LOW);\ndigitalWrite(LED_GREEN, LOW);\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\nSerial.print(mm);\nSerial.print(\"mm\");\nSerial.println();\ndelay(15000);\n}\nelse\n{\nSerial.println(\"Out of range\");\n}\ndelay(50);\n\n}\n\nlong int duration_time()\n{\nlong int respondTime;\npinMode(TRIG, OUTPUT);\ndigitalWrite(TRIG, HIGH);\ndelayMicroseconds(12);   //pull high time need over 10us\ndigitalWrite(TRIG, LOW);\npinMode(ECHO, INPUT);\nrespondTime = pulseIn(ECHO, HIGH); // microseconds\ndelay(33);\nif(RAK4631_BOARD)\n{\nrespondTime = respondTime*0.7726; // Time calibration factor is 0.7726,to get real time microseconds for 4631board\n}\nSerial.printf(\"respond time is %d\\r\\n\",respondTime);\n\nif((respondTime>0)&&(respondTime < TIME_OUT))  //ECHO pin max timeout is 33000us according it's datasheet\n{\nreturn respondTime;\n}\nelse\n{\nreturn -1;\n}\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void)\n{\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void)\n{\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data)\n{\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class)\n{\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void)\n{\nif (lmh_join_status_get() != LMH_SET)\n{\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\ndata = \"Distance:\" + String(mm) + \"mm\";\nSerial.println(data);\n\nuint32_t mm_data = mm;\n\nm_lora_app_data.buffer[i++] = 0x0A;\nm_lora_app_data.buffer[i++] = (uint8_t)((mm_data & 0xFF000000) >> 24);\nm_lora_app_data.buffer[i++] = (uint8_t)((mm_data & 0x00FF0000) >> 16);\nm_lora_app_data.buffer[i++] = (uint8_t)((mm_data & 0x0000FF00) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(mm_data & 0x000000FF);\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS)\n{\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n}\nelse\n{\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The following steps will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired regions to work with. You can change this to a region that is applicable to you, like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc.  \nThe following table lists the LoRaWAN regions and the countries where they are used:  \n| LoRaWAN Region         | Usage                                                             |\n| ---------------------- | ----------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1 | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan          |\n| LORAMAC_REGION_AS923-2 | Vietnam                                                           |\n| LORAMAC_REGION_AS923-3 | Philippines, Albania, Algeria, Denmark, Greenland, Jordan         |\n| LORAMAC_REGION_AS923-4 | Israel                                                            |\n| LORAMAC_REGION_AU915   | Australia, Anguilla, Argentina, and other parts of South America  |\n| LORAMAC_REGION_CN470   | China                                                             |\n| LORAMAC_REGION_EU433   | EU, UK, Brazil, Costa Rica, Cuba, and other parts of Africa       |\n| LORAMAC_REGION_IN865   | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger |\n| LORAMAC_REGION_EU868   | EU, UK and other parts of Africa                                  |\n| LORAMAC_REGION_KR920   | Republic of Korea                                                 |\n| LORAMAC_REGION_US915   | USA                                                               |\n| LORAMAC_REGION_RU864   | Russia                                                            |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n\n```\n- Set up the LoRaWAN activation method. In this case, you will use the **OTAA** configuration, which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change it to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n\n```  \n- Set up the EUIs and KEY. The **DeviceEUI**, **AppEUI**, and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x8B, 0x0E, 0x96, 0x86, 0xE8, 0x4E, 0xA3, 0xB5, 0x31, 0x42, 0xB3, 0x65, 0x75, 0xB1, 0xD3, 0xED};\n\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once you're done with the code, you can now proceed with uploading it to your device. You must first choose your RAK4631 board on your desktop or laptop. To do so, navigate to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** and select **WisBlock RAK4631**.  \n> **Image:** Selecting the RAK4631 board  \n4. After you have selected your board, go to **Tools** > **Port** and then select the specific port of your board.  \n> **Image:** Selecting the port of RAK4631 board  \n5. You can then upload your code by clicking the Upload button (the right arrow sign). Once completed, the **Device programmed** notification will appear in the console at the bottom of the Arduino IDE.  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "55d6da914729e10d2844d36bc7779c7f", "product_family": "wisblock", "product_id": "kit3-movement-detection", "category": "How-To", "title": "WisBlock Movement Detection Kit Quick Start Guide > WisBlock IoT Education Kit - Movement Detection Quick Start Guide > Product Configuration > Software Configuration and Examples > RAK12007 Ultrasonic Sensor LoRaWAN Application > LoRaWAN Code for RAK12007 > Programming RAK12007 Module with Arduino IDE [CODE]", "content": "uint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x8B, 0x0E, 0x96, 0x86, 0xE8, 0x4E, 0xA3, 0xB5, 0x31, 0x42, 0xB3, 0x65, 0x75, 0xB1, 0xD3, 0xED};", "keywords": ["Arduino IDE", "RAK4631", "RAK12007", "LoRaWAN", "programming"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed on your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you have not yet installed the **Arduino IDE**, go to the [RAK4631 Installation](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#arduino-ide-installation-rak4631) section and execute the following steps.  \n2. After the installation, you can now proceed with programming your **RAK12007** module. Simply copy the **RAK12007 LoRaWAN Application** code below and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE\nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n```c\n\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h> //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define  RAK4631_BOARD true\n#else\n#define  RAK4631_BOARD false\n#endif\n\n// Section to add include libraries, declarations and variables.\n\n#define Enable WB_IO2\n#define TRIG WB_IO6\n#define ECHO WB_IO4\n#define PD   WB_IO5   //power done control \uff08=1 power done\uff0c=0 power on\uff09\n\n#define TIME_OUT  24125 //max measure distance is 4m,the velocity of sound is 331.6m/s in 0\u2103,TIME_OUT=4*2/331.6*1000000=24215us\n\nfloat ratio = 346.6/1000/2;   //velocity of sound =331.6+0.6*25\u2103(m/s),(Indoor temperature about 25\u2103)\n\nlong int duration_time();  //measure high level time\n\nlong int duration, mm;\n\nbool doOTAA = true;   // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                     /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                   /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5             /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                      /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                      /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = {LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF};\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = {BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler\n};\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x8B, 0x0E, 0x96, 0x86, 0xE8, 0x4E, 0xA3, 0xB5, 0x31, 0x42, 0xB3, 0x65, 0x75, 0xB1, 0xD3, 0xED};\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = {0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23};\nuint8_t nodeAppsKey[16] = {0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C};\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                     /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];            //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = {m_lora_app_data_buffer, 0, 0, 0, 0}; //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup()\n{\npinMode(Enable, OUTPUT);\ndigitalWrite(Enable, HIGH);\npinMode(ECHO, INPUT);   // Echo Pin of Ultrasonic Sensor is an Input\npinMode(TRIG, OUTPUT);  // Trigger Pin of Ultrasonic Sensor is an Output\npinMode(PD, OUTPUT);    // power done control pin is an Output\ndigitalWrite(TRIG,LOW);\ndigitalWrite(PD,LOW);\n\npinMode(LED_GREEN, OUTPUT);  // Output LED\npinMode(LED_BLUE, OUTPUT);   // Output LED\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial)\n{\nif ((millis() - timeout) < 5000)\n{\ndelay(100);\n}\nelse\n{\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA)\n{\nSerial.println(\"Type: OTAA\");\n}\nelse\n{\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion)\n{\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA)\n{\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n}\nelse\n{\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0)\n{\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"========================\");\nSerial.println(\"  RAK12007 LoRaWAN test \");\nSerial.println(\"========================\");\n\n}\n\nvoid loop()\n{\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\n// long int duration, mm;\ndigitalWrite(LED_BLUE,HIGH);\ndigitalWrite(LED_GREEN, HIGH);\nduration = duration_time();\nif(duration > 0)\n{\nmm = duration*ratio; //Test distance = (high level time\u00d7velocity of sound (340M/S) / 2,\ndigitalWrite(LED_BLUE,LOW);\ndigitalWrite(LED_GREEN, LOW);\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\nSerial.print(mm);\nSerial.print(\"mm\");\nSerial.println();\ndelay(15000);\n}\nelse\n{\nSerial.println(\"Out of range\");\n}\ndelay(50);\n\n}\n\nlong int duration_time()\n{\nlong int respondTime;\npinMode(TRIG, OUTPUT);\ndigitalWrite(TRIG, HIGH);\ndelayMicroseconds(12);   //pull high time need over 10us\ndigitalWrite(TRIG, LOW);\npinMode(ECHO, INPUT);\nrespondTime = pulseIn(ECHO, HIGH); // microseconds\ndelay(33);\nif(RAK4631_BOARD)\n{\nrespondTime = respondTime*0.7726; // Time calibration factor is 0.7726,to get real time microseconds for 4631board\n}\nSerial.printf(\"respond time is %d\\r\\n\",respondTime);\n\nif((respondTime>0)&&(respondTime < TIME_OUT))  //ECHO pin max timeout is 33000us according it's datasheet\n{\nreturn respondTime;\n}\nelse\n{\nreturn -1;\n}\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void)\n{\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void)\n{\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data)\n{\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class)\n{\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void)\n{\nif (lmh_join_status_get() != LMH_SET)\n{\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\ndata = \"Distance:\" + String(mm) + \"mm\";\nSerial.println(data);\n\nuint32_t mm_data = mm;\n\nm_lora_app_data.buffer[i++] = 0x0A;\nm_lora_app_data.buffer[i++] = (uint8_t)((mm_data & 0xFF000000) >> 24);\nm_lora_app_data.buffer[i++] = (uint8_t)((mm_data & 0x00FF0000) >> 16);\nm_lora_app_data.buffer[i++] = (uint8_t)((mm_data & 0x0000FF00) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(mm_data & 0x000000FF);\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS)\n{\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n}\nelse\n{\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The following steps will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired regions to work with. You can change this to a region that is applicable to you, like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc.  \nThe following table lists the LoRaWAN regions and the countries where they are used:  \n| LoRaWAN Region         | Usage                                                             |\n| ---------------------- | ----------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1 | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan          |\n| LORAMAC_REGION_AS923-2 | Vietnam                                                           |\n| LORAMAC_REGION_AS923-3 | Philippines, Albania, Algeria, Denmark, Greenland, Jordan         |\n| LORAMAC_REGION_AS923-4 | Israel                                                            |\n| LORAMAC_REGION_AU915   | Australia, Anguilla, Argentina, and other parts of South America  |\n| LORAMAC_REGION_CN470   | China                                                             |\n| LORAMAC_REGION_EU433   | EU, UK, Brazil, Costa Rica, Cuba, and other parts of Africa       |\n| LORAMAC_REGION_IN865   | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger |\n| LORAMAC_REGION_EU868   | EU, UK and other parts of Africa                                  |\n| LORAMAC_REGION_KR920   | Republic of Korea                                                 |\n| LORAMAC_REGION_US915   | USA                                                               |\n| LORAMAC_REGION_RU864   | Russia                                                            |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n\n```\n- Set up the LoRaWAN activation method. In this case, you will use the **OTAA** configuration, which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change it to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n\n```  \n- Set up the EUIs and KEY. The **DeviceEUI**, **AppEUI**, and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x8B, 0x0E, 0x96, 0x86, 0xE8, 0x4E, 0xA3, 0xB5, 0x31, 0x42, 0xB3, 0x65, 0x75, 0xB1, 0xD3, 0xED};\n\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once you're done with the code, you can now proceed with uploading it to your device. You must first choose your RAK4631 board on your desktop or laptop. To do so, navigate to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** and select **WisBlock RAK4631**.  \n> **Image:** Selecting the RAK4631 board  \n4. After you have selected your board, go to **Tools** > **Port** and then select the specific port of your board.  \n> **Image:** Selecting the port of RAK4631 board  \n5. You can then upload your code by clicking the Upload button (the right arrow sign). Once completed, the **Device programmed** notification will appear in the console at the bottom of the Arduino IDE.  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "4e19288743a81df06ebefabadd43903c", "product_family": "wisblock", "product_id": "kit3-movement-detection", "category": "How-To", "title": "WisBlock Movement Detection Kit Quick Start Guide > WisBlock IoT Education Kit - Movement Detection Quick Start Guide > Product Configuration > Software Configuration and Examples > RAK12007 Ultrasonic Sensor LoRaWAN Application > LoRaWAN Code for RAK12007 > Programming RAK12007 Module with Arduino IDE [CODE]", "content": "// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = {0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23};\nuint8_t nodeAppsKey[16] = {0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C};", "keywords": ["Arduino IDE", "RAK4631", "RAK12007", "LoRaWAN", "programming"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed on your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you have not yet installed the **Arduino IDE**, go to the [RAK4631 Installation](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#arduino-ide-installation-rak4631) section and execute the following steps.  \n2. After the installation, you can now proceed with programming your **RAK12007** module. Simply copy the **RAK12007 LoRaWAN Application** code below and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE\nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n```c\n\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h> //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define  RAK4631_BOARD true\n#else\n#define  RAK4631_BOARD false\n#endif\n\n// Section to add include libraries, declarations and variables.\n\n#define Enable WB_IO2\n#define TRIG WB_IO6\n#define ECHO WB_IO4\n#define PD   WB_IO5   //power done control \uff08=1 power done\uff0c=0 power on\uff09\n\n#define TIME_OUT  24125 //max measure distance is 4m,the velocity of sound is 331.6m/s in 0\u2103,TIME_OUT=4*2/331.6*1000000=24215us\n\nfloat ratio = 346.6/1000/2;   //velocity of sound =331.6+0.6*25\u2103(m/s),(Indoor temperature about 25\u2103)\n\nlong int duration_time();  //measure high level time\n\nlong int duration, mm;\n\nbool doOTAA = true;   // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                     /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                   /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5             /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                      /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                      /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = {LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF};\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = {BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler\n};\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x8B, 0x0E, 0x96, 0x86, 0xE8, 0x4E, 0xA3, 0xB5, 0x31, 0x42, 0xB3, 0x65, 0x75, 0xB1, 0xD3, 0xED};\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = {0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23};\nuint8_t nodeAppsKey[16] = {0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C};\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                     /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];            //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = {m_lora_app_data_buffer, 0, 0, 0, 0}; //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup()\n{\npinMode(Enable, OUTPUT);\ndigitalWrite(Enable, HIGH);\npinMode(ECHO, INPUT);   // Echo Pin of Ultrasonic Sensor is an Input\npinMode(TRIG, OUTPUT);  // Trigger Pin of Ultrasonic Sensor is an Output\npinMode(PD, OUTPUT);    // power done control pin is an Output\ndigitalWrite(TRIG,LOW);\ndigitalWrite(PD,LOW);\n\npinMode(LED_GREEN, OUTPUT);  // Output LED\npinMode(LED_BLUE, OUTPUT);   // Output LED\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial)\n{\nif ((millis() - timeout) < 5000)\n{\ndelay(100);\n}\nelse\n{\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA)\n{\nSerial.println(\"Type: OTAA\");\n}\nelse\n{\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion)\n{\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA)\n{\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n}\nelse\n{\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0)\n{\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"========================\");\nSerial.println(\"  RAK12007 LoRaWAN test \");\nSerial.println(\"========================\");\n\n}\n\nvoid loop()\n{\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\n// long int duration, mm;\ndigitalWrite(LED_BLUE,HIGH);\ndigitalWrite(LED_GREEN, HIGH);\nduration = duration_time();\nif(duration > 0)\n{\nmm = duration*ratio; //Test distance = (high level time\u00d7velocity of sound (340M/S) / 2,\ndigitalWrite(LED_BLUE,LOW);\ndigitalWrite(LED_GREEN, LOW);\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\nSerial.print(mm);\nSerial.print(\"mm\");\nSerial.println();\ndelay(15000);\n}\nelse\n{\nSerial.println(\"Out of range\");\n}\ndelay(50);\n\n}\n\nlong int duration_time()\n{\nlong int respondTime;\npinMode(TRIG, OUTPUT);\ndigitalWrite(TRIG, HIGH);\ndelayMicroseconds(12);   //pull high time need over 10us\ndigitalWrite(TRIG, LOW);\npinMode(ECHO, INPUT);\nrespondTime = pulseIn(ECHO, HIGH); // microseconds\ndelay(33);\nif(RAK4631_BOARD)\n{\nrespondTime = respondTime*0.7726; // Time calibration factor is 0.7726,to get real time microseconds for 4631board\n}\nSerial.printf(\"respond time is %d\\r\\n\",respondTime);\n\nif((respondTime>0)&&(respondTime < TIME_OUT))  //ECHO pin max timeout is 33000us according it's datasheet\n{\nreturn respondTime;\n}\nelse\n{\nreturn -1;\n}\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void)\n{\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void)\n{\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data)\n{\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class)\n{\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void)\n{\nif (lmh_join_status_get() != LMH_SET)\n{\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\ndata = \"Distance:\" + String(mm) + \"mm\";\nSerial.println(data);\n\nuint32_t mm_data = mm;\n\nm_lora_app_data.buffer[i++] = 0x0A;\nm_lora_app_data.buffer[i++] = (uint8_t)((mm_data & 0xFF000000) >> 24);\nm_lora_app_data.buffer[i++] = (uint8_t)((mm_data & 0x00FF0000) >> 16);\nm_lora_app_data.buffer[i++] = (uint8_t)((mm_data & 0x0000FF00) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(mm_data & 0x000000FF);\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS)\n{\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n}\nelse\n{\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The following steps will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired regions to work with. You can change this to a region that is applicable to you, like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc.  \nThe following table lists the LoRaWAN regions and the countries where they are used:  \n| LoRaWAN Region         | Usage                                                             |\n| ---------------------- | ----------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1 | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan          |\n| LORAMAC_REGION_AS923-2 | Vietnam                                                           |\n| LORAMAC_REGION_AS923-3 | Philippines, Albania, Algeria, Denmark, Greenland, Jordan         |\n| LORAMAC_REGION_AS923-4 | Israel                                                            |\n| LORAMAC_REGION_AU915   | Australia, Anguilla, Argentina, and other parts of South America  |\n| LORAMAC_REGION_CN470   | China                                                             |\n| LORAMAC_REGION_EU433   | EU, UK, Brazil, Costa Rica, Cuba, and other parts of Africa       |\n| LORAMAC_REGION_IN865   | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger |\n| LORAMAC_REGION_EU868   | EU, UK and other parts of Africa                                  |\n| LORAMAC_REGION_KR920   | Republic of Korea                                                 |\n| LORAMAC_REGION_US915   | USA                                                               |\n| LORAMAC_REGION_RU864   | Russia                                                            |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n\n```\n- Set up the LoRaWAN activation method. In this case, you will use the **OTAA** configuration, which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change it to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n\n```  \n- Set up the EUIs and KEY. The **DeviceEUI**, **AppEUI**, and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x8B, 0x0E, 0x96, 0x86, 0xE8, 0x4E, 0xA3, 0xB5, 0x31, 0x42, 0xB3, 0x65, 0x75, 0xB1, 0xD3, 0xED};\n\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once you're done with the code, you can now proceed with uploading it to your device. You must first choose your RAK4631 board on your desktop or laptop. To do so, navigate to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** and select **WisBlock RAK4631**.  \n> **Image:** Selecting the RAK4631 board  \n4. After you have selected your board, go to **Tools** > **Port** and then select the specific port of your board.  \n> **Image:** Selecting the port of RAK4631 board  \n5. You can then upload your code by clicking the Upload button (the right arrow sign). Once completed, the **Device programmed** notification will appear in the console at the bottom of the Arduino IDE.  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "aa51d0ef938e6d48d6cf25ea7947a53e", "product_family": "wisblock", "product_id": "kit3-movement-detection", "category": "How-To", "title": "WisBlock Movement Detection Kit Quick Start Guide > WisBlock IoT Education Kit - Movement Detection Quick Start Guide > Product Configuration > Software Configuration and Examples > RAK12007 Ultrasonic Sensor LoRaWAN Application > LoRaWAN Code for RAK12007 > Programming RAK12007 Module with Arduino IDE [CODE]", "content": "// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                     /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];            //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = {m_lora_app_data_buffer, 0, 0, 0, 0}; //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;", "keywords": ["Arduino IDE", "RAK4631", "RAK12007", "LoRaWAN", "programming"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed on your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you have not yet installed the **Arduino IDE**, go to the [RAK4631 Installation](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#arduino-ide-installation-rak4631) section and execute the following steps.  \n2. After the installation, you can now proceed with programming your **RAK12007** module. Simply copy the **RAK12007 LoRaWAN Application** code below and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE\nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n```c\n\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h> //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define  RAK4631_BOARD true\n#else\n#define  RAK4631_BOARD false\n#endif\n\n// Section to add include libraries, declarations and variables.\n\n#define Enable WB_IO2\n#define TRIG WB_IO6\n#define ECHO WB_IO4\n#define PD   WB_IO5   //power done control \uff08=1 power done\uff0c=0 power on\uff09\n\n#define TIME_OUT  24125 //max measure distance is 4m,the velocity of sound is 331.6m/s in 0\u2103,TIME_OUT=4*2/331.6*1000000=24215us\n\nfloat ratio = 346.6/1000/2;   //velocity of sound =331.6+0.6*25\u2103(m/s),(Indoor temperature about 25\u2103)\n\nlong int duration_time();  //measure high level time\n\nlong int duration, mm;\n\nbool doOTAA = true;   // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                     /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                   /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5             /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                      /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                      /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = {LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF};\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = {BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler\n};\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x8B, 0x0E, 0x96, 0x86, 0xE8, 0x4E, 0xA3, 0xB5, 0x31, 0x42, 0xB3, 0x65, 0x75, 0xB1, 0xD3, 0xED};\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = {0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23};\nuint8_t nodeAppsKey[16] = {0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C};\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                     /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];            //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = {m_lora_app_data_buffer, 0, 0, 0, 0}; //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup()\n{\npinMode(Enable, OUTPUT);\ndigitalWrite(Enable, HIGH);\npinMode(ECHO, INPUT);   // Echo Pin of Ultrasonic Sensor is an Input\npinMode(TRIG, OUTPUT);  // Trigger Pin of Ultrasonic Sensor is an Output\npinMode(PD, OUTPUT);    // power done control pin is an Output\ndigitalWrite(TRIG,LOW);\ndigitalWrite(PD,LOW);\n\npinMode(LED_GREEN, OUTPUT);  // Output LED\npinMode(LED_BLUE, OUTPUT);   // Output LED\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial)\n{\nif ((millis() - timeout) < 5000)\n{\ndelay(100);\n}\nelse\n{\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA)\n{\nSerial.println(\"Type: OTAA\");\n}\nelse\n{\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion)\n{\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA)\n{\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n}\nelse\n{\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0)\n{\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"========================\");\nSerial.println(\"  RAK12007 LoRaWAN test \");\nSerial.println(\"========================\");\n\n}\n\nvoid loop()\n{\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\n// long int duration, mm;\ndigitalWrite(LED_BLUE,HIGH);\ndigitalWrite(LED_GREEN, HIGH);\nduration = duration_time();\nif(duration > 0)\n{\nmm = duration*ratio; //Test distance = (high level time\u00d7velocity of sound (340M/S) / 2,\ndigitalWrite(LED_BLUE,LOW);\ndigitalWrite(LED_GREEN, LOW);\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\nSerial.print(mm);\nSerial.print(\"mm\");\nSerial.println();\ndelay(15000);\n}\nelse\n{\nSerial.println(\"Out of range\");\n}\ndelay(50);\n\n}\n\nlong int duration_time()\n{\nlong int respondTime;\npinMode(TRIG, OUTPUT);\ndigitalWrite(TRIG, HIGH);\ndelayMicroseconds(12);   //pull high time need over 10us\ndigitalWrite(TRIG, LOW);\npinMode(ECHO, INPUT);\nrespondTime = pulseIn(ECHO, HIGH); // microseconds\ndelay(33);\nif(RAK4631_BOARD)\n{\nrespondTime = respondTime*0.7726; // Time calibration factor is 0.7726,to get real time microseconds for 4631board\n}\nSerial.printf(\"respond time is %d\\r\\n\",respondTime);\n\nif((respondTime>0)&&(respondTime < TIME_OUT))  //ECHO pin max timeout is 33000us according it's datasheet\n{\nreturn respondTime;\n}\nelse\n{\nreturn -1;\n}\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void)\n{\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void)\n{\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data)\n{\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class)\n{\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void)\n{\nif (lmh_join_status_get() != LMH_SET)\n{\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\ndata = \"Distance:\" + String(mm) + \"mm\";\nSerial.println(data);\n\nuint32_t mm_data = mm;\n\nm_lora_app_data.buffer[i++] = 0x0A;\nm_lora_app_data.buffer[i++] = (uint8_t)((mm_data & 0xFF000000) >> 24);\nm_lora_app_data.buffer[i++] = (uint8_t)((mm_data & 0x00FF0000) >> 16);\nm_lora_app_data.buffer[i++] = (uint8_t)((mm_data & 0x0000FF00) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(mm_data & 0x000000FF);\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS)\n{\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n}\nelse\n{\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The following steps will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired regions to work with. You can change this to a region that is applicable to you, like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc.  \nThe following table lists the LoRaWAN regions and the countries where they are used:  \n| LoRaWAN Region         | Usage                                                             |\n| ---------------------- | ----------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1 | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan          |\n| LORAMAC_REGION_AS923-2 | Vietnam                                                           |\n| LORAMAC_REGION_AS923-3 | Philippines, Albania, Algeria, Denmark, Greenland, Jordan         |\n| LORAMAC_REGION_AS923-4 | Israel                                                            |\n| LORAMAC_REGION_AU915   | Australia, Anguilla, Argentina, and other parts of South America  |\n| LORAMAC_REGION_CN470   | China                                                             |\n| LORAMAC_REGION_EU433   | EU, UK, Brazil, Costa Rica, Cuba, and other parts of Africa       |\n| LORAMAC_REGION_IN865   | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger |\n| LORAMAC_REGION_EU868   | EU, UK and other parts of Africa                                  |\n| LORAMAC_REGION_KR920   | Republic of Korea                                                 |\n| LORAMAC_REGION_US915   | USA                                                               |\n| LORAMAC_REGION_RU864   | Russia                                                            |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n\n```\n- Set up the LoRaWAN activation method. In this case, you will use the **OTAA** configuration, which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change it to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n\n```  \n- Set up the EUIs and KEY. The **DeviceEUI**, **AppEUI**, and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x8B, 0x0E, 0x96, 0x86, 0xE8, 0x4E, 0xA3, 0xB5, 0x31, 0x42, 0xB3, 0x65, 0x75, 0xB1, 0xD3, 0xED};\n\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once you're done with the code, you can now proceed with uploading it to your device. You must first choose your RAK4631 board on your desktop or laptop. To do so, navigate to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** and select **WisBlock RAK4631**.  \n> **Image:** Selecting the RAK4631 board  \n4. After you have selected your board, go to **Tools** > **Port** and then select the specific port of your board.  \n> **Image:** Selecting the port of RAK4631 board  \n5. You can then upload your code by clicking the Upload button (the right arrow sign). Once completed, the **Device programmed** notification will appear in the console at the bottom of the Arduino IDE.  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "c37aafc15e17dbede719adb2dad91a36", "product_family": "wisblock", "product_id": "kit3-movement-detection", "category": "How-To", "title": "WisBlock Movement Detection Kit Quick Start Guide > WisBlock IoT Education Kit - Movement Detection Quick Start Guide > Product Configuration > Software Configuration and Examples > RAK12007 Ultrasonic Sensor LoRaWAN Application > LoRaWAN Code for RAK12007 > Programming RAK12007 Module with Arduino IDE [CODE]", "content": "static uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup()\n{\npinMode(Enable, OUTPUT);\ndigitalWrite(Enable, HIGH);\npinMode(ECHO, INPUT);   // Echo Pin of Ultrasonic Sensor is an Input\npinMode(TRIG, OUTPUT);  // Trigger Pin of Ultrasonic Sensor is an Output\npinMode(PD, OUTPUT);    // power done control pin is an Output\ndigitalWrite(TRIG,LOW);\ndigitalWrite(PD,LOW);\n\npinMode(LED_GREEN, OUTPUT);  // Output LED\npinMode(LED_BLUE, OUTPUT);   // Output LED", "keywords": ["Arduino IDE", "RAK4631", "RAK12007", "LoRaWAN", "programming"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed on your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you have not yet installed the **Arduino IDE**, go to the [RAK4631 Installation](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#arduino-ide-installation-rak4631) section and execute the following steps.  \n2. After the installation, you can now proceed with programming your **RAK12007** module. Simply copy the **RAK12007 LoRaWAN Application** code below and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE\nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n```c\n\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h> //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define  RAK4631_BOARD true\n#else\n#define  RAK4631_BOARD false\n#endif\n\n// Section to add include libraries, declarations and variables.\n\n#define Enable WB_IO2\n#define TRIG WB_IO6\n#define ECHO WB_IO4\n#define PD   WB_IO5   //power done control \uff08=1 power done\uff0c=0 power on\uff09\n\n#define TIME_OUT  24125 //max measure distance is 4m,the velocity of sound is 331.6m/s in 0\u2103,TIME_OUT=4*2/331.6*1000000=24215us\n\nfloat ratio = 346.6/1000/2;   //velocity of sound =331.6+0.6*25\u2103(m/s),(Indoor temperature about 25\u2103)\n\nlong int duration_time();  //measure high level time\n\nlong int duration, mm;\n\nbool doOTAA = true;   // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                     /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                   /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5             /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                      /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                      /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = {LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF};\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = {BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler\n};\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x8B, 0x0E, 0x96, 0x86, 0xE8, 0x4E, 0xA3, 0xB5, 0x31, 0x42, 0xB3, 0x65, 0x75, 0xB1, 0xD3, 0xED};\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = {0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23};\nuint8_t nodeAppsKey[16] = {0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C};\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                     /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];            //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = {m_lora_app_data_buffer, 0, 0, 0, 0}; //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup()\n{\npinMode(Enable, OUTPUT);\ndigitalWrite(Enable, HIGH);\npinMode(ECHO, INPUT);   // Echo Pin of Ultrasonic Sensor is an Input\npinMode(TRIG, OUTPUT);  // Trigger Pin of Ultrasonic Sensor is an Output\npinMode(PD, OUTPUT);    // power done control pin is an Output\ndigitalWrite(TRIG,LOW);\ndigitalWrite(PD,LOW);\n\npinMode(LED_GREEN, OUTPUT);  // Output LED\npinMode(LED_BLUE, OUTPUT);   // Output LED\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial)\n{\nif ((millis() - timeout) < 5000)\n{\ndelay(100);\n}\nelse\n{\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA)\n{\nSerial.println(\"Type: OTAA\");\n}\nelse\n{\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion)\n{\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA)\n{\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n}\nelse\n{\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0)\n{\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"========================\");\nSerial.println(\"  RAK12007 LoRaWAN test \");\nSerial.println(\"========================\");\n\n}\n\nvoid loop()\n{\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\n// long int duration, mm;\ndigitalWrite(LED_BLUE,HIGH);\ndigitalWrite(LED_GREEN, HIGH);\nduration = duration_time();\nif(duration > 0)\n{\nmm = duration*ratio; //Test distance = (high level time\u00d7velocity of sound (340M/S) / 2,\ndigitalWrite(LED_BLUE,LOW);\ndigitalWrite(LED_GREEN, LOW);\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\nSerial.print(mm);\nSerial.print(\"mm\");\nSerial.println();\ndelay(15000);\n}\nelse\n{\nSerial.println(\"Out of range\");\n}\ndelay(50);\n\n}\n\nlong int duration_time()\n{\nlong int respondTime;\npinMode(TRIG, OUTPUT);\ndigitalWrite(TRIG, HIGH);\ndelayMicroseconds(12);   //pull high time need over 10us\ndigitalWrite(TRIG, LOW);\npinMode(ECHO, INPUT);\nrespondTime = pulseIn(ECHO, HIGH); // microseconds\ndelay(33);\nif(RAK4631_BOARD)\n{\nrespondTime = respondTime*0.7726; // Time calibration factor is 0.7726,to get real time microseconds for 4631board\n}\nSerial.printf(\"respond time is %d\\r\\n\",respondTime);\n\nif((respondTime>0)&&(respondTime < TIME_OUT))  //ECHO pin max timeout is 33000us according it's datasheet\n{\nreturn respondTime;\n}\nelse\n{\nreturn -1;\n}\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void)\n{\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void)\n{\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data)\n{\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class)\n{\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void)\n{\nif (lmh_join_status_get() != LMH_SET)\n{\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\ndata = \"Distance:\" + String(mm) + \"mm\";\nSerial.println(data);\n\nuint32_t mm_data = mm;\n\nm_lora_app_data.buffer[i++] = 0x0A;\nm_lora_app_data.buffer[i++] = (uint8_t)((mm_data & 0xFF000000) >> 24);\nm_lora_app_data.buffer[i++] = (uint8_t)((mm_data & 0x00FF0000) >> 16);\nm_lora_app_data.buffer[i++] = (uint8_t)((mm_data & 0x0000FF00) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(mm_data & 0x000000FF);\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS)\n{\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n}\nelse\n{\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The following steps will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired regions to work with. You can change this to a region that is applicable to you, like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc.  \nThe following table lists the LoRaWAN regions and the countries where they are used:  \n| LoRaWAN Region         | Usage                                                             |\n| ---------------------- | ----------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1 | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan          |\n| LORAMAC_REGION_AS923-2 | Vietnam                                                           |\n| LORAMAC_REGION_AS923-3 | Philippines, Albania, Algeria, Denmark, Greenland, Jordan         |\n| LORAMAC_REGION_AS923-4 | Israel                                                            |\n| LORAMAC_REGION_AU915   | Australia, Anguilla, Argentina, and other parts of South America  |\n| LORAMAC_REGION_CN470   | China                                                             |\n| LORAMAC_REGION_EU433   | EU, UK, Brazil, Costa Rica, Cuba, and other parts of Africa       |\n| LORAMAC_REGION_IN865   | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger |\n| LORAMAC_REGION_EU868   | EU, UK and other parts of Africa                                  |\n| LORAMAC_REGION_KR920   | Republic of Korea                                                 |\n| LORAMAC_REGION_US915   | USA                                                               |\n| LORAMAC_REGION_RU864   | Russia                                                            |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n\n```\n- Set up the LoRaWAN activation method. In this case, you will use the **OTAA** configuration, which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change it to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n\n```  \n- Set up the EUIs and KEY. The **DeviceEUI**, **AppEUI**, and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x8B, 0x0E, 0x96, 0x86, 0xE8, 0x4E, 0xA3, 0xB5, 0x31, 0x42, 0xB3, 0x65, 0x75, 0xB1, 0xD3, 0xED};\n\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once you're done with the code, you can now proceed with uploading it to your device. You must first choose your RAK4631 board on your desktop or laptop. To do so, navigate to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** and select **WisBlock RAK4631**.  \n> **Image:** Selecting the RAK4631 board  \n4. After you have selected your board, go to **Tools** > **Port** and then select the specific port of your board.  \n> **Image:** Selecting the port of RAK4631 board  \n5. You can then upload your code by clicking the Upload button (the right arrow sign). Once completed, the **Device programmed** notification will appear in the console at the bottom of the Arduino IDE.  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "a0ce1a2455cf7bf23b5af92cd3b4a870", "product_family": "wisblock", "product_id": "kit3-movement-detection", "category": "How-To", "title": "WisBlock Movement Detection Kit Quick Start Guide > WisBlock IoT Education Kit - Movement Detection Quick Start Guide > Product Configuration > Software Configuration and Examples > RAK12007 Ultrasonic Sensor LoRaWAN Application > LoRaWAN Code for RAK12007 > Programming RAK12007 Module with Arduino IDE [CODE]", "content": "pinMode(LED_GREEN, OUTPUT);  // Output LED\npinMode(LED_BLUE, OUTPUT);   // Output LED\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial)\n{\nif ((millis() - timeout) < 5000)\n{\ndelay(100);\n}\nelse\n{\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA)\n{\nSerial.println(\"Type: OTAA\");\n}\nelse\n{\nSerial.println(\"Type: ABP\");\n}", "keywords": ["Arduino IDE", "RAK4631", "RAK12007", "LoRaWAN", "programming"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed on your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you have not yet installed the **Arduino IDE**, go to the [RAK4631 Installation](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#arduino-ide-installation-rak4631) section and execute the following steps.  \n2. After the installation, you can now proceed with programming your **RAK12007** module. Simply copy the **RAK12007 LoRaWAN Application** code below and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE\nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n```c\n\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h> //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define  RAK4631_BOARD true\n#else\n#define  RAK4631_BOARD false\n#endif\n\n// Section to add include libraries, declarations and variables.\n\n#define Enable WB_IO2\n#define TRIG WB_IO6\n#define ECHO WB_IO4\n#define PD   WB_IO5   //power done control \uff08=1 power done\uff0c=0 power on\uff09\n\n#define TIME_OUT  24125 //max measure distance is 4m,the velocity of sound is 331.6m/s in 0\u2103,TIME_OUT=4*2/331.6*1000000=24215us\n\nfloat ratio = 346.6/1000/2;   //velocity of sound =331.6+0.6*25\u2103(m/s),(Indoor temperature about 25\u2103)\n\nlong int duration_time();  //measure high level time\n\nlong int duration, mm;\n\nbool doOTAA = true;   // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                     /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                   /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5             /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                      /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                      /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = {LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF};\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = {BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler\n};\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x8B, 0x0E, 0x96, 0x86, 0xE8, 0x4E, 0xA3, 0xB5, 0x31, 0x42, 0xB3, 0x65, 0x75, 0xB1, 0xD3, 0xED};\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = {0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23};\nuint8_t nodeAppsKey[16] = {0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C};\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                     /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];            //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = {m_lora_app_data_buffer, 0, 0, 0, 0}; //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup()\n{\npinMode(Enable, OUTPUT);\ndigitalWrite(Enable, HIGH);\npinMode(ECHO, INPUT);   // Echo Pin of Ultrasonic Sensor is an Input\npinMode(TRIG, OUTPUT);  // Trigger Pin of Ultrasonic Sensor is an Output\npinMode(PD, OUTPUT);    // power done control pin is an Output\ndigitalWrite(TRIG,LOW);\ndigitalWrite(PD,LOW);\n\npinMode(LED_GREEN, OUTPUT);  // Output LED\npinMode(LED_BLUE, OUTPUT);   // Output LED\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial)\n{\nif ((millis() - timeout) < 5000)\n{\ndelay(100);\n}\nelse\n{\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA)\n{\nSerial.println(\"Type: OTAA\");\n}\nelse\n{\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion)\n{\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA)\n{\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n}\nelse\n{\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0)\n{\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"========================\");\nSerial.println(\"  RAK12007 LoRaWAN test \");\nSerial.println(\"========================\");\n\n}\n\nvoid loop()\n{\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\n// long int duration, mm;\ndigitalWrite(LED_BLUE,HIGH);\ndigitalWrite(LED_GREEN, HIGH);\nduration = duration_time();\nif(duration > 0)\n{\nmm = duration*ratio; //Test distance = (high level time\u00d7velocity of sound (340M/S) / 2,\ndigitalWrite(LED_BLUE,LOW);\ndigitalWrite(LED_GREEN, LOW);\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\nSerial.print(mm);\nSerial.print(\"mm\");\nSerial.println();\ndelay(15000);\n}\nelse\n{\nSerial.println(\"Out of range\");\n}\ndelay(50);\n\n}\n\nlong int duration_time()\n{\nlong int respondTime;\npinMode(TRIG, OUTPUT);\ndigitalWrite(TRIG, HIGH);\ndelayMicroseconds(12);   //pull high time need over 10us\ndigitalWrite(TRIG, LOW);\npinMode(ECHO, INPUT);\nrespondTime = pulseIn(ECHO, HIGH); // microseconds\ndelay(33);\nif(RAK4631_BOARD)\n{\nrespondTime = respondTime*0.7726; // Time calibration factor is 0.7726,to get real time microseconds for 4631board\n}\nSerial.printf(\"respond time is %d\\r\\n\",respondTime);\n\nif((respondTime>0)&&(respondTime < TIME_OUT))  //ECHO pin max timeout is 33000us according it's datasheet\n{\nreturn respondTime;\n}\nelse\n{\nreturn -1;\n}\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void)\n{\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void)\n{\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data)\n{\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class)\n{\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void)\n{\nif (lmh_join_status_get() != LMH_SET)\n{\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\ndata = \"Distance:\" + String(mm) + \"mm\";\nSerial.println(data);\n\nuint32_t mm_data = mm;\n\nm_lora_app_data.buffer[i++] = 0x0A;\nm_lora_app_data.buffer[i++] = (uint8_t)((mm_data & 0xFF000000) >> 24);\nm_lora_app_data.buffer[i++] = (uint8_t)((mm_data & 0x00FF0000) >> 16);\nm_lora_app_data.buffer[i++] = (uint8_t)((mm_data & 0x0000FF00) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(mm_data & 0x000000FF);\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS)\n{\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n}\nelse\n{\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The following steps will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired regions to work with. You can change this to a region that is applicable to you, like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc.  \nThe following table lists the LoRaWAN regions and the countries where they are used:  \n| LoRaWAN Region         | Usage                                                             |\n| ---------------------- | ----------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1 | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan          |\n| LORAMAC_REGION_AS923-2 | Vietnam                                                           |\n| LORAMAC_REGION_AS923-3 | Philippines, Albania, Algeria, Denmark, Greenland, Jordan         |\n| LORAMAC_REGION_AS923-4 | Israel                                                            |\n| LORAMAC_REGION_AU915   | Australia, Anguilla, Argentina, and other parts of South America  |\n| LORAMAC_REGION_CN470   | China                                                             |\n| LORAMAC_REGION_EU433   | EU, UK, Brazil, Costa Rica, Cuba, and other parts of Africa       |\n| LORAMAC_REGION_IN865   | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger |\n| LORAMAC_REGION_EU868   | EU, UK and other parts of Africa                                  |\n| LORAMAC_REGION_KR920   | Republic of Korea                                                 |\n| LORAMAC_REGION_US915   | USA                                                               |\n| LORAMAC_REGION_RU864   | Russia                                                            |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n\n```\n- Set up the LoRaWAN activation method. In this case, you will use the **OTAA** configuration, which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change it to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n\n```  \n- Set up the EUIs and KEY. The **DeviceEUI**, **AppEUI**, and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x8B, 0x0E, 0x96, 0x86, 0xE8, 0x4E, 0xA3, 0xB5, 0x31, 0x42, 0xB3, 0x65, 0x75, 0xB1, 0xD3, 0xED};\n\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once you're done with the code, you can now proceed with uploading it to your device. You must first choose your RAK4631 board on your desktop or laptop. To do so, navigate to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** and select **WisBlock RAK4631**.  \n> **Image:** Selecting the RAK4631 board  \n4. After you have selected your board, go to **Tools** > **Port** and then select the specific port of your board.  \n> **Image:** Selecting the port of RAK4631 board  \n5. You can then upload your code by clicking the Upload button (the right arrow sign). Once completed, the **Device programmed** notification will appear in the console at the bottom of the Arduino IDE.  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "e304fb1b0ea5909899d77fac8c468af2", "product_family": "wisblock", "product_id": "kit3-movement-detection", "category": "How-To", "title": "WisBlock Movement Detection Kit Quick Start Guide > WisBlock IoT Education Kit - Movement Detection Quick Start Guide > Product Configuration > Software Configuration and Examples > RAK12007 Ultrasonic Sensor LoRaWAN Application > LoRaWAN Code for RAK12007 > Programming RAK12007 Module with Arduino IDE [CODE]", "content": "switch (g_CurrentRegion)\n{\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;", "keywords": ["Arduino IDE", "RAK4631", "RAK12007", "LoRaWAN", "programming"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed on your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you have not yet installed the **Arduino IDE**, go to the [RAK4631 Installation](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#arduino-ide-installation-rak4631) section and execute the following steps.  \n2. After the installation, you can now proceed with programming your **RAK12007** module. Simply copy the **RAK12007 LoRaWAN Application** code below and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE\nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n```c\n\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h> //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define  RAK4631_BOARD true\n#else\n#define  RAK4631_BOARD false\n#endif\n\n// Section to add include libraries, declarations and variables.\n\n#define Enable WB_IO2\n#define TRIG WB_IO6\n#define ECHO WB_IO4\n#define PD   WB_IO5   //power done control \uff08=1 power done\uff0c=0 power on\uff09\n\n#define TIME_OUT  24125 //max measure distance is 4m,the velocity of sound is 331.6m/s in 0\u2103,TIME_OUT=4*2/331.6*1000000=24215us\n\nfloat ratio = 346.6/1000/2;   //velocity of sound =331.6+0.6*25\u2103(m/s),(Indoor temperature about 25\u2103)\n\nlong int duration_time();  //measure high level time\n\nlong int duration, mm;\n\nbool doOTAA = true;   // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                     /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                   /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5             /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                      /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                      /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = {LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF};\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = {BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler\n};\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x8B, 0x0E, 0x96, 0x86, 0xE8, 0x4E, 0xA3, 0xB5, 0x31, 0x42, 0xB3, 0x65, 0x75, 0xB1, 0xD3, 0xED};\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = {0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23};\nuint8_t nodeAppsKey[16] = {0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C};\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                     /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];            //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = {m_lora_app_data_buffer, 0, 0, 0, 0}; //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup()\n{\npinMode(Enable, OUTPUT);\ndigitalWrite(Enable, HIGH);\npinMode(ECHO, INPUT);   // Echo Pin of Ultrasonic Sensor is an Input\npinMode(TRIG, OUTPUT);  // Trigger Pin of Ultrasonic Sensor is an Output\npinMode(PD, OUTPUT);    // power done control pin is an Output\ndigitalWrite(TRIG,LOW);\ndigitalWrite(PD,LOW);\n\npinMode(LED_GREEN, OUTPUT);  // Output LED\npinMode(LED_BLUE, OUTPUT);   // Output LED\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial)\n{\nif ((millis() - timeout) < 5000)\n{\ndelay(100);\n}\nelse\n{\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA)\n{\nSerial.println(\"Type: OTAA\");\n}\nelse\n{\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion)\n{\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA)\n{\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n}\nelse\n{\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0)\n{\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"========================\");\nSerial.println(\"  RAK12007 LoRaWAN test \");\nSerial.println(\"========================\");\n\n}\n\nvoid loop()\n{\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\n// long int duration, mm;\ndigitalWrite(LED_BLUE,HIGH);\ndigitalWrite(LED_GREEN, HIGH);\nduration = duration_time();\nif(duration > 0)\n{\nmm = duration*ratio; //Test distance = (high level time\u00d7velocity of sound (340M/S) / 2,\ndigitalWrite(LED_BLUE,LOW);\ndigitalWrite(LED_GREEN, LOW);\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\nSerial.print(mm);\nSerial.print(\"mm\");\nSerial.println();\ndelay(15000);\n}\nelse\n{\nSerial.println(\"Out of range\");\n}\ndelay(50);\n\n}\n\nlong int duration_time()\n{\nlong int respondTime;\npinMode(TRIG, OUTPUT);\ndigitalWrite(TRIG, HIGH);\ndelayMicroseconds(12);   //pull high time need over 10us\ndigitalWrite(TRIG, LOW);\npinMode(ECHO, INPUT);\nrespondTime = pulseIn(ECHO, HIGH); // microseconds\ndelay(33);\nif(RAK4631_BOARD)\n{\nrespondTime = respondTime*0.7726; // Time calibration factor is 0.7726,to get real time microseconds for 4631board\n}\nSerial.printf(\"respond time is %d\\r\\n\",respondTime);\n\nif((respondTime>0)&&(respondTime < TIME_OUT))  //ECHO pin max timeout is 33000us according it's datasheet\n{\nreturn respondTime;\n}\nelse\n{\nreturn -1;\n}\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void)\n{\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void)\n{\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data)\n{\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class)\n{\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void)\n{\nif (lmh_join_status_get() != LMH_SET)\n{\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\ndata = \"Distance:\" + String(mm) + \"mm\";\nSerial.println(data);\n\nuint32_t mm_data = mm;\n\nm_lora_app_data.buffer[i++] = 0x0A;\nm_lora_app_data.buffer[i++] = (uint8_t)((mm_data & 0xFF000000) >> 24);\nm_lora_app_data.buffer[i++] = (uint8_t)((mm_data & 0x00FF0000) >> 16);\nm_lora_app_data.buffer[i++] = (uint8_t)((mm_data & 0x0000FF00) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(mm_data & 0x000000FF);\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS)\n{\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n}\nelse\n{\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The following steps will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired regions to work with. You can change this to a region that is applicable to you, like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc.  \nThe following table lists the LoRaWAN regions and the countries where they are used:  \n| LoRaWAN Region         | Usage                                                             |\n| ---------------------- | ----------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1 | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan          |\n| LORAMAC_REGION_AS923-2 | Vietnam                                                           |\n| LORAMAC_REGION_AS923-3 | Philippines, Albania, Algeria, Denmark, Greenland, Jordan         |\n| LORAMAC_REGION_AS923-4 | Israel                                                            |\n| LORAMAC_REGION_AU915   | Australia, Anguilla, Argentina, and other parts of South America  |\n| LORAMAC_REGION_CN470   | China                                                             |\n| LORAMAC_REGION_EU433   | EU, UK, Brazil, Costa Rica, Cuba, and other parts of Africa       |\n| LORAMAC_REGION_IN865   | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger |\n| LORAMAC_REGION_EU868   | EU, UK and other parts of Africa                                  |\n| LORAMAC_REGION_KR920   | Republic of Korea                                                 |\n| LORAMAC_REGION_US915   | USA                                                               |\n| LORAMAC_REGION_RU864   | Russia                                                            |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n\n```\n- Set up the LoRaWAN activation method. In this case, you will use the **OTAA** configuration, which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change it to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n\n```  \n- Set up the EUIs and KEY. The **DeviceEUI**, **AppEUI**, and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x8B, 0x0E, 0x96, 0x86, 0xE8, 0x4E, 0xA3, 0xB5, 0x31, 0x42, 0xB3, 0x65, 0x75, 0xB1, 0xD3, 0xED};\n\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once you're done with the code, you can now proceed with uploading it to your device. You must first choose your RAK4631 board on your desktop or laptop. To do so, navigate to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** and select **WisBlock RAK4631**.  \n> **Image:** Selecting the RAK4631 board  \n4. After you have selected your board, go to **Tools** > **Port** and then select the specific port of your board.  \n> **Image:** Selecting the port of RAK4631 board  \n5. You can then upload your code by clicking the Upload button (the right arrow sign). Once completed, the **Device programmed** notification will appear in the console at the bottom of the Arduino IDE.  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "9195de49b08a672ef89c737fe7fe9948", "product_family": "wisblock", "product_id": "kit3-movement-detection", "category": "How-To", "title": "WisBlock Movement Detection Kit Quick Start Guide > WisBlock IoT Education Kit - Movement Detection Quick Start Guide > Product Configuration > Software Configuration and Examples > RAK12007 Ultrasonic Sensor LoRaWAN Application > LoRaWAN Code for RAK12007 > Programming RAK12007 Module with Arduino IDE [CODE]", "content": "break;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");", "keywords": ["Arduino IDE", "RAK4631", "RAK12007", "LoRaWAN", "programming"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed on your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you have not yet installed the **Arduino IDE**, go to the [RAK4631 Installation](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#arduino-ide-installation-rak4631) section and execute the following steps.  \n2. After the installation, you can now proceed with programming your **RAK12007** module. Simply copy the **RAK12007 LoRaWAN Application** code below and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE\nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n```c\n\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h> //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define  RAK4631_BOARD true\n#else\n#define  RAK4631_BOARD false\n#endif\n\n// Section to add include libraries, declarations and variables.\n\n#define Enable WB_IO2\n#define TRIG WB_IO6\n#define ECHO WB_IO4\n#define PD   WB_IO5   //power done control \uff08=1 power done\uff0c=0 power on\uff09\n\n#define TIME_OUT  24125 //max measure distance is 4m,the velocity of sound is 331.6m/s in 0\u2103,TIME_OUT=4*2/331.6*1000000=24215us\n\nfloat ratio = 346.6/1000/2;   //velocity of sound =331.6+0.6*25\u2103(m/s),(Indoor temperature about 25\u2103)\n\nlong int duration_time();  //measure high level time\n\nlong int duration, mm;\n\nbool doOTAA = true;   // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                     /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                   /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5             /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                      /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                      /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = {LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF};\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = {BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler\n};\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x8B, 0x0E, 0x96, 0x86, 0xE8, 0x4E, 0xA3, 0xB5, 0x31, 0x42, 0xB3, 0x65, 0x75, 0xB1, 0xD3, 0xED};\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = {0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23};\nuint8_t nodeAppsKey[16] = {0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C};\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                     /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];            //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = {m_lora_app_data_buffer, 0, 0, 0, 0}; //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup()\n{\npinMode(Enable, OUTPUT);\ndigitalWrite(Enable, HIGH);\npinMode(ECHO, INPUT);   // Echo Pin of Ultrasonic Sensor is an Input\npinMode(TRIG, OUTPUT);  // Trigger Pin of Ultrasonic Sensor is an Output\npinMode(PD, OUTPUT);    // power done control pin is an Output\ndigitalWrite(TRIG,LOW);\ndigitalWrite(PD,LOW);\n\npinMode(LED_GREEN, OUTPUT);  // Output LED\npinMode(LED_BLUE, OUTPUT);   // Output LED\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial)\n{\nif ((millis() - timeout) < 5000)\n{\ndelay(100);\n}\nelse\n{\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA)\n{\nSerial.println(\"Type: OTAA\");\n}\nelse\n{\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion)\n{\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA)\n{\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n}\nelse\n{\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0)\n{\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"========================\");\nSerial.println(\"  RAK12007 LoRaWAN test \");\nSerial.println(\"========================\");\n\n}\n\nvoid loop()\n{\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\n// long int duration, mm;\ndigitalWrite(LED_BLUE,HIGH);\ndigitalWrite(LED_GREEN, HIGH);\nduration = duration_time();\nif(duration > 0)\n{\nmm = duration*ratio; //Test distance = (high level time\u00d7velocity of sound (340M/S) / 2,\ndigitalWrite(LED_BLUE,LOW);\ndigitalWrite(LED_GREEN, LOW);\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\nSerial.print(mm);\nSerial.print(\"mm\");\nSerial.println();\ndelay(15000);\n}\nelse\n{\nSerial.println(\"Out of range\");\n}\ndelay(50);\n\n}\n\nlong int duration_time()\n{\nlong int respondTime;\npinMode(TRIG, OUTPUT);\ndigitalWrite(TRIG, HIGH);\ndelayMicroseconds(12);   //pull high time need over 10us\ndigitalWrite(TRIG, LOW);\npinMode(ECHO, INPUT);\nrespondTime = pulseIn(ECHO, HIGH); // microseconds\ndelay(33);\nif(RAK4631_BOARD)\n{\nrespondTime = respondTime*0.7726; // Time calibration factor is 0.7726,to get real time microseconds for 4631board\n}\nSerial.printf(\"respond time is %d\\r\\n\",respondTime);\n\nif((respondTime>0)&&(respondTime < TIME_OUT))  //ECHO pin max timeout is 33000us according it's datasheet\n{\nreturn respondTime;\n}\nelse\n{\nreturn -1;\n}\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void)\n{\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void)\n{\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data)\n{\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class)\n{\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void)\n{\nif (lmh_join_status_get() != LMH_SET)\n{\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\ndata = \"Distance:\" + String(mm) + \"mm\";\nSerial.println(data);\n\nuint32_t mm_data = mm;\n\nm_lora_app_data.buffer[i++] = 0x0A;\nm_lora_app_data.buffer[i++] = (uint8_t)((mm_data & 0xFF000000) >> 24);\nm_lora_app_data.buffer[i++] = (uint8_t)((mm_data & 0x00FF0000) >> 16);\nm_lora_app_data.buffer[i++] = (uint8_t)((mm_data & 0x0000FF00) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(mm_data & 0x000000FF);\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS)\n{\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n}\nelse\n{\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The following steps will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired regions to work with. You can change this to a region that is applicable to you, like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc.  \nThe following table lists the LoRaWAN regions and the countries where they are used:  \n| LoRaWAN Region         | Usage                                                             |\n| ---------------------- | ----------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1 | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan          |\n| LORAMAC_REGION_AS923-2 | Vietnam                                                           |\n| LORAMAC_REGION_AS923-3 | Philippines, Albania, Algeria, Denmark, Greenland, Jordan         |\n| LORAMAC_REGION_AS923-4 | Israel                                                            |\n| LORAMAC_REGION_AU915   | Australia, Anguilla, Argentina, and other parts of South America  |\n| LORAMAC_REGION_CN470   | China                                                             |\n| LORAMAC_REGION_EU433   | EU, UK, Brazil, Costa Rica, Cuba, and other parts of Africa       |\n| LORAMAC_REGION_IN865   | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger |\n| LORAMAC_REGION_EU868   | EU, UK and other parts of Africa                                  |\n| LORAMAC_REGION_KR920   | Republic of Korea                                                 |\n| LORAMAC_REGION_US915   | USA                                                               |\n| LORAMAC_REGION_RU864   | Russia                                                            |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n\n```\n- Set up the LoRaWAN activation method. In this case, you will use the **OTAA** configuration, which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change it to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n\n```  \n- Set up the EUIs and KEY. The **DeviceEUI**, **AppEUI**, and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x8B, 0x0E, 0x96, 0x86, 0xE8, 0x4E, 0xA3, 0xB5, 0x31, 0x42, 0xB3, 0x65, 0x75, 0xB1, 0xD3, 0xED};\n\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once you're done with the code, you can now proceed with uploading it to your device. You must first choose your RAK4631 board on your desktop or laptop. To do so, navigate to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** and select **WisBlock RAK4631**.  \n> **Image:** Selecting the RAK4631 board  \n4. After you have selected your board, go to **Tools** > **Port** and then select the specific port of your board.  \n> **Image:** Selecting the port of RAK4631 board  \n5. You can then upload your code by clicking the Upload button (the right arrow sign). Once completed, the **Device programmed** notification will appear in the console at the bottom of the Arduino IDE.  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "cf9f7ab624327eb505bd9f17109fcc99", "product_family": "wisblock", "product_id": "kit3-movement-detection", "category": "How-To", "title": "WisBlock Movement Detection Kit Quick Start Guide > WisBlock IoT Education Kit - Movement Detection Quick Start Guide > Product Configuration > Software Configuration and Examples > RAK12007 Ultrasonic Sensor LoRaWAN Application > LoRaWAN Code for RAK12007 > Programming RAK12007 Module with Arduino IDE [CODE]", "content": "// Setup the EUIs and Keys\nif (doOTAA)\n{\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n}\nelse\n{\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0)\n{\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();", "keywords": ["Arduino IDE", "RAK4631", "RAK12007", "LoRaWAN", "programming"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed on your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you have not yet installed the **Arduino IDE**, go to the [RAK4631 Installation](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#arduino-ide-installation-rak4631) section and execute the following steps.  \n2. After the installation, you can now proceed with programming your **RAK12007** module. Simply copy the **RAK12007 LoRaWAN Application** code below and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE\nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n```c\n\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h> //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define  RAK4631_BOARD true\n#else\n#define  RAK4631_BOARD false\n#endif\n\n// Section to add include libraries, declarations and variables.\n\n#define Enable WB_IO2\n#define TRIG WB_IO6\n#define ECHO WB_IO4\n#define PD   WB_IO5   //power done control \uff08=1 power done\uff0c=0 power on\uff09\n\n#define TIME_OUT  24125 //max measure distance is 4m,the velocity of sound is 331.6m/s in 0\u2103,TIME_OUT=4*2/331.6*1000000=24215us\n\nfloat ratio = 346.6/1000/2;   //velocity of sound =331.6+0.6*25\u2103(m/s),(Indoor temperature about 25\u2103)\n\nlong int duration_time();  //measure high level time\n\nlong int duration, mm;\n\nbool doOTAA = true;   // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                     /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                   /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5             /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                      /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                      /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = {LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF};\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = {BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler\n};\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x8B, 0x0E, 0x96, 0x86, 0xE8, 0x4E, 0xA3, 0xB5, 0x31, 0x42, 0xB3, 0x65, 0x75, 0xB1, 0xD3, 0xED};\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = {0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23};\nuint8_t nodeAppsKey[16] = {0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C};\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                     /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];            //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = {m_lora_app_data_buffer, 0, 0, 0, 0}; //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup()\n{\npinMode(Enable, OUTPUT);\ndigitalWrite(Enable, HIGH);\npinMode(ECHO, INPUT);   // Echo Pin of Ultrasonic Sensor is an Input\npinMode(TRIG, OUTPUT);  // Trigger Pin of Ultrasonic Sensor is an Output\npinMode(PD, OUTPUT);    // power done control pin is an Output\ndigitalWrite(TRIG,LOW);\ndigitalWrite(PD,LOW);\n\npinMode(LED_GREEN, OUTPUT);  // Output LED\npinMode(LED_BLUE, OUTPUT);   // Output LED\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial)\n{\nif ((millis() - timeout) < 5000)\n{\ndelay(100);\n}\nelse\n{\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA)\n{\nSerial.println(\"Type: OTAA\");\n}\nelse\n{\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion)\n{\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA)\n{\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n}\nelse\n{\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0)\n{\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"========================\");\nSerial.println(\"  RAK12007 LoRaWAN test \");\nSerial.println(\"========================\");\n\n}\n\nvoid loop()\n{\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\n// long int duration, mm;\ndigitalWrite(LED_BLUE,HIGH);\ndigitalWrite(LED_GREEN, HIGH);\nduration = duration_time();\nif(duration > 0)\n{\nmm = duration*ratio; //Test distance = (high level time\u00d7velocity of sound (340M/S) / 2,\ndigitalWrite(LED_BLUE,LOW);\ndigitalWrite(LED_GREEN, LOW);\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\nSerial.print(mm);\nSerial.print(\"mm\");\nSerial.println();\ndelay(15000);\n}\nelse\n{\nSerial.println(\"Out of range\");\n}\ndelay(50);\n\n}\n\nlong int duration_time()\n{\nlong int respondTime;\npinMode(TRIG, OUTPUT);\ndigitalWrite(TRIG, HIGH);\ndelayMicroseconds(12);   //pull high time need over 10us\ndigitalWrite(TRIG, LOW);\npinMode(ECHO, INPUT);\nrespondTime = pulseIn(ECHO, HIGH); // microseconds\ndelay(33);\nif(RAK4631_BOARD)\n{\nrespondTime = respondTime*0.7726; // Time calibration factor is 0.7726,to get real time microseconds for 4631board\n}\nSerial.printf(\"respond time is %d\\r\\n\",respondTime);\n\nif((respondTime>0)&&(respondTime < TIME_OUT))  //ECHO pin max timeout is 33000us according it's datasheet\n{\nreturn respondTime;\n}\nelse\n{\nreturn -1;\n}\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void)\n{\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void)\n{\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data)\n{\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class)\n{\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void)\n{\nif (lmh_join_status_get() != LMH_SET)\n{\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\ndata = \"Distance:\" + String(mm) + \"mm\";\nSerial.println(data);\n\nuint32_t mm_data = mm;\n\nm_lora_app_data.buffer[i++] = 0x0A;\nm_lora_app_data.buffer[i++] = (uint8_t)((mm_data & 0xFF000000) >> 24);\nm_lora_app_data.buffer[i++] = (uint8_t)((mm_data & 0x00FF0000) >> 16);\nm_lora_app_data.buffer[i++] = (uint8_t)((mm_data & 0x0000FF00) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(mm_data & 0x000000FF);\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS)\n{\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n}\nelse\n{\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The following steps will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired regions to work with. You can change this to a region that is applicable to you, like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc.  \nThe following table lists the LoRaWAN regions and the countries where they are used:  \n| LoRaWAN Region         | Usage                                                             |\n| ---------------------- | ----------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1 | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan          |\n| LORAMAC_REGION_AS923-2 | Vietnam                                                           |\n| LORAMAC_REGION_AS923-3 | Philippines, Albania, Algeria, Denmark, Greenland, Jordan         |\n| LORAMAC_REGION_AS923-4 | Israel                                                            |\n| LORAMAC_REGION_AU915   | Australia, Anguilla, Argentina, and other parts of South America  |\n| LORAMAC_REGION_CN470   | China                                                             |\n| LORAMAC_REGION_EU433   | EU, UK, Brazil, Costa Rica, Cuba, and other parts of Africa       |\n| LORAMAC_REGION_IN865   | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger |\n| LORAMAC_REGION_EU868   | EU, UK and other parts of Africa                                  |\n| LORAMAC_REGION_KR920   | Republic of Korea                                                 |\n| LORAMAC_REGION_US915   | USA                                                               |\n| LORAMAC_REGION_RU864   | Russia                                                            |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n\n```\n- Set up the LoRaWAN activation method. In this case, you will use the **OTAA** configuration, which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change it to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n\n```  \n- Set up the EUIs and KEY. The **DeviceEUI**, **AppEUI**, and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x8B, 0x0E, 0x96, 0x86, 0xE8, 0x4E, 0xA3, 0xB5, 0x31, 0x42, 0xB3, 0x65, 0x75, 0xB1, 0xD3, 0xED};\n\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once you're done with the code, you can now proceed with uploading it to your device. You must first choose your RAK4631 board on your desktop or laptop. To do so, navigate to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** and select **WisBlock RAK4631**.  \n> **Image:** Selecting the RAK4631 board  \n4. After you have selected your board, go to **Tools** > **Port** and then select the specific port of your board.  \n> **Image:** Selecting the port of RAK4631 board  \n5. You can then upload your code by clicking the Upload button (the right arrow sign). Once completed, the **Device programmed** notification will appear in the console at the bottom of the Arduino IDE.  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "39ce2a5a20d542fad720766c938d0ab7", "product_family": "wisblock", "product_id": "kit3-movement-detection", "category": "How-To", "title": "WisBlock Movement Detection Kit Quick Start Guide > WisBlock IoT Education Kit - Movement Detection Quick Start Guide > Product Configuration > Software Configuration and Examples > RAK12007 Ultrasonic Sensor LoRaWAN Application > LoRaWAN Code for RAK12007 > Programming RAK12007 Module with Arduino IDE [CODE]", "content": "// Start Join procedure\nlmh_join();\n\nSerial.println(\"========================\");\nSerial.println(\"  RAK12007 LoRaWAN test \");\nSerial.println(\"========================\");\n\n}\n\nvoid loop()\n{\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.", "keywords": ["Arduino IDE", "RAK4631", "RAK12007", "LoRaWAN", "programming"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed on your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you have not yet installed the **Arduino IDE**, go to the [RAK4631 Installation](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#arduino-ide-installation-rak4631) section and execute the following steps.  \n2. After the installation, you can now proceed with programming your **RAK12007** module. Simply copy the **RAK12007 LoRaWAN Application** code below and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE\nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n```c\n\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h> //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define  RAK4631_BOARD true\n#else\n#define  RAK4631_BOARD false\n#endif\n\n// Section to add include libraries, declarations and variables.\n\n#define Enable WB_IO2\n#define TRIG WB_IO6\n#define ECHO WB_IO4\n#define PD   WB_IO5   //power done control \uff08=1 power done\uff0c=0 power on\uff09\n\n#define TIME_OUT  24125 //max measure distance is 4m,the velocity of sound is 331.6m/s in 0\u2103,TIME_OUT=4*2/331.6*1000000=24215us\n\nfloat ratio = 346.6/1000/2;   //velocity of sound =331.6+0.6*25\u2103(m/s),(Indoor temperature about 25\u2103)\n\nlong int duration_time();  //measure high level time\n\nlong int duration, mm;\n\nbool doOTAA = true;   // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                     /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                   /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5             /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                      /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                      /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = {LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF};\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = {BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler\n};\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x8B, 0x0E, 0x96, 0x86, 0xE8, 0x4E, 0xA3, 0xB5, 0x31, 0x42, 0xB3, 0x65, 0x75, 0xB1, 0xD3, 0xED};\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = {0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23};\nuint8_t nodeAppsKey[16] = {0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C};\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                     /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];            //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = {m_lora_app_data_buffer, 0, 0, 0, 0}; //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup()\n{\npinMode(Enable, OUTPUT);\ndigitalWrite(Enable, HIGH);\npinMode(ECHO, INPUT);   // Echo Pin of Ultrasonic Sensor is an Input\npinMode(TRIG, OUTPUT);  // Trigger Pin of Ultrasonic Sensor is an Output\npinMode(PD, OUTPUT);    // power done control pin is an Output\ndigitalWrite(TRIG,LOW);\ndigitalWrite(PD,LOW);\n\npinMode(LED_GREEN, OUTPUT);  // Output LED\npinMode(LED_BLUE, OUTPUT);   // Output LED\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial)\n{\nif ((millis() - timeout) < 5000)\n{\ndelay(100);\n}\nelse\n{\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA)\n{\nSerial.println(\"Type: OTAA\");\n}\nelse\n{\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion)\n{\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA)\n{\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n}\nelse\n{\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0)\n{\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"========================\");\nSerial.println(\"  RAK12007 LoRaWAN test \");\nSerial.println(\"========================\");\n\n}\n\nvoid loop()\n{\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\n// long int duration, mm;\ndigitalWrite(LED_BLUE,HIGH);\ndigitalWrite(LED_GREEN, HIGH);\nduration = duration_time();\nif(duration > 0)\n{\nmm = duration*ratio; //Test distance = (high level time\u00d7velocity of sound (340M/S) / 2,\ndigitalWrite(LED_BLUE,LOW);\ndigitalWrite(LED_GREEN, LOW);\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\nSerial.print(mm);\nSerial.print(\"mm\");\nSerial.println();\ndelay(15000);\n}\nelse\n{\nSerial.println(\"Out of range\");\n}\ndelay(50);\n\n}\n\nlong int duration_time()\n{\nlong int respondTime;\npinMode(TRIG, OUTPUT);\ndigitalWrite(TRIG, HIGH);\ndelayMicroseconds(12);   //pull high time need over 10us\ndigitalWrite(TRIG, LOW);\npinMode(ECHO, INPUT);\nrespondTime = pulseIn(ECHO, HIGH); // microseconds\ndelay(33);\nif(RAK4631_BOARD)\n{\nrespondTime = respondTime*0.7726; // Time calibration factor is 0.7726,to get real time microseconds for 4631board\n}\nSerial.printf(\"respond time is %d\\r\\n\",respondTime);\n\nif((respondTime>0)&&(respondTime < TIME_OUT))  //ECHO pin max timeout is 33000us according it's datasheet\n{\nreturn respondTime;\n}\nelse\n{\nreturn -1;\n}\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void)\n{\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void)\n{\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data)\n{\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class)\n{\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void)\n{\nif (lmh_join_status_get() != LMH_SET)\n{\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\ndata = \"Distance:\" + String(mm) + \"mm\";\nSerial.println(data);\n\nuint32_t mm_data = mm;\n\nm_lora_app_data.buffer[i++] = 0x0A;\nm_lora_app_data.buffer[i++] = (uint8_t)((mm_data & 0xFF000000) >> 24);\nm_lora_app_data.buffer[i++] = (uint8_t)((mm_data & 0x00FF0000) >> 16);\nm_lora_app_data.buffer[i++] = (uint8_t)((mm_data & 0x0000FF00) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(mm_data & 0x000000FF);\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS)\n{\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n}\nelse\n{\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The following steps will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired regions to work with. You can change this to a region that is applicable to you, like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc.  \nThe following table lists the LoRaWAN regions and the countries where they are used:  \n| LoRaWAN Region         | Usage                                                             |\n| ---------------------- | ----------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1 | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan          |\n| LORAMAC_REGION_AS923-2 | Vietnam                                                           |\n| LORAMAC_REGION_AS923-3 | Philippines, Albania, Algeria, Denmark, Greenland, Jordan         |\n| LORAMAC_REGION_AS923-4 | Israel                                                            |\n| LORAMAC_REGION_AU915   | Australia, Anguilla, Argentina, and other parts of South America  |\n| LORAMAC_REGION_CN470   | China                                                             |\n| LORAMAC_REGION_EU433   | EU, UK, Brazil, Costa Rica, Cuba, and other parts of Africa       |\n| LORAMAC_REGION_IN865   | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger |\n| LORAMAC_REGION_EU868   | EU, UK and other parts of Africa                                  |\n| LORAMAC_REGION_KR920   | Republic of Korea                                                 |\n| LORAMAC_REGION_US915   | USA                                                               |\n| LORAMAC_REGION_RU864   | Russia                                                            |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n\n```\n- Set up the LoRaWAN activation method. In this case, you will use the **OTAA** configuration, which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change it to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n\n```  \n- Set up the EUIs and KEY. The **DeviceEUI**, **AppEUI**, and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x8B, 0x0E, 0x96, 0x86, 0xE8, 0x4E, 0xA3, 0xB5, 0x31, 0x42, 0xB3, 0x65, 0x75, 0xB1, 0xD3, 0xED};\n\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once you're done with the code, you can now proceed with uploading it to your device. You must first choose your RAK4631 board on your desktop or laptop. To do so, navigate to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** and select **WisBlock RAK4631**.  \n> **Image:** Selecting the RAK4631 board  \n4. After you have selected your board, go to **Tools** > **Port** and then select the specific port of your board.  \n> **Image:** Selecting the port of RAK4631 board  \n5. You can then upload your code by clicking the Upload button (the right arrow sign). Once completed, the **Device programmed** notification will appear in the console at the bottom of the Arduino IDE.  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "62a5dde818f9ccf07a16dbcd8cabc2f3", "product_family": "wisblock", "product_id": "kit3-movement-detection", "category": "How-To", "title": "WisBlock Movement Detection Kit Quick Start Guide > WisBlock IoT Education Kit - Movement Detection Quick Start Guide > Product Configuration > Software Configuration and Examples > RAK12007 Ultrasonic Sensor LoRaWAN Application > LoRaWAN Code for RAK12007 > Programming RAK12007 Module with Arduino IDE [CODE]", "content": "// long int duration, mm;\ndigitalWrite(LED_BLUE,HIGH);\ndigitalWrite(LED_GREEN, HIGH);\nduration = duration_time();\nif(duration > 0)\n{\nmm = duration*ratio; //Test distance = (high level time\u00d7velocity of sound (340M/S) / 2,\ndigitalWrite(LED_BLUE,LOW);\ndigitalWrite(LED_GREEN, LOW);\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\nSerial.print(mm);\nSerial.print(\"mm\");\nSerial.println();\ndelay(15000);\n}\nelse\n{\nSerial.println(\"Out of range\");\n}\ndelay(50);\n\n}", "keywords": ["Arduino IDE", "RAK4631", "RAK12007", "LoRaWAN", "programming"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed on your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you have not yet installed the **Arduino IDE**, go to the [RAK4631 Installation](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#arduino-ide-installation-rak4631) section and execute the following steps.  \n2. After the installation, you can now proceed with programming your **RAK12007** module. Simply copy the **RAK12007 LoRaWAN Application** code below and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE\nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n```c\n\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h> //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define  RAK4631_BOARD true\n#else\n#define  RAK4631_BOARD false\n#endif\n\n// Section to add include libraries, declarations and variables.\n\n#define Enable WB_IO2\n#define TRIG WB_IO6\n#define ECHO WB_IO4\n#define PD   WB_IO5   //power done control \uff08=1 power done\uff0c=0 power on\uff09\n\n#define TIME_OUT  24125 //max measure distance is 4m,the velocity of sound is 331.6m/s in 0\u2103,TIME_OUT=4*2/331.6*1000000=24215us\n\nfloat ratio = 346.6/1000/2;   //velocity of sound =331.6+0.6*25\u2103(m/s),(Indoor temperature about 25\u2103)\n\nlong int duration_time();  //measure high level time\n\nlong int duration, mm;\n\nbool doOTAA = true;   // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                     /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                   /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5             /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                      /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                      /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = {LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF};\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = {BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler\n};\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x8B, 0x0E, 0x96, 0x86, 0xE8, 0x4E, 0xA3, 0xB5, 0x31, 0x42, 0xB3, 0x65, 0x75, 0xB1, 0xD3, 0xED};\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = {0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23};\nuint8_t nodeAppsKey[16] = {0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C};\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                     /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];            //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = {m_lora_app_data_buffer, 0, 0, 0, 0}; //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup()\n{\npinMode(Enable, OUTPUT);\ndigitalWrite(Enable, HIGH);\npinMode(ECHO, INPUT);   // Echo Pin of Ultrasonic Sensor is an Input\npinMode(TRIG, OUTPUT);  // Trigger Pin of Ultrasonic Sensor is an Output\npinMode(PD, OUTPUT);    // power done control pin is an Output\ndigitalWrite(TRIG,LOW);\ndigitalWrite(PD,LOW);\n\npinMode(LED_GREEN, OUTPUT);  // Output LED\npinMode(LED_BLUE, OUTPUT);   // Output LED\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial)\n{\nif ((millis() - timeout) < 5000)\n{\ndelay(100);\n}\nelse\n{\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA)\n{\nSerial.println(\"Type: OTAA\");\n}\nelse\n{\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion)\n{\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA)\n{\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n}\nelse\n{\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0)\n{\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"========================\");\nSerial.println(\"  RAK12007 LoRaWAN test \");\nSerial.println(\"========================\");\n\n}\n\nvoid loop()\n{\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\n// long int duration, mm;\ndigitalWrite(LED_BLUE,HIGH);\ndigitalWrite(LED_GREEN, HIGH);\nduration = duration_time();\nif(duration > 0)\n{\nmm = duration*ratio; //Test distance = (high level time\u00d7velocity of sound (340M/S) / 2,\ndigitalWrite(LED_BLUE,LOW);\ndigitalWrite(LED_GREEN, LOW);\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\nSerial.print(mm);\nSerial.print(\"mm\");\nSerial.println();\ndelay(15000);\n}\nelse\n{\nSerial.println(\"Out of range\");\n}\ndelay(50);\n\n}\n\nlong int duration_time()\n{\nlong int respondTime;\npinMode(TRIG, OUTPUT);\ndigitalWrite(TRIG, HIGH);\ndelayMicroseconds(12);   //pull high time need over 10us\ndigitalWrite(TRIG, LOW);\npinMode(ECHO, INPUT);\nrespondTime = pulseIn(ECHO, HIGH); // microseconds\ndelay(33);\nif(RAK4631_BOARD)\n{\nrespondTime = respondTime*0.7726; // Time calibration factor is 0.7726,to get real time microseconds for 4631board\n}\nSerial.printf(\"respond time is %d\\r\\n\",respondTime);\n\nif((respondTime>0)&&(respondTime < TIME_OUT))  //ECHO pin max timeout is 33000us according it's datasheet\n{\nreturn respondTime;\n}\nelse\n{\nreturn -1;\n}\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void)\n{\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void)\n{\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data)\n{\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class)\n{\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void)\n{\nif (lmh_join_status_get() != LMH_SET)\n{\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\ndata = \"Distance:\" + String(mm) + \"mm\";\nSerial.println(data);\n\nuint32_t mm_data = mm;\n\nm_lora_app_data.buffer[i++] = 0x0A;\nm_lora_app_data.buffer[i++] = (uint8_t)((mm_data & 0xFF000000) >> 24);\nm_lora_app_data.buffer[i++] = (uint8_t)((mm_data & 0x00FF0000) >> 16);\nm_lora_app_data.buffer[i++] = (uint8_t)((mm_data & 0x0000FF00) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(mm_data & 0x000000FF);\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS)\n{\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n}\nelse\n{\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The following steps will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired regions to work with. You can change this to a region that is applicable to you, like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc.  \nThe following table lists the LoRaWAN regions and the countries where they are used:  \n| LoRaWAN Region         | Usage                                                             |\n| ---------------------- | ----------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1 | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan          |\n| LORAMAC_REGION_AS923-2 | Vietnam                                                           |\n| LORAMAC_REGION_AS923-3 | Philippines, Albania, Algeria, Denmark, Greenland, Jordan         |\n| LORAMAC_REGION_AS923-4 | Israel                                                            |\n| LORAMAC_REGION_AU915   | Australia, Anguilla, Argentina, and other parts of South America  |\n| LORAMAC_REGION_CN470   | China                                                             |\n| LORAMAC_REGION_EU433   | EU, UK, Brazil, Costa Rica, Cuba, and other parts of Africa       |\n| LORAMAC_REGION_IN865   | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger |\n| LORAMAC_REGION_EU868   | EU, UK and other parts of Africa                                  |\n| LORAMAC_REGION_KR920   | Republic of Korea                                                 |\n| LORAMAC_REGION_US915   | USA                                                               |\n| LORAMAC_REGION_RU864   | Russia                                                            |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n\n```\n- Set up the LoRaWAN activation method. In this case, you will use the **OTAA** configuration, which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change it to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n\n```  \n- Set up the EUIs and KEY. The **DeviceEUI**, **AppEUI**, and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x8B, 0x0E, 0x96, 0x86, 0xE8, 0x4E, 0xA3, 0xB5, 0x31, 0x42, 0xB3, 0x65, 0x75, 0xB1, 0xD3, 0xED};\n\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once you're done with the code, you can now proceed with uploading it to your device. You must first choose your RAK4631 board on your desktop or laptop. To do so, navigate to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** and select **WisBlock RAK4631**.  \n> **Image:** Selecting the RAK4631 board  \n4. After you have selected your board, go to **Tools** > **Port** and then select the specific port of your board.  \n> **Image:** Selecting the port of RAK4631 board  \n5. You can then upload your code by clicking the Upload button (the right arrow sign). Once completed, the **Device programmed** notification will appear in the console at the bottom of the Arduino IDE.  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "6b68176820e112eed185e1f1ebcae5e8", "product_family": "wisblock", "product_id": "kit3-movement-detection", "category": "How-To", "title": "WisBlock Movement Detection Kit Quick Start Guide > WisBlock IoT Education Kit - Movement Detection Quick Start Guide > Product Configuration > Software Configuration and Examples > RAK12007 Ultrasonic Sensor LoRaWAN Application > LoRaWAN Code for RAK12007 > Programming RAK12007 Module with Arduino IDE [CODE]", "content": "}\n\nlong int duration_time()\n{\nlong int respondTime;\npinMode(TRIG, OUTPUT);\ndigitalWrite(TRIG, HIGH);\ndelayMicroseconds(12);   //pull high time need over 10us\ndigitalWrite(TRIG, LOW);\npinMode(ECHO, INPUT);\nrespondTime = pulseIn(ECHO, HIGH); // microseconds\ndelay(33);\nif(RAK4631_BOARD)\n{\nrespondTime = respondTime*0.7726; // Time calibration factor is 0.7726,to get real time microseconds for 4631board\n}\nSerial.printf(\"respond time is %d\\r\\n\",respondTime);", "keywords": ["Arduino IDE", "RAK4631", "RAK12007", "LoRaWAN", "programming"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed on your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you have not yet installed the **Arduino IDE**, go to the [RAK4631 Installation](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#arduino-ide-installation-rak4631) section and execute the following steps.  \n2. After the installation, you can now proceed with programming your **RAK12007** module. Simply copy the **RAK12007 LoRaWAN Application** code below and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE\nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n```c\n\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h> //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define  RAK4631_BOARD true\n#else\n#define  RAK4631_BOARD false\n#endif\n\n// Section to add include libraries, declarations and variables.\n\n#define Enable WB_IO2\n#define TRIG WB_IO6\n#define ECHO WB_IO4\n#define PD   WB_IO5   //power done control \uff08=1 power done\uff0c=0 power on\uff09\n\n#define TIME_OUT  24125 //max measure distance is 4m,the velocity of sound is 331.6m/s in 0\u2103,TIME_OUT=4*2/331.6*1000000=24215us\n\nfloat ratio = 346.6/1000/2;   //velocity of sound =331.6+0.6*25\u2103(m/s),(Indoor temperature about 25\u2103)\n\nlong int duration_time();  //measure high level time\n\nlong int duration, mm;\n\nbool doOTAA = true;   // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                     /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                   /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5             /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                      /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                      /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = {LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF};\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = {BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler\n};\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x8B, 0x0E, 0x96, 0x86, 0xE8, 0x4E, 0xA3, 0xB5, 0x31, 0x42, 0xB3, 0x65, 0x75, 0xB1, 0xD3, 0xED};\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = {0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23};\nuint8_t nodeAppsKey[16] = {0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C};\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                     /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];            //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = {m_lora_app_data_buffer, 0, 0, 0, 0}; //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup()\n{\npinMode(Enable, OUTPUT);\ndigitalWrite(Enable, HIGH);\npinMode(ECHO, INPUT);   // Echo Pin of Ultrasonic Sensor is an Input\npinMode(TRIG, OUTPUT);  // Trigger Pin of Ultrasonic Sensor is an Output\npinMode(PD, OUTPUT);    // power done control pin is an Output\ndigitalWrite(TRIG,LOW);\ndigitalWrite(PD,LOW);\n\npinMode(LED_GREEN, OUTPUT);  // Output LED\npinMode(LED_BLUE, OUTPUT);   // Output LED\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial)\n{\nif ((millis() - timeout) < 5000)\n{\ndelay(100);\n}\nelse\n{\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA)\n{\nSerial.println(\"Type: OTAA\");\n}\nelse\n{\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion)\n{\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA)\n{\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n}\nelse\n{\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0)\n{\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"========================\");\nSerial.println(\"  RAK12007 LoRaWAN test \");\nSerial.println(\"========================\");\n\n}\n\nvoid loop()\n{\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\n// long int duration, mm;\ndigitalWrite(LED_BLUE,HIGH);\ndigitalWrite(LED_GREEN, HIGH);\nduration = duration_time();\nif(duration > 0)\n{\nmm = duration*ratio; //Test distance = (high level time\u00d7velocity of sound (340M/S) / 2,\ndigitalWrite(LED_BLUE,LOW);\ndigitalWrite(LED_GREEN, LOW);\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\nSerial.print(mm);\nSerial.print(\"mm\");\nSerial.println();\ndelay(15000);\n}\nelse\n{\nSerial.println(\"Out of range\");\n}\ndelay(50);\n\n}\n\nlong int duration_time()\n{\nlong int respondTime;\npinMode(TRIG, OUTPUT);\ndigitalWrite(TRIG, HIGH);\ndelayMicroseconds(12);   //pull high time need over 10us\ndigitalWrite(TRIG, LOW);\npinMode(ECHO, INPUT);\nrespondTime = pulseIn(ECHO, HIGH); // microseconds\ndelay(33);\nif(RAK4631_BOARD)\n{\nrespondTime = respondTime*0.7726; // Time calibration factor is 0.7726,to get real time microseconds for 4631board\n}\nSerial.printf(\"respond time is %d\\r\\n\",respondTime);\n\nif((respondTime>0)&&(respondTime < TIME_OUT))  //ECHO pin max timeout is 33000us according it's datasheet\n{\nreturn respondTime;\n}\nelse\n{\nreturn -1;\n}\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void)\n{\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void)\n{\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data)\n{\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class)\n{\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void)\n{\nif (lmh_join_status_get() != LMH_SET)\n{\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\ndata = \"Distance:\" + String(mm) + \"mm\";\nSerial.println(data);\n\nuint32_t mm_data = mm;\n\nm_lora_app_data.buffer[i++] = 0x0A;\nm_lora_app_data.buffer[i++] = (uint8_t)((mm_data & 0xFF000000) >> 24);\nm_lora_app_data.buffer[i++] = (uint8_t)((mm_data & 0x00FF0000) >> 16);\nm_lora_app_data.buffer[i++] = (uint8_t)((mm_data & 0x0000FF00) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(mm_data & 0x000000FF);\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS)\n{\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n}\nelse\n{\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The following steps will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired regions to work with. You can change this to a region that is applicable to you, like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc.  \nThe following table lists the LoRaWAN regions and the countries where they are used:  \n| LoRaWAN Region         | Usage                                                             |\n| ---------------------- | ----------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1 | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan          |\n| LORAMAC_REGION_AS923-2 | Vietnam                                                           |\n| LORAMAC_REGION_AS923-3 | Philippines, Albania, Algeria, Denmark, Greenland, Jordan         |\n| LORAMAC_REGION_AS923-4 | Israel                                                            |\n| LORAMAC_REGION_AU915   | Australia, Anguilla, Argentina, and other parts of South America  |\n| LORAMAC_REGION_CN470   | China                                                             |\n| LORAMAC_REGION_EU433   | EU, UK, Brazil, Costa Rica, Cuba, and other parts of Africa       |\n| LORAMAC_REGION_IN865   | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger |\n| LORAMAC_REGION_EU868   | EU, UK and other parts of Africa                                  |\n| LORAMAC_REGION_KR920   | Republic of Korea                                                 |\n| LORAMAC_REGION_US915   | USA                                                               |\n| LORAMAC_REGION_RU864   | Russia                                                            |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n\n```\n- Set up the LoRaWAN activation method. In this case, you will use the **OTAA** configuration, which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change it to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n\n```  \n- Set up the EUIs and KEY. The **DeviceEUI**, **AppEUI**, and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x8B, 0x0E, 0x96, 0x86, 0xE8, 0x4E, 0xA3, 0xB5, 0x31, 0x42, 0xB3, 0x65, 0x75, 0xB1, 0xD3, 0xED};\n\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once you're done with the code, you can now proceed with uploading it to your device. You must first choose your RAK4631 board on your desktop or laptop. To do so, navigate to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** and select **WisBlock RAK4631**.  \n> **Image:** Selecting the RAK4631 board  \n4. After you have selected your board, go to **Tools** > **Port** and then select the specific port of your board.  \n> **Image:** Selecting the port of RAK4631 board  \n5. You can then upload your code by clicking the Upload button (the right arrow sign). Once completed, the **Device programmed** notification will appear in the console at the bottom of the Arduino IDE.  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "33b7a7d9f1a7b0c4d01ad6389a86a0d5", "product_family": "wisblock", "product_id": "kit3-movement-detection", "category": "How-To", "title": "WisBlock Movement Detection Kit Quick Start Guide > WisBlock IoT Education Kit - Movement Detection Quick Start Guide > Product Configuration > Software Configuration and Examples > RAK12007 Ultrasonic Sensor LoRaWAN Application > LoRaWAN Code for RAK12007 > Programming RAK12007 Module with Arduino IDE [CODE]", "content": "if((respondTime>0)&&(respondTime < TIME_OUT))  //ECHO pin max timeout is 33000us according it's datasheet\n{\nreturn respondTime;\n}\nelse\n{\nreturn -1;\n}\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void)\n{\nSerial.println(\"OTAA Mode, Network Joined!\");\n}", "keywords": ["Arduino IDE", "RAK4631", "RAK12007", "LoRaWAN", "programming"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed on your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you have not yet installed the **Arduino IDE**, go to the [RAK4631 Installation](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#arduino-ide-installation-rak4631) section and execute the following steps.  \n2. After the installation, you can now proceed with programming your **RAK12007** module. Simply copy the **RAK12007 LoRaWAN Application** code below and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE\nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n```c\n\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h> //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define  RAK4631_BOARD true\n#else\n#define  RAK4631_BOARD false\n#endif\n\n// Section to add include libraries, declarations and variables.\n\n#define Enable WB_IO2\n#define TRIG WB_IO6\n#define ECHO WB_IO4\n#define PD   WB_IO5   //power done control \uff08=1 power done\uff0c=0 power on\uff09\n\n#define TIME_OUT  24125 //max measure distance is 4m,the velocity of sound is 331.6m/s in 0\u2103,TIME_OUT=4*2/331.6*1000000=24215us\n\nfloat ratio = 346.6/1000/2;   //velocity of sound =331.6+0.6*25\u2103(m/s),(Indoor temperature about 25\u2103)\n\nlong int duration_time();  //measure high level time\n\nlong int duration, mm;\n\nbool doOTAA = true;   // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                     /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                   /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5             /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                      /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                      /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = {LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF};\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = {BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler\n};\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x8B, 0x0E, 0x96, 0x86, 0xE8, 0x4E, 0xA3, 0xB5, 0x31, 0x42, 0xB3, 0x65, 0x75, 0xB1, 0xD3, 0xED};\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = {0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23};\nuint8_t nodeAppsKey[16] = {0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C};\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                     /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];            //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = {m_lora_app_data_buffer, 0, 0, 0, 0}; //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup()\n{\npinMode(Enable, OUTPUT);\ndigitalWrite(Enable, HIGH);\npinMode(ECHO, INPUT);   // Echo Pin of Ultrasonic Sensor is an Input\npinMode(TRIG, OUTPUT);  // Trigger Pin of Ultrasonic Sensor is an Output\npinMode(PD, OUTPUT);    // power done control pin is an Output\ndigitalWrite(TRIG,LOW);\ndigitalWrite(PD,LOW);\n\npinMode(LED_GREEN, OUTPUT);  // Output LED\npinMode(LED_BLUE, OUTPUT);   // Output LED\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial)\n{\nif ((millis() - timeout) < 5000)\n{\ndelay(100);\n}\nelse\n{\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA)\n{\nSerial.println(\"Type: OTAA\");\n}\nelse\n{\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion)\n{\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA)\n{\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n}\nelse\n{\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0)\n{\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"========================\");\nSerial.println(\"  RAK12007 LoRaWAN test \");\nSerial.println(\"========================\");\n\n}\n\nvoid loop()\n{\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\n// long int duration, mm;\ndigitalWrite(LED_BLUE,HIGH);\ndigitalWrite(LED_GREEN, HIGH);\nduration = duration_time();\nif(duration > 0)\n{\nmm = duration*ratio; //Test distance = (high level time\u00d7velocity of sound (340M/S) / 2,\ndigitalWrite(LED_BLUE,LOW);\ndigitalWrite(LED_GREEN, LOW);\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\nSerial.print(mm);\nSerial.print(\"mm\");\nSerial.println();\ndelay(15000);\n}\nelse\n{\nSerial.println(\"Out of range\");\n}\ndelay(50);\n\n}\n\nlong int duration_time()\n{\nlong int respondTime;\npinMode(TRIG, OUTPUT);\ndigitalWrite(TRIG, HIGH);\ndelayMicroseconds(12);   //pull high time need over 10us\ndigitalWrite(TRIG, LOW);\npinMode(ECHO, INPUT);\nrespondTime = pulseIn(ECHO, HIGH); // microseconds\ndelay(33);\nif(RAK4631_BOARD)\n{\nrespondTime = respondTime*0.7726; // Time calibration factor is 0.7726,to get real time microseconds for 4631board\n}\nSerial.printf(\"respond time is %d\\r\\n\",respondTime);\n\nif((respondTime>0)&&(respondTime < TIME_OUT))  //ECHO pin max timeout is 33000us according it's datasheet\n{\nreturn respondTime;\n}\nelse\n{\nreturn -1;\n}\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void)\n{\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void)\n{\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data)\n{\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class)\n{\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void)\n{\nif (lmh_join_status_get() != LMH_SET)\n{\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\ndata = \"Distance:\" + String(mm) + \"mm\";\nSerial.println(data);\n\nuint32_t mm_data = mm;\n\nm_lora_app_data.buffer[i++] = 0x0A;\nm_lora_app_data.buffer[i++] = (uint8_t)((mm_data & 0xFF000000) >> 24);\nm_lora_app_data.buffer[i++] = (uint8_t)((mm_data & 0x00FF0000) >> 16);\nm_lora_app_data.buffer[i++] = (uint8_t)((mm_data & 0x0000FF00) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(mm_data & 0x000000FF);\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS)\n{\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n}\nelse\n{\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The following steps will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired regions to work with. You can change this to a region that is applicable to you, like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc.  \nThe following table lists the LoRaWAN regions and the countries where they are used:  \n| LoRaWAN Region         | Usage                                                             |\n| ---------------------- | ----------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1 | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan          |\n| LORAMAC_REGION_AS923-2 | Vietnam                                                           |\n| LORAMAC_REGION_AS923-3 | Philippines, Albania, Algeria, Denmark, Greenland, Jordan         |\n| LORAMAC_REGION_AS923-4 | Israel                                                            |\n| LORAMAC_REGION_AU915   | Australia, Anguilla, Argentina, and other parts of South America  |\n| LORAMAC_REGION_CN470   | China                                                             |\n| LORAMAC_REGION_EU433   | EU, UK, Brazil, Costa Rica, Cuba, and other parts of Africa       |\n| LORAMAC_REGION_IN865   | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger |\n| LORAMAC_REGION_EU868   | EU, UK and other parts of Africa                                  |\n| LORAMAC_REGION_KR920   | Republic of Korea                                                 |\n| LORAMAC_REGION_US915   | USA                                                               |\n| LORAMAC_REGION_RU864   | Russia                                                            |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n\n```\n- Set up the LoRaWAN activation method. In this case, you will use the **OTAA** configuration, which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change it to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n\n```  \n- Set up the EUIs and KEY. The **DeviceEUI**, **AppEUI**, and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x8B, 0x0E, 0x96, 0x86, 0xE8, 0x4E, 0xA3, 0xB5, 0x31, 0x42, 0xB3, 0x65, 0x75, 0xB1, 0xD3, 0xED};\n\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once you're done with the code, you can now proceed with uploading it to your device. You must first choose your RAK4631 board on your desktop or laptop. To do so, navigate to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** and select **WisBlock RAK4631**.  \n> **Image:** Selecting the RAK4631 board  \n4. After you have selected your board, go to **Tools** > **Port** and then select the specific port of your board.  \n> **Image:** Selecting the port of RAK4631 board  \n5. You can then upload your code by clicking the Upload button (the right arrow sign). Once completed, the **Device programmed** notification will appear in the console at the bottom of the Arduino IDE.  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "ff46eb88eadf3e339d89670f343c457d", "product_family": "wisblock", "product_id": "kit3-movement-detection", "category": "How-To", "title": "WisBlock Movement Detection Kit Quick Start Guide > WisBlock IoT Education Kit - Movement Detection Quick Start Guide > Product Configuration > Software Configuration and Examples > RAK12007 Ultrasonic Sensor LoRaWAN Application > LoRaWAN Code for RAK12007 > Programming RAK12007 Module with Arduino IDE [CODE]", "content": "/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void)\n{\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data)\n{\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",", "keywords": ["Arduino IDE", "RAK4631", "RAK12007", "LoRaWAN", "programming"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed on your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you have not yet installed the **Arduino IDE**, go to the [RAK4631 Installation](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#arduino-ide-installation-rak4631) section and execute the following steps.  \n2. After the installation, you can now proceed with programming your **RAK12007** module. Simply copy the **RAK12007 LoRaWAN Application** code below and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE\nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n```c\n\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h> //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define  RAK4631_BOARD true\n#else\n#define  RAK4631_BOARD false\n#endif\n\n// Section to add include libraries, declarations and variables.\n\n#define Enable WB_IO2\n#define TRIG WB_IO6\n#define ECHO WB_IO4\n#define PD   WB_IO5   //power done control \uff08=1 power done\uff0c=0 power on\uff09\n\n#define TIME_OUT  24125 //max measure distance is 4m,the velocity of sound is 331.6m/s in 0\u2103,TIME_OUT=4*2/331.6*1000000=24215us\n\nfloat ratio = 346.6/1000/2;   //velocity of sound =331.6+0.6*25\u2103(m/s),(Indoor temperature about 25\u2103)\n\nlong int duration_time();  //measure high level time\n\nlong int duration, mm;\n\nbool doOTAA = true;   // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                     /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                   /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5             /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                      /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                      /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = {LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF};\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = {BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler\n};\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x8B, 0x0E, 0x96, 0x86, 0xE8, 0x4E, 0xA3, 0xB5, 0x31, 0x42, 0xB3, 0x65, 0x75, 0xB1, 0xD3, 0xED};\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = {0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23};\nuint8_t nodeAppsKey[16] = {0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C};\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                     /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];            //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = {m_lora_app_data_buffer, 0, 0, 0, 0}; //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup()\n{\npinMode(Enable, OUTPUT);\ndigitalWrite(Enable, HIGH);\npinMode(ECHO, INPUT);   // Echo Pin of Ultrasonic Sensor is an Input\npinMode(TRIG, OUTPUT);  // Trigger Pin of Ultrasonic Sensor is an Output\npinMode(PD, OUTPUT);    // power done control pin is an Output\ndigitalWrite(TRIG,LOW);\ndigitalWrite(PD,LOW);\n\npinMode(LED_GREEN, OUTPUT);  // Output LED\npinMode(LED_BLUE, OUTPUT);   // Output LED\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial)\n{\nif ((millis() - timeout) < 5000)\n{\ndelay(100);\n}\nelse\n{\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA)\n{\nSerial.println(\"Type: OTAA\");\n}\nelse\n{\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion)\n{\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA)\n{\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n}\nelse\n{\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0)\n{\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"========================\");\nSerial.println(\"  RAK12007 LoRaWAN test \");\nSerial.println(\"========================\");\n\n}\n\nvoid loop()\n{\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\n// long int duration, mm;\ndigitalWrite(LED_BLUE,HIGH);\ndigitalWrite(LED_GREEN, HIGH);\nduration = duration_time();\nif(duration > 0)\n{\nmm = duration*ratio; //Test distance = (high level time\u00d7velocity of sound (340M/S) / 2,\ndigitalWrite(LED_BLUE,LOW);\ndigitalWrite(LED_GREEN, LOW);\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\nSerial.print(mm);\nSerial.print(\"mm\");\nSerial.println();\ndelay(15000);\n}\nelse\n{\nSerial.println(\"Out of range\");\n}\ndelay(50);\n\n}\n\nlong int duration_time()\n{\nlong int respondTime;\npinMode(TRIG, OUTPUT);\ndigitalWrite(TRIG, HIGH);\ndelayMicroseconds(12);   //pull high time need over 10us\ndigitalWrite(TRIG, LOW);\npinMode(ECHO, INPUT);\nrespondTime = pulseIn(ECHO, HIGH); // microseconds\ndelay(33);\nif(RAK4631_BOARD)\n{\nrespondTime = respondTime*0.7726; // Time calibration factor is 0.7726,to get real time microseconds for 4631board\n}\nSerial.printf(\"respond time is %d\\r\\n\",respondTime);\n\nif((respondTime>0)&&(respondTime < TIME_OUT))  //ECHO pin max timeout is 33000us according it's datasheet\n{\nreturn respondTime;\n}\nelse\n{\nreturn -1;\n}\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void)\n{\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void)\n{\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data)\n{\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class)\n{\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void)\n{\nif (lmh_join_status_get() != LMH_SET)\n{\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\ndata = \"Distance:\" + String(mm) + \"mm\";\nSerial.println(data);\n\nuint32_t mm_data = mm;\n\nm_lora_app_data.buffer[i++] = 0x0A;\nm_lora_app_data.buffer[i++] = (uint8_t)((mm_data & 0xFF000000) >> 24);\nm_lora_app_data.buffer[i++] = (uint8_t)((mm_data & 0x00FF0000) >> 16);\nm_lora_app_data.buffer[i++] = (uint8_t)((mm_data & 0x0000FF00) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(mm_data & 0x000000FF);\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS)\n{\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n}\nelse\n{\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The following steps will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired regions to work with. You can change this to a region that is applicable to you, like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc.  \nThe following table lists the LoRaWAN regions and the countries where they are used:  \n| LoRaWAN Region         | Usage                                                             |\n| ---------------------- | ----------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1 | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan          |\n| LORAMAC_REGION_AS923-2 | Vietnam                                                           |\n| LORAMAC_REGION_AS923-3 | Philippines, Albania, Algeria, Denmark, Greenland, Jordan         |\n| LORAMAC_REGION_AS923-4 | Israel                                                            |\n| LORAMAC_REGION_AU915   | Australia, Anguilla, Argentina, and other parts of South America  |\n| LORAMAC_REGION_CN470   | China                                                             |\n| LORAMAC_REGION_EU433   | EU, UK, Brazil, Costa Rica, Cuba, and other parts of Africa       |\n| LORAMAC_REGION_IN865   | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger |\n| LORAMAC_REGION_EU868   | EU, UK and other parts of Africa                                  |\n| LORAMAC_REGION_KR920   | Republic of Korea                                                 |\n| LORAMAC_REGION_US915   | USA                                                               |\n| LORAMAC_REGION_RU864   | Russia                                                            |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n\n```\n- Set up the LoRaWAN activation method. In this case, you will use the **OTAA** configuration, which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change it to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n\n```  \n- Set up the EUIs and KEY. The **DeviceEUI**, **AppEUI**, and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x8B, 0x0E, 0x96, 0x86, 0xE8, 0x4E, 0xA3, 0xB5, 0x31, 0x42, 0xB3, 0x65, 0x75, 0xB1, 0xD3, 0xED};\n\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once you're done with the code, you can now proceed with uploading it to your device. You must first choose your RAK4631 board on your desktop or laptop. To do so, navigate to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** and select **WisBlock RAK4631**.  \n> **Image:** Selecting the RAK4631 board  \n4. After you have selected your board, go to **Tools** > **Port** and then select the specific port of your board.  \n> **Image:** Selecting the port of RAK4631 board  \n5. You can then upload your code by clicking the Upload button (the right arrow sign). Once completed, the **Device programmed** notification will appear in the console at the bottom of the Arduino IDE.  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "fc8d6f5284de290cfe998e08d2d89ba8", "product_family": "wisblock", "product_id": "kit3-movement-detection", "category": "How-To", "title": "WisBlock Movement Detection Kit Quick Start Guide > WisBlock IoT Education Kit - Movement Detection Quick Start Guide > Product Configuration > Software Configuration and Examples > RAK12007 Ultrasonic Sensor LoRaWAN Application > LoRaWAN Code for RAK12007 > Programming RAK12007 Module with Arduino IDE [CODE]", "content": "{\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}", "keywords": ["Arduino IDE", "RAK4631", "RAK12007", "LoRaWAN", "programming"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed on your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you have not yet installed the **Arduino IDE**, go to the [RAK4631 Installation](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#arduino-ide-installation-rak4631) section and execute the following steps.  \n2. After the installation, you can now proceed with programming your **RAK12007** module. Simply copy the **RAK12007 LoRaWAN Application** code below and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE\nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n```c\n\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h> //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define  RAK4631_BOARD true\n#else\n#define  RAK4631_BOARD false\n#endif\n\n// Section to add include libraries, declarations and variables.\n\n#define Enable WB_IO2\n#define TRIG WB_IO6\n#define ECHO WB_IO4\n#define PD   WB_IO5   //power done control \uff08=1 power done\uff0c=0 power on\uff09\n\n#define TIME_OUT  24125 //max measure distance is 4m,the velocity of sound is 331.6m/s in 0\u2103,TIME_OUT=4*2/331.6*1000000=24215us\n\nfloat ratio = 346.6/1000/2;   //velocity of sound =331.6+0.6*25\u2103(m/s),(Indoor temperature about 25\u2103)\n\nlong int duration_time();  //measure high level time\n\nlong int duration, mm;\n\nbool doOTAA = true;   // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                     /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                   /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5             /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                      /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                      /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = {LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF};\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = {BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler\n};\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x8B, 0x0E, 0x96, 0x86, 0xE8, 0x4E, 0xA3, 0xB5, 0x31, 0x42, 0xB3, 0x65, 0x75, 0xB1, 0xD3, 0xED};\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = {0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23};\nuint8_t nodeAppsKey[16] = {0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C};\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                     /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];            //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = {m_lora_app_data_buffer, 0, 0, 0, 0}; //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup()\n{\npinMode(Enable, OUTPUT);\ndigitalWrite(Enable, HIGH);\npinMode(ECHO, INPUT);   // Echo Pin of Ultrasonic Sensor is an Input\npinMode(TRIG, OUTPUT);  // Trigger Pin of Ultrasonic Sensor is an Output\npinMode(PD, OUTPUT);    // power done control pin is an Output\ndigitalWrite(TRIG,LOW);\ndigitalWrite(PD,LOW);\n\npinMode(LED_GREEN, OUTPUT);  // Output LED\npinMode(LED_BLUE, OUTPUT);   // Output LED\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial)\n{\nif ((millis() - timeout) < 5000)\n{\ndelay(100);\n}\nelse\n{\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA)\n{\nSerial.println(\"Type: OTAA\");\n}\nelse\n{\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion)\n{\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA)\n{\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n}\nelse\n{\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0)\n{\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"========================\");\nSerial.println(\"  RAK12007 LoRaWAN test \");\nSerial.println(\"========================\");\n\n}\n\nvoid loop()\n{\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\n// long int duration, mm;\ndigitalWrite(LED_BLUE,HIGH);\ndigitalWrite(LED_GREEN, HIGH);\nduration = duration_time();\nif(duration > 0)\n{\nmm = duration*ratio; //Test distance = (high level time\u00d7velocity of sound (340M/S) / 2,\ndigitalWrite(LED_BLUE,LOW);\ndigitalWrite(LED_GREEN, LOW);\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\nSerial.print(mm);\nSerial.print(\"mm\");\nSerial.println();\ndelay(15000);\n}\nelse\n{\nSerial.println(\"Out of range\");\n}\ndelay(50);\n\n}\n\nlong int duration_time()\n{\nlong int respondTime;\npinMode(TRIG, OUTPUT);\ndigitalWrite(TRIG, HIGH);\ndelayMicroseconds(12);   //pull high time need over 10us\ndigitalWrite(TRIG, LOW);\npinMode(ECHO, INPUT);\nrespondTime = pulseIn(ECHO, HIGH); // microseconds\ndelay(33);\nif(RAK4631_BOARD)\n{\nrespondTime = respondTime*0.7726; // Time calibration factor is 0.7726,to get real time microseconds for 4631board\n}\nSerial.printf(\"respond time is %d\\r\\n\",respondTime);\n\nif((respondTime>0)&&(respondTime < TIME_OUT))  //ECHO pin max timeout is 33000us according it's datasheet\n{\nreturn respondTime;\n}\nelse\n{\nreturn -1;\n}\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void)\n{\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void)\n{\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data)\n{\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class)\n{\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void)\n{\nif (lmh_join_status_get() != LMH_SET)\n{\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\ndata = \"Distance:\" + String(mm) + \"mm\";\nSerial.println(data);\n\nuint32_t mm_data = mm;\n\nm_lora_app_data.buffer[i++] = 0x0A;\nm_lora_app_data.buffer[i++] = (uint8_t)((mm_data & 0xFF000000) >> 24);\nm_lora_app_data.buffer[i++] = (uint8_t)((mm_data & 0x00FF0000) >> 16);\nm_lora_app_data.buffer[i++] = (uint8_t)((mm_data & 0x0000FF00) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(mm_data & 0x000000FF);\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS)\n{\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n}\nelse\n{\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The following steps will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired regions to work with. You can change this to a region that is applicable to you, like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc.  \nThe following table lists the LoRaWAN regions and the countries where they are used:  \n| LoRaWAN Region         | Usage                                                             |\n| ---------------------- | ----------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1 | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan          |\n| LORAMAC_REGION_AS923-2 | Vietnam                                                           |\n| LORAMAC_REGION_AS923-3 | Philippines, Albania, Algeria, Denmark, Greenland, Jordan         |\n| LORAMAC_REGION_AS923-4 | Israel                                                            |\n| LORAMAC_REGION_AU915   | Australia, Anguilla, Argentina, and other parts of South America  |\n| LORAMAC_REGION_CN470   | China                                                             |\n| LORAMAC_REGION_EU433   | EU, UK, Brazil, Costa Rica, Cuba, and other parts of Africa       |\n| LORAMAC_REGION_IN865   | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger |\n| LORAMAC_REGION_EU868   | EU, UK and other parts of Africa                                  |\n| LORAMAC_REGION_KR920   | Republic of Korea                                                 |\n| LORAMAC_REGION_US915   | USA                                                               |\n| LORAMAC_REGION_RU864   | Russia                                                            |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n\n```\n- Set up the LoRaWAN activation method. In this case, you will use the **OTAA** configuration, which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change it to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n\n```  \n- Set up the EUIs and KEY. The **DeviceEUI**, **AppEUI**, and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x8B, 0x0E, 0x96, 0x86, 0xE8, 0x4E, 0xA3, 0xB5, 0x31, 0x42, 0xB3, 0x65, 0x75, 0xB1, 0xD3, 0xED};\n\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once you're done with the code, you can now proceed with uploading it to your device. You must first choose your RAK4631 board on your desktop or laptop. To do so, navigate to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** and select **WisBlock RAK4631**.  \n> **Image:** Selecting the RAK4631 board  \n4. After you have selected your board, go to **Tools** > **Port** and then select the specific port of your board.  \n> **Image:** Selecting the port of RAK4631 board  \n5. You can then upload your code by clicking the Upload button (the right arrow sign). Once completed, the **Device programmed** notification will appear in the console at the bottom of the Arduino IDE.  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "15d4f2f767f0128419596964d0189cdd", "product_family": "wisblock", "product_id": "kit3-movement-detection", "category": "How-To", "title": "WisBlock Movement Detection Kit Quick Start Guide > WisBlock IoT Education Kit - Movement Detection Quick Start Guide > Product Configuration > Software Configuration and Examples > RAK12007 Ultrasonic Sensor LoRaWAN Application > LoRaWAN Code for RAK12007 > Programming RAK12007 Module with Arduino IDE [CODE]", "content": "void lorawan_confirm_class_handler(DeviceClass_t Class)\n{\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void)\n{\nif (lmh_join_status_get() != LMH_SET)\n{\n//Not joined, try again later\nreturn;\n}", "keywords": ["Arduino IDE", "RAK4631", "RAK12007", "LoRaWAN", "programming"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed on your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you have not yet installed the **Arduino IDE**, go to the [RAK4631 Installation](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#arduino-ide-installation-rak4631) section and execute the following steps.  \n2. After the installation, you can now proceed with programming your **RAK12007** module. Simply copy the **RAK12007 LoRaWAN Application** code below and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE\nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n```c\n\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h> //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define  RAK4631_BOARD true\n#else\n#define  RAK4631_BOARD false\n#endif\n\n// Section to add include libraries, declarations and variables.\n\n#define Enable WB_IO2\n#define TRIG WB_IO6\n#define ECHO WB_IO4\n#define PD   WB_IO5   //power done control \uff08=1 power done\uff0c=0 power on\uff09\n\n#define TIME_OUT  24125 //max measure distance is 4m,the velocity of sound is 331.6m/s in 0\u2103,TIME_OUT=4*2/331.6*1000000=24215us\n\nfloat ratio = 346.6/1000/2;   //velocity of sound =331.6+0.6*25\u2103(m/s),(Indoor temperature about 25\u2103)\n\nlong int duration_time();  //measure high level time\n\nlong int duration, mm;\n\nbool doOTAA = true;   // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                     /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                   /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5             /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                      /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                      /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = {LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF};\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = {BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler\n};\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x8B, 0x0E, 0x96, 0x86, 0xE8, 0x4E, 0xA3, 0xB5, 0x31, 0x42, 0xB3, 0x65, 0x75, 0xB1, 0xD3, 0xED};\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = {0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23};\nuint8_t nodeAppsKey[16] = {0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C};\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                     /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];            //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = {m_lora_app_data_buffer, 0, 0, 0, 0}; //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup()\n{\npinMode(Enable, OUTPUT);\ndigitalWrite(Enable, HIGH);\npinMode(ECHO, INPUT);   // Echo Pin of Ultrasonic Sensor is an Input\npinMode(TRIG, OUTPUT);  // Trigger Pin of Ultrasonic Sensor is an Output\npinMode(PD, OUTPUT);    // power done control pin is an Output\ndigitalWrite(TRIG,LOW);\ndigitalWrite(PD,LOW);\n\npinMode(LED_GREEN, OUTPUT);  // Output LED\npinMode(LED_BLUE, OUTPUT);   // Output LED\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial)\n{\nif ((millis() - timeout) < 5000)\n{\ndelay(100);\n}\nelse\n{\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA)\n{\nSerial.println(\"Type: OTAA\");\n}\nelse\n{\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion)\n{\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA)\n{\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n}\nelse\n{\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0)\n{\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"========================\");\nSerial.println(\"  RAK12007 LoRaWAN test \");\nSerial.println(\"========================\");\n\n}\n\nvoid loop()\n{\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\n// long int duration, mm;\ndigitalWrite(LED_BLUE,HIGH);\ndigitalWrite(LED_GREEN, HIGH);\nduration = duration_time();\nif(duration > 0)\n{\nmm = duration*ratio; //Test distance = (high level time\u00d7velocity of sound (340M/S) / 2,\ndigitalWrite(LED_BLUE,LOW);\ndigitalWrite(LED_GREEN, LOW);\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\nSerial.print(mm);\nSerial.print(\"mm\");\nSerial.println();\ndelay(15000);\n}\nelse\n{\nSerial.println(\"Out of range\");\n}\ndelay(50);\n\n}\n\nlong int duration_time()\n{\nlong int respondTime;\npinMode(TRIG, OUTPUT);\ndigitalWrite(TRIG, HIGH);\ndelayMicroseconds(12);   //pull high time need over 10us\ndigitalWrite(TRIG, LOW);\npinMode(ECHO, INPUT);\nrespondTime = pulseIn(ECHO, HIGH); // microseconds\ndelay(33);\nif(RAK4631_BOARD)\n{\nrespondTime = respondTime*0.7726; // Time calibration factor is 0.7726,to get real time microseconds for 4631board\n}\nSerial.printf(\"respond time is %d\\r\\n\",respondTime);\n\nif((respondTime>0)&&(respondTime < TIME_OUT))  //ECHO pin max timeout is 33000us according it's datasheet\n{\nreturn respondTime;\n}\nelse\n{\nreturn -1;\n}\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void)\n{\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void)\n{\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data)\n{\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class)\n{\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void)\n{\nif (lmh_join_status_get() != LMH_SET)\n{\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\ndata = \"Distance:\" + String(mm) + \"mm\";\nSerial.println(data);\n\nuint32_t mm_data = mm;\n\nm_lora_app_data.buffer[i++] = 0x0A;\nm_lora_app_data.buffer[i++] = (uint8_t)((mm_data & 0xFF000000) >> 24);\nm_lora_app_data.buffer[i++] = (uint8_t)((mm_data & 0x00FF0000) >> 16);\nm_lora_app_data.buffer[i++] = (uint8_t)((mm_data & 0x0000FF00) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(mm_data & 0x000000FF);\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS)\n{\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n}\nelse\n{\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The following steps will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired regions to work with. You can change this to a region that is applicable to you, like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc.  \nThe following table lists the LoRaWAN regions and the countries where they are used:  \n| LoRaWAN Region         | Usage                                                             |\n| ---------------------- | ----------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1 | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan          |\n| LORAMAC_REGION_AS923-2 | Vietnam                                                           |\n| LORAMAC_REGION_AS923-3 | Philippines, Albania, Algeria, Denmark, Greenland, Jordan         |\n| LORAMAC_REGION_AS923-4 | Israel                                                            |\n| LORAMAC_REGION_AU915   | Australia, Anguilla, Argentina, and other parts of South America  |\n| LORAMAC_REGION_CN470   | China                                                             |\n| LORAMAC_REGION_EU433   | EU, UK, Brazil, Costa Rica, Cuba, and other parts of Africa       |\n| LORAMAC_REGION_IN865   | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger |\n| LORAMAC_REGION_EU868   | EU, UK and other parts of Africa                                  |\n| LORAMAC_REGION_KR920   | Republic of Korea                                                 |\n| LORAMAC_REGION_US915   | USA                                                               |\n| LORAMAC_REGION_RU864   | Russia                                                            |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n\n```\n- Set up the LoRaWAN activation method. In this case, you will use the **OTAA** configuration, which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change it to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n\n```  \n- Set up the EUIs and KEY. The **DeviceEUI**, **AppEUI**, and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x8B, 0x0E, 0x96, 0x86, 0xE8, 0x4E, 0xA3, 0xB5, 0x31, 0x42, 0xB3, 0x65, 0x75, 0xB1, 0xD3, 0xED};\n\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once you're done with the code, you can now proceed with uploading it to your device. You must first choose your RAK4631 board on your desktop or laptop. To do so, navigate to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** and select **WisBlock RAK4631**.  \n> **Image:** Selecting the RAK4631 board  \n4. After you have selected your board, go to **Tools** > **Port** and then select the specific port of your board.  \n> **Image:** Selecting the port of RAK4631 board  \n5. You can then upload your code by clicking the Upload button (the right arrow sign). Once completed, the **Device programmed** notification will appear in the console at the bottom of the Arduino IDE.  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "dd2457c92b4a0bb1f2a080ae3007b60b", "product_family": "wisblock", "product_id": "kit3-movement-detection", "category": "How-To", "title": "WisBlock Movement Detection Kit Quick Start Guide > WisBlock IoT Education Kit - Movement Detection Quick Start Guide > Product Configuration > Software Configuration and Examples > RAK12007 Ultrasonic Sensor LoRaWAN Application > LoRaWAN Code for RAK12007 > Programming RAK12007 Module with Arduino IDE [CODE]", "content": "Serial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\ndata = \"Distance:\" + String(mm) + \"mm\";\nSerial.println(data);\n\nuint32_t mm_data = mm;", "keywords": ["Arduino IDE", "RAK4631", "RAK12007", "LoRaWAN", "programming"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed on your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you have not yet installed the **Arduino IDE**, go to the [RAK4631 Installation](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#arduino-ide-installation-rak4631) section and execute the following steps.  \n2. After the installation, you can now proceed with programming your **RAK12007** module. Simply copy the **RAK12007 LoRaWAN Application** code below and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE\nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n```c\n\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h> //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define  RAK4631_BOARD true\n#else\n#define  RAK4631_BOARD false\n#endif\n\n// Section to add include libraries, declarations and variables.\n\n#define Enable WB_IO2\n#define TRIG WB_IO6\n#define ECHO WB_IO4\n#define PD   WB_IO5   //power done control \uff08=1 power done\uff0c=0 power on\uff09\n\n#define TIME_OUT  24125 //max measure distance is 4m,the velocity of sound is 331.6m/s in 0\u2103,TIME_OUT=4*2/331.6*1000000=24215us\n\nfloat ratio = 346.6/1000/2;   //velocity of sound =331.6+0.6*25\u2103(m/s),(Indoor temperature about 25\u2103)\n\nlong int duration_time();  //measure high level time\n\nlong int duration, mm;\n\nbool doOTAA = true;   // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                     /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                   /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5             /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                      /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                      /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = {LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF};\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = {BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler\n};\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x8B, 0x0E, 0x96, 0x86, 0xE8, 0x4E, 0xA3, 0xB5, 0x31, 0x42, 0xB3, 0x65, 0x75, 0xB1, 0xD3, 0xED};\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = {0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23};\nuint8_t nodeAppsKey[16] = {0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C};\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                     /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];            //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = {m_lora_app_data_buffer, 0, 0, 0, 0}; //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup()\n{\npinMode(Enable, OUTPUT);\ndigitalWrite(Enable, HIGH);\npinMode(ECHO, INPUT);   // Echo Pin of Ultrasonic Sensor is an Input\npinMode(TRIG, OUTPUT);  // Trigger Pin of Ultrasonic Sensor is an Output\npinMode(PD, OUTPUT);    // power done control pin is an Output\ndigitalWrite(TRIG,LOW);\ndigitalWrite(PD,LOW);\n\npinMode(LED_GREEN, OUTPUT);  // Output LED\npinMode(LED_BLUE, OUTPUT);   // Output LED\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial)\n{\nif ((millis() - timeout) < 5000)\n{\ndelay(100);\n}\nelse\n{\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA)\n{\nSerial.println(\"Type: OTAA\");\n}\nelse\n{\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion)\n{\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA)\n{\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n}\nelse\n{\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0)\n{\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"========================\");\nSerial.println(\"  RAK12007 LoRaWAN test \");\nSerial.println(\"========================\");\n\n}\n\nvoid loop()\n{\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\n// long int duration, mm;\ndigitalWrite(LED_BLUE,HIGH);\ndigitalWrite(LED_GREEN, HIGH);\nduration = duration_time();\nif(duration > 0)\n{\nmm = duration*ratio; //Test distance = (high level time\u00d7velocity of sound (340M/S) / 2,\ndigitalWrite(LED_BLUE,LOW);\ndigitalWrite(LED_GREEN, LOW);\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\nSerial.print(mm);\nSerial.print(\"mm\");\nSerial.println();\ndelay(15000);\n}\nelse\n{\nSerial.println(\"Out of range\");\n}\ndelay(50);\n\n}\n\nlong int duration_time()\n{\nlong int respondTime;\npinMode(TRIG, OUTPUT);\ndigitalWrite(TRIG, HIGH);\ndelayMicroseconds(12);   //pull high time need over 10us\ndigitalWrite(TRIG, LOW);\npinMode(ECHO, INPUT);\nrespondTime = pulseIn(ECHO, HIGH); // microseconds\ndelay(33);\nif(RAK4631_BOARD)\n{\nrespondTime = respondTime*0.7726; // Time calibration factor is 0.7726,to get real time microseconds for 4631board\n}\nSerial.printf(\"respond time is %d\\r\\n\",respondTime);\n\nif((respondTime>0)&&(respondTime < TIME_OUT))  //ECHO pin max timeout is 33000us according it's datasheet\n{\nreturn respondTime;\n}\nelse\n{\nreturn -1;\n}\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void)\n{\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void)\n{\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data)\n{\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class)\n{\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void)\n{\nif (lmh_join_status_get() != LMH_SET)\n{\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\ndata = \"Distance:\" + String(mm) + \"mm\";\nSerial.println(data);\n\nuint32_t mm_data = mm;\n\nm_lora_app_data.buffer[i++] = 0x0A;\nm_lora_app_data.buffer[i++] = (uint8_t)((mm_data & 0xFF000000) >> 24);\nm_lora_app_data.buffer[i++] = (uint8_t)((mm_data & 0x00FF0000) >> 16);\nm_lora_app_data.buffer[i++] = (uint8_t)((mm_data & 0x0000FF00) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(mm_data & 0x000000FF);\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS)\n{\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n}\nelse\n{\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The following steps will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired regions to work with. You can change this to a region that is applicable to you, like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc.  \nThe following table lists the LoRaWAN regions and the countries where they are used:  \n| LoRaWAN Region         | Usage                                                             |\n| ---------------------- | ----------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1 | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan          |\n| LORAMAC_REGION_AS923-2 | Vietnam                                                           |\n| LORAMAC_REGION_AS923-3 | Philippines, Albania, Algeria, Denmark, Greenland, Jordan         |\n| LORAMAC_REGION_AS923-4 | Israel                                                            |\n| LORAMAC_REGION_AU915   | Australia, Anguilla, Argentina, and other parts of South America  |\n| LORAMAC_REGION_CN470   | China                                                             |\n| LORAMAC_REGION_EU433   | EU, UK, Brazil, Costa Rica, Cuba, and other parts of Africa       |\n| LORAMAC_REGION_IN865   | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger |\n| LORAMAC_REGION_EU868   | EU, UK and other parts of Africa                                  |\n| LORAMAC_REGION_KR920   | Republic of Korea                                                 |\n| LORAMAC_REGION_US915   | USA                                                               |\n| LORAMAC_REGION_RU864   | Russia                                                            |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n\n```\n- Set up the LoRaWAN activation method. In this case, you will use the **OTAA** configuration, which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change it to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n\n```  \n- Set up the EUIs and KEY. The **DeviceEUI**, **AppEUI**, and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x8B, 0x0E, 0x96, 0x86, 0xE8, 0x4E, 0xA3, 0xB5, 0x31, 0x42, 0xB3, 0x65, 0x75, 0xB1, 0xD3, 0xED};\n\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once you're done with the code, you can now proceed with uploading it to your device. You must first choose your RAK4631 board on your desktop or laptop. To do so, navigate to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** and select **WisBlock RAK4631**.  \n> **Image:** Selecting the RAK4631 board  \n4. After you have selected your board, go to **Tools** > **Port** and then select the specific port of your board.  \n> **Image:** Selecting the port of RAK4631 board  \n5. You can then upload your code by clicking the Upload button (the right arrow sign). Once completed, the **Device programmed** notification will appear in the console at the bottom of the Arduino IDE.  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "a43c2511ff304eb0605470b6c51af9c9", "product_family": "wisblock", "product_id": "kit3-movement-detection", "category": "How-To", "title": "WisBlock Movement Detection Kit Quick Start Guide > WisBlock IoT Education Kit - Movement Detection Quick Start Guide > Product Configuration > Software Configuration and Examples > RAK12007 Ultrasonic Sensor LoRaWAN Application > LoRaWAN Code for RAK12007 > Programming RAK12007 Module with Arduino IDE [CODE]", "content": "data = \"Distance:\" + String(mm) + \"mm\";\nSerial.println(data);\n\nuint32_t mm_data = mm;\n\nm_lora_app_data.buffer[i++] = 0x0A;\nm_lora_app_data.buffer[i++] = (uint8_t)((mm_data & 0xFF000000) >> 24);\nm_lora_app_data.buffer[i++] = (uint8_t)((mm_data & 0x00FF0000) >> 16);\nm_lora_app_data.buffer[i++] = (uint8_t)((mm_data & 0x0000FF00) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(mm_data & 0x000000FF);\nm_lora_app_data.buffsize = i;", "keywords": ["Arduino IDE", "RAK4631", "RAK12007", "LoRaWAN", "programming"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed on your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you have not yet installed the **Arduino IDE**, go to the [RAK4631 Installation](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#arduino-ide-installation-rak4631) section and execute the following steps.  \n2. After the installation, you can now proceed with programming your **RAK12007** module. Simply copy the **RAK12007 LoRaWAN Application** code below and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE\nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n```c\n\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h> //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define  RAK4631_BOARD true\n#else\n#define  RAK4631_BOARD false\n#endif\n\n// Section to add include libraries, declarations and variables.\n\n#define Enable WB_IO2\n#define TRIG WB_IO6\n#define ECHO WB_IO4\n#define PD   WB_IO5   //power done control \uff08=1 power done\uff0c=0 power on\uff09\n\n#define TIME_OUT  24125 //max measure distance is 4m,the velocity of sound is 331.6m/s in 0\u2103,TIME_OUT=4*2/331.6*1000000=24215us\n\nfloat ratio = 346.6/1000/2;   //velocity of sound =331.6+0.6*25\u2103(m/s),(Indoor temperature about 25\u2103)\n\nlong int duration_time();  //measure high level time\n\nlong int duration, mm;\n\nbool doOTAA = true;   // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                     /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                   /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5             /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                      /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                      /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = {LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF};\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = {BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler\n};\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x8B, 0x0E, 0x96, 0x86, 0xE8, 0x4E, 0xA3, 0xB5, 0x31, 0x42, 0xB3, 0x65, 0x75, 0xB1, 0xD3, 0xED};\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = {0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23};\nuint8_t nodeAppsKey[16] = {0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C};\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                     /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];            //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = {m_lora_app_data_buffer, 0, 0, 0, 0}; //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup()\n{\npinMode(Enable, OUTPUT);\ndigitalWrite(Enable, HIGH);\npinMode(ECHO, INPUT);   // Echo Pin of Ultrasonic Sensor is an Input\npinMode(TRIG, OUTPUT);  // Trigger Pin of Ultrasonic Sensor is an Output\npinMode(PD, OUTPUT);    // power done control pin is an Output\ndigitalWrite(TRIG,LOW);\ndigitalWrite(PD,LOW);\n\npinMode(LED_GREEN, OUTPUT);  // Output LED\npinMode(LED_BLUE, OUTPUT);   // Output LED\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial)\n{\nif ((millis() - timeout) < 5000)\n{\ndelay(100);\n}\nelse\n{\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA)\n{\nSerial.println(\"Type: OTAA\");\n}\nelse\n{\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion)\n{\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA)\n{\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n}\nelse\n{\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0)\n{\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"========================\");\nSerial.println(\"  RAK12007 LoRaWAN test \");\nSerial.println(\"========================\");\n\n}\n\nvoid loop()\n{\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\n// long int duration, mm;\ndigitalWrite(LED_BLUE,HIGH);\ndigitalWrite(LED_GREEN, HIGH);\nduration = duration_time();\nif(duration > 0)\n{\nmm = duration*ratio; //Test distance = (high level time\u00d7velocity of sound (340M/S) / 2,\ndigitalWrite(LED_BLUE,LOW);\ndigitalWrite(LED_GREEN, LOW);\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\nSerial.print(mm);\nSerial.print(\"mm\");\nSerial.println();\ndelay(15000);\n}\nelse\n{\nSerial.println(\"Out of range\");\n}\ndelay(50);\n\n}\n\nlong int duration_time()\n{\nlong int respondTime;\npinMode(TRIG, OUTPUT);\ndigitalWrite(TRIG, HIGH);\ndelayMicroseconds(12);   //pull high time need over 10us\ndigitalWrite(TRIG, LOW);\npinMode(ECHO, INPUT);\nrespondTime = pulseIn(ECHO, HIGH); // microseconds\ndelay(33);\nif(RAK4631_BOARD)\n{\nrespondTime = respondTime*0.7726; // Time calibration factor is 0.7726,to get real time microseconds for 4631board\n}\nSerial.printf(\"respond time is %d\\r\\n\",respondTime);\n\nif((respondTime>0)&&(respondTime < TIME_OUT))  //ECHO pin max timeout is 33000us according it's datasheet\n{\nreturn respondTime;\n}\nelse\n{\nreturn -1;\n}\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void)\n{\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void)\n{\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data)\n{\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class)\n{\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void)\n{\nif (lmh_join_status_get() != LMH_SET)\n{\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\ndata = \"Distance:\" + String(mm) + \"mm\";\nSerial.println(data);\n\nuint32_t mm_data = mm;\n\nm_lora_app_data.buffer[i++] = 0x0A;\nm_lora_app_data.buffer[i++] = (uint8_t)((mm_data & 0xFF000000) >> 24);\nm_lora_app_data.buffer[i++] = (uint8_t)((mm_data & 0x00FF0000) >> 16);\nm_lora_app_data.buffer[i++] = (uint8_t)((mm_data & 0x0000FF00) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(mm_data & 0x000000FF);\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS)\n{\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n}\nelse\n{\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The following steps will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired regions to work with. You can change this to a region that is applicable to you, like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc.  \nThe following table lists the LoRaWAN regions and the countries where they are used:  \n| LoRaWAN Region         | Usage                                                             |\n| ---------------------- | ----------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1 | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan          |\n| LORAMAC_REGION_AS923-2 | Vietnam                                                           |\n| LORAMAC_REGION_AS923-3 | Philippines, Albania, Algeria, Denmark, Greenland, Jordan         |\n| LORAMAC_REGION_AS923-4 | Israel                                                            |\n| LORAMAC_REGION_AU915   | Australia, Anguilla, Argentina, and other parts of South America  |\n| LORAMAC_REGION_CN470   | China                                                             |\n| LORAMAC_REGION_EU433   | EU, UK, Brazil, Costa Rica, Cuba, and other parts of Africa       |\n| LORAMAC_REGION_IN865   | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger |\n| LORAMAC_REGION_EU868   | EU, UK and other parts of Africa                                  |\n| LORAMAC_REGION_KR920   | Republic of Korea                                                 |\n| LORAMAC_REGION_US915   | USA                                                               |\n| LORAMAC_REGION_RU864   | Russia                                                            |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n\n```\n- Set up the LoRaWAN activation method. In this case, you will use the **OTAA** configuration, which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change it to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n\n```  \n- Set up the EUIs and KEY. The **DeviceEUI**, **AppEUI**, and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x8B, 0x0E, 0x96, 0x86, 0xE8, 0x4E, 0xA3, 0xB5, 0x31, 0x42, 0xB3, 0x65, 0x75, 0xB1, 0xD3, 0xED};\n\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once you're done with the code, you can now proceed with uploading it to your device. You must first choose your RAK4631 board on your desktop or laptop. To do so, navigate to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** and select **WisBlock RAK4631**.  \n> **Image:** Selecting the RAK4631 board  \n4. After you have selected your board, go to **Tools** > **Port** and then select the specific port of your board.  \n> **Image:** Selecting the port of RAK4631 board  \n5. You can then upload your code by clicking the Upload button (the right arrow sign). Once completed, the **Device programmed** notification will appear in the console at the bottom of the Arduino IDE.  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "63735c6bdd84c9f9f326ad8c63ded078", "product_family": "wisblock", "product_id": "kit3-movement-detection", "category": "How-To", "title": "WisBlock Movement Detection Kit Quick Start Guide > WisBlock IoT Education Kit - Movement Detection Quick Start Guide > Product Configuration > Software Configuration and Examples > RAK12007 Ultrasonic Sensor LoRaWAN Application > LoRaWAN Code for RAK12007 > Programming RAK12007 Module with Arduino IDE [CODE]", "content": "lmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS)\n{\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n}\nelse\n{\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}", "keywords": ["Arduino IDE", "RAK4631", "RAK12007", "LoRaWAN", "programming"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed on your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you have not yet installed the **Arduino IDE**, go to the [RAK4631 Installation](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#arduino-ide-installation-rak4631) section and execute the following steps.  \n2. After the installation, you can now proceed with programming your **RAK12007** module. Simply copy the **RAK12007 LoRaWAN Application** code below and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE\nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n```c\n\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h> //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define  RAK4631_BOARD true\n#else\n#define  RAK4631_BOARD false\n#endif\n\n// Section to add include libraries, declarations and variables.\n\n#define Enable WB_IO2\n#define TRIG WB_IO6\n#define ECHO WB_IO4\n#define PD   WB_IO5   //power done control \uff08=1 power done\uff0c=0 power on\uff09\n\n#define TIME_OUT  24125 //max measure distance is 4m,the velocity of sound is 331.6m/s in 0\u2103,TIME_OUT=4*2/331.6*1000000=24215us\n\nfloat ratio = 346.6/1000/2;   //velocity of sound =331.6+0.6*25\u2103(m/s),(Indoor temperature about 25\u2103)\n\nlong int duration_time();  //measure high level time\n\nlong int duration, mm;\n\nbool doOTAA = true;   // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                     /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                   /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5             /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                      /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                      /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = {LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF};\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = {BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler\n};\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x8B, 0x0E, 0x96, 0x86, 0xE8, 0x4E, 0xA3, 0xB5, 0x31, 0x42, 0xB3, 0x65, 0x75, 0xB1, 0xD3, 0xED};\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = {0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23};\nuint8_t nodeAppsKey[16] = {0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C};\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                     /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];            //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = {m_lora_app_data_buffer, 0, 0, 0, 0}; //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup()\n{\npinMode(Enable, OUTPUT);\ndigitalWrite(Enable, HIGH);\npinMode(ECHO, INPUT);   // Echo Pin of Ultrasonic Sensor is an Input\npinMode(TRIG, OUTPUT);  // Trigger Pin of Ultrasonic Sensor is an Output\npinMode(PD, OUTPUT);    // power done control pin is an Output\ndigitalWrite(TRIG,LOW);\ndigitalWrite(PD,LOW);\n\npinMode(LED_GREEN, OUTPUT);  // Output LED\npinMode(LED_BLUE, OUTPUT);   // Output LED\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial)\n{\nif ((millis() - timeout) < 5000)\n{\ndelay(100);\n}\nelse\n{\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA)\n{\nSerial.println(\"Type: OTAA\");\n}\nelse\n{\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion)\n{\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA)\n{\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n}\nelse\n{\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0)\n{\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"========================\");\nSerial.println(\"  RAK12007 LoRaWAN test \");\nSerial.println(\"========================\");\n\n}\n\nvoid loop()\n{\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\n// long int duration, mm;\ndigitalWrite(LED_BLUE,HIGH);\ndigitalWrite(LED_GREEN, HIGH);\nduration = duration_time();\nif(duration > 0)\n{\nmm = duration*ratio; //Test distance = (high level time\u00d7velocity of sound (340M/S) / 2,\ndigitalWrite(LED_BLUE,LOW);\ndigitalWrite(LED_GREEN, LOW);\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\nSerial.print(mm);\nSerial.print(\"mm\");\nSerial.println();\ndelay(15000);\n}\nelse\n{\nSerial.println(\"Out of range\");\n}\ndelay(50);\n\n}\n\nlong int duration_time()\n{\nlong int respondTime;\npinMode(TRIG, OUTPUT);\ndigitalWrite(TRIG, HIGH);\ndelayMicroseconds(12);   //pull high time need over 10us\ndigitalWrite(TRIG, LOW);\npinMode(ECHO, INPUT);\nrespondTime = pulseIn(ECHO, HIGH); // microseconds\ndelay(33);\nif(RAK4631_BOARD)\n{\nrespondTime = respondTime*0.7726; // Time calibration factor is 0.7726,to get real time microseconds for 4631board\n}\nSerial.printf(\"respond time is %d\\r\\n\",respondTime);\n\nif((respondTime>0)&&(respondTime < TIME_OUT))  //ECHO pin max timeout is 33000us according it's datasheet\n{\nreturn respondTime;\n}\nelse\n{\nreturn -1;\n}\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void)\n{\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void)\n{\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data)\n{\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class)\n{\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void)\n{\nif (lmh_join_status_get() != LMH_SET)\n{\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\ndata = \"Distance:\" + String(mm) + \"mm\";\nSerial.println(data);\n\nuint32_t mm_data = mm;\n\nm_lora_app_data.buffer[i++] = 0x0A;\nm_lora_app_data.buffer[i++] = (uint8_t)((mm_data & 0xFF000000) >> 24);\nm_lora_app_data.buffer[i++] = (uint8_t)((mm_data & 0x00FF0000) >> 16);\nm_lora_app_data.buffer[i++] = (uint8_t)((mm_data & 0x0000FF00) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(mm_data & 0x000000FF);\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS)\n{\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n}\nelse\n{\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The following steps will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired regions to work with. You can change this to a region that is applicable to you, like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc.  \nThe following table lists the LoRaWAN regions and the countries where they are used:  \n| LoRaWAN Region         | Usage                                                             |\n| ---------------------- | ----------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1 | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan          |\n| LORAMAC_REGION_AS923-2 | Vietnam                                                           |\n| LORAMAC_REGION_AS923-3 | Philippines, Albania, Algeria, Denmark, Greenland, Jordan         |\n| LORAMAC_REGION_AS923-4 | Israel                                                            |\n| LORAMAC_REGION_AU915   | Australia, Anguilla, Argentina, and other parts of South America  |\n| LORAMAC_REGION_CN470   | China                                                             |\n| LORAMAC_REGION_EU433   | EU, UK, Brazil, Costa Rica, Cuba, and other parts of Africa       |\n| LORAMAC_REGION_IN865   | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger |\n| LORAMAC_REGION_EU868   | EU, UK and other parts of Africa                                  |\n| LORAMAC_REGION_KR920   | Republic of Korea                                                 |\n| LORAMAC_REGION_US915   | USA                                                               |\n| LORAMAC_REGION_RU864   | Russia                                                            |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n\n```\n- Set up the LoRaWAN activation method. In this case, you will use the **OTAA** configuration, which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change it to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n\n```  \n- Set up the EUIs and KEY. The **DeviceEUI**, **AppEUI**, and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x8B, 0x0E, 0x96, 0x86, 0xE8, 0x4E, 0xA3, 0xB5, 0x31, 0x42, 0xB3, 0x65, 0x75, 0xB1, 0xD3, 0xED};\n\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once you're done with the code, you can now proceed with uploading it to your device. You must first choose your RAK4631 board on your desktop or laptop. To do so, navigate to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** and select **WisBlock RAK4631**.  \n> **Image:** Selecting the RAK4631 board  \n4. After you have selected your board, go to **Tools** > **Port** and then select the specific port of your board.  \n> **Image:** Selecting the port of RAK4631 board  \n5. You can then upload your code by clicking the Upload button (the right arrow sign). Once completed, the **Device programmed** notification will appear in the console at the bottom of the Arduino IDE.  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "7fd669c3d36951f3b39ca476f68b8f1b", "product_family": "wisblock", "product_id": "kit3-movement-detection", "category": "How-To", "title": "WisBlock Movement Detection Kit Quick Start Guide > WisBlock IoT Education Kit - Movement Detection Quick Start Guide > Product Configuration > Software Configuration and Examples > RAK12007 Ultrasonic Sensor LoRaWAN Application > LoRaWAN Code for RAK12007 > Programming RAK12007 Module with Arduino IDE [CODE]", "content": "```  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The following steps will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired regions to work with. You can change this to a region that is applicable to you, like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc.", "keywords": ["Arduino IDE", "RAK4631", "RAK12007", "LoRaWAN", "programming"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed on your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you have not yet installed the **Arduino IDE**, go to the [RAK4631 Installation](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#arduino-ide-installation-rak4631) section and execute the following steps.  \n2. After the installation, you can now proceed with programming your **RAK12007** module. Simply copy the **RAK12007 LoRaWAN Application** code below and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE\nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n```c\n\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h> //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define  RAK4631_BOARD true\n#else\n#define  RAK4631_BOARD false\n#endif\n\n// Section to add include libraries, declarations and variables.\n\n#define Enable WB_IO2\n#define TRIG WB_IO6\n#define ECHO WB_IO4\n#define PD   WB_IO5   //power done control \uff08=1 power done\uff0c=0 power on\uff09\n\n#define TIME_OUT  24125 //max measure distance is 4m,the velocity of sound is 331.6m/s in 0\u2103,TIME_OUT=4*2/331.6*1000000=24215us\n\nfloat ratio = 346.6/1000/2;   //velocity of sound =331.6+0.6*25\u2103(m/s),(Indoor temperature about 25\u2103)\n\nlong int duration_time();  //measure high level time\n\nlong int duration, mm;\n\nbool doOTAA = true;   // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                     /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                   /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5             /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                      /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                      /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = {LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF};\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = {BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler\n};\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x8B, 0x0E, 0x96, 0x86, 0xE8, 0x4E, 0xA3, 0xB5, 0x31, 0x42, 0xB3, 0x65, 0x75, 0xB1, 0xD3, 0xED};\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = {0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23};\nuint8_t nodeAppsKey[16] = {0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C};\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                     /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];            //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = {m_lora_app_data_buffer, 0, 0, 0, 0}; //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup()\n{\npinMode(Enable, OUTPUT);\ndigitalWrite(Enable, HIGH);\npinMode(ECHO, INPUT);   // Echo Pin of Ultrasonic Sensor is an Input\npinMode(TRIG, OUTPUT);  // Trigger Pin of Ultrasonic Sensor is an Output\npinMode(PD, OUTPUT);    // power done control pin is an Output\ndigitalWrite(TRIG,LOW);\ndigitalWrite(PD,LOW);\n\npinMode(LED_GREEN, OUTPUT);  // Output LED\npinMode(LED_BLUE, OUTPUT);   // Output LED\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial)\n{\nif ((millis() - timeout) < 5000)\n{\ndelay(100);\n}\nelse\n{\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA)\n{\nSerial.println(\"Type: OTAA\");\n}\nelse\n{\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion)\n{\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA)\n{\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n}\nelse\n{\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0)\n{\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"========================\");\nSerial.println(\"  RAK12007 LoRaWAN test \");\nSerial.println(\"========================\");\n\n}\n\nvoid loop()\n{\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\n// long int duration, mm;\ndigitalWrite(LED_BLUE,HIGH);\ndigitalWrite(LED_GREEN, HIGH);\nduration = duration_time();\nif(duration > 0)\n{\nmm = duration*ratio; //Test distance = (high level time\u00d7velocity of sound (340M/S) / 2,\ndigitalWrite(LED_BLUE,LOW);\ndigitalWrite(LED_GREEN, LOW);\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\nSerial.print(mm);\nSerial.print(\"mm\");\nSerial.println();\ndelay(15000);\n}\nelse\n{\nSerial.println(\"Out of range\");\n}\ndelay(50);\n\n}\n\nlong int duration_time()\n{\nlong int respondTime;\npinMode(TRIG, OUTPUT);\ndigitalWrite(TRIG, HIGH);\ndelayMicroseconds(12);   //pull high time need over 10us\ndigitalWrite(TRIG, LOW);\npinMode(ECHO, INPUT);\nrespondTime = pulseIn(ECHO, HIGH); // microseconds\ndelay(33);\nif(RAK4631_BOARD)\n{\nrespondTime = respondTime*0.7726; // Time calibration factor is 0.7726,to get real time microseconds for 4631board\n}\nSerial.printf(\"respond time is %d\\r\\n\",respondTime);\n\nif((respondTime>0)&&(respondTime < TIME_OUT))  //ECHO pin max timeout is 33000us according it's datasheet\n{\nreturn respondTime;\n}\nelse\n{\nreturn -1;\n}\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void)\n{\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void)\n{\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data)\n{\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class)\n{\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void)\n{\nif (lmh_join_status_get() != LMH_SET)\n{\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\ndata = \"Distance:\" + String(mm) + \"mm\";\nSerial.println(data);\n\nuint32_t mm_data = mm;\n\nm_lora_app_data.buffer[i++] = 0x0A;\nm_lora_app_data.buffer[i++] = (uint8_t)((mm_data & 0xFF000000) >> 24);\nm_lora_app_data.buffer[i++] = (uint8_t)((mm_data & 0x00FF0000) >> 16);\nm_lora_app_data.buffer[i++] = (uint8_t)((mm_data & 0x0000FF00) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(mm_data & 0x000000FF);\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS)\n{\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n}\nelse\n{\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The following steps will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired regions to work with. You can change this to a region that is applicable to you, like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc.  \nThe following table lists the LoRaWAN regions and the countries where they are used:  \n| LoRaWAN Region         | Usage                                                             |\n| ---------------------- | ----------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1 | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan          |\n| LORAMAC_REGION_AS923-2 | Vietnam                                                           |\n| LORAMAC_REGION_AS923-3 | Philippines, Albania, Algeria, Denmark, Greenland, Jordan         |\n| LORAMAC_REGION_AS923-4 | Israel                                                            |\n| LORAMAC_REGION_AU915   | Australia, Anguilla, Argentina, and other parts of South America  |\n| LORAMAC_REGION_CN470   | China                                                             |\n| LORAMAC_REGION_EU433   | EU, UK, Brazil, Costa Rica, Cuba, and other parts of Africa       |\n| LORAMAC_REGION_IN865   | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger |\n| LORAMAC_REGION_EU868   | EU, UK and other parts of Africa                                  |\n| LORAMAC_REGION_KR920   | Republic of Korea                                                 |\n| LORAMAC_REGION_US915   | USA                                                               |\n| LORAMAC_REGION_RU864   | Russia                                                            |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n\n```\n- Set up the LoRaWAN activation method. In this case, you will use the **OTAA** configuration, which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change it to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n\n```  \n- Set up the EUIs and KEY. The **DeviceEUI**, **AppEUI**, and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x8B, 0x0E, 0x96, 0x86, 0xE8, 0x4E, 0xA3, 0xB5, 0x31, 0x42, 0xB3, 0x65, 0x75, 0xB1, 0xD3, 0xED};\n\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once you're done with the code, you can now proceed with uploading it to your device. You must first choose your RAK4631 board on your desktop or laptop. To do so, navigate to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** and select **WisBlock RAK4631**.  \n> **Image:** Selecting the RAK4631 board  \n4. After you have selected your board, go to **Tools** > **Port** and then select the specific port of your board.  \n> **Image:** Selecting the port of RAK4631 board  \n5. You can then upload your code by clicking the Upload button (the right arrow sign). Once completed, the **Device programmed** notification will appear in the console at the bottom of the Arduino IDE.  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "d3de0db4e38ecdb8e83bbeff29151488", "product_family": "wisblock", "product_id": "kit3-movement-detection", "category": "How-To", "title": "WisBlock Movement Detection Kit Quick Start Guide > WisBlock IoT Education Kit - Movement Detection Quick Start Guide > Product Configuration > Software Configuration and Examples > RAK12007 Ultrasonic Sensor LoRaWAN Application > LoRaWAN Code for RAK12007 > Programming RAK12007 Module with Arduino IDE [CODE]", "content": "The following table lists the LoRaWAN regions and the countries where they are used:  \n| LoRaWAN Region         | Usage                                                             |\n| ---------------------- | ----------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1 | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan          |\n| LORAMAC_REGION_AS923-2 | Vietnam                                                           |", "keywords": ["Arduino IDE", "RAK4631", "RAK12007", "LoRaWAN", "programming"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed on your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you have not yet installed the **Arduino IDE**, go to the [RAK4631 Installation](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#arduino-ide-installation-rak4631) section and execute the following steps.  \n2. After the installation, you can now proceed with programming your **RAK12007** module. Simply copy the **RAK12007 LoRaWAN Application** code below and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE\nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n```c\n\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h> //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define  RAK4631_BOARD true\n#else\n#define  RAK4631_BOARD false\n#endif\n\n// Section to add include libraries, declarations and variables.\n\n#define Enable WB_IO2\n#define TRIG WB_IO6\n#define ECHO WB_IO4\n#define PD   WB_IO5   //power done control \uff08=1 power done\uff0c=0 power on\uff09\n\n#define TIME_OUT  24125 //max measure distance is 4m,the velocity of sound is 331.6m/s in 0\u2103,TIME_OUT=4*2/331.6*1000000=24215us\n\nfloat ratio = 346.6/1000/2;   //velocity of sound =331.6+0.6*25\u2103(m/s),(Indoor temperature about 25\u2103)\n\nlong int duration_time();  //measure high level time\n\nlong int duration, mm;\n\nbool doOTAA = true;   // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                     /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                   /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5             /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                      /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                      /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = {LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF};\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = {BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler\n};\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x8B, 0x0E, 0x96, 0x86, 0xE8, 0x4E, 0xA3, 0xB5, 0x31, 0x42, 0xB3, 0x65, 0x75, 0xB1, 0xD3, 0xED};\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = {0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23};\nuint8_t nodeAppsKey[16] = {0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C};\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                     /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];            //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = {m_lora_app_data_buffer, 0, 0, 0, 0}; //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup()\n{\npinMode(Enable, OUTPUT);\ndigitalWrite(Enable, HIGH);\npinMode(ECHO, INPUT);   // Echo Pin of Ultrasonic Sensor is an Input\npinMode(TRIG, OUTPUT);  // Trigger Pin of Ultrasonic Sensor is an Output\npinMode(PD, OUTPUT);    // power done control pin is an Output\ndigitalWrite(TRIG,LOW);\ndigitalWrite(PD,LOW);\n\npinMode(LED_GREEN, OUTPUT);  // Output LED\npinMode(LED_BLUE, OUTPUT);   // Output LED\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial)\n{\nif ((millis() - timeout) < 5000)\n{\ndelay(100);\n}\nelse\n{\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA)\n{\nSerial.println(\"Type: OTAA\");\n}\nelse\n{\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion)\n{\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA)\n{\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n}\nelse\n{\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0)\n{\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"========================\");\nSerial.println(\"  RAK12007 LoRaWAN test \");\nSerial.println(\"========================\");\n\n}\n\nvoid loop()\n{\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\n// long int duration, mm;\ndigitalWrite(LED_BLUE,HIGH);\ndigitalWrite(LED_GREEN, HIGH);\nduration = duration_time();\nif(duration > 0)\n{\nmm = duration*ratio; //Test distance = (high level time\u00d7velocity of sound (340M/S) / 2,\ndigitalWrite(LED_BLUE,LOW);\ndigitalWrite(LED_GREEN, LOW);\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\nSerial.print(mm);\nSerial.print(\"mm\");\nSerial.println();\ndelay(15000);\n}\nelse\n{\nSerial.println(\"Out of range\");\n}\ndelay(50);\n\n}\n\nlong int duration_time()\n{\nlong int respondTime;\npinMode(TRIG, OUTPUT);\ndigitalWrite(TRIG, HIGH);\ndelayMicroseconds(12);   //pull high time need over 10us\ndigitalWrite(TRIG, LOW);\npinMode(ECHO, INPUT);\nrespondTime = pulseIn(ECHO, HIGH); // microseconds\ndelay(33);\nif(RAK4631_BOARD)\n{\nrespondTime = respondTime*0.7726; // Time calibration factor is 0.7726,to get real time microseconds for 4631board\n}\nSerial.printf(\"respond time is %d\\r\\n\",respondTime);\n\nif((respondTime>0)&&(respondTime < TIME_OUT))  //ECHO pin max timeout is 33000us according it's datasheet\n{\nreturn respondTime;\n}\nelse\n{\nreturn -1;\n}\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void)\n{\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void)\n{\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data)\n{\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class)\n{\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void)\n{\nif (lmh_join_status_get() != LMH_SET)\n{\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\ndata = \"Distance:\" + String(mm) + \"mm\";\nSerial.println(data);\n\nuint32_t mm_data = mm;\n\nm_lora_app_data.buffer[i++] = 0x0A;\nm_lora_app_data.buffer[i++] = (uint8_t)((mm_data & 0xFF000000) >> 24);\nm_lora_app_data.buffer[i++] = (uint8_t)((mm_data & 0x00FF0000) >> 16);\nm_lora_app_data.buffer[i++] = (uint8_t)((mm_data & 0x0000FF00) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(mm_data & 0x000000FF);\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS)\n{\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n}\nelse\n{\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The following steps will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired regions to work with. You can change this to a region that is applicable to you, like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc.  \nThe following table lists the LoRaWAN regions and the countries where they are used:  \n| LoRaWAN Region         | Usage                                                             |\n| ---------------------- | ----------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1 | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan          |\n| LORAMAC_REGION_AS923-2 | Vietnam                                                           |\n| LORAMAC_REGION_AS923-3 | Philippines, Albania, Algeria, Denmark, Greenland, Jordan         |\n| LORAMAC_REGION_AS923-4 | Israel                                                            |\n| LORAMAC_REGION_AU915   | Australia, Anguilla, Argentina, and other parts of South America  |\n| LORAMAC_REGION_CN470   | China                                                             |\n| LORAMAC_REGION_EU433   | EU, UK, Brazil, Costa Rica, Cuba, and other parts of Africa       |\n| LORAMAC_REGION_IN865   | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger |\n| LORAMAC_REGION_EU868   | EU, UK and other parts of Africa                                  |\n| LORAMAC_REGION_KR920   | Republic of Korea                                                 |\n| LORAMAC_REGION_US915   | USA                                                               |\n| LORAMAC_REGION_RU864   | Russia                                                            |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n\n```\n- Set up the LoRaWAN activation method. In this case, you will use the **OTAA** configuration, which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change it to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n\n```  \n- Set up the EUIs and KEY. The **DeviceEUI**, **AppEUI**, and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x8B, 0x0E, 0x96, 0x86, 0xE8, 0x4E, 0xA3, 0xB5, 0x31, 0x42, 0xB3, 0x65, 0x75, 0xB1, 0xD3, 0xED};\n\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once you're done with the code, you can now proceed with uploading it to your device. You must first choose your RAK4631 board on your desktop or laptop. To do so, navigate to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** and select **WisBlock RAK4631**.  \n> **Image:** Selecting the RAK4631 board  \n4. After you have selected your board, go to **Tools** > **Port** and then select the specific port of your board.  \n> **Image:** Selecting the port of RAK4631 board  \n5. You can then upload your code by clicking the Upload button (the right arrow sign). Once completed, the **Device programmed** notification will appear in the console at the bottom of the Arduino IDE.  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "d0e2232f7aa4d95016075a73d1769f85", "product_family": "wisblock", "product_id": "kit3-movement-detection", "category": "How-To", "title": "WisBlock Movement Detection Kit Quick Start Guide > WisBlock IoT Education Kit - Movement Detection Quick Start Guide > Product Configuration > Software Configuration and Examples > RAK12007 Ultrasonic Sensor LoRaWAN Application > LoRaWAN Code for RAK12007 > Programming RAK12007 Module with Arduino IDE [CODE]", "content": "| LoRaWAN Region         | Usage                                                             |\n| ---------------------- | ----------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-2 | Vietnam                                                           |\n| LORAMAC_REGION_AS923-3 | Philippines, Albania, Algeria, Denmark, Greenland, Jordan         |\n| LORAMAC_REGION_AS923-4 | Israel                                                            |\n| LORAMAC_REGION_AU915   | Australia, Anguilla, Argentina, and other parts of South America  |\n| LORAMAC_REGION_CN470   | China                                                             |", "keywords": ["Arduino IDE", "RAK4631", "RAK12007", "LoRaWAN", "programming"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed on your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you have not yet installed the **Arduino IDE**, go to the [RAK4631 Installation](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#arduino-ide-installation-rak4631) section and execute the following steps.  \n2. After the installation, you can now proceed with programming your **RAK12007** module. Simply copy the **RAK12007 LoRaWAN Application** code below and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE\nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n```c\n\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h> //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define  RAK4631_BOARD true\n#else\n#define  RAK4631_BOARD false\n#endif\n\n// Section to add include libraries, declarations and variables.\n\n#define Enable WB_IO2\n#define TRIG WB_IO6\n#define ECHO WB_IO4\n#define PD   WB_IO5   //power done control \uff08=1 power done\uff0c=0 power on\uff09\n\n#define TIME_OUT  24125 //max measure distance is 4m,the velocity of sound is 331.6m/s in 0\u2103,TIME_OUT=4*2/331.6*1000000=24215us\n\nfloat ratio = 346.6/1000/2;   //velocity of sound =331.6+0.6*25\u2103(m/s),(Indoor temperature about 25\u2103)\n\nlong int duration_time();  //measure high level time\n\nlong int duration, mm;\n\nbool doOTAA = true;   // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                     /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                   /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5             /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                      /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                      /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = {LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF};\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = {BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler\n};\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x8B, 0x0E, 0x96, 0x86, 0xE8, 0x4E, 0xA3, 0xB5, 0x31, 0x42, 0xB3, 0x65, 0x75, 0xB1, 0xD3, 0xED};\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = {0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23};\nuint8_t nodeAppsKey[16] = {0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C};\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                     /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];            //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = {m_lora_app_data_buffer, 0, 0, 0, 0}; //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup()\n{\npinMode(Enable, OUTPUT);\ndigitalWrite(Enable, HIGH);\npinMode(ECHO, INPUT);   // Echo Pin of Ultrasonic Sensor is an Input\npinMode(TRIG, OUTPUT);  // Trigger Pin of Ultrasonic Sensor is an Output\npinMode(PD, OUTPUT);    // power done control pin is an Output\ndigitalWrite(TRIG,LOW);\ndigitalWrite(PD,LOW);\n\npinMode(LED_GREEN, OUTPUT);  // Output LED\npinMode(LED_BLUE, OUTPUT);   // Output LED\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial)\n{\nif ((millis() - timeout) < 5000)\n{\ndelay(100);\n}\nelse\n{\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA)\n{\nSerial.println(\"Type: OTAA\");\n}\nelse\n{\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion)\n{\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA)\n{\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n}\nelse\n{\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0)\n{\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"========================\");\nSerial.println(\"  RAK12007 LoRaWAN test \");\nSerial.println(\"========================\");\n\n}\n\nvoid loop()\n{\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\n// long int duration, mm;\ndigitalWrite(LED_BLUE,HIGH);\ndigitalWrite(LED_GREEN, HIGH);\nduration = duration_time();\nif(duration > 0)\n{\nmm = duration*ratio; //Test distance = (high level time\u00d7velocity of sound (340M/S) / 2,\ndigitalWrite(LED_BLUE,LOW);\ndigitalWrite(LED_GREEN, LOW);\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\nSerial.print(mm);\nSerial.print(\"mm\");\nSerial.println();\ndelay(15000);\n}\nelse\n{\nSerial.println(\"Out of range\");\n}\ndelay(50);\n\n}\n\nlong int duration_time()\n{\nlong int respondTime;\npinMode(TRIG, OUTPUT);\ndigitalWrite(TRIG, HIGH);\ndelayMicroseconds(12);   //pull high time need over 10us\ndigitalWrite(TRIG, LOW);\npinMode(ECHO, INPUT);\nrespondTime = pulseIn(ECHO, HIGH); // microseconds\ndelay(33);\nif(RAK4631_BOARD)\n{\nrespondTime = respondTime*0.7726; // Time calibration factor is 0.7726,to get real time microseconds for 4631board\n}\nSerial.printf(\"respond time is %d\\r\\n\",respondTime);\n\nif((respondTime>0)&&(respondTime < TIME_OUT))  //ECHO pin max timeout is 33000us according it's datasheet\n{\nreturn respondTime;\n}\nelse\n{\nreturn -1;\n}\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void)\n{\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void)\n{\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data)\n{\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class)\n{\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void)\n{\nif (lmh_join_status_get() != LMH_SET)\n{\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\ndata = \"Distance:\" + String(mm) + \"mm\";\nSerial.println(data);\n\nuint32_t mm_data = mm;\n\nm_lora_app_data.buffer[i++] = 0x0A;\nm_lora_app_data.buffer[i++] = (uint8_t)((mm_data & 0xFF000000) >> 24);\nm_lora_app_data.buffer[i++] = (uint8_t)((mm_data & 0x00FF0000) >> 16);\nm_lora_app_data.buffer[i++] = (uint8_t)((mm_data & 0x0000FF00) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(mm_data & 0x000000FF);\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS)\n{\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n}\nelse\n{\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The following steps will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired regions to work with. You can change this to a region that is applicable to you, like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc.  \nThe following table lists the LoRaWAN regions and the countries where they are used:  \n| LoRaWAN Region         | Usage                                                             |\n| ---------------------- | ----------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1 | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan          |\n| LORAMAC_REGION_AS923-2 | Vietnam                                                           |\n| LORAMAC_REGION_AS923-3 | Philippines, Albania, Algeria, Denmark, Greenland, Jordan         |\n| LORAMAC_REGION_AS923-4 | Israel                                                            |\n| LORAMAC_REGION_AU915   | Australia, Anguilla, Argentina, and other parts of South America  |\n| LORAMAC_REGION_CN470   | China                                                             |\n| LORAMAC_REGION_EU433   | EU, UK, Brazil, Costa Rica, Cuba, and other parts of Africa       |\n| LORAMAC_REGION_IN865   | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger |\n| LORAMAC_REGION_EU868   | EU, UK and other parts of Africa                                  |\n| LORAMAC_REGION_KR920   | Republic of Korea                                                 |\n| LORAMAC_REGION_US915   | USA                                                               |\n| LORAMAC_REGION_RU864   | Russia                                                            |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n\n```\n- Set up the LoRaWAN activation method. In this case, you will use the **OTAA** configuration, which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change it to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n\n```  \n- Set up the EUIs and KEY. The **DeviceEUI**, **AppEUI**, and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x8B, 0x0E, 0x96, 0x86, 0xE8, 0x4E, 0xA3, 0xB5, 0x31, 0x42, 0xB3, 0x65, 0x75, 0xB1, 0xD3, 0xED};\n\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once you're done with the code, you can now proceed with uploading it to your device. You must first choose your RAK4631 board on your desktop or laptop. To do so, navigate to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** and select **WisBlock RAK4631**.  \n> **Image:** Selecting the RAK4631 board  \n4. After you have selected your board, go to **Tools** > **Port** and then select the specific port of your board.  \n> **Image:** Selecting the port of RAK4631 board  \n5. You can then upload your code by clicking the Upload button (the right arrow sign). Once completed, the **Device programmed** notification will appear in the console at the bottom of the Arduino IDE.  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "5cb1ec0d0acc4522b912726858bae043", "product_family": "wisblock", "product_id": "kit3-movement-detection", "category": "How-To", "title": "WisBlock Movement Detection Kit Quick Start Guide > WisBlock IoT Education Kit - Movement Detection Quick Start Guide > Product Configuration > Software Configuration and Examples > RAK12007 Ultrasonic Sensor LoRaWAN Application > LoRaWAN Code for RAK12007 > Programming RAK12007 Module with Arduino IDE [CODE]", "content": "| LoRaWAN Region         | Usage                                                             |\n| ---------------------- | ----------------------------------------------------------------- |\n| LORAMAC_REGION_CN470   | China                                                             |\n| LORAMAC_REGION_EU433   | EU, UK, Brazil, Costa Rica, Cuba, and other parts of Africa       |\n| LORAMAC_REGION_IN865   | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger |\n| LORAMAC_REGION_EU868   | EU, UK and other parts of Africa                                  |\n| LORAMAC_REGION_KR920   | Republic of Korea                                                 |", "keywords": ["Arduino IDE", "RAK4631", "RAK12007", "LoRaWAN", "programming"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed on your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you have not yet installed the **Arduino IDE**, go to the [RAK4631 Installation](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#arduino-ide-installation-rak4631) section and execute the following steps.  \n2. After the installation, you can now proceed with programming your **RAK12007** module. Simply copy the **RAK12007 LoRaWAN Application** code below and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE\nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n```c\n\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h> //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define  RAK4631_BOARD true\n#else\n#define  RAK4631_BOARD false\n#endif\n\n// Section to add include libraries, declarations and variables.\n\n#define Enable WB_IO2\n#define TRIG WB_IO6\n#define ECHO WB_IO4\n#define PD   WB_IO5   //power done control \uff08=1 power done\uff0c=0 power on\uff09\n\n#define TIME_OUT  24125 //max measure distance is 4m,the velocity of sound is 331.6m/s in 0\u2103,TIME_OUT=4*2/331.6*1000000=24215us\n\nfloat ratio = 346.6/1000/2;   //velocity of sound =331.6+0.6*25\u2103(m/s),(Indoor temperature about 25\u2103)\n\nlong int duration_time();  //measure high level time\n\nlong int duration, mm;\n\nbool doOTAA = true;   // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                     /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                   /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5             /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                      /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                      /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = {LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF};\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = {BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler\n};\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x8B, 0x0E, 0x96, 0x86, 0xE8, 0x4E, 0xA3, 0xB5, 0x31, 0x42, 0xB3, 0x65, 0x75, 0xB1, 0xD3, 0xED};\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = {0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23};\nuint8_t nodeAppsKey[16] = {0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C};\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                     /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];            //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = {m_lora_app_data_buffer, 0, 0, 0, 0}; //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup()\n{\npinMode(Enable, OUTPUT);\ndigitalWrite(Enable, HIGH);\npinMode(ECHO, INPUT);   // Echo Pin of Ultrasonic Sensor is an Input\npinMode(TRIG, OUTPUT);  // Trigger Pin of Ultrasonic Sensor is an Output\npinMode(PD, OUTPUT);    // power done control pin is an Output\ndigitalWrite(TRIG,LOW);\ndigitalWrite(PD,LOW);\n\npinMode(LED_GREEN, OUTPUT);  // Output LED\npinMode(LED_BLUE, OUTPUT);   // Output LED\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial)\n{\nif ((millis() - timeout) < 5000)\n{\ndelay(100);\n}\nelse\n{\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA)\n{\nSerial.println(\"Type: OTAA\");\n}\nelse\n{\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion)\n{\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA)\n{\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n}\nelse\n{\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0)\n{\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"========================\");\nSerial.println(\"  RAK12007 LoRaWAN test \");\nSerial.println(\"========================\");\n\n}\n\nvoid loop()\n{\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\n// long int duration, mm;\ndigitalWrite(LED_BLUE,HIGH);\ndigitalWrite(LED_GREEN, HIGH);\nduration = duration_time();\nif(duration > 0)\n{\nmm = duration*ratio; //Test distance = (high level time\u00d7velocity of sound (340M/S) / 2,\ndigitalWrite(LED_BLUE,LOW);\ndigitalWrite(LED_GREEN, LOW);\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\nSerial.print(mm);\nSerial.print(\"mm\");\nSerial.println();\ndelay(15000);\n}\nelse\n{\nSerial.println(\"Out of range\");\n}\ndelay(50);\n\n}\n\nlong int duration_time()\n{\nlong int respondTime;\npinMode(TRIG, OUTPUT);\ndigitalWrite(TRIG, HIGH);\ndelayMicroseconds(12);   //pull high time need over 10us\ndigitalWrite(TRIG, LOW);\npinMode(ECHO, INPUT);\nrespondTime = pulseIn(ECHO, HIGH); // microseconds\ndelay(33);\nif(RAK4631_BOARD)\n{\nrespondTime = respondTime*0.7726; // Time calibration factor is 0.7726,to get real time microseconds for 4631board\n}\nSerial.printf(\"respond time is %d\\r\\n\",respondTime);\n\nif((respondTime>0)&&(respondTime < TIME_OUT))  //ECHO pin max timeout is 33000us according it's datasheet\n{\nreturn respondTime;\n}\nelse\n{\nreturn -1;\n}\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void)\n{\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void)\n{\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data)\n{\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class)\n{\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void)\n{\nif (lmh_join_status_get() != LMH_SET)\n{\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\ndata = \"Distance:\" + String(mm) + \"mm\";\nSerial.println(data);\n\nuint32_t mm_data = mm;\n\nm_lora_app_data.buffer[i++] = 0x0A;\nm_lora_app_data.buffer[i++] = (uint8_t)((mm_data & 0xFF000000) >> 24);\nm_lora_app_data.buffer[i++] = (uint8_t)((mm_data & 0x00FF0000) >> 16);\nm_lora_app_data.buffer[i++] = (uint8_t)((mm_data & 0x0000FF00) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(mm_data & 0x000000FF);\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS)\n{\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n}\nelse\n{\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The following steps will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired regions to work with. You can change this to a region that is applicable to you, like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc.  \nThe following table lists the LoRaWAN regions and the countries where they are used:  \n| LoRaWAN Region         | Usage                                                             |\n| ---------------------- | ----------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1 | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan          |\n| LORAMAC_REGION_AS923-2 | Vietnam                                                           |\n| LORAMAC_REGION_AS923-3 | Philippines, Albania, Algeria, Denmark, Greenland, Jordan         |\n| LORAMAC_REGION_AS923-4 | Israel                                                            |\n| LORAMAC_REGION_AU915   | Australia, Anguilla, Argentina, and other parts of South America  |\n| LORAMAC_REGION_CN470   | China                                                             |\n| LORAMAC_REGION_EU433   | EU, UK, Brazil, Costa Rica, Cuba, and other parts of Africa       |\n| LORAMAC_REGION_IN865   | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger |\n| LORAMAC_REGION_EU868   | EU, UK and other parts of Africa                                  |\n| LORAMAC_REGION_KR920   | Republic of Korea                                                 |\n| LORAMAC_REGION_US915   | USA                                                               |\n| LORAMAC_REGION_RU864   | Russia                                                            |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n\n```\n- Set up the LoRaWAN activation method. In this case, you will use the **OTAA** configuration, which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change it to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n\n```  \n- Set up the EUIs and KEY. The **DeviceEUI**, **AppEUI**, and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x8B, 0x0E, 0x96, 0x86, 0xE8, 0x4E, 0xA3, 0xB5, 0x31, 0x42, 0xB3, 0x65, 0x75, 0xB1, 0xD3, 0xED};\n\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once you're done with the code, you can now proceed with uploading it to your device. You must first choose your RAK4631 board on your desktop or laptop. To do so, navigate to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** and select **WisBlock RAK4631**.  \n> **Image:** Selecting the RAK4631 board  \n4. After you have selected your board, go to **Tools** > **Port** and then select the specific port of your board.  \n> **Image:** Selecting the port of RAK4631 board  \n5. You can then upload your code by clicking the Upload button (the right arrow sign). Once completed, the **Device programmed** notification will appear in the console at the bottom of the Arduino IDE.  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "aeb34b6d48942805bfb56266cef4031d", "product_family": "wisblock", "product_id": "kit3-movement-detection", "category": "How-To", "title": "WisBlock Movement Detection Kit Quick Start Guide > WisBlock IoT Education Kit - Movement Detection Quick Start Guide > Product Configuration > Software Configuration and Examples > RAK12007 Ultrasonic Sensor LoRaWAN Application > LoRaWAN Code for RAK12007 > Programming RAK12007 Module with Arduino IDE [CODE]", "content": "| LoRaWAN Region         | Usage                                                             |\n| ---------------------- | ----------------------------------------------------------------- |\n| LORAMAC_REGION_KR920   | Republic of Korea                                                 |\n| LORAMAC_REGION_US915   | USA                                                               |\n| LORAMAC_REGION_RU864   | Russia                                                            |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/", "keywords": ["Arduino IDE", "RAK4631", "RAK12007", "LoRaWAN", "programming"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed on your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you have not yet installed the **Arduino IDE**, go to the [RAK4631 Installation](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#arduino-ide-installation-rak4631) section and execute the following steps.  \n2. After the installation, you can now proceed with programming your **RAK12007** module. Simply copy the **RAK12007 LoRaWAN Application** code below and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE\nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n```c\n\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h> //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define  RAK4631_BOARD true\n#else\n#define  RAK4631_BOARD false\n#endif\n\n// Section to add include libraries, declarations and variables.\n\n#define Enable WB_IO2\n#define TRIG WB_IO6\n#define ECHO WB_IO4\n#define PD   WB_IO5   //power done control \uff08=1 power done\uff0c=0 power on\uff09\n\n#define TIME_OUT  24125 //max measure distance is 4m,the velocity of sound is 331.6m/s in 0\u2103,TIME_OUT=4*2/331.6*1000000=24215us\n\nfloat ratio = 346.6/1000/2;   //velocity of sound =331.6+0.6*25\u2103(m/s),(Indoor temperature about 25\u2103)\n\nlong int duration_time();  //measure high level time\n\nlong int duration, mm;\n\nbool doOTAA = true;   // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                     /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                   /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5             /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                      /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                      /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = {LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF};\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = {BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler\n};\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x8B, 0x0E, 0x96, 0x86, 0xE8, 0x4E, 0xA3, 0xB5, 0x31, 0x42, 0xB3, 0x65, 0x75, 0xB1, 0xD3, 0xED};\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = {0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23};\nuint8_t nodeAppsKey[16] = {0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C};\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                     /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];            //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = {m_lora_app_data_buffer, 0, 0, 0, 0}; //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup()\n{\npinMode(Enable, OUTPUT);\ndigitalWrite(Enable, HIGH);\npinMode(ECHO, INPUT);   // Echo Pin of Ultrasonic Sensor is an Input\npinMode(TRIG, OUTPUT);  // Trigger Pin of Ultrasonic Sensor is an Output\npinMode(PD, OUTPUT);    // power done control pin is an Output\ndigitalWrite(TRIG,LOW);\ndigitalWrite(PD,LOW);\n\npinMode(LED_GREEN, OUTPUT);  // Output LED\npinMode(LED_BLUE, OUTPUT);   // Output LED\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial)\n{\nif ((millis() - timeout) < 5000)\n{\ndelay(100);\n}\nelse\n{\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA)\n{\nSerial.println(\"Type: OTAA\");\n}\nelse\n{\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion)\n{\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA)\n{\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n}\nelse\n{\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0)\n{\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"========================\");\nSerial.println(\"  RAK12007 LoRaWAN test \");\nSerial.println(\"========================\");\n\n}\n\nvoid loop()\n{\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\n// long int duration, mm;\ndigitalWrite(LED_BLUE,HIGH);\ndigitalWrite(LED_GREEN, HIGH);\nduration = duration_time();\nif(duration > 0)\n{\nmm = duration*ratio; //Test distance = (high level time\u00d7velocity of sound (340M/S) / 2,\ndigitalWrite(LED_BLUE,LOW);\ndigitalWrite(LED_GREEN, LOW);\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\nSerial.print(mm);\nSerial.print(\"mm\");\nSerial.println();\ndelay(15000);\n}\nelse\n{\nSerial.println(\"Out of range\");\n}\ndelay(50);\n\n}\n\nlong int duration_time()\n{\nlong int respondTime;\npinMode(TRIG, OUTPUT);\ndigitalWrite(TRIG, HIGH);\ndelayMicroseconds(12);   //pull high time need over 10us\ndigitalWrite(TRIG, LOW);\npinMode(ECHO, INPUT);\nrespondTime = pulseIn(ECHO, HIGH); // microseconds\ndelay(33);\nif(RAK4631_BOARD)\n{\nrespondTime = respondTime*0.7726; // Time calibration factor is 0.7726,to get real time microseconds for 4631board\n}\nSerial.printf(\"respond time is %d\\r\\n\",respondTime);\n\nif((respondTime>0)&&(respondTime < TIME_OUT))  //ECHO pin max timeout is 33000us according it's datasheet\n{\nreturn respondTime;\n}\nelse\n{\nreturn -1;\n}\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void)\n{\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void)\n{\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data)\n{\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class)\n{\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void)\n{\nif (lmh_join_status_get() != LMH_SET)\n{\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\ndata = \"Distance:\" + String(mm) + \"mm\";\nSerial.println(data);\n\nuint32_t mm_data = mm;\n\nm_lora_app_data.buffer[i++] = 0x0A;\nm_lora_app_data.buffer[i++] = (uint8_t)((mm_data & 0xFF000000) >> 24);\nm_lora_app_data.buffer[i++] = (uint8_t)((mm_data & 0x00FF0000) >> 16);\nm_lora_app_data.buffer[i++] = (uint8_t)((mm_data & 0x0000FF00) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(mm_data & 0x000000FF);\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS)\n{\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n}\nelse\n{\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The following steps will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired regions to work with. You can change this to a region that is applicable to you, like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc.  \nThe following table lists the LoRaWAN regions and the countries where they are used:  \n| LoRaWAN Region         | Usage                                                             |\n| ---------------------- | ----------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1 | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan          |\n| LORAMAC_REGION_AS923-2 | Vietnam                                                           |\n| LORAMAC_REGION_AS923-3 | Philippines, Albania, Algeria, Denmark, Greenland, Jordan         |\n| LORAMAC_REGION_AS923-4 | Israel                                                            |\n| LORAMAC_REGION_AU915   | Australia, Anguilla, Argentina, and other parts of South America  |\n| LORAMAC_REGION_CN470   | China                                                             |\n| LORAMAC_REGION_EU433   | EU, UK, Brazil, Costa Rica, Cuba, and other parts of Africa       |\n| LORAMAC_REGION_IN865   | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger |\n| LORAMAC_REGION_EU868   | EU, UK and other parts of Africa                                  |\n| LORAMAC_REGION_KR920   | Republic of Korea                                                 |\n| LORAMAC_REGION_US915   | USA                                                               |\n| LORAMAC_REGION_RU864   | Russia                                                            |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n\n```\n- Set up the LoRaWAN activation method. In this case, you will use the **OTAA** configuration, which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change it to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n\n```  \n- Set up the EUIs and KEY. The **DeviceEUI**, **AppEUI**, and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x8B, 0x0E, 0x96, 0x86, 0xE8, 0x4E, 0xA3, 0xB5, 0x31, 0x42, 0xB3, 0x65, 0x75, 0xB1, 0xD3, 0xED};\n\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once you're done with the code, you can now proceed with uploading it to your device. You must first choose your RAK4631 board on your desktop or laptop. To do so, navigate to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** and select **WisBlock RAK4631**.  \n> **Image:** Selecting the RAK4631 board  \n4. After you have selected your board, go to **Tools** > **Port** and then select the specific port of your board.  \n> **Image:** Selecting the port of RAK4631 board  \n5. You can then upload your code by clicking the Upload button (the right arrow sign). Once completed, the **Device programmed** notification will appear in the console at the bottom of the Arduino IDE.  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "e24c39e221a7eb2f475142eea10ee1f3", "product_family": "wisblock", "product_id": "kit3-movement-detection", "category": "How-To", "title": "WisBlock Movement Detection Kit Quick Start Guide > WisBlock IoT Education Kit - Movement Detection Quick Start Guide > Product Configuration > Software Configuration and Examples > RAK12007 Ultrasonic Sensor LoRaWAN Application > LoRaWAN Code for RAK12007 > Programming RAK12007 Module with Arduino IDE [CODE]", "content": "```\n- Set up the LoRaWAN activation method. In this case, you will use the **OTAA** configuration, which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.", "keywords": ["Arduino IDE", "RAK4631", "RAK12007", "LoRaWAN", "programming"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed on your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you have not yet installed the **Arduino IDE**, go to the [RAK4631 Installation](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#arduino-ide-installation-rak4631) section and execute the following steps.  \n2. After the installation, you can now proceed with programming your **RAK12007** module. Simply copy the **RAK12007 LoRaWAN Application** code below and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE\nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n```c\n\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h> //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define  RAK4631_BOARD true\n#else\n#define  RAK4631_BOARD false\n#endif\n\n// Section to add include libraries, declarations and variables.\n\n#define Enable WB_IO2\n#define TRIG WB_IO6\n#define ECHO WB_IO4\n#define PD   WB_IO5   //power done control \uff08=1 power done\uff0c=0 power on\uff09\n\n#define TIME_OUT  24125 //max measure distance is 4m,the velocity of sound is 331.6m/s in 0\u2103,TIME_OUT=4*2/331.6*1000000=24215us\n\nfloat ratio = 346.6/1000/2;   //velocity of sound =331.6+0.6*25\u2103(m/s),(Indoor temperature about 25\u2103)\n\nlong int duration_time();  //measure high level time\n\nlong int duration, mm;\n\nbool doOTAA = true;   // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                     /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                   /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5             /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                      /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                      /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = {LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF};\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = {BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler\n};\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x8B, 0x0E, 0x96, 0x86, 0xE8, 0x4E, 0xA3, 0xB5, 0x31, 0x42, 0xB3, 0x65, 0x75, 0xB1, 0xD3, 0xED};\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = {0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23};\nuint8_t nodeAppsKey[16] = {0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C};\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                     /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];            //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = {m_lora_app_data_buffer, 0, 0, 0, 0}; //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup()\n{\npinMode(Enable, OUTPUT);\ndigitalWrite(Enable, HIGH);\npinMode(ECHO, INPUT);   // Echo Pin of Ultrasonic Sensor is an Input\npinMode(TRIG, OUTPUT);  // Trigger Pin of Ultrasonic Sensor is an Output\npinMode(PD, OUTPUT);    // power done control pin is an Output\ndigitalWrite(TRIG,LOW);\ndigitalWrite(PD,LOW);\n\npinMode(LED_GREEN, OUTPUT);  // Output LED\npinMode(LED_BLUE, OUTPUT);   // Output LED\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial)\n{\nif ((millis() - timeout) < 5000)\n{\ndelay(100);\n}\nelse\n{\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA)\n{\nSerial.println(\"Type: OTAA\");\n}\nelse\n{\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion)\n{\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA)\n{\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n}\nelse\n{\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0)\n{\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"========================\");\nSerial.println(\"  RAK12007 LoRaWAN test \");\nSerial.println(\"========================\");\n\n}\n\nvoid loop()\n{\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\n// long int duration, mm;\ndigitalWrite(LED_BLUE,HIGH);\ndigitalWrite(LED_GREEN, HIGH);\nduration = duration_time();\nif(duration > 0)\n{\nmm = duration*ratio; //Test distance = (high level time\u00d7velocity of sound (340M/S) / 2,\ndigitalWrite(LED_BLUE,LOW);\ndigitalWrite(LED_GREEN, LOW);\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\nSerial.print(mm);\nSerial.print(\"mm\");\nSerial.println();\ndelay(15000);\n}\nelse\n{\nSerial.println(\"Out of range\");\n}\ndelay(50);\n\n}\n\nlong int duration_time()\n{\nlong int respondTime;\npinMode(TRIG, OUTPUT);\ndigitalWrite(TRIG, HIGH);\ndelayMicroseconds(12);   //pull high time need over 10us\ndigitalWrite(TRIG, LOW);\npinMode(ECHO, INPUT);\nrespondTime = pulseIn(ECHO, HIGH); // microseconds\ndelay(33);\nif(RAK4631_BOARD)\n{\nrespondTime = respondTime*0.7726; // Time calibration factor is 0.7726,to get real time microseconds for 4631board\n}\nSerial.printf(\"respond time is %d\\r\\n\",respondTime);\n\nif((respondTime>0)&&(respondTime < TIME_OUT))  //ECHO pin max timeout is 33000us according it's datasheet\n{\nreturn respondTime;\n}\nelse\n{\nreturn -1;\n}\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void)\n{\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void)\n{\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data)\n{\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class)\n{\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void)\n{\nif (lmh_join_status_get() != LMH_SET)\n{\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\ndata = \"Distance:\" + String(mm) + \"mm\";\nSerial.println(data);\n\nuint32_t mm_data = mm;\n\nm_lora_app_data.buffer[i++] = 0x0A;\nm_lora_app_data.buffer[i++] = (uint8_t)((mm_data & 0xFF000000) >> 24);\nm_lora_app_data.buffer[i++] = (uint8_t)((mm_data & 0x00FF0000) >> 16);\nm_lora_app_data.buffer[i++] = (uint8_t)((mm_data & 0x0000FF00) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(mm_data & 0x000000FF);\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS)\n{\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n}\nelse\n{\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The following steps will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired regions to work with. You can change this to a region that is applicable to you, like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc.  \nThe following table lists the LoRaWAN regions and the countries where they are used:  \n| LoRaWAN Region         | Usage                                                             |\n| ---------------------- | ----------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1 | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan          |\n| LORAMAC_REGION_AS923-2 | Vietnam                                                           |\n| LORAMAC_REGION_AS923-3 | Philippines, Albania, Algeria, Denmark, Greenland, Jordan         |\n| LORAMAC_REGION_AS923-4 | Israel                                                            |\n| LORAMAC_REGION_AU915   | Australia, Anguilla, Argentina, and other parts of South America  |\n| LORAMAC_REGION_CN470   | China                                                             |\n| LORAMAC_REGION_EU433   | EU, UK, Brazil, Costa Rica, Cuba, and other parts of Africa       |\n| LORAMAC_REGION_IN865   | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger |\n| LORAMAC_REGION_EU868   | EU, UK and other parts of Africa                                  |\n| LORAMAC_REGION_KR920   | Republic of Korea                                                 |\n| LORAMAC_REGION_US915   | USA                                                               |\n| LORAMAC_REGION_RU864   | Russia                                                            |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n\n```\n- Set up the LoRaWAN activation method. In this case, you will use the **OTAA** configuration, which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change it to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n\n```  \n- Set up the EUIs and KEY. The **DeviceEUI**, **AppEUI**, and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x8B, 0x0E, 0x96, 0x86, 0xE8, 0x4E, 0xA3, 0xB5, 0x31, 0x42, 0xB3, 0x65, 0x75, 0xB1, 0xD3, 0xED};\n\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once you're done with the code, you can now proceed with uploading it to your device. You must first choose your RAK4631 board on your desktop or laptop. To do so, navigate to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** and select **WisBlock RAK4631**.  \n> **Image:** Selecting the RAK4631 board  \n4. After you have selected your board, go to **Tools** > **Port** and then select the specific port of your board.  \n> **Image:** Selecting the port of RAK4631 board  \n5. You can then upload your code by clicking the Upload button (the right arrow sign). Once completed, the **Device programmed** notification will appear in the console at the bottom of the Arduino IDE.  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "815588da5a0ce51e0107a077db9c99ba", "product_family": "wisblock", "product_id": "kit3-movement-detection", "category": "How-To", "title": "WisBlock Movement Detection Kit Quick Start Guide > WisBlock IoT Education Kit - Movement Detection Quick Start Guide > Product Configuration > Software Configuration and Examples > RAK12007 Ultrasonic Sensor LoRaWAN Application > LoRaWAN Code for RAK12007 > Programming RAK12007 Module with Arduino IDE [CODE]", "content": "```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change it to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/", "keywords": ["Arduino IDE", "RAK4631", "RAK12007", "LoRaWAN", "programming"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed on your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you have not yet installed the **Arduino IDE**, go to the [RAK4631 Installation](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#arduino-ide-installation-rak4631) section and execute the following steps.  \n2. After the installation, you can now proceed with programming your **RAK12007** module. Simply copy the **RAK12007 LoRaWAN Application** code below and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE\nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n```c\n\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h> //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define  RAK4631_BOARD true\n#else\n#define  RAK4631_BOARD false\n#endif\n\n// Section to add include libraries, declarations and variables.\n\n#define Enable WB_IO2\n#define TRIG WB_IO6\n#define ECHO WB_IO4\n#define PD   WB_IO5   //power done control \uff08=1 power done\uff0c=0 power on\uff09\n\n#define TIME_OUT  24125 //max measure distance is 4m,the velocity of sound is 331.6m/s in 0\u2103,TIME_OUT=4*2/331.6*1000000=24215us\n\nfloat ratio = 346.6/1000/2;   //velocity of sound =331.6+0.6*25\u2103(m/s),(Indoor temperature about 25\u2103)\n\nlong int duration_time();  //measure high level time\n\nlong int duration, mm;\n\nbool doOTAA = true;   // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                     /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                   /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5             /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                      /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                      /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = {LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF};\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = {BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler\n};\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x8B, 0x0E, 0x96, 0x86, 0xE8, 0x4E, 0xA3, 0xB5, 0x31, 0x42, 0xB3, 0x65, 0x75, 0xB1, 0xD3, 0xED};\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = {0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23};\nuint8_t nodeAppsKey[16] = {0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C};\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                     /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];            //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = {m_lora_app_data_buffer, 0, 0, 0, 0}; //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup()\n{\npinMode(Enable, OUTPUT);\ndigitalWrite(Enable, HIGH);\npinMode(ECHO, INPUT);   // Echo Pin of Ultrasonic Sensor is an Input\npinMode(TRIG, OUTPUT);  // Trigger Pin of Ultrasonic Sensor is an Output\npinMode(PD, OUTPUT);    // power done control pin is an Output\ndigitalWrite(TRIG,LOW);\ndigitalWrite(PD,LOW);\n\npinMode(LED_GREEN, OUTPUT);  // Output LED\npinMode(LED_BLUE, OUTPUT);   // Output LED\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial)\n{\nif ((millis() - timeout) < 5000)\n{\ndelay(100);\n}\nelse\n{\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA)\n{\nSerial.println(\"Type: OTAA\");\n}\nelse\n{\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion)\n{\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA)\n{\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n}\nelse\n{\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0)\n{\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"========================\");\nSerial.println(\"  RAK12007 LoRaWAN test \");\nSerial.println(\"========================\");\n\n}\n\nvoid loop()\n{\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\n// long int duration, mm;\ndigitalWrite(LED_BLUE,HIGH);\ndigitalWrite(LED_GREEN, HIGH);\nduration = duration_time();\nif(duration > 0)\n{\nmm = duration*ratio; //Test distance = (high level time\u00d7velocity of sound (340M/S) / 2,\ndigitalWrite(LED_BLUE,LOW);\ndigitalWrite(LED_GREEN, LOW);\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\nSerial.print(mm);\nSerial.print(\"mm\");\nSerial.println();\ndelay(15000);\n}\nelse\n{\nSerial.println(\"Out of range\");\n}\ndelay(50);\n\n}\n\nlong int duration_time()\n{\nlong int respondTime;\npinMode(TRIG, OUTPUT);\ndigitalWrite(TRIG, HIGH);\ndelayMicroseconds(12);   //pull high time need over 10us\ndigitalWrite(TRIG, LOW);\npinMode(ECHO, INPUT);\nrespondTime = pulseIn(ECHO, HIGH); // microseconds\ndelay(33);\nif(RAK4631_BOARD)\n{\nrespondTime = respondTime*0.7726; // Time calibration factor is 0.7726,to get real time microseconds for 4631board\n}\nSerial.printf(\"respond time is %d\\r\\n\",respondTime);\n\nif((respondTime>0)&&(respondTime < TIME_OUT))  //ECHO pin max timeout is 33000us according it's datasheet\n{\nreturn respondTime;\n}\nelse\n{\nreturn -1;\n}\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void)\n{\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void)\n{\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data)\n{\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class)\n{\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void)\n{\nif (lmh_join_status_get() != LMH_SET)\n{\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\ndata = \"Distance:\" + String(mm) + \"mm\";\nSerial.println(data);\n\nuint32_t mm_data = mm;\n\nm_lora_app_data.buffer[i++] = 0x0A;\nm_lora_app_data.buffer[i++] = (uint8_t)((mm_data & 0xFF000000) >> 24);\nm_lora_app_data.buffer[i++] = (uint8_t)((mm_data & 0x00FF0000) >> 16);\nm_lora_app_data.buffer[i++] = (uint8_t)((mm_data & 0x0000FF00) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(mm_data & 0x000000FF);\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS)\n{\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n}\nelse\n{\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The following steps will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired regions to work with. You can change this to a region that is applicable to you, like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc.  \nThe following table lists the LoRaWAN regions and the countries where they are used:  \n| LoRaWAN Region         | Usage                                                             |\n| ---------------------- | ----------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1 | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan          |\n| LORAMAC_REGION_AS923-2 | Vietnam                                                           |\n| LORAMAC_REGION_AS923-3 | Philippines, Albania, Algeria, Denmark, Greenland, Jordan         |\n| LORAMAC_REGION_AS923-4 | Israel                                                            |\n| LORAMAC_REGION_AU915   | Australia, Anguilla, Argentina, and other parts of South America  |\n| LORAMAC_REGION_CN470   | China                                                             |\n| LORAMAC_REGION_EU433   | EU, UK, Brazil, Costa Rica, Cuba, and other parts of Africa       |\n| LORAMAC_REGION_IN865   | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger |\n| LORAMAC_REGION_EU868   | EU, UK and other parts of Africa                                  |\n| LORAMAC_REGION_KR920   | Republic of Korea                                                 |\n| LORAMAC_REGION_US915   | USA                                                               |\n| LORAMAC_REGION_RU864   | Russia                                                            |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n\n```\n- Set up the LoRaWAN activation method. In this case, you will use the **OTAA** configuration, which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change it to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n\n```  \n- Set up the EUIs and KEY. The **DeviceEUI**, **AppEUI**, and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x8B, 0x0E, 0x96, 0x86, 0xE8, 0x4E, 0xA3, 0xB5, 0x31, 0x42, 0xB3, 0x65, 0x75, 0xB1, 0xD3, 0xED};\n\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once you're done with the code, you can now proceed with uploading it to your device. You must first choose your RAK4631 board on your desktop or laptop. To do so, navigate to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** and select **WisBlock RAK4631**.  \n> **Image:** Selecting the RAK4631 board  \n4. After you have selected your board, go to **Tools** > **Port** and then select the specific port of your board.  \n> **Image:** Selecting the port of RAK4631 board  \n5. You can then upload your code by clicking the Upload button (the right arrow sign). Once completed, the **Device programmed** notification will appear in the console at the bottom of the Arduino IDE.  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "8d41db7ba642dbab511f74e3a71eac6f", "product_family": "wisblock", "product_id": "kit3-movement-detection", "category": "How-To", "title": "WisBlock Movement Detection Kit Quick Start Guide > WisBlock IoT Education Kit - Movement Detection Quick Start Guide > Product Configuration > Software Configuration and Examples > RAK12007 Ultrasonic Sensor LoRaWAN Application > LoRaWAN Code for RAK12007 > Programming RAK12007 Module with Arduino IDE [CODE]", "content": "```  \n- Set up the EUIs and KEY. The **DeviceEUI**, **AppEUI**, and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};", "keywords": ["Arduino IDE", "RAK4631", "RAK12007", "LoRaWAN", "programming"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed on your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you have not yet installed the **Arduino IDE**, go to the [RAK4631 Installation](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#arduino-ide-installation-rak4631) section and execute the following steps.  \n2. After the installation, you can now proceed with programming your **RAK12007** module. Simply copy the **RAK12007 LoRaWAN Application** code below and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE\nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n```c\n\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h> //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define  RAK4631_BOARD true\n#else\n#define  RAK4631_BOARD false\n#endif\n\n// Section to add include libraries, declarations and variables.\n\n#define Enable WB_IO2\n#define TRIG WB_IO6\n#define ECHO WB_IO4\n#define PD   WB_IO5   //power done control \uff08=1 power done\uff0c=0 power on\uff09\n\n#define TIME_OUT  24125 //max measure distance is 4m,the velocity of sound is 331.6m/s in 0\u2103,TIME_OUT=4*2/331.6*1000000=24215us\n\nfloat ratio = 346.6/1000/2;   //velocity of sound =331.6+0.6*25\u2103(m/s),(Indoor temperature about 25\u2103)\n\nlong int duration_time();  //measure high level time\n\nlong int duration, mm;\n\nbool doOTAA = true;   // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                     /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                   /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5             /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                      /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                      /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = {LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF};\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = {BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler\n};\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x8B, 0x0E, 0x96, 0x86, 0xE8, 0x4E, 0xA3, 0xB5, 0x31, 0x42, 0xB3, 0x65, 0x75, 0xB1, 0xD3, 0xED};\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = {0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23};\nuint8_t nodeAppsKey[16] = {0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C};\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                     /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];            //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = {m_lora_app_data_buffer, 0, 0, 0, 0}; //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup()\n{\npinMode(Enable, OUTPUT);\ndigitalWrite(Enable, HIGH);\npinMode(ECHO, INPUT);   // Echo Pin of Ultrasonic Sensor is an Input\npinMode(TRIG, OUTPUT);  // Trigger Pin of Ultrasonic Sensor is an Output\npinMode(PD, OUTPUT);    // power done control pin is an Output\ndigitalWrite(TRIG,LOW);\ndigitalWrite(PD,LOW);\n\npinMode(LED_GREEN, OUTPUT);  // Output LED\npinMode(LED_BLUE, OUTPUT);   // Output LED\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial)\n{\nif ((millis() - timeout) < 5000)\n{\ndelay(100);\n}\nelse\n{\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA)\n{\nSerial.println(\"Type: OTAA\");\n}\nelse\n{\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion)\n{\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA)\n{\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n}\nelse\n{\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0)\n{\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"========================\");\nSerial.println(\"  RAK12007 LoRaWAN test \");\nSerial.println(\"========================\");\n\n}\n\nvoid loop()\n{\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\n// long int duration, mm;\ndigitalWrite(LED_BLUE,HIGH);\ndigitalWrite(LED_GREEN, HIGH);\nduration = duration_time();\nif(duration > 0)\n{\nmm = duration*ratio; //Test distance = (high level time\u00d7velocity of sound (340M/S) / 2,\ndigitalWrite(LED_BLUE,LOW);\ndigitalWrite(LED_GREEN, LOW);\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\nSerial.print(mm);\nSerial.print(\"mm\");\nSerial.println();\ndelay(15000);\n}\nelse\n{\nSerial.println(\"Out of range\");\n}\ndelay(50);\n\n}\n\nlong int duration_time()\n{\nlong int respondTime;\npinMode(TRIG, OUTPUT);\ndigitalWrite(TRIG, HIGH);\ndelayMicroseconds(12);   //pull high time need over 10us\ndigitalWrite(TRIG, LOW);\npinMode(ECHO, INPUT);\nrespondTime = pulseIn(ECHO, HIGH); // microseconds\ndelay(33);\nif(RAK4631_BOARD)\n{\nrespondTime = respondTime*0.7726; // Time calibration factor is 0.7726,to get real time microseconds for 4631board\n}\nSerial.printf(\"respond time is %d\\r\\n\",respondTime);\n\nif((respondTime>0)&&(respondTime < TIME_OUT))  //ECHO pin max timeout is 33000us according it's datasheet\n{\nreturn respondTime;\n}\nelse\n{\nreturn -1;\n}\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void)\n{\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void)\n{\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data)\n{\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class)\n{\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void)\n{\nif (lmh_join_status_get() != LMH_SET)\n{\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\ndata = \"Distance:\" + String(mm) + \"mm\";\nSerial.println(data);\n\nuint32_t mm_data = mm;\n\nm_lora_app_data.buffer[i++] = 0x0A;\nm_lora_app_data.buffer[i++] = (uint8_t)((mm_data & 0xFF000000) >> 24);\nm_lora_app_data.buffer[i++] = (uint8_t)((mm_data & 0x00FF0000) >> 16);\nm_lora_app_data.buffer[i++] = (uint8_t)((mm_data & 0x0000FF00) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(mm_data & 0x000000FF);\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS)\n{\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n}\nelse\n{\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The following steps will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired regions to work with. You can change this to a region that is applicable to you, like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc.  \nThe following table lists the LoRaWAN regions and the countries where they are used:  \n| LoRaWAN Region         | Usage                                                             |\n| ---------------------- | ----------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1 | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan          |\n| LORAMAC_REGION_AS923-2 | Vietnam                                                           |\n| LORAMAC_REGION_AS923-3 | Philippines, Albania, Algeria, Denmark, Greenland, Jordan         |\n| LORAMAC_REGION_AS923-4 | Israel                                                            |\n| LORAMAC_REGION_AU915   | Australia, Anguilla, Argentina, and other parts of South America  |\n| LORAMAC_REGION_CN470   | China                                                             |\n| LORAMAC_REGION_EU433   | EU, UK, Brazil, Costa Rica, Cuba, and other parts of Africa       |\n| LORAMAC_REGION_IN865   | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger |\n| LORAMAC_REGION_EU868   | EU, UK and other parts of Africa                                  |\n| LORAMAC_REGION_KR920   | Republic of Korea                                                 |\n| LORAMAC_REGION_US915   | USA                                                               |\n| LORAMAC_REGION_RU864   | Russia                                                            |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n\n```\n- Set up the LoRaWAN activation method. In this case, you will use the **OTAA** configuration, which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change it to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n\n```  \n- Set up the EUIs and KEY. The **DeviceEUI**, **AppEUI**, and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x8B, 0x0E, 0x96, 0x86, 0xE8, 0x4E, 0xA3, 0xB5, 0x31, 0x42, 0xB3, 0x65, 0x75, 0xB1, 0xD3, 0xED};\n\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once you're done with the code, you can now proceed with uploading it to your device. You must first choose your RAK4631 board on your desktop or laptop. To do so, navigate to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** and select **WisBlock RAK4631**.  \n> **Image:** Selecting the RAK4631 board  \n4. After you have selected your board, go to **Tools** > **Port** and then select the specific port of your board.  \n> **Image:** Selecting the port of RAK4631 board  \n5. You can then upload your code by clicking the Upload button (the right arrow sign). Once completed, the **Device programmed** notification will appear in the console at the bottom of the Arduino IDE.  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "95d74d79f6a76e3af005859f89ce2f5c", "product_family": "wisblock", "product_id": "kit3-movement-detection", "category": "How-To", "title": "WisBlock Movement Detection Kit Quick Start Guide > WisBlock IoT Education Kit - Movement Detection Quick Start Guide > Product Configuration > Software Configuration and Examples > RAK12007 Ultrasonic Sensor LoRaWAN Application > LoRaWAN Code for RAK12007 > Programming RAK12007 Module with Arduino IDE [CODE]", "content": "uint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x8B, 0x0E, 0x96, 0x86, 0xE8, 0x4E, 0xA3, 0xB5, 0x31, 0x42, 0xB3, 0x65, 0x75, 0xB1, 0xD3, 0xED};", "keywords": ["Arduino IDE", "RAK4631", "RAK12007", "LoRaWAN", "programming"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed on your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you have not yet installed the **Arduino IDE**, go to the [RAK4631 Installation](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#arduino-ide-installation-rak4631) section and execute the following steps.  \n2. After the installation, you can now proceed with programming your **RAK12007** module. Simply copy the **RAK12007 LoRaWAN Application** code below and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE\nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n```c\n\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h> //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define  RAK4631_BOARD true\n#else\n#define  RAK4631_BOARD false\n#endif\n\n// Section to add include libraries, declarations and variables.\n\n#define Enable WB_IO2\n#define TRIG WB_IO6\n#define ECHO WB_IO4\n#define PD   WB_IO5   //power done control \uff08=1 power done\uff0c=0 power on\uff09\n\n#define TIME_OUT  24125 //max measure distance is 4m,the velocity of sound is 331.6m/s in 0\u2103,TIME_OUT=4*2/331.6*1000000=24215us\n\nfloat ratio = 346.6/1000/2;   //velocity of sound =331.6+0.6*25\u2103(m/s),(Indoor temperature about 25\u2103)\n\nlong int duration_time();  //measure high level time\n\nlong int duration, mm;\n\nbool doOTAA = true;   // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                     /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                   /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5             /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                      /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                      /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = {LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF};\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = {BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler\n};\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x8B, 0x0E, 0x96, 0x86, 0xE8, 0x4E, 0xA3, 0xB5, 0x31, 0x42, 0xB3, 0x65, 0x75, 0xB1, 0xD3, 0xED};\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = {0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23};\nuint8_t nodeAppsKey[16] = {0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C};\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                     /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];            //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = {m_lora_app_data_buffer, 0, 0, 0, 0}; //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup()\n{\npinMode(Enable, OUTPUT);\ndigitalWrite(Enable, HIGH);\npinMode(ECHO, INPUT);   // Echo Pin of Ultrasonic Sensor is an Input\npinMode(TRIG, OUTPUT);  // Trigger Pin of Ultrasonic Sensor is an Output\npinMode(PD, OUTPUT);    // power done control pin is an Output\ndigitalWrite(TRIG,LOW);\ndigitalWrite(PD,LOW);\n\npinMode(LED_GREEN, OUTPUT);  // Output LED\npinMode(LED_BLUE, OUTPUT);   // Output LED\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial)\n{\nif ((millis() - timeout) < 5000)\n{\ndelay(100);\n}\nelse\n{\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA)\n{\nSerial.println(\"Type: OTAA\");\n}\nelse\n{\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion)\n{\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA)\n{\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n}\nelse\n{\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0)\n{\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"========================\");\nSerial.println(\"  RAK12007 LoRaWAN test \");\nSerial.println(\"========================\");\n\n}\n\nvoid loop()\n{\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\n// long int duration, mm;\ndigitalWrite(LED_BLUE,HIGH);\ndigitalWrite(LED_GREEN, HIGH);\nduration = duration_time();\nif(duration > 0)\n{\nmm = duration*ratio; //Test distance = (high level time\u00d7velocity of sound (340M/S) / 2,\ndigitalWrite(LED_BLUE,LOW);\ndigitalWrite(LED_GREEN, LOW);\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\nSerial.print(mm);\nSerial.print(\"mm\");\nSerial.println();\ndelay(15000);\n}\nelse\n{\nSerial.println(\"Out of range\");\n}\ndelay(50);\n\n}\n\nlong int duration_time()\n{\nlong int respondTime;\npinMode(TRIG, OUTPUT);\ndigitalWrite(TRIG, HIGH);\ndelayMicroseconds(12);   //pull high time need over 10us\ndigitalWrite(TRIG, LOW);\npinMode(ECHO, INPUT);\nrespondTime = pulseIn(ECHO, HIGH); // microseconds\ndelay(33);\nif(RAK4631_BOARD)\n{\nrespondTime = respondTime*0.7726; // Time calibration factor is 0.7726,to get real time microseconds for 4631board\n}\nSerial.printf(\"respond time is %d\\r\\n\",respondTime);\n\nif((respondTime>0)&&(respondTime < TIME_OUT))  //ECHO pin max timeout is 33000us according it's datasheet\n{\nreturn respondTime;\n}\nelse\n{\nreturn -1;\n}\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void)\n{\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void)\n{\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data)\n{\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class)\n{\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void)\n{\nif (lmh_join_status_get() != LMH_SET)\n{\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\ndata = \"Distance:\" + String(mm) + \"mm\";\nSerial.println(data);\n\nuint32_t mm_data = mm;\n\nm_lora_app_data.buffer[i++] = 0x0A;\nm_lora_app_data.buffer[i++] = (uint8_t)((mm_data & 0xFF000000) >> 24);\nm_lora_app_data.buffer[i++] = (uint8_t)((mm_data & 0x00FF0000) >> 16);\nm_lora_app_data.buffer[i++] = (uint8_t)((mm_data & 0x0000FF00) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(mm_data & 0x000000FF);\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS)\n{\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n}\nelse\n{\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The following steps will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired regions to work with. You can change this to a region that is applicable to you, like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc.  \nThe following table lists the LoRaWAN regions and the countries where they are used:  \n| LoRaWAN Region         | Usage                                                             |\n| ---------------------- | ----------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1 | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan          |\n| LORAMAC_REGION_AS923-2 | Vietnam                                                           |\n| LORAMAC_REGION_AS923-3 | Philippines, Albania, Algeria, Denmark, Greenland, Jordan         |\n| LORAMAC_REGION_AS923-4 | Israel                                                            |\n| LORAMAC_REGION_AU915   | Australia, Anguilla, Argentina, and other parts of South America  |\n| LORAMAC_REGION_CN470   | China                                                             |\n| LORAMAC_REGION_EU433   | EU, UK, Brazil, Costa Rica, Cuba, and other parts of Africa       |\n| LORAMAC_REGION_IN865   | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger |\n| LORAMAC_REGION_EU868   | EU, UK and other parts of Africa                                  |\n| LORAMAC_REGION_KR920   | Republic of Korea                                                 |\n| LORAMAC_REGION_US915   | USA                                                               |\n| LORAMAC_REGION_RU864   | Russia                                                            |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n\n```\n- Set up the LoRaWAN activation method. In this case, you will use the **OTAA** configuration, which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change it to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n\n```  \n- Set up the EUIs and KEY. The **DeviceEUI**, **AppEUI**, and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x8B, 0x0E, 0x96, 0x86, 0xE8, 0x4E, 0xA3, 0xB5, 0x31, 0x42, 0xB3, 0x65, 0x75, 0xB1, 0xD3, 0xED};\n\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once you're done with the code, you can now proceed with uploading it to your device. You must first choose your RAK4631 board on your desktop or laptop. To do so, navigate to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** and select **WisBlock RAK4631**.  \n> **Image:** Selecting the RAK4631 board  \n4. After you have selected your board, go to **Tools** > **Port** and then select the specific port of your board.  \n> **Image:** Selecting the port of RAK4631 board  \n5. You can then upload your code by clicking the Upload button (the right arrow sign). Once completed, the **Device programmed** notification will appear in the console at the bottom of the Arduino IDE.  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "51eec313426821bac508ddbcafa2fbc5", "product_family": "wisblock", "product_id": "kit3-movement-detection", "category": "How-To", "title": "WisBlock Movement Detection Kit Quick Start Guide > WisBlock IoT Education Kit - Movement Detection Quick Start Guide > Product Configuration > Software Configuration and Examples > RAK12007 Ultrasonic Sensor LoRaWAN Application > LoRaWAN Code for RAK12007 > Programming RAK12007 Module with Arduino IDE [CODE]", "content": "```  \n> **Image:** Device's credentials registered in TTN  \n3. Once you're done with the code, you can now proceed with uploading it to your device. You must first choose your RAK4631 board on your desktop or laptop. To do so, navigate to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** and select **WisBlock RAK4631**.  \n> **Image:** Selecting the RAK4631 board  \n4. After you have selected your board, go to **Tools** > **Port** and then select the specific port of your board.", "keywords": ["Arduino IDE", "RAK4631", "RAK12007", "LoRaWAN", "programming"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed on your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you have not yet installed the **Arduino IDE**, go to the [RAK4631 Installation](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#arduino-ide-installation-rak4631) section and execute the following steps.  \n2. After the installation, you can now proceed with programming your **RAK12007** module. Simply copy the **RAK12007 LoRaWAN Application** code below and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE\nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n```c\n\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h> //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define  RAK4631_BOARD true\n#else\n#define  RAK4631_BOARD false\n#endif\n\n// Section to add include libraries, declarations and variables.\n\n#define Enable WB_IO2\n#define TRIG WB_IO6\n#define ECHO WB_IO4\n#define PD   WB_IO5   //power done control \uff08=1 power done\uff0c=0 power on\uff09\n\n#define TIME_OUT  24125 //max measure distance is 4m,the velocity of sound is 331.6m/s in 0\u2103,TIME_OUT=4*2/331.6*1000000=24215us\n\nfloat ratio = 346.6/1000/2;   //velocity of sound =331.6+0.6*25\u2103(m/s),(Indoor temperature about 25\u2103)\n\nlong int duration_time();  //measure high level time\n\nlong int duration, mm;\n\nbool doOTAA = true;   // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                     /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                   /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5             /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                      /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                      /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = {LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF};\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = {BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler\n};\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x8B, 0x0E, 0x96, 0x86, 0xE8, 0x4E, 0xA3, 0xB5, 0x31, 0x42, 0xB3, 0x65, 0x75, 0xB1, 0xD3, 0xED};\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = {0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23};\nuint8_t nodeAppsKey[16] = {0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C};\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                     /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];            //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = {m_lora_app_data_buffer, 0, 0, 0, 0}; //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup()\n{\npinMode(Enable, OUTPUT);\ndigitalWrite(Enable, HIGH);\npinMode(ECHO, INPUT);   // Echo Pin of Ultrasonic Sensor is an Input\npinMode(TRIG, OUTPUT);  // Trigger Pin of Ultrasonic Sensor is an Output\npinMode(PD, OUTPUT);    // power done control pin is an Output\ndigitalWrite(TRIG,LOW);\ndigitalWrite(PD,LOW);\n\npinMode(LED_GREEN, OUTPUT);  // Output LED\npinMode(LED_BLUE, OUTPUT);   // Output LED\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial)\n{\nif ((millis() - timeout) < 5000)\n{\ndelay(100);\n}\nelse\n{\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA)\n{\nSerial.println(\"Type: OTAA\");\n}\nelse\n{\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion)\n{\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA)\n{\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n}\nelse\n{\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0)\n{\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"========================\");\nSerial.println(\"  RAK12007 LoRaWAN test \");\nSerial.println(\"========================\");\n\n}\n\nvoid loop()\n{\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\n// long int duration, mm;\ndigitalWrite(LED_BLUE,HIGH);\ndigitalWrite(LED_GREEN, HIGH);\nduration = duration_time();\nif(duration > 0)\n{\nmm = duration*ratio; //Test distance = (high level time\u00d7velocity of sound (340M/S) / 2,\ndigitalWrite(LED_BLUE,LOW);\ndigitalWrite(LED_GREEN, LOW);\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\nSerial.print(mm);\nSerial.print(\"mm\");\nSerial.println();\ndelay(15000);\n}\nelse\n{\nSerial.println(\"Out of range\");\n}\ndelay(50);\n\n}\n\nlong int duration_time()\n{\nlong int respondTime;\npinMode(TRIG, OUTPUT);\ndigitalWrite(TRIG, HIGH);\ndelayMicroseconds(12);   //pull high time need over 10us\ndigitalWrite(TRIG, LOW);\npinMode(ECHO, INPUT);\nrespondTime = pulseIn(ECHO, HIGH); // microseconds\ndelay(33);\nif(RAK4631_BOARD)\n{\nrespondTime = respondTime*0.7726; // Time calibration factor is 0.7726,to get real time microseconds for 4631board\n}\nSerial.printf(\"respond time is %d\\r\\n\",respondTime);\n\nif((respondTime>0)&&(respondTime < TIME_OUT))  //ECHO pin max timeout is 33000us according it's datasheet\n{\nreturn respondTime;\n}\nelse\n{\nreturn -1;\n}\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void)\n{\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void)\n{\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data)\n{\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class)\n{\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void)\n{\nif (lmh_join_status_get() != LMH_SET)\n{\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\ndata = \"Distance:\" + String(mm) + \"mm\";\nSerial.println(data);\n\nuint32_t mm_data = mm;\n\nm_lora_app_data.buffer[i++] = 0x0A;\nm_lora_app_data.buffer[i++] = (uint8_t)((mm_data & 0xFF000000) >> 24);\nm_lora_app_data.buffer[i++] = (uint8_t)((mm_data & 0x00FF0000) >> 16);\nm_lora_app_data.buffer[i++] = (uint8_t)((mm_data & 0x0000FF00) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(mm_data & 0x000000FF);\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS)\n{\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n}\nelse\n{\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The following steps will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired regions to work with. You can change this to a region that is applicable to you, like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc.  \nThe following table lists the LoRaWAN regions and the countries where they are used:  \n| LoRaWAN Region         | Usage                                                             |\n| ---------------------- | ----------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1 | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan          |\n| LORAMAC_REGION_AS923-2 | Vietnam                                                           |\n| LORAMAC_REGION_AS923-3 | Philippines, Albania, Algeria, Denmark, Greenland, Jordan         |\n| LORAMAC_REGION_AS923-4 | Israel                                                            |\n| LORAMAC_REGION_AU915   | Australia, Anguilla, Argentina, and other parts of South America  |\n| LORAMAC_REGION_CN470   | China                                                             |\n| LORAMAC_REGION_EU433   | EU, UK, Brazil, Costa Rica, Cuba, and other parts of Africa       |\n| LORAMAC_REGION_IN865   | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger |\n| LORAMAC_REGION_EU868   | EU, UK and other parts of Africa                                  |\n| LORAMAC_REGION_KR920   | Republic of Korea                                                 |\n| LORAMAC_REGION_US915   | USA                                                               |\n| LORAMAC_REGION_RU864   | Russia                                                            |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n\n```\n- Set up the LoRaWAN activation method. In this case, you will use the **OTAA** configuration, which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change it to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n\n```  \n- Set up the EUIs and KEY. The **DeviceEUI**, **AppEUI**, and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x8B, 0x0E, 0x96, 0x86, 0xE8, 0x4E, 0xA3, 0xB5, 0x31, 0x42, 0xB3, 0x65, 0x75, 0xB1, 0xD3, 0xED};\n\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once you're done with the code, you can now proceed with uploading it to your device. You must first choose your RAK4631 board on your desktop or laptop. To do so, navigate to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** and select **WisBlock RAK4631**.  \n> **Image:** Selecting the RAK4631 board  \n4. After you have selected your board, go to **Tools** > **Port** and then select the specific port of your board.  \n> **Image:** Selecting the port of RAK4631 board  \n5. You can then upload your code by clicking the Upload button (the right arrow sign). Once completed, the **Device programmed** notification will appear in the console at the bottom of the Arduino IDE.  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "40c86595f5c0e394e8495a6f78874133", "product_family": "wisblock", "product_id": "kit3-movement-detection", "category": "How-To", "title": "WisBlock Movement Detection Kit Quick Start Guide > WisBlock IoT Education Kit - Movement Detection Quick Start Guide > Product Configuration > Software Configuration and Examples > RAK12007 Ultrasonic Sensor LoRaWAN Application > LoRaWAN Code for RAK12007 > Programming RAK12007 Module with Arduino IDE [CODE]", "content": "> **Image:** Selecting the port of RAK4631 board  \n5. You can then upload your code by clicking the Upload button (the right arrow sign). Once completed, the **Device programmed** notification will appear in the console at the bottom of the Arduino IDE.  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board", "keywords": ["Arduino IDE", "RAK4631", "RAK12007", "LoRaWAN", "programming"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. If you already have **Arduino IDE** installed on your laptop or PC and added **RAK4631 board** into it, you may proceed to the next step. If you have not yet installed the **Arduino IDE**, go to the [RAK4631 Installation](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#arduino-ide-installation-rak4631) section and execute the following steps.  \n2. After the installation, you can now proceed with programming your **RAK12007** module. Simply copy the **RAK12007 LoRaWAN Application** code below and paste it into the **Arduino IDE**.  \n> **TIP:** NOTE\nThe example code uses [SX126x-Arduino](https://github.com/beegee-tokyo/SX126x-Arduino) library which needs to be added to successfully compile the LoRaWAN code.  \n```c\n\n#include <Arduino.h>\n#include <LoRaWan-RAK4630.h> //http://librarymanager/All#SX126x\n#include <SPI.h>\n#include <Wire.h>\n\n#ifdef RAK4630\n#define BOARD \"RAK4631 \"\n#define  RAK4631_BOARD true\n#else\n#define  RAK4631_BOARD false\n#endif\n\n// Section to add include libraries, declarations and variables.\n\n#define Enable WB_IO2\n#define TRIG WB_IO6\n#define ECHO WB_IO4\n#define PD   WB_IO5   //power done control \uff08=1 power done\uff0c=0 power on\uff09\n\n#define TIME_OUT  24125 //max measure distance is 4m,the velocity of sound is 331.6m/s in 0\u2103,TIME_OUT=4*2/331.6*1000000=24215us\n\nfloat ratio = 346.6/1000/2;   //velocity of sound =331.6+0.6*25\u2103(m/s),(Indoor temperature about 25\u2103)\n\nlong int duration_time();  //measure high level time\n\nlong int duration, mm;\n\nbool doOTAA = true;   // OTAA is used by default.\n#define SCHED_MAX_EVENT_DATA_SIZE APP_TIMER_SCHED_EVENT_DATA_SIZE /**< Maximum size of scheduler events. */\n#define SCHED_QUEUE_SIZE 60                     /**< Maximum number of events in the scheduler queue. */\n#define LORAWAN_DATERATE DR_0                   /*LoRaMac datarates definition, from DR_0 to DR_5*/\n#define LORAWAN_TX_POWER TX_POWER_5             /*LoRaMac tx power definition, from TX_POWER_0 to TX_POWER_15*/\n#define JOINREQ_NBTRIALS 3                      /**< Number of trials for the join request. */\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\nuint8_t gAppPort = LORAWAN_APP_PORT;                      /* data port*/\n\n/**@brief Structure containing LoRaWan parameters, needed for lmh_init()\n*/\nstatic lmh_param_t g_lora_param_init = {LORAWAN_ADR_ON, LORAWAN_DATERATE, LORAWAN_PUBLIC_NETWORK, JOINREQ_NBTRIALS, LORAWAN_TX_POWER, LORAWAN_DUTYCYCLE_OFF};\n\n// Forward declaration\nstatic void lorawan_has_joined_handler(void);\nstatic void lorawan_join_failed_handler(void);\nstatic void lorawan_rx_handler(lmh_app_data_t *app_data);\nstatic void lorawan_confirm_class_handler(DeviceClass_t Class);\nstatic void send_lora_frame(void);\n\n/**@brief Structure containing LoRaWan callback functions, needed for lmh_init()\n*/\nstatic lmh_callback_t g_lora_callbacks = {BoardGetBatteryLevel, BoardGetUniqueId, BoardGetRandomSeed,\nlorawan_rx_handler, lorawan_has_joined_handler, lorawan_confirm_class_handler, lorawan_join_failed_handler\n};\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x8B, 0x0E, 0x96, 0x86, 0xE8, 0x4E, 0xA3, 0xB5, 0x31, 0x42, 0xB3, 0x65, 0x75, 0xB1, 0xD3, 0xED};\n\n// ABP keys\nuint32_t nodeDevAddr = 0x260116F8;\nuint8_t nodeNwsKey[16] = {0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23};\nuint8_t nodeAppsKey[16] = {0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C};\n\n// Private definition\n#define LORAWAN_APP_DATA_BUFF_SIZE 64                     /**< buffer size of the data to be transmitted. */\nstatic uint8_t m_lora_app_data_buffer[LORAWAN_APP_DATA_BUFF_SIZE];            //< Lora user application data buffer.\nstatic lmh_app_data_t m_lora_app_data = {m_lora_app_data_buffer, 0, 0, 0, 0}; //< Lora user application data structure.\n\nstatic uint32_t count = 0;\nstatic uint32_t count_fail = 0;\n\nvoid setup()\n{\npinMode(Enable, OUTPUT);\ndigitalWrite(Enable, HIGH);\npinMode(ECHO, INPUT);   // Echo Pin of Ultrasonic Sensor is an Input\npinMode(TRIG, OUTPUT);  // Trigger Pin of Ultrasonic Sensor is an Output\npinMode(PD, OUTPUT);    // power done control pin is an Output\ndigitalWrite(TRIG,LOW);\ndigitalWrite(PD,LOW);\n\npinMode(LED_GREEN, OUTPUT);  // Output LED\npinMode(LED_BLUE, OUTPUT);   // Output LED\n\n// Initialize LoRa chip.\nlora_rak4630_init();\n\n// Initialize Serial for debug output\ntime_t timeout = millis();\nSerial.begin(115200);\nwhile (!Serial)\n{\nif ((millis() - timeout) < 5000)\n{\ndelay(100);\n}\nelse\n{\nbreak;\n}\n}\nSerial.println(\"=====================================\");\nSerial.println(\"Welcome to RAK4630 LoRaWan!!!\");\nif (doOTAA)\n{\nSerial.println(\"Type: OTAA\");\n}\nelse\n{\nSerial.println(\"Type: ABP\");\n}\n\nswitch (g_CurrentRegion)\n{\ncase LORAMAC_REGION_AS923:\nSerial.println(\"Region: AS923\");\nbreak;\ncase LORAMAC_REGION_AU915:\nSerial.println(\"Region: AU915\");\nbreak;\ncase LORAMAC_REGION_CN470:\nSerial.println(\"Region: CN470\");\nbreak;\ncase LORAMAC_REGION_EU433:\nSerial.println(\"Region: EU433\");\nbreak;\ncase LORAMAC_REGION_IN865:\nSerial.println(\"Region: IN865\");\nbreak;\ncase LORAMAC_REGION_EU868:\nSerial.println(\"Region: EU868\");\nbreak;\ncase LORAMAC_REGION_KR920:\nSerial.println(\"Region: KR920\");\nbreak;\ncase LORAMAC_REGION_US915:\nSerial.println(\"Region: US915\");\nbreak;\n}\nSerial.println(\"=====================================\");\n\n// Setup the EUIs and Keys\nif (doOTAA)\n{\nlmh_setDevEui(nodeDeviceEUI);\nlmh_setAppEui(nodeAppEUI);\nlmh_setAppKey(nodeAppKey);\n}\nelse\n{\nlmh_setNwkSKey(nodeNwsKey);\nlmh_setAppSKey(nodeAppsKey);\nlmh_setDevAddr(nodeDevAddr);\n}\n\nuint32_t err_code;\n// Initialize LoRaWan\nerr_code = lmh_init(&g_lora_callbacks, g_lora_param_init, doOTAA, g_CurrentClass, g_CurrentRegion);\nif (err_code != 0)\n{\nSerial.printf(\"lmh_init failed - %d\\n\", err_code);\nreturn;\n}\n\n// Start Join procedure\nlmh_join();\n\nSerial.println(\"========================\");\nSerial.println(\"  RAK12007 LoRaWAN test \");\nSerial.println(\"========================\");\n\n}\n\nvoid loop()\n{\n// Put your application tasks here, like reading of sensors,\n// Controlling actuators and/or other functions.\n\n// long int duration, mm;\ndigitalWrite(LED_BLUE,HIGH);\ndigitalWrite(LED_GREEN, HIGH);\nduration = duration_time();\nif(duration > 0)\n{\nmm = duration*ratio; //Test distance = (high level time\u00d7velocity of sound (340M/S) / 2,\ndigitalWrite(LED_BLUE,LOW);\ndigitalWrite(LED_GREEN, LOW);\nSerial.println(\"Sending frame now...\");\nsend_lora_frame();\nSerial.print(mm);\nSerial.print(\"mm\");\nSerial.println();\ndelay(15000);\n}\nelse\n{\nSerial.println(\"Out of range\");\n}\ndelay(50);\n\n}\n\nlong int duration_time()\n{\nlong int respondTime;\npinMode(TRIG, OUTPUT);\ndigitalWrite(TRIG, HIGH);\ndelayMicroseconds(12);   //pull high time need over 10us\ndigitalWrite(TRIG, LOW);\npinMode(ECHO, INPUT);\nrespondTime = pulseIn(ECHO, HIGH); // microseconds\ndelay(33);\nif(RAK4631_BOARD)\n{\nrespondTime = respondTime*0.7726; // Time calibration factor is 0.7726,to get real time microseconds for 4631board\n}\nSerial.printf(\"respond time is %d\\r\\n\",respondTime);\n\nif((respondTime>0)&&(respondTime < TIME_OUT))  //ECHO pin max timeout is 33000us according it's datasheet\n{\nreturn respondTime;\n}\nelse\n{\nreturn -1;\n}\n}\n\n/**@brief LoRa function for handling HasJoined event.\n*/\nvoid lorawan_has_joined_handler(void)\n{\nSerial.println(\"OTAA Mode, Network Joined!\");\n}\n\n/**@brief LoRa function for handling OTAA join failed\n*/\nstatic void lorawan_join_failed_handler(void)\n{\nSerial.println(\"OTAA join failed!\");\nSerial.println(\"Check your EUI's and Keys's!\");\nSerial.println(\"Check if a Gateway is in range!\");\n}\n/**@brief Function for handling LoRaWan received data from Gateway\n*\n* @param[in] app_data  Pointer to rx data\n*/\nvoid lorawan_rx_handler(lmh_app_data_t *app_data)\n{\nSerial.printf(\"LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\\n\",\napp_data->port, app_data->buffsize, app_data->rssi, app_data->snr, app_data->buffer);\n}\n\nvoid lorawan_confirm_class_handler(DeviceClass_t Class)\n{\nSerial.printf(\"switch to class %c done\\n\", \"ABC\"[Class]);\n// Informs the server that switch has occurred ASAP\nm_lora_app_data.buffsize = 0;\nm_lora_app_data.port = gAppPort;\nlmh_send(&m_lora_app_data, g_CurrentConfirm);\n}\n\nString data = \"\";\n\nvoid send_lora_frame(void)\n{\nif (lmh_join_status_get() != LMH_SET)\n{\n//Not joined, try again later\nreturn;\n}\n\nSerial.print(\"result: \");\nuint32_t i = 0;\nmemset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);\nm_lora_app_data.port = gAppPort;\n\ndata = \"Distance:\" + String(mm) + \"mm\";\nSerial.println(data);\n\nuint32_t mm_data = mm;\n\nm_lora_app_data.buffer[i++] = 0x0A;\nm_lora_app_data.buffer[i++] = (uint8_t)((mm_data & 0xFF000000) >> 24);\nm_lora_app_data.buffer[i++] = (uint8_t)((mm_data & 0x00FF0000) >> 16);\nm_lora_app_data.buffer[i++] = (uint8_t)((mm_data & 0x0000FF00) >> 8);\nm_lora_app_data.buffer[i++] = (uint8_t)(mm_data & 0x000000FF);\nm_lora_app_data.buffsize = i;\n\nlmh_error_status error = lmh_send(&m_lora_app_data, g_CurrentConfirm);\nif (error == LMH_SUCCESS)\n{\ncount++;\nSerial.printf(\"lmh_send ok count %d\\n\", count);\n}\nelse\n{\ncount_fail++;\nSerial.printf(\"lmh_send fail count %d\\n\", count_fail);\n}\n}\n\n```  \nBefore uploading the Arduino Code, there are configurations that you need to set up to ensure that the device can join a LoRaWAN Network server. The following steps will explain the default settings and how to configure them.  \n- Set up the LoRaWAN region. The **LORAMAC_REGION** can be any of your desired regions to work with. You can change this to a region that is applicable to you, like `LORAMAC_REGION_US915`, `LORAMAC_REGION_AU915`, etc.  \nThe following table lists the LoRaWAN regions and the countries where they are used:  \n| LoRaWAN Region         | Usage                                                             |\n| ---------------------- | ----------------------------------------------------------------- |\n| LORAMAC_REGION_AS923-1 | Australia, Singapore, Solomon Islands, Sri-Lanka, Taiwan          |\n| LORAMAC_REGION_AS923-2 | Vietnam                                                           |\n| LORAMAC_REGION_AS923-3 | Philippines, Albania, Algeria, Denmark, Greenland, Jordan         |\n| LORAMAC_REGION_AS923-4 | Israel                                                            |\n| LORAMAC_REGION_AU915   | Australia, Anguilla, Argentina, and other parts of South America  |\n| LORAMAC_REGION_CN470   | China                                                             |\n| LORAMAC_REGION_EU433   | EU, UK, Brazil, Costa Rica, Cuba, and other parts of Africa       |\n| LORAMAC_REGION_IN865   | India, Cook Islands, Egypt, Hong Kong, Jordan, New Zealand, Niger |\n| LORAMAC_REGION_EU868   | EU, UK and other parts of Africa                                  |\n| LORAMAC_REGION_KR920   | Republic of Korea                                                 |\n| LORAMAC_REGION_US915   | USA                                                               |\n| LORAMAC_REGION_RU864   | Russia                                                            |  \n```c\nLoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_US915;    /* Region:US915*/\n\n```\n- Set up the LoRaWAN activation method. In this case, you will use the **OTAA** configuration, which is also the default from the given code.  \n```c\nbool doOTAA = true;   // OTAA is used by default.\n\n```  \n- Set up the message type if confirmed or not. **Confirmed message** is the default for this one. You can change it to an **unconfirmed message** by changing the value to `LMH_UNCONFIRMED_MSG`.  \n```c\nlmh_confirm g_CurrentConfirm = LMH_CONFIRMED_MSG;         /* confirm/unconfirm packet definition*/\n\n```  \n- Set the device to **Class A**.  \n```c\nDeviceClass_t g_CurrentClass = CLASS_A;         /* class definition*/\n\n```  \n- Set up the EUIs and KEY. The **DeviceEUI**, **AppEUI**, and **AppKey** are the credentials of your device registered to TTN that will be used for the OTAA keys in the code. You need to replace the ones in the code with the credentials registered in TTN.  \n```c\n//OTAA keys !!!! KEYS ARE MSB !!!!\nuint8_t nodeDeviceEUI[8] = {0xAC, 0x1F, 0x09, 0xFF, 0xFE, 0x06, 0xD3, 0xE9};\nuint8_t nodeAppEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nuint8_t nodeAppKey[16] = {0x8B, 0x0E, 0x96, 0x86, 0xE8, 0x4E, 0xA3, 0xB5, 0x31, 0x42, 0xB3, 0x65, 0x75, 0xB1, 0xD3, 0xED};\n\n```  \n> **Image:** Device's credentials registered in TTN  \n3. Once you're done with the code, you can now proceed with uploading it to your device. You must first choose your RAK4631 board on your desktop or laptop. To do so, navigate to **Tools** > **Board:XXXXX** > **RAKwireless nRF Boards** and select **WisBlock RAK4631**.  \n> **Image:** Selecting the RAK4631 board  \n4. After you have selected your board, go to **Tools** > **Port** and then select the specific port of your board.  \n> **Image:** Selecting the port of RAK4631 board  \n5. You can then upload your code by clicking the Upload button (the right arrow sign). Once completed, the **Device programmed** notification will appear in the console at the bottom of the Arduino IDE.  \n> **Image:** Arduino code is successfully uploaded into your RAK4631 board"}
{"id": "a4cd7f863474b04a3bb30b15e9db92de", "product_family": "wisblock", "product_id": "kit3-movement-detection", "category": "How-To", "title": "WisBlock Movement Detection Kit Quick Start Guide > WisBlock IoT Education Kit - Movement Detection Quick Start Guide > Product Configuration > Software Configuration and Examples > RAK12013 Radar Sensor LoRaWAN Application > Connect to The Things Network (TTN) > TTN Account Setup and OTAA Device Registration", "content": "- If you already have an existing TTN account, you may proceed to the [OTAA Device Registration](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#otaa-device-registration) section.\n- If you do not already have an account, go to the [The Things Network Configuration](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#the-things-network-configuration) section and create one, then register your end-device.", "keywords": ["TTN", "OTAA", "Device Registration", "The Things Network"], "source_file": "quickstart.md", "token_count": 50, "parent_content": "- If you already have an existing TTN account, you may proceed to the [OTAA Device Registration](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#otaa-device-registration) section.\n- If you do not already have an account, go to the [The Things Network Configuration](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#the-things-network-configuration) section and create one, then register your end-device."}
{"id": "afcda0a14b4aaf81bfcc46a7faa15608", "product_family": "wisblock", "product_id": "kit3-movement-detection", "category": "How-To", "title": "WisBlock Movement Detection Kit Quick Start Guide > WisBlock IoT Education Kit - Movement Detection Quick Start Guide > Product Configuration > Software Configuration and Examples > RAK12017 IR Proximity Sensor LoRaWAN Application > Connect to The Things Network (TTN) > TTN Account Creation and Device Registration for kit3-movement-detection", "content": "1. If you already have an existing TTN account, you may proceed to the next step. If you haven't yet created a TTN account, please refer to this [link](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#ttn-account-creation) for the steps.", "keywords": ["TTN", "account creation", "device registration", "kit3-movement-detection"], "source_file": "quickstart.md", "token_count": 0, "parent_content": "1. If you already have an existing TTN account, you may proceed to the next step. If you haven't yet created a TTN account, please refer to this [link](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#ttn-account-creation) for the steps.  \n2. Once done with the TTN account creation, you may now proceed with the device registration. Please refer to this [guide](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#device-registration) for your reference."}
{"id": "5db63a87948b8370f989c2c4bb669a6d", "product_family": "wisblock", "product_id": "kit3-movement-detection", "category": "How-To", "title": "WisBlock Movement Detection Kit Quick Start Guide > WisBlock IoT Education Kit - Movement Detection Quick Start Guide > Product Configuration > Software Configuration and Examples > RAK12017 IR Proximity Sensor LoRaWAN Application > Connect to The Things Network (TTN) > TTN Account Creation and Device Registration for kit3-movement-detection", "content": "2. Once done with the TTN account creation, you may now proceed with the device registration. Please refer to this [guide](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#device-registration) for your reference.", "keywords": ["TTN", "account creation", "device registration", "kit3-movement-detection"], "source_file": "quickstart.md", "token_count": 0, "parent_content": "1. If you already have an existing TTN account, you may proceed to the next step. If you haven't yet created a TTN account, please refer to this [link](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#ttn-account-creation) for the steps.  \n2. Once done with the TTN account creation, you may now proceed with the device registration. Please refer to this [guide](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#device-registration) for your reference."}
{"id": "0550931a6407b9e3c15b195d144485dc", "product_family": "wisblock", "product_id": "kit3-movement-detection", "category": "How-To", "title": "WisBlock Movement Detection Kit Quick Start Guide > WisBlock IoT Education Kit - Movement Detection Quick Start Guide > Miscellaneous > The Things Network Configuration > Create a TTN Account > How to Sign Up for The Things Network (TTN)", "content": "1. Go to [The Things Network](https://www.thethingsnetwork.org/) and sign up an account.  \n> **Image:** Signing up an account in TTN  \n2. Choose a **Community** and get started.  \n> **Image:** Signing up an account in TTN  \n3. Choose a network cluster.  \n> **Image:** Selecting Cluster in TTN  \nYou can also opt to sign up and create an account using your The Things ID.  \n> **Image:** Signing up through the Things ID", "keywords": ["TTN", "The Things Network", "account creation", "sign up"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. Go to [The Things Network](https://www.thethingsnetwork.org/) and sign up an account.  \n> **Image:** Signing up an account in TTN  \n2. Choose a **Community** and get started.  \n> **Image:** Signing up an account in TTN  \n3. Choose a network cluster.  \n> **Image:** Selecting Cluster in TTN  \nYou can also opt to sign up and create an account using your The Things ID.  \n> **Image:** Signing up through the Things ID  \nIf you have a TTN V2, you can use the same login credentials. If you do not yet have an account, you must create one.  \n> **Image:** Creation of an account through the Things ID"}
{"id": "7e029d8f8acb8734c94bb2dc799c5cd0", "product_family": "wisblock", "product_id": "kit3-movement-detection", "category": "How-To", "title": "WisBlock Movement Detection Kit Quick Start Guide > WisBlock IoT Education Kit - Movement Detection Quick Start Guide > Miscellaneous > The Things Network Configuration > Create a TTN Account > How to Sign Up for The Things Network (TTN)", "content": "> **Image:** Signing up through the Things ID  \nIf you have a TTN V2, you can use the same login credentials. If you do not yet have an account, you must create one.  \n> **Image:** Creation of an account through the Things ID", "keywords": ["TTN", "The Things Network", "account creation", "sign up"], "source_file": "quickstart.md", "token_count": 100, "parent_content": "1. Go to [The Things Network](https://www.thethingsnetwork.org/) and sign up an account.  \n> **Image:** Signing up an account in TTN  \n2. Choose a **Community** and get started.  \n> **Image:** Signing up an account in TTN  \n3. Choose a network cluster.  \n> **Image:** Selecting Cluster in TTN  \nYou can also opt to sign up and create an account using your The Things ID.  \n> **Image:** Signing up through the Things ID  \nIf you have a TTN V2, you can use the same login credentials. If you do not yet have an account, you must create one.  \n> **Image:** Creation of an account through the Things ID"}
{"id": "6825be45a6ed5535c89c4b532483d47d", "product_family": "wisblock", "product_id": "kit3-movement-detection", "category": "How-To", "title": "WisBlock Movement Detection Kit Quick Start Guide > WisBlock IoT Education Kit - Movement Detection Quick Start Guide > Miscellaneous > The Things Network Configuration > Adding an Account > Creating an Application on The Things Stack Platform", "content": "1. Now that you are logged in to the platform, the next step is to create an application. Select **Create an application**.  \n> **Image:** The Things Stack Platform  \n2. Fill in the needed information, then click the **Create application** button.  \n- **Application ID** - This will be the unique ID of your application in the Network. ID must contain only lowercase letters, numbers, and dashes (-).\n- **Application name** (optional) - This is the name of your application.", "keywords": ["The Things Stack", "application creation", "TTN", "LoRaWAN"], "source_file": "quickstart.md", "token_count": 150, "parent_content": "1. Now that you are logged in to the platform, the next step is to create an application. Select **Create an application**.  \n> **Image:** The Things Stack Platform  \n2. Fill in the needed information, then click the **Create application** button.  \n- **Application ID** - This will be the unique ID of your application in the Network. ID must contain only lowercase letters, numbers, and dashes (-).\n- **Application name** (optional) - This is the name of your application.\n- **Description** (optional) \u2013 Description of your application. Optional application description; can also be used to save notes about the application.  \n> **Image:** Details of the TTN application  \n> **TIP:** NOTE\nThe details and information are dependent on what device you are using.  \nIf you have no error on the previous step, you should now be on the application console page.  \n<!-- The next step is to add end-devices to your TTN application. -->  \n<!-- LoRaWAN specifications enforce that each end-device has to be personalized and activated. Activation can be done via Over-The-Air-Activation (OTAA) mode to register your device. -->"}
{"id": "c1620d73ef7d0b5f32efa92459d6fd69", "product_family": "wisblock", "product_id": "kit3-movement-detection", "category": "How-To", "title": "WisBlock Movement Detection Kit Quick Start Guide > WisBlock IoT Education Kit - Movement Detection Quick Start Guide > Miscellaneous > The Things Network Configuration > Adding an Account > Creating an Application on The Things Stack Platform", "content": "- **Application name** (optional) - This is the name of your application.\n- **Description** (optional) \u2013 Description of your application. Optional application description; can also be used to save notes about the application.  \n> **Image:** Details of the TTN application  \n> **TIP:** NOTE\nThe details and information are dependent on what device you are using.  \nIf you have no error on the previous step, you should now be on the application console page.", "keywords": ["The Things Stack", "application creation", "TTN", "LoRaWAN"], "source_file": "quickstart.md", "token_count": 150, "parent_content": "1. Now that you are logged in to the platform, the next step is to create an application. Select **Create an application**.  \n> **Image:** The Things Stack Platform  \n2. Fill in the needed information, then click the **Create application** button.  \n- **Application ID** - This will be the unique ID of your application in the Network. ID must contain only lowercase letters, numbers, and dashes (-).\n- **Application name** (optional) - This is the name of your application.\n- **Description** (optional) \u2013 Description of your application. Optional application description; can also be used to save notes about the application.  \n> **Image:** Details of the TTN application  \n> **TIP:** NOTE\nThe details and information are dependent on what device you are using.  \nIf you have no error on the previous step, you should now be on the application console page.  \n<!-- The next step is to add end-devices to your TTN application. -->  \n<!-- LoRaWAN specifications enforce that each end-device has to be personalized and activated. Activation can be done via Over-The-Air-Activation (OTAA) mode to register your device. -->"}
{"id": "6808deb24158a31860c18ec842abd932", "product_family": "wisblock", "product_id": "kit3-movement-detection", "category": "How-To", "title": "WisBlock Movement Detection Kit Quick Start Guide > WisBlock IoT Education Kit - Movement Detection Quick Start Guide > Miscellaneous > The Things Network Configuration > Adding an Account > Creating an Application on The Things Stack Platform", "content": "If you have no error on the previous step, you should now be on the application console page.  \n<!-- The next step is to add end-devices to your TTN application. -->  \n<!-- LoRaWAN specifications enforce that each end-device has to be personalized and activated. Activation can be done via Over-The-Air-Activation (OTAA) mode to register your device. -->", "keywords": ["The Things Stack", "application creation", "TTN", "LoRaWAN"], "source_file": "quickstart.md", "token_count": 150, "parent_content": "1. Now that you are logged in to the platform, the next step is to create an application. Select **Create an application**.  \n> **Image:** The Things Stack Platform  \n2. Fill in the needed information, then click the **Create application** button.  \n- **Application ID** - This will be the unique ID of your application in the Network. ID must contain only lowercase letters, numbers, and dashes (-).\n- **Application name** (optional) - This is the name of your application.\n- **Description** (optional) \u2013 Description of your application. Optional application description; can also be used to save notes about the application.  \n> **Image:** Details of the TTN application  \n> **TIP:** NOTE\nThe details and information are dependent on what device you are using.  \nIf you have no error on the previous step, you should now be on the application console page.  \n<!-- The next step is to add end-devices to your TTN application. -->  \n<!-- LoRaWAN specifications enforce that each end-device has to be personalized and activated. Activation can be done via Over-The-Air-Activation (OTAA) mode to register your device. -->"}
{"id": "36d4b8c67502d84d9fac9fd599af793b", "product_family": "wisblock", "product_id": "kit3-movement-detection", "category": "How-To", "title": "WisBlock Movement Detection Kit Quick Start Guide > WisBlock IoT Education Kit - Movement Detection Quick Start Guide > Miscellaneous > The Things Network Configuration > OTAA Device Registration > Register an OTAA End-Device on TTN", "content": "1. To start adding an OTAA end-device, go to your application console and click **+ Register end device**.  \n> **Image:** Adding a device in OTAA mode  \n2. In the input method, select **Enter end device specifics manually** to register your device.  \n> **Image:** Registering the device in OTAA mode  \n3. Next, set up the **Frequency plan**, the compatible **LoRaWAN version**, and the supported **Regional Parameters version**. Then provide the **JoinEUI** credentials by entering zeroes.", "keywords": ["OTAA", "end-device", "TTN", "registration", "LoRaWAN"], "source_file": "quickstart.md", "token_count": 0, "parent_content": "1. To start adding an OTAA end-device, go to your application console and click **+ Register end device**.  \n> **Image:** Adding a device in OTAA mode  \n2. In the input method, select **Enter end device specifics manually** to register your device.  \n> **Image:** Registering the device in OTAA mode  \n3. Next, set up the **Frequency plan**, the compatible **LoRaWAN version**, and the supported **Regional Parameters version**. Then provide the **JoinEUI** credentials by entering zeroes.  \n> **Image:** Setting up your device  \n4. Click **Show advanced activation, LoRaWAN class and cluster settings** and configure the following parameters, then click **Confirm**:\n- Activation mode: **Over the air activation (OTAA)**\n- Additional LoRaWAN class capabilities: **None (class A only)**\n- Network defaults: **Use network's default MAC settings**  \n> **Image:** Setting up your device  \n> **Image:** Setting up your device  \n5. Once done, provide the DevEUI credentials of your device into the **DevEUI** portion. Click the **Generate** button under **Provisioning Information** > **AppKey** to automatically generate the specific end-device ID of your board.  \nOnce done, you need to change the **End device ID** since it is automatically prefilled using the **DevEUI** of your device. Then click **Register end device**.  \n> **TIP:** NOTE  \n- The **AppEUI**, **DevEUI**, and **AppKey** are hidden in this section as these are unique from a specific device. The **DevEUI** credential is unique to every **RAK4631** device. Also, you should generate your own **AppEUI** and **AppKey** credentials for your specific device and application.\n- The **AppEUI** is the same as **JoinEUI**.\n- The details under **End device ID** are dependent on what device you are using.  \n> **Image:** Register End Device  \n6. After you have fully registered your device, you should be able to see it on the TTN console.  \n> **TIP:** NOTE  \n- The **AppEUI**, **DevEUI**, and **AppKey** are the parameters that you will need to activate your LoRaWAN end-device via OTAA. The **AppKey** is hidden by default for security reasons, but you can easily show it by clicking the show button. You can also copy the parameters quickly using the copy button.\n- These parameters are always accessible on the device console page, as shown in **Figure 82**.  \n> **Image:** OTAA device successfully registered to TTN"}
{"id": "b528b79ee4e186e57dfbc5ce8735ddf5", "product_family": "wisblock", "product_id": "kit3-movement-detection", "category": "How-To", "title": "WisBlock Movement Detection Kit Quick Start Guide > WisBlock IoT Education Kit - Movement Detection Quick Start Guide > Miscellaneous > The Things Network Configuration > OTAA Device Registration > Register an OTAA End-Device on TTN", "content": "> **Image:** Setting up your device  \n4. Click **Show advanced activation, LoRaWAN class and cluster settings** and configure the following parameters, then click **Confirm**:\n- Activation mode: **Over the air activation (OTAA)**\n- Additional LoRaWAN class capabilities: **None (class A only)**\n- Network defaults: **Use network's default MAC settings**  \n> **Image:** Setting up your device  \n> **Image:** Setting up your device", "keywords": ["OTAA", "end-device", "TTN", "registration", "LoRaWAN"], "source_file": "quickstart.md", "token_count": 0, "parent_content": "1. To start adding an OTAA end-device, go to your application console and click **+ Register end device**.  \n> **Image:** Adding a device in OTAA mode  \n2. In the input method, select **Enter end device specifics manually** to register your device.  \n> **Image:** Registering the device in OTAA mode  \n3. Next, set up the **Frequency plan**, the compatible **LoRaWAN version**, and the supported **Regional Parameters version**. Then provide the **JoinEUI** credentials by entering zeroes.  \n> **Image:** Setting up your device  \n4. Click **Show advanced activation, LoRaWAN class and cluster settings** and configure the following parameters, then click **Confirm**:\n- Activation mode: **Over the air activation (OTAA)**\n- Additional LoRaWAN class capabilities: **None (class A only)**\n- Network defaults: **Use network's default MAC settings**  \n> **Image:** Setting up your device  \n> **Image:** Setting up your device  \n5. Once done, provide the DevEUI credentials of your device into the **DevEUI** portion. Click the **Generate** button under **Provisioning Information** > **AppKey** to automatically generate the specific end-device ID of your board.  \nOnce done, you need to change the **End device ID** since it is automatically prefilled using the **DevEUI** of your device. Then click **Register end device**.  \n> **TIP:** NOTE  \n- The **AppEUI**, **DevEUI**, and **AppKey** are hidden in this section as these are unique from a specific device. The **DevEUI** credential is unique to every **RAK4631** device. Also, you should generate your own **AppEUI** and **AppKey** credentials for your specific device and application.\n- The **AppEUI** is the same as **JoinEUI**.\n- The details under **End device ID** are dependent on what device you are using.  \n> **Image:** Register End Device  \n6. After you have fully registered your device, you should be able to see it on the TTN console.  \n> **TIP:** NOTE  \n- The **AppEUI**, **DevEUI**, and **AppKey** are the parameters that you will need to activate your LoRaWAN end-device via OTAA. The **AppKey** is hidden by default for security reasons, but you can easily show it by clicking the show button. You can also copy the parameters quickly using the copy button.\n- These parameters are always accessible on the device console page, as shown in **Figure 82**.  \n> **Image:** OTAA device successfully registered to TTN"}
{"id": "4b645f7a4be9569d9df36a9bd312bcd5", "product_family": "wisblock", "product_id": "kit3-movement-detection", "category": "How-To", "title": "WisBlock Movement Detection Kit Quick Start Guide > WisBlock IoT Education Kit - Movement Detection Quick Start Guide > Miscellaneous > The Things Network Configuration > OTAA Device Registration > Register an OTAA End-Device on TTN", "content": "> **Image:** Setting up your device  \n> **Image:** Setting up your device  \n5. Once done, provide the DevEUI credentials of your device into the **DevEUI** portion. Click the **Generate** button under **Provisioning Information** > **AppKey** to automatically generate the specific end-device ID of your board.  \nOnce done, you need to change the **End device ID** since it is automatically prefilled using the **DevEUI** of your device. Then click **Register end device**.  \n> **TIP:** NOTE", "keywords": ["OTAA", "end-device", "TTN", "registration", "LoRaWAN"], "source_file": "quickstart.md", "token_count": 0, "parent_content": "1. To start adding an OTAA end-device, go to your application console and click **+ Register end device**.  \n> **Image:** Adding a device in OTAA mode  \n2. In the input method, select **Enter end device specifics manually** to register your device.  \n> **Image:** Registering the device in OTAA mode  \n3. Next, set up the **Frequency plan**, the compatible **LoRaWAN version**, and the supported **Regional Parameters version**. Then provide the **JoinEUI** credentials by entering zeroes.  \n> **Image:** Setting up your device  \n4. Click **Show advanced activation, LoRaWAN class and cluster settings** and configure the following parameters, then click **Confirm**:\n- Activation mode: **Over the air activation (OTAA)**\n- Additional LoRaWAN class capabilities: **None (class A only)**\n- Network defaults: **Use network's default MAC settings**  \n> **Image:** Setting up your device  \n> **Image:** Setting up your device  \n5. Once done, provide the DevEUI credentials of your device into the **DevEUI** portion. Click the **Generate** button under **Provisioning Information** > **AppKey** to automatically generate the specific end-device ID of your board.  \nOnce done, you need to change the **End device ID** since it is automatically prefilled using the **DevEUI** of your device. Then click **Register end device**.  \n> **TIP:** NOTE  \n- The **AppEUI**, **DevEUI**, and **AppKey** are hidden in this section as these are unique from a specific device. The **DevEUI** credential is unique to every **RAK4631** device. Also, you should generate your own **AppEUI** and **AppKey** credentials for your specific device and application.\n- The **AppEUI** is the same as **JoinEUI**.\n- The details under **End device ID** are dependent on what device you are using.  \n> **Image:** Register End Device  \n6. After you have fully registered your device, you should be able to see it on the TTN console.  \n> **TIP:** NOTE  \n- The **AppEUI**, **DevEUI**, and **AppKey** are the parameters that you will need to activate your LoRaWAN end-device via OTAA. The **AppKey** is hidden by default for security reasons, but you can easily show it by clicking the show button. You can also copy the parameters quickly using the copy button.\n- These parameters are always accessible on the device console page, as shown in **Figure 82**.  \n> **Image:** OTAA device successfully registered to TTN"}
{"id": "910e7d6d2c8bf52f0bb98ccb4b2ba21c", "product_family": "wisblock", "product_id": "kit3-movement-detection", "category": "How-To", "title": "WisBlock Movement Detection Kit Quick Start Guide > WisBlock IoT Education Kit - Movement Detection Quick Start Guide > Miscellaneous > The Things Network Configuration > OTAA Device Registration > Register an OTAA End-Device on TTN", "content": "> **TIP:** NOTE  \n- The **AppEUI**, **DevEUI**, and **AppKey** are hidden in this section as these are unique from a specific device. The **DevEUI** credential is unique to every **RAK4631** device. Also, you should generate your own **AppEUI** and **AppKey** credentials for your specific device and application.\n- The **AppEUI** is the same as **JoinEUI**.\n- The details under **End device ID** are dependent on what device you are using.  \n> **Image:** Register End Device", "keywords": ["OTAA", "end-device", "TTN", "registration", "LoRaWAN"], "source_file": "quickstart.md", "token_count": 0, "parent_content": "1. To start adding an OTAA end-device, go to your application console and click **+ Register end device**.  \n> **Image:** Adding a device in OTAA mode  \n2. In the input method, select **Enter end device specifics manually** to register your device.  \n> **Image:** Registering the device in OTAA mode  \n3. Next, set up the **Frequency plan**, the compatible **LoRaWAN version**, and the supported **Regional Parameters version**. Then provide the **JoinEUI** credentials by entering zeroes.  \n> **Image:** Setting up your device  \n4. Click **Show advanced activation, LoRaWAN class and cluster settings** and configure the following parameters, then click **Confirm**:\n- Activation mode: **Over the air activation (OTAA)**\n- Additional LoRaWAN class capabilities: **None (class A only)**\n- Network defaults: **Use network's default MAC settings**  \n> **Image:** Setting up your device  \n> **Image:** Setting up your device  \n5. Once done, provide the DevEUI credentials of your device into the **DevEUI** portion. Click the **Generate** button under **Provisioning Information** > **AppKey** to automatically generate the specific end-device ID of your board.  \nOnce done, you need to change the **End device ID** since it is automatically prefilled using the **DevEUI** of your device. Then click **Register end device**.  \n> **TIP:** NOTE  \n- The **AppEUI**, **DevEUI**, and **AppKey** are hidden in this section as these are unique from a specific device. The **DevEUI** credential is unique to every **RAK4631** device. Also, you should generate your own **AppEUI** and **AppKey** credentials for your specific device and application.\n- The **AppEUI** is the same as **JoinEUI**.\n- The details under **End device ID** are dependent on what device you are using.  \n> **Image:** Register End Device  \n6. After you have fully registered your device, you should be able to see it on the TTN console.  \n> **TIP:** NOTE  \n- The **AppEUI**, **DevEUI**, and **AppKey** are the parameters that you will need to activate your LoRaWAN end-device via OTAA. The **AppKey** is hidden by default for security reasons, but you can easily show it by clicking the show button. You can also copy the parameters quickly using the copy button.\n- These parameters are always accessible on the device console page, as shown in **Figure 82**.  \n> **Image:** OTAA device successfully registered to TTN"}
{"id": "a73496354ed07ba9c191b8f395aaeb88", "product_family": "wisblock", "product_id": "kit3-movement-detection", "category": "How-To", "title": "WisBlock Movement Detection Kit Quick Start Guide > WisBlock IoT Education Kit - Movement Detection Quick Start Guide > Miscellaneous > The Things Network Configuration > OTAA Device Registration > Register an OTAA End-Device on TTN", "content": "> **Image:** Register End Device  \n6. After you have fully registered your device, you should be able to see it on the TTN console.  \n> **TIP:** NOTE  \n- The **AppEUI**, **DevEUI**, and **AppKey** are the parameters that you will need to activate your LoRaWAN end-device via OTAA. The **AppKey** is hidden by default for security reasons, but you can easily show it by clicking the show button. You can also copy the parameters quickly using the copy button.", "keywords": ["OTAA", "end-device", "TTN", "registration", "LoRaWAN"], "source_file": "quickstart.md", "token_count": 0, "parent_content": "1. To start adding an OTAA end-device, go to your application console and click **+ Register end device**.  \n> **Image:** Adding a device in OTAA mode  \n2. In the input method, select **Enter end device specifics manually** to register your device.  \n> **Image:** Registering the device in OTAA mode  \n3. Next, set up the **Frequency plan**, the compatible **LoRaWAN version**, and the supported **Regional Parameters version**. Then provide the **JoinEUI** credentials by entering zeroes.  \n> **Image:** Setting up your device  \n4. Click **Show advanced activation, LoRaWAN class and cluster settings** and configure the following parameters, then click **Confirm**:\n- Activation mode: **Over the air activation (OTAA)**\n- Additional LoRaWAN class capabilities: **None (class A only)**\n- Network defaults: **Use network's default MAC settings**  \n> **Image:** Setting up your device  \n> **Image:** Setting up your device  \n5. Once done, provide the DevEUI credentials of your device into the **DevEUI** portion. Click the **Generate** button under **Provisioning Information** > **AppKey** to automatically generate the specific end-device ID of your board.  \nOnce done, you need to change the **End device ID** since it is automatically prefilled using the **DevEUI** of your device. Then click **Register end device**.  \n> **TIP:** NOTE  \n- The **AppEUI**, **DevEUI**, and **AppKey** are hidden in this section as these are unique from a specific device. The **DevEUI** credential is unique to every **RAK4631** device. Also, you should generate your own **AppEUI** and **AppKey** credentials for your specific device and application.\n- The **AppEUI** is the same as **JoinEUI**.\n- The details under **End device ID** are dependent on what device you are using.  \n> **Image:** Register End Device  \n6. After you have fully registered your device, you should be able to see it on the TTN console.  \n> **TIP:** NOTE  \n- The **AppEUI**, **DevEUI**, and **AppKey** are the parameters that you will need to activate your LoRaWAN end-device via OTAA. The **AppKey** is hidden by default for security reasons, but you can easily show it by clicking the show button. You can also copy the parameters quickly using the copy button.\n- These parameters are always accessible on the device console page, as shown in **Figure 82**.  \n> **Image:** OTAA device successfully registered to TTN"}
{"id": "3c5f74cf814e8b7fcfe4ad25c788f0de", "product_family": "wisblock", "product_id": "kit3-movement-detection", "category": "How-To", "title": "WisBlock Movement Detection Kit Quick Start Guide > WisBlock IoT Education Kit - Movement Detection Quick Start Guide > Miscellaneous > The Things Network Configuration > OTAA Device Registration > Register an OTAA End-Device on TTN", "content": "- These parameters are always accessible on the device console page, as shown in **Figure 82**.  \n> **Image:** OTAA device successfully registered to TTN", "keywords": ["OTAA", "end-device", "TTN", "registration", "LoRaWAN"], "source_file": "quickstart.md", "token_count": 0, "parent_content": "1. To start adding an OTAA end-device, go to your application console and click **+ Register end device**.  \n> **Image:** Adding a device in OTAA mode  \n2. In the input method, select **Enter end device specifics manually** to register your device.  \n> **Image:** Registering the device in OTAA mode  \n3. Next, set up the **Frequency plan**, the compatible **LoRaWAN version**, and the supported **Regional Parameters version**. Then provide the **JoinEUI** credentials by entering zeroes.  \n> **Image:** Setting up your device  \n4. Click **Show advanced activation, LoRaWAN class and cluster settings** and configure the following parameters, then click **Confirm**:\n- Activation mode: **Over the air activation (OTAA)**\n- Additional LoRaWAN class capabilities: **None (class A only)**\n- Network defaults: **Use network's default MAC settings**  \n> **Image:** Setting up your device  \n> **Image:** Setting up your device  \n5. Once done, provide the DevEUI credentials of your device into the **DevEUI** portion. Click the **Generate** button under **Provisioning Information** > **AppKey** to automatically generate the specific end-device ID of your board.  \nOnce done, you need to change the **End device ID** since it is automatically prefilled using the **DevEUI** of your device. Then click **Register end device**.  \n> **TIP:** NOTE  \n- The **AppEUI**, **DevEUI**, and **AppKey** are hidden in this section as these are unique from a specific device. The **DevEUI** credential is unique to every **RAK4631** device. Also, you should generate your own **AppEUI** and **AppKey** credentials for your specific device and application.\n- The **AppEUI** is the same as **JoinEUI**.\n- The details under **End device ID** are dependent on what device you are using.  \n> **Image:** Register End Device  \n6. After you have fully registered your device, you should be able to see it on the TTN console.  \n> **TIP:** NOTE  \n- The **AppEUI**, **DevEUI**, and **AppKey** are the parameters that you will need to activate your LoRaWAN end-device via OTAA. The **AppKey** is hidden by default for security reasons, but you can easily show it by clicking the show button. You can also copy the parameters quickly using the copy button.\n- These parameters are always accessible on the device console page, as shown in **Figure 82**.  \n> **Image:** OTAA device successfully registered to TTN"}
{"id": "b1bc3719f21ce272e2e4a0a4e3f15ae8", "product_family": "wisblock", "product_id": "kit3-movement-detection", "category": "How-To", "title": "WisBlock Movement Detection Kit Quick Start Guide > WisBlock IoT Education Kit - Movement Detection Quick Start Guide > Miscellaneous > Arduino IDE Installation + RAK4631 > Setting Up Arduino IDE for RAKwireless WisBlock Core", "content": "1. Download the [Arduino IDE](https://www.arduino.cc/en/software) and install it on your PC or laptop. You must choose the appropriate **Arduino IDE** depending on your operating system.  \n> **Image:** Download Options for the Arduino IDE  \n2. Install the [RAKwireless Arduino BSP](https://github.com/RAKWireless/RAKwireless-Arduino-BSP-Index) for WisBlock by using the `package_rakwireless_index.json` board installation package. The WisBlock Core should now be available on the Arduino IDE.", "keywords": ["Arduino IDE", "RAKwireless Arduino BSP", "WisBlock Core", "RAK4631", "setup"], "source_file": "quickstart.md", "token_count": 250, "parent_content": "1. Download the [Arduino IDE](https://www.arduino.cc/en/software) and install it on your PC or laptop. You must choose the appropriate **Arduino IDE** depending on your operating system.  \n> **Image:** Download Options for the Arduino IDE  \n2. Install the [RAKwireless Arduino BSP](https://github.com/RAKWireless/RAKwireless-Arduino-BSP-Index) for WisBlock by using the `package_rakwireless_index.json` board installation package. The WisBlock Core should now be available on the Arduino IDE.  \n3. Open the **Arduino IDE** and go to **File** > **Preference**.  \n> **Image:** Preference Set-Up  \n4. In the **Preferences** window, under the **Settings** tab, click the icon in line with **Additional Boards Manager URLs**.  \n> **Image:** Preference Window  \n5. A window will pop up. Copy the highlighted link and click **OK**.  \n> **Image:** RAKwireless Arduino BSP  \n6. Paste the link under the **Additional boards manager URLs:** field, and then click **OK**.  \n> **Image:** Completing the setup of the RAKwireless BSP support for the Arduino Board Manager  \n7. In your **Arduino IDE**, go to **Tools** > **Board:XXXXX** > **Boards Manager** and look for **RAKwireless Boards by RAKwireless** since you will be working with **RAK4631 WisBlock Core**. Choose the latest version, then install it. Once done, close the **Board Manager**.  \n> **Image:** Opening the Boards Manager  \n> **Image:** Installing the RAKwireless nRF Boards  \n> **TIP:** NOTE\nThe steps outlined above apply to all devices you will be using. Once done with the installation of the device, proceed to its next step:  \n- **RAK12006**: [LoRaWAN Code for RAK12006](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#lorawan-code-for-rak12006)\n- **RAK12007**: [LoRaWAN Code for RAK12007](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#lorawan-code-for-rak12007)\n- **RAK12013**: [LoRaWAN Code for RAK12013](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#lorawan-code-for-rak12013)\n- **RAK12017**: [LoRaWAN Code for RAK12017](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#lorawan-code-for-rak12017)"}
{"id": "92c5f9a98d65ecd906a235d7d65d914c", "product_family": "wisblock", "product_id": "kit3-movement-detection", "category": "How-To", "title": "WisBlock Movement Detection Kit Quick Start Guide > WisBlock IoT Education Kit - Movement Detection Quick Start Guide > Miscellaneous > Arduino IDE Installation + RAK4631 > Setting Up Arduino IDE for RAKwireless WisBlock Core", "content": "3. Open the **Arduino IDE** and go to **File** > **Preference**.  \n> **Image:** Preference Set-Up  \n4. In the **Preferences** window, under the **Settings** tab, click the icon in line with **Additional Boards Manager URLs**.  \n> **Image:** Preference Window  \n5. A window will pop up. Copy the highlighted link and click **OK**.  \n> **Image:** RAKwireless Arduino BSP  \n6. Paste the link under the **Additional boards manager URLs:** field, and then click **OK**.", "keywords": ["Arduino IDE", "RAKwireless Arduino BSP", "WisBlock Core", "RAK4631", "setup"], "source_file": "quickstart.md", "token_count": 250, "parent_content": "1. Download the [Arduino IDE](https://www.arduino.cc/en/software) and install it on your PC or laptop. You must choose the appropriate **Arduino IDE** depending on your operating system.  \n> **Image:** Download Options for the Arduino IDE  \n2. Install the [RAKwireless Arduino BSP](https://github.com/RAKWireless/RAKwireless-Arduino-BSP-Index) for WisBlock by using the `package_rakwireless_index.json` board installation package. The WisBlock Core should now be available on the Arduino IDE.  \n3. Open the **Arduino IDE** and go to **File** > **Preference**.  \n> **Image:** Preference Set-Up  \n4. In the **Preferences** window, under the **Settings** tab, click the icon in line with **Additional Boards Manager URLs**.  \n> **Image:** Preference Window  \n5. A window will pop up. Copy the highlighted link and click **OK**.  \n> **Image:** RAKwireless Arduino BSP  \n6. Paste the link under the **Additional boards manager URLs:** field, and then click **OK**.  \n> **Image:** Completing the setup of the RAKwireless BSP support for the Arduino Board Manager  \n7. In your **Arduino IDE**, go to **Tools** > **Board:XXXXX** > **Boards Manager** and look for **RAKwireless Boards by RAKwireless** since you will be working with **RAK4631 WisBlock Core**. Choose the latest version, then install it. Once done, close the **Board Manager**.  \n> **Image:** Opening the Boards Manager  \n> **Image:** Installing the RAKwireless nRF Boards  \n> **TIP:** NOTE\nThe steps outlined above apply to all devices you will be using. Once done with the installation of the device, proceed to its next step:  \n- **RAK12006**: [LoRaWAN Code for RAK12006](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#lorawan-code-for-rak12006)\n- **RAK12007**: [LoRaWAN Code for RAK12007](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#lorawan-code-for-rak12007)\n- **RAK12013**: [LoRaWAN Code for RAK12013](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#lorawan-code-for-rak12013)\n- **RAK12017**: [LoRaWAN Code for RAK12017](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#lorawan-code-for-rak12017)"}
{"id": "343d04e7fab059ddd5690599123f565a", "product_family": "wisblock", "product_id": "kit3-movement-detection", "category": "How-To", "title": "WisBlock Movement Detection Kit Quick Start Guide > WisBlock IoT Education Kit - Movement Detection Quick Start Guide > Miscellaneous > Arduino IDE Installation + RAK4631 > Setting Up Arduino IDE for RAKwireless WisBlock Core", "content": "6. Paste the link under the **Additional boards manager URLs:** field, and then click **OK**.  \n> **Image:** Completing the setup of the RAKwireless BSP support for the Arduino Board Manager  \n7. In your **Arduino IDE**, go to **Tools** > **Board:XXXXX** > **Boards Manager** and look for **RAKwireless Boards by RAKwireless** since you will be working with **RAK4631 WisBlock Core**. Choose the latest version, then install it. Once done, close the **Board Manager**.", "keywords": ["Arduino IDE", "RAKwireless Arduino BSP", "WisBlock Core", "RAK4631", "setup"], "source_file": "quickstart.md", "token_count": 250, "parent_content": "1. Download the [Arduino IDE](https://www.arduino.cc/en/software) and install it on your PC or laptop. You must choose the appropriate **Arduino IDE** depending on your operating system.  \n> **Image:** Download Options for the Arduino IDE  \n2. Install the [RAKwireless Arduino BSP](https://github.com/RAKWireless/RAKwireless-Arduino-BSP-Index) for WisBlock by using the `package_rakwireless_index.json` board installation package. The WisBlock Core should now be available on the Arduino IDE.  \n3. Open the **Arduino IDE** and go to **File** > **Preference**.  \n> **Image:** Preference Set-Up  \n4. In the **Preferences** window, under the **Settings** tab, click the icon in line with **Additional Boards Manager URLs**.  \n> **Image:** Preference Window  \n5. A window will pop up. Copy the highlighted link and click **OK**.  \n> **Image:** RAKwireless Arduino BSP  \n6. Paste the link under the **Additional boards manager URLs:** field, and then click **OK**.  \n> **Image:** Completing the setup of the RAKwireless BSP support for the Arduino Board Manager  \n7. In your **Arduino IDE**, go to **Tools** > **Board:XXXXX** > **Boards Manager** and look for **RAKwireless Boards by RAKwireless** since you will be working with **RAK4631 WisBlock Core**. Choose the latest version, then install it. Once done, close the **Board Manager**.  \n> **Image:** Opening the Boards Manager  \n> **Image:** Installing the RAKwireless nRF Boards  \n> **TIP:** NOTE\nThe steps outlined above apply to all devices you will be using. Once done with the installation of the device, proceed to its next step:  \n- **RAK12006**: [LoRaWAN Code for RAK12006](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#lorawan-code-for-rak12006)\n- **RAK12007**: [LoRaWAN Code for RAK12007](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#lorawan-code-for-rak12007)\n- **RAK12013**: [LoRaWAN Code for RAK12013](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#lorawan-code-for-rak12013)\n- **RAK12017**: [LoRaWAN Code for RAK12017](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#lorawan-code-for-rak12017)"}
{"id": "40c64a22efac74d6431b461957c277ad", "product_family": "wisblock", "product_id": "kit3-movement-detection", "category": "How-To", "title": "WisBlock Movement Detection Kit Quick Start Guide > WisBlock IoT Education Kit - Movement Detection Quick Start Guide > Miscellaneous > Arduino IDE Installation + RAK4631 > Setting Up Arduino IDE for RAKwireless WisBlock Core", "content": "> **Image:** Opening the Boards Manager  \n> **Image:** Installing the RAKwireless nRF Boards  \n> **TIP:** NOTE\nThe steps outlined above apply to all devices you will be using. Once done with the installation of the device, proceed to its next step:  \n- **RAK12006**: [LoRaWAN Code for RAK12006](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#lorawan-code-for-rak12006)", "keywords": ["Arduino IDE", "RAKwireless Arduino BSP", "WisBlock Core", "RAK4631", "setup"], "source_file": "quickstart.md", "token_count": 250, "parent_content": "1. Download the [Arduino IDE](https://www.arduino.cc/en/software) and install it on your PC or laptop. You must choose the appropriate **Arduino IDE** depending on your operating system.  \n> **Image:** Download Options for the Arduino IDE  \n2. Install the [RAKwireless Arduino BSP](https://github.com/RAKWireless/RAKwireless-Arduino-BSP-Index) for WisBlock by using the `package_rakwireless_index.json` board installation package. The WisBlock Core should now be available on the Arduino IDE.  \n3. Open the **Arduino IDE** and go to **File** > **Preference**.  \n> **Image:** Preference Set-Up  \n4. In the **Preferences** window, under the **Settings** tab, click the icon in line with **Additional Boards Manager URLs**.  \n> **Image:** Preference Window  \n5. A window will pop up. Copy the highlighted link and click **OK**.  \n> **Image:** RAKwireless Arduino BSP  \n6. Paste the link under the **Additional boards manager URLs:** field, and then click **OK**.  \n> **Image:** Completing the setup of the RAKwireless BSP support for the Arduino Board Manager  \n7. In your **Arduino IDE**, go to **Tools** > **Board:XXXXX** > **Boards Manager** and look for **RAKwireless Boards by RAKwireless** since you will be working with **RAK4631 WisBlock Core**. Choose the latest version, then install it. Once done, close the **Board Manager**.  \n> **Image:** Opening the Boards Manager  \n> **Image:** Installing the RAKwireless nRF Boards  \n> **TIP:** NOTE\nThe steps outlined above apply to all devices you will be using. Once done with the installation of the device, proceed to its next step:  \n- **RAK12006**: [LoRaWAN Code for RAK12006](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#lorawan-code-for-rak12006)\n- **RAK12007**: [LoRaWAN Code for RAK12007](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#lorawan-code-for-rak12007)\n- **RAK12013**: [LoRaWAN Code for RAK12013](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#lorawan-code-for-rak12013)\n- **RAK12017**: [LoRaWAN Code for RAK12017](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#lorawan-code-for-rak12017)"}
{"id": "0fdfcd0b1d51480913124edf56e3578a", "product_family": "wisblock", "product_id": "kit3-movement-detection", "category": "How-To", "title": "WisBlock Movement Detection Kit Quick Start Guide > WisBlock IoT Education Kit - Movement Detection Quick Start Guide > Miscellaneous > Arduino IDE Installation + RAK4631 > Setting Up Arduino IDE for RAKwireless WisBlock Core", "content": "- **RAK12007**: [LoRaWAN Code for RAK12007](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#lorawan-code-for-rak12007)\n- **RAK12013**: [LoRaWAN Code for RAK12013](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#lorawan-code-for-rak12013)\n- **RAK12017**: [LoRaWAN Code for RAK12017](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#lorawan-code-for-rak12017)", "keywords": ["Arduino IDE", "RAKwireless Arduino BSP", "WisBlock Core", "RAK4631", "setup"], "source_file": "quickstart.md", "token_count": 250, "parent_content": "1. Download the [Arduino IDE](https://www.arduino.cc/en/software) and install it on your PC or laptop. You must choose the appropriate **Arduino IDE** depending on your operating system.  \n> **Image:** Download Options for the Arduino IDE  \n2. Install the [RAKwireless Arduino BSP](https://github.com/RAKWireless/RAKwireless-Arduino-BSP-Index) for WisBlock by using the `package_rakwireless_index.json` board installation package. The WisBlock Core should now be available on the Arduino IDE.  \n3. Open the **Arduino IDE** and go to **File** > **Preference**.  \n> **Image:** Preference Set-Up  \n4. In the **Preferences** window, under the **Settings** tab, click the icon in line with **Additional Boards Manager URLs**.  \n> **Image:** Preference Window  \n5. A window will pop up. Copy the highlighted link and click **OK**.  \n> **Image:** RAKwireless Arduino BSP  \n6. Paste the link under the **Additional boards manager URLs:** field, and then click **OK**.  \n> **Image:** Completing the setup of the RAKwireless BSP support for the Arduino Board Manager  \n7. In your **Arduino IDE**, go to **Tools** > **Board:XXXXX** > **Boards Manager** and look for **RAKwireless Boards by RAKwireless** since you will be working with **RAK4631 WisBlock Core**. Choose the latest version, then install it. Once done, close the **Board Manager**.  \n> **Image:** Opening the Boards Manager  \n> **Image:** Installing the RAKwireless nRF Boards  \n> **TIP:** NOTE\nThe steps outlined above apply to all devices you will be using. Once done with the installation of the device, proceed to its next step:  \n- **RAK12006**: [LoRaWAN Code for RAK12006](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#lorawan-code-for-rak12006)\n- **RAK12007**: [LoRaWAN Code for RAK12007](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#lorawan-code-for-rak12007)\n- **RAK12013**: [LoRaWAN Code for RAK12013](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#lorawan-code-for-rak12013)\n- **RAK12017**: [LoRaWAN Code for RAK12017](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#lorawan-code-for-rak12017)"}
{"id": "ba5e71830fa6c14ea80a38f91043704f", "product_family": "wisblock", "product_id": "kit3-movement-detection", "category": "How-To", "title": "WisBlock Movement Detection Kit Quick Start Guide > WisBlock IoT Education Kit - Movement Detection Quick Start Guide > Miscellaneous > Setting up Your Device Using ThingSpeak > Creating a ThingSpeak Account and Channel for RAKwireless Devices", "content": "1. Go to [thingspeak.com](https://thingspeak.com/), then click **Get Started For Free**. Select **Create One!** to create your ThingSpeak account.  \n> **Image:** ThingSpeak Platform  \n2. Once your newly created account has been verified, click **OK**. Then, for the **ThingSpeak Usage Intent**, select **Personal, non-commercial projects** and click **OK**.  \n> **Image:** ThingSpeak Account creation  \n> **Image:** ThingSpeak Account creation  \n3. Then under **Channels**, click **New Channel**.", "keywords": ["ThingSpeak", "account creation", "channel setup", "RAK12006", "RAK12007", "RAK12013", "RAK12017"], "source_file": "quickstart.md", "token_count": 0, "parent_content": "1. Go to [thingspeak.com](https://thingspeak.com/), then click **Get Started For Free**. Select **Create One!** to create your ThingSpeak account.  \n> **Image:** ThingSpeak Platform  \n2. Once your newly created account has been verified, click **OK**. Then, for the **ThingSpeak Usage Intent**, select **Personal, non-commercial projects** and click **OK**.  \n> **Image:** ThingSpeak Account creation  \n> **Image:** ThingSpeak Account creation  \n3. Then under **Channels**, click **New Channel**.  \n> **Image:** Creating New Channel in ThingSpeak  \n> **TIP:** NOTE\nThe steps outlined above apply to all devices you will be using. Once you have finished creating a ThingSpeak account and are ready to start adding channels, proceed to the next step:  \n- **RAK12006**: [LoRaWAN Code for RAK12006](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#setting-up-rak12006-pir-motion-sensor-dashboard-using-thingspeak)\n- **RAK12007**: [LoRaWAN Code for RAK12007](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#setting-up-rak12006-pir-motion-sensor-dashboard-using-thingspeak)\n- **RAK12013**: [LoRaWAN Code for RAK12013](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#setting-up-rak12013-radar-sensor-dashboard-using-thingspeak)\n- **RAK12017**: [LoRaWAN Code for RAK12017](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#setting-up-rak12017-ir-proximity-sensor-dashboard-using-thingspeak)"}
{"id": "127c16e1f3036c49ce8edb2b9284bbc8", "product_family": "wisblock", "product_id": "kit3-movement-detection", "category": "How-To", "title": "WisBlock Movement Detection Kit Quick Start Guide > WisBlock IoT Education Kit - Movement Detection Quick Start Guide > Miscellaneous > Setting up Your Device Using ThingSpeak > Creating a ThingSpeak Account and Channel for RAKwireless Devices", "content": "> **Image:** ThingSpeak Account creation  \n3. Then under **Channels**, click **New Channel**.  \n> **Image:** Creating New Channel in ThingSpeak  \n> **TIP:** NOTE\nThe steps outlined above apply to all devices you will be using. Once you have finished creating a ThingSpeak account and are ready to start adding channels, proceed to the next step:", "keywords": ["ThingSpeak", "account creation", "channel setup", "RAK12006", "RAK12007", "RAK12013", "RAK12017"], "source_file": "quickstart.md", "token_count": 0, "parent_content": "1. Go to [thingspeak.com](https://thingspeak.com/), then click **Get Started For Free**. Select **Create One!** to create your ThingSpeak account.  \n> **Image:** ThingSpeak Platform  \n2. Once your newly created account has been verified, click **OK**. Then, for the **ThingSpeak Usage Intent**, select **Personal, non-commercial projects** and click **OK**.  \n> **Image:** ThingSpeak Account creation  \n> **Image:** ThingSpeak Account creation  \n3. Then under **Channels**, click **New Channel**.  \n> **Image:** Creating New Channel in ThingSpeak  \n> **TIP:** NOTE\nThe steps outlined above apply to all devices you will be using. Once you have finished creating a ThingSpeak account and are ready to start adding channels, proceed to the next step:  \n- **RAK12006**: [LoRaWAN Code for RAK12006](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#setting-up-rak12006-pir-motion-sensor-dashboard-using-thingspeak)\n- **RAK12007**: [LoRaWAN Code for RAK12007](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#setting-up-rak12006-pir-motion-sensor-dashboard-using-thingspeak)\n- **RAK12013**: [LoRaWAN Code for RAK12013](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#setting-up-rak12013-radar-sensor-dashboard-using-thingspeak)\n- **RAK12017**: [LoRaWAN Code for RAK12017](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#setting-up-rak12017-ir-proximity-sensor-dashboard-using-thingspeak)"}
{"id": "8d54bbe297558d3393ef5fed7ce5f5e0", "product_family": "wisblock", "product_id": "kit3-movement-detection", "category": "How-To", "title": "WisBlock Movement Detection Kit Quick Start Guide > WisBlock IoT Education Kit - Movement Detection Quick Start Guide > Miscellaneous > Setting up Your Device Using ThingSpeak > Creating a ThingSpeak Account and Channel for RAKwireless Devices", "content": "- **RAK12006**: [LoRaWAN Code for RAK12006](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#setting-up-rak12006-pir-motion-sensor-dashboard-using-thingspeak)\n- **RAK12007**: [LoRaWAN Code for RAK12007](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#setting-up-rak12006-pir-motion-sensor-dashboard-using-thingspeak)", "keywords": ["ThingSpeak", "account creation", "channel setup", "RAK12006", "RAK12007", "RAK12013", "RAK12017"], "source_file": "quickstart.md", "token_count": 0, "parent_content": "1. Go to [thingspeak.com](https://thingspeak.com/), then click **Get Started For Free**. Select **Create One!** to create your ThingSpeak account.  \n> **Image:** ThingSpeak Platform  \n2. Once your newly created account has been verified, click **OK**. Then, for the **ThingSpeak Usage Intent**, select **Personal, non-commercial projects** and click **OK**.  \n> **Image:** ThingSpeak Account creation  \n> **Image:** ThingSpeak Account creation  \n3. Then under **Channels**, click **New Channel**.  \n> **Image:** Creating New Channel in ThingSpeak  \n> **TIP:** NOTE\nThe steps outlined above apply to all devices you will be using. Once you have finished creating a ThingSpeak account and are ready to start adding channels, proceed to the next step:  \n- **RAK12006**: [LoRaWAN Code for RAK12006](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#setting-up-rak12006-pir-motion-sensor-dashboard-using-thingspeak)\n- **RAK12007**: [LoRaWAN Code for RAK12007](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#setting-up-rak12006-pir-motion-sensor-dashboard-using-thingspeak)\n- **RAK12013**: [LoRaWAN Code for RAK12013](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#setting-up-rak12013-radar-sensor-dashboard-using-thingspeak)\n- **RAK12017**: [LoRaWAN Code for RAK12017](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#setting-up-rak12017-ir-proximity-sensor-dashboard-using-thingspeak)"}
{"id": "f7b5b7017f358a0d73f9216ba5cf43db", "product_family": "wisblock", "product_id": "kit3-movement-detection", "category": "How-To", "title": "WisBlock Movement Detection Kit Quick Start Guide > WisBlock IoT Education Kit - Movement Detection Quick Start Guide > Miscellaneous > Setting up Your Device Using ThingSpeak > Creating a ThingSpeak Account and Channel for RAKwireless Devices", "content": "- **RAK12013**: [LoRaWAN Code for RAK12013](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#setting-up-rak12013-radar-sensor-dashboard-using-thingspeak)\n- **RAK12017**: [LoRaWAN Code for RAK12017](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#setting-up-rak12017-ir-proximity-sensor-dashboard-using-thingspeak)", "keywords": ["ThingSpeak", "account creation", "channel setup", "RAK12006", "RAK12007", "RAK12013", "RAK12017"], "source_file": "quickstart.md", "token_count": 0, "parent_content": "1. Go to [thingspeak.com](https://thingspeak.com/), then click **Get Started For Free**. Select **Create One!** to create your ThingSpeak account.  \n> **Image:** ThingSpeak Platform  \n2. Once your newly created account has been verified, click **OK**. Then, for the **ThingSpeak Usage Intent**, select **Personal, non-commercial projects** and click **OK**.  \n> **Image:** ThingSpeak Account creation  \n> **Image:** ThingSpeak Account creation  \n3. Then under **Channels**, click **New Channel**.  \n> **Image:** Creating New Channel in ThingSpeak  \n> **TIP:** NOTE\nThe steps outlined above apply to all devices you will be using. Once you have finished creating a ThingSpeak account and are ready to start adding channels, proceed to the next step:  \n- **RAK12006**: [LoRaWAN Code for RAK12006](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#setting-up-rak12006-pir-motion-sensor-dashboard-using-thingspeak)\n- **RAK12007**: [LoRaWAN Code for RAK12007](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#setting-up-rak12006-pir-motion-sensor-dashboard-using-thingspeak)\n- **RAK12013**: [LoRaWAN Code for RAK12013](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#setting-up-rak12013-radar-sensor-dashboard-using-thingspeak)\n- **RAK12017**: [LoRaWAN Code for RAK12017](https://docs.rakwireless.com/product-categories/wisblock/kit3-movement-detection/quickstart/#setting-up-rak12017-ir-proximity-sensor-dashboard-using-thingspeak)"}
