{"id": "337cea5e9c7917d7b1b0f430d8057088", "product_family": "wisduo", "product_id": "rak811-module", "category": "Concept", "title": "Low Level Development Reference > Low Level Development Reference > Overview > RAK811 Module Firmware Configuration and Customization", "content": "RAK811 module comes with a standard version of firmware that allows you to configure its functionality via AT commands. This simplicity helps you develop LoRa(P2P) and LoRaWAN projects quickly.", "keywords": ["firmware", "AT commands", "RUI", "customization", "STM32"], "source_file": "low-level-development.md", "token_count": 150, "parent_content": "RAK811 module comes with a standard version of firmware that allows you to configure its functionality via AT commands. This simplicity helps you develop LoRa(P2P) and LoRaWAN projects quickly.  \nFurther customization of the firmware can be done through the [RUI (RAKwireless Unified Interface) Online compiler](https://docs.rakwireless.com/product-categories/software-apis-and-libraries/rui/). RAK's LoRaWAN node modules support not only out-of-the-box integration via AT commands but also allow you to customize RAK811 firmware and access other functionalities of the internal MCU using RUI API. More so, you can adapt and extend the logic in the firmware to meet your requirements.  \nAdditionally, RAK offers a third alternative for advanced customers who need to have deeper integration of their solutions with these modules. In this alternative, you could develop your own version of STM32 firmware that runs inside of the RAK811 module."}
{"id": "fadf0d6e8a6519b116c246b34dada09f", "product_family": "wisduo", "product_id": "rak811-module", "category": "Concept", "title": "Low Level Development Reference > Low Level Development Reference > Overview > RAK811 Module Firmware Configuration and Customization", "content": "Further customization of the firmware can be done through the [RUI (RAKwireless Unified Interface) Online compiler](https://docs.rakwireless.com/product-categories/software-apis-and-libraries/rui/). RAK's LoRaWAN node modules support not only out-of-the-box integration via AT commands but also allow you to customize RAK811 firmware and access other functionalities of the internal MCU using RUI API. More so, you can adapt and extend the logic in the firmware to meet your requirements.", "keywords": ["firmware", "AT commands", "RUI", "customization", "STM32"], "source_file": "low-level-development.md", "token_count": 150, "parent_content": "RAK811 module comes with a standard version of firmware that allows you to configure its functionality via AT commands. This simplicity helps you develop LoRa(P2P) and LoRaWAN projects quickly.  \nFurther customization of the firmware can be done through the [RUI (RAKwireless Unified Interface) Online compiler](https://docs.rakwireless.com/product-categories/software-apis-and-libraries/rui/). RAK's LoRaWAN node modules support not only out-of-the-box integration via AT commands but also allow you to customize RAK811 firmware and access other functionalities of the internal MCU using RUI API. More so, you can adapt and extend the logic in the firmware to meet your requirements.  \nAdditionally, RAK offers a third alternative for advanced customers who need to have deeper integration of their solutions with these modules. In this alternative, you could develop your own version of STM32 firmware that runs inside of the RAK811 module."}
{"id": "37ce86d1e0e9d6a9b5186307abe11c9b", "product_family": "wisduo", "product_id": "rak811-module", "category": "Concept", "title": "Low Level Development Reference > Low Level Development Reference > Overview > RAK811 Module Firmware Configuration and Customization", "content": "Additionally, RAK offers a third alternative for advanced customers who need to have deeper integration of their solutions with these modules. In this alternative, you could develop your own version of STM32 firmware that runs inside of the RAK811 module.", "keywords": ["firmware", "AT commands", "RUI", "customization", "STM32"], "source_file": "low-level-development.md", "token_count": 150, "parent_content": "RAK811 module comes with a standard version of firmware that allows you to configure its functionality via AT commands. This simplicity helps you develop LoRa(P2P) and LoRaWAN projects quickly.  \nFurther customization of the firmware can be done through the [RUI (RAKwireless Unified Interface) Online compiler](https://docs.rakwireless.com/product-categories/software-apis-and-libraries/rui/). RAK's LoRaWAN node modules support not only out-of-the-box integration via AT commands but also allow you to customize RAK811 firmware and access other functionalities of the internal MCU using RUI API. More so, you can adapt and extend the logic in the firmware to meet your requirements.  \nAdditionally, RAK offers a third alternative for advanced customers who need to have deeper integration of their solutions with these modules. In this alternative, you could develop your own version of STM32 firmware that runs inside of the RAK811 module."}
{"id": "104e750b967d5cfbcbc650bd1e467b77", "product_family": "wisduo", "product_id": "rak811-module", "category": "Reference", "title": "Low Level Development Reference > Low Level Development Reference > How to Implement Your Own Firmware on RAK811 Module > Schematic > RAK811 Hardware Schematic and Datasheet Reference", "content": "One of the essential aspects that allow customers to develop their own version of firmware is the [RAK811 Hardware Schematic](https://downloads.rakwireless.com/#LoRa/RAK811/Hardware_Specification/). This allows the customers to understand the module\u2019s pinout and the connections between the internal STM32 MCU and the LoRa transceiver. Other important details can be found on [RAK811 Datasheet](https://docs.rakwireless.com/product-categories/wisduo/rak811-module/datasheet/).  \n> **TIP:** NOTE", "keywords": ["RAK811", "Hardware Schematic", "Datasheet", "Firmware Development", "Pinout", "STM32 MCU", "LoRa Transceiver", "RAK811(H)", "RAK811(L)", "Frequency Bands"], "source_file": "low-level-development.md", "token_count": 100, "parent_content": "One of the essential aspects that allow customers to develop their own version of firmware is the [RAK811 Hardware Schematic](https://downloads.rakwireless.com/#LoRa/RAK811/Hardware_Specification/). This allows the customers to understand the module\u2019s pinout and the connections between the internal STM32 MCU and the LoRa transceiver. Other important details can be found on [RAK811 Datasheet](https://docs.rakwireless.com/product-categories/wisduo/rak811-module/datasheet/).  \n> **TIP:** NOTE  \nThere are two versions of the RAK811 module: the high-frequency bands RAK811(H) used on EU868, US915, AU915, KR920, AS923, and IN865, and the low-frequency bands RAK811(L) used on EU433 and CN470. These two modules have few differences in their schematic diagram that you should be aware of when you develop your own firmware."}
{"id": "0291b7643715b413c2183176860eaccc", "product_family": "wisduo", "product_id": "rak811-module", "category": "Reference", "title": "Low Level Development Reference > Low Level Development Reference > How to Implement Your Own Firmware on RAK811 Module > Schematic > RAK811 Hardware Schematic and Datasheet Reference", "content": "> **TIP:** NOTE  \nThere are two versions of the RAK811 module: the high-frequency bands RAK811(H) used on EU868, US915, AU915, KR920, AS923, and IN865, and the low-frequency bands RAK811(L) used on EU433 and CN470. These two modules have few differences in their schematic diagram that you should be aware of when you develop your own firmware.", "keywords": ["RAK811", "Hardware Schematic", "Datasheet", "Firmware Development", "Pinout", "STM32 MCU", "LoRa Transceiver", "RAK811(H)", "RAK811(L)", "Frequency Bands"], "source_file": "low-level-development.md", "token_count": 100, "parent_content": "One of the essential aspects that allow customers to develop their own version of firmware is the [RAK811 Hardware Schematic](https://downloads.rakwireless.com/#LoRa/RAK811/Hardware_Specification/). This allows the customers to understand the module\u2019s pinout and the connections between the internal STM32 MCU and the LoRa transceiver. Other important details can be found on [RAK811 Datasheet](https://docs.rakwireless.com/product-categories/wisduo/rak811-module/datasheet/).  \n> **TIP:** NOTE  \nThere are two versions of the RAK811 module: the high-frequency bands RAK811(H) used on EU868, US915, AU915, KR920, AS923, and IN865, and the low-frequency bands RAK811(L) used on EU433 and CN470. These two modules have few differences in their schematic diagram that you should be aware of when you develop your own firmware."}
{"id": "6fdc2f77b8ee30b3270f79cd3cb98585", "product_family": "wisduo", "product_id": "rak811-module", "category": "Concept", "title": "Low Level Development Reference > Low Level Development Reference > How to Implement Your Own Firmware on RAK811 Module > Porting Lora Protocol Stack > Key Considerations for Implementing LoRa Protocol Stack on RAK811 Module", "content": "When implementing the LoRa protocol stack, special attention must be given to the SPI connections since the LoRa transceivers are controlled by the MCU through an SPI interface. Hence, the following are the important pins: **SPI1_MISO, SPI1_MOSI, SPI_NSS, SPI_CLK**.", "keywords": ["LoRa protocol stack", "SPI connections", "DIO pins", "RF signal paths", "RF switch logic table", "Real-Time Clock (RTC)", "RAK811 Datasheet"], "source_file": "low-level-development.md", "token_count": 150, "parent_content": "When implementing the LoRa protocol stack, special attention must be given to the SPI connections since the LoRa transceivers are controlled by the MCU through an SPI interface. Hence, the following are the important pins: **SPI1_MISO, SPI1_MOSI, SPI_NSS, SPI_CLK**.  \nAdditionally, the DIO pins and RF signal paths are significant as well to have functional LoRa communication. Another important thing to consider is the RF switch logic table. The complete details of pin connections can be found on the [RAK811 Datasheet](https://docs.rakwireless.com/product-categories/wisduo/rak811-module/datasheet/).  \nAfter that, the **Real-Time Clock (RTC)** must be properly configured in the MCU to ensure accurate timing of the protocol stack during the runtime. Finally, the protocol stack code can be added after configuring the other pins."}
{"id": "e5c6e65ca58b49c489902f5b1720c0bd", "product_family": "wisduo", "product_id": "rak811-module", "category": "Concept", "title": "Low Level Development Reference > Low Level Development Reference > How to Implement Your Own Firmware on RAK811 Module > Porting Lora Protocol Stack > Key Considerations for Implementing LoRa Protocol Stack on RAK811 Module", "content": "Additionally, the DIO pins and RF signal paths are significant as well to have functional LoRa communication. Another important thing to consider is the RF switch logic table. The complete details of pin connections can be found on the [RAK811 Datasheet](https://docs.rakwireless.com/product-categories/wisduo/rak811-module/datasheet/).", "keywords": ["LoRa protocol stack", "SPI connections", "DIO pins", "RF signal paths", "RF switch logic table", "Real-Time Clock (RTC)", "RAK811 Datasheet"], "source_file": "low-level-development.md", "token_count": 150, "parent_content": "When implementing the LoRa protocol stack, special attention must be given to the SPI connections since the LoRa transceivers are controlled by the MCU through an SPI interface. Hence, the following are the important pins: **SPI1_MISO, SPI1_MOSI, SPI_NSS, SPI_CLK**.  \nAdditionally, the DIO pins and RF signal paths are significant as well to have functional LoRa communication. Another important thing to consider is the RF switch logic table. The complete details of pin connections can be found on the [RAK811 Datasheet](https://docs.rakwireless.com/product-categories/wisduo/rak811-module/datasheet/).  \nAfter that, the **Real-Time Clock (RTC)** must be properly configured in the MCU to ensure accurate timing of the protocol stack during the runtime. Finally, the protocol stack code can be added after configuring the other pins."}
{"id": "a47bf22b2f6f8181338ccbf03f2de9d9", "product_family": "wisduo", "product_id": "rak811-module", "category": "Concept", "title": "Low Level Development Reference > Low Level Development Reference > How to Implement Your Own Firmware on RAK811 Module > Porting Lora Protocol Stack > Key Considerations for Implementing LoRa Protocol Stack on RAK811 Module", "content": "After that, the **Real-Time Clock (RTC)** must be properly configured in the MCU to ensure accurate timing of the protocol stack during the runtime. Finally, the protocol stack code can be added after configuring the other pins.", "keywords": ["LoRa protocol stack", "SPI connections", "DIO pins", "RF signal paths", "RF switch logic table", "Real-Time Clock (RTC)", "RAK811 Datasheet"], "source_file": "low-level-development.md", "token_count": 150, "parent_content": "When implementing the LoRa protocol stack, special attention must be given to the SPI connections since the LoRa transceivers are controlled by the MCU through an SPI interface. Hence, the following are the important pins: **SPI1_MISO, SPI1_MOSI, SPI_NSS, SPI_CLK**.  \nAdditionally, the DIO pins and RF signal paths are significant as well to have functional LoRa communication. Another important thing to consider is the RF switch logic table. The complete details of pin connections can be found on the [RAK811 Datasheet](https://docs.rakwireless.com/product-categories/wisduo/rak811-module/datasheet/).  \nAfter that, the **Real-Time Clock (RTC)** must be properly configured in the MCU to ensure accurate timing of the protocol stack during the runtime. Finally, the protocol stack code can be added after configuring the other pins."}
{"id": "8b2aafac2f3fd58e46a6275662d6e6a8", "product_family": "wisduo", "product_id": "rak811-module", "category": "How-To", "title": "Low Level Development Reference > Low Level Development Reference > How to Implement Your Own Firmware on RAK811 Module > Application > Firmware Development Options for RAK811 Module", "content": "Once the porting of the protocol stack is ready, you can focus on the development of their applications. There are two options you can choose with:  \na. Develop your own bootloader.  \nb. Use RAK bootloader and the upgrade the custom firmware by using [RAK Device Firmware Upgrade (DFU) Tool](https://downloads.rakwireless.com/#LoRa/Tools/RAK_Device_Firmware_Upgrade_tool/).", "keywords": ["firmware", "bootloader", "DFU", "development"], "source_file": "low-level-development.md", "token_count": 0, "parent_content": "Once the porting of the protocol stack is ready, you can focus on the development of their applications. There are two options you can choose with:  \na. Develop your own bootloader.  \nb. Use RAK bootloader and the upgrade the custom firmware by using [RAK Device Firmware Upgrade (DFU) Tool](https://downloads.rakwireless.com/#LoRa/Tools/RAK_Device_Firmware_Upgrade_tool/).  \nIf you want to fully develop your own, you can refer to the schematic diagram and the datasheet of the MCU to implement the code. But if you want to use the RAK bootloader, continue reading the next section."}
{"id": "be7325326b7905cf1183c5d9218e01ef", "product_family": "wisduo", "product_id": "rak811-module", "category": "How-To", "title": "Low Level Development Reference > Low Level Development Reference > How to Implement Your Own Firmware on RAK811 Module > Application > Firmware Development Options for RAK811 Module", "content": "If you want to fully develop your own, you can refer to the schematic diagram and the datasheet of the MCU to implement the code. But if you want to use the RAK bootloader, continue reading the next section.", "keywords": ["firmware", "bootloader", "DFU", "development"], "source_file": "low-level-development.md", "token_count": 0, "parent_content": "Once the porting of the protocol stack is ready, you can focus on the development of their applications. There are two options you can choose with:  \na. Develop your own bootloader.  \nb. Use RAK bootloader and the upgrade the custom firmware by using [RAK Device Firmware Upgrade (DFU) Tool](https://downloads.rakwireless.com/#LoRa/Tools/RAK_Device_Firmware_Upgrade_tool/).  \nIf you want to fully develop your own, you can refer to the schematic diagram and the datasheet of the MCU to implement the code. But if you want to use the RAK bootloader, continue reading the next section."}
{"id": "86946e66bc6bcff9d5c23a5e1577d392", "product_family": "wisduo", "product_id": "rak811-module", "category": "Concept", "title": "Low Level Development Reference > Low Level Development Reference > How to Implement Your Own Firmware on RAK811 Module > Bootloader > RAK811 Bootloader Memory Map and Functionality", "content": "After the power is connected, the system bootloader will set up the Interrupt Vector table, initialize variables, and jump to the address of the main() symbol.  \nFigure 1 below shows the usual memory map of an ARM Cortex M3 MCU, which is the architecture of the MCU of the RAK811.  \n> **Image:** Usual memory map for an ARM Cortex M3 MCU  \nThe flash section is between the 0x0800 0000 and 0x080X 0000. X depends on the different models of MCU.", "keywords": ["bootloader", "memory map", "ARM Cortex M3", "firmware upgrade", "Ymodem protocol", "UART1"], "source_file": "low-level-development.md", "token_count": 0, "parent_content": "After the power is connected, the system bootloader will set up the Interrupt Vector table, initialize variables, and jump to the address of the main() symbol.  \nFigure 1 below shows the usual memory map of an ARM Cortex M3 MCU, which is the architecture of the MCU of the RAK811.  \n> **Image:** Usual memory map for an ARM Cortex M3 MCU  \nThe flash section is between the 0x0800 0000 and 0x080X 0000. X depends on the different models of MCU.  \nThe RAK bootloader is stored in the internal flash section and has a size of 12K, located between 0x0800 0000 to 0x0800 2FFF. Its primary function is to write a new version of firmware received from the serial port into the flash memory section. The bootloader uses the Ymodem protocol and supervises all possible exceptions internally during the upgrade process. When the upgrade process is interrupted, the bootloader will detect abnormal events, and the FW upgrade will fail. You can perform the FW upgrade again using the bootloader after recycling the power.  \nThe RAK811 bootloader uses flash memory segments between 0x0808 0F00 and 0x0808 0FFF to store its parameters.\nIn the bootloader parameter storage area, 256bytes are reserved for bootloading process, but only two words are used to store the jump flag and upgrade the status flag.  \nFinally, the serial port to communicate with the RAK bootloader in these modules is the UART1 (pin PA9, pin PA10). The parameters of the UART communication are the 115200 / 8-N-1, which need to be configured properly in the RAK firmware upgrade tool."}
{"id": "4ae22a3eedcecde5a4251a73453aeaf9", "product_family": "wisduo", "product_id": "rak811-module", "category": "Concept", "title": "Low Level Development Reference > Low Level Development Reference > How to Implement Your Own Firmware on RAK811 Module > Bootloader > RAK811 Bootloader Memory Map and Functionality", "content": "The RAK bootloader is stored in the internal flash section and has a size of 12K, located between 0x0800 0000 to 0x0800 2FFF. Its primary function is to write a new version of firmware received from the serial port into the flash memory section. The bootloader uses the Ymodem protocol and supervises all possible exceptions internally during the upgrade process. When the upgrade process is interrupted, the bootloader will detect abnormal events, and the FW upgrade will fail. You can perform the", "keywords": ["bootloader", "memory map", "ARM Cortex M3", "firmware upgrade", "Ymodem protocol", "UART1"], "source_file": "low-level-development.md", "token_count": 0, "parent_content": "After the power is connected, the system bootloader will set up the Interrupt Vector table, initialize variables, and jump to the address of the main() symbol.  \nFigure 1 below shows the usual memory map of an ARM Cortex M3 MCU, which is the architecture of the MCU of the RAK811.  \n> **Image:** Usual memory map for an ARM Cortex M3 MCU  \nThe flash section is between the 0x0800 0000 and 0x080X 0000. X depends on the different models of MCU.  \nThe RAK bootloader is stored in the internal flash section and has a size of 12K, located between 0x0800 0000 to 0x0800 2FFF. Its primary function is to write a new version of firmware received from the serial port into the flash memory section. The bootloader uses the Ymodem protocol and supervises all possible exceptions internally during the upgrade process. When the upgrade process is interrupted, the bootloader will detect abnormal events, and the FW upgrade will fail. You can perform the FW upgrade again using the bootloader after recycling the power.  \nThe RAK811 bootloader uses flash memory segments between 0x0808 0F00 and 0x0808 0FFF to store its parameters.\nIn the bootloader parameter storage area, 256bytes are reserved for bootloading process, but only two words are used to store the jump flag and upgrade the status flag.  \nFinally, the serial port to communicate with the RAK bootloader in these modules is the UART1 (pin PA9, pin PA10). The parameters of the UART communication are the 115200 / 8-N-1, which need to be configured properly in the RAK firmware upgrade tool."}
{"id": "eae491f52d5df061996f18b0e58b8de5", "product_family": "wisduo", "product_id": "rak811-module", "category": "Concept", "title": "Low Level Development Reference > Low Level Development Reference > How to Implement Your Own Firmware on RAK811 Module > Bootloader > RAK811 Bootloader Memory Map and Functionality", "content": "the bootloader will detect abnormal events, and the FW upgrade will fail. You can perform the FW upgrade again using the bootloader after recycling the power.", "keywords": ["bootloader", "memory map", "ARM Cortex M3", "firmware upgrade", "Ymodem protocol", "UART1"], "source_file": "low-level-development.md", "token_count": 0, "parent_content": "After the power is connected, the system bootloader will set up the Interrupt Vector table, initialize variables, and jump to the address of the main() symbol.  \nFigure 1 below shows the usual memory map of an ARM Cortex M3 MCU, which is the architecture of the MCU of the RAK811.  \n> **Image:** Usual memory map for an ARM Cortex M3 MCU  \nThe flash section is between the 0x0800 0000 and 0x080X 0000. X depends on the different models of MCU.  \nThe RAK bootloader is stored in the internal flash section and has a size of 12K, located between 0x0800 0000 to 0x0800 2FFF. Its primary function is to write a new version of firmware received from the serial port into the flash memory section. The bootloader uses the Ymodem protocol and supervises all possible exceptions internally during the upgrade process. When the upgrade process is interrupted, the bootloader will detect abnormal events, and the FW upgrade will fail. You can perform the FW upgrade again using the bootloader after recycling the power.  \nThe RAK811 bootloader uses flash memory segments between 0x0808 0F00 and 0x0808 0FFF to store its parameters.\nIn the bootloader parameter storage area, 256bytes are reserved for bootloading process, but only two words are used to store the jump flag and upgrade the status flag.  \nFinally, the serial port to communicate with the RAK bootloader in these modules is the UART1 (pin PA9, pin PA10). The parameters of the UART communication are the 115200 / 8-N-1, which need to be configured properly in the RAK firmware upgrade tool."}
{"id": "5a179cce96af6abd475f3b2ae612852f", "product_family": "wisduo", "product_id": "rak811-module", "category": "Concept", "title": "Low Level Development Reference > Low Level Development Reference > How to Implement Your Own Firmware on RAK811 Module > Bootloader > RAK811 Bootloader Memory Map and Functionality", "content": "The RAK811 bootloader uses flash memory segments between 0x0808 0F00 and 0x0808 0FFF to store its parameters.\nIn the bootloader parameter storage area, 256bytes are reserved for bootloading process, but only two words are used to store the jump flag and upgrade the status flag.", "keywords": ["bootloader", "memory map", "ARM Cortex M3", "firmware upgrade", "Ymodem protocol", "UART1"], "source_file": "low-level-development.md", "token_count": 0, "parent_content": "After the power is connected, the system bootloader will set up the Interrupt Vector table, initialize variables, and jump to the address of the main() symbol.  \nFigure 1 below shows the usual memory map of an ARM Cortex M3 MCU, which is the architecture of the MCU of the RAK811.  \n> **Image:** Usual memory map for an ARM Cortex M3 MCU  \nThe flash section is between the 0x0800 0000 and 0x080X 0000. X depends on the different models of MCU.  \nThe RAK bootloader is stored in the internal flash section and has a size of 12K, located between 0x0800 0000 to 0x0800 2FFF. Its primary function is to write a new version of firmware received from the serial port into the flash memory section. The bootloader uses the Ymodem protocol and supervises all possible exceptions internally during the upgrade process. When the upgrade process is interrupted, the bootloader will detect abnormal events, and the FW upgrade will fail. You can perform the FW upgrade again using the bootloader after recycling the power.  \nThe RAK811 bootloader uses flash memory segments between 0x0808 0F00 and 0x0808 0FFF to store its parameters.\nIn the bootloader parameter storage area, 256bytes are reserved for bootloading process, but only two words are used to store the jump flag and upgrade the status flag.  \nFinally, the serial port to communicate with the RAK bootloader in these modules is the UART1 (pin PA9, pin PA10). The parameters of the UART communication are the 115200 / 8-N-1, which need to be configured properly in the RAK firmware upgrade tool."}
{"id": "e5ca1e021767f3091fc706f51472ac45", "product_family": "wisduo", "product_id": "rak811-module", "category": "Concept", "title": "Low Level Development Reference > Low Level Development Reference > How to Implement Your Own Firmware on RAK811 Module > Bootloader > RAK811 Bootloader Memory Map and Functionality", "content": "Finally, the serial port to communicate with the RAK bootloader in these modules is the UART1 (pin PA9, pin PA10). The parameters of the UART communication are the 115200 / 8-N-1, which need to be configured properly in the RAK firmware upgrade tool.", "keywords": ["bootloader", "memory map", "ARM Cortex M3", "firmware upgrade", "Ymodem protocol", "UART1"], "source_file": "low-level-development.md", "token_count": 0, "parent_content": "After the power is connected, the system bootloader will set up the Interrupt Vector table, initialize variables, and jump to the address of the main() symbol.  \nFigure 1 below shows the usual memory map of an ARM Cortex M3 MCU, which is the architecture of the MCU of the RAK811.  \n> **Image:** Usual memory map for an ARM Cortex M3 MCU  \nThe flash section is between the 0x0800 0000 and 0x080X 0000. X depends on the different models of MCU.  \nThe RAK bootloader is stored in the internal flash section and has a size of 12K, located between 0x0800 0000 to 0x0800 2FFF. Its primary function is to write a new version of firmware received from the serial port into the flash memory section. The bootloader uses the Ymodem protocol and supervises all possible exceptions internally during the upgrade process. When the upgrade process is interrupted, the bootloader will detect abnormal events, and the FW upgrade will fail. You can perform the FW upgrade again using the bootloader after recycling the power.  \nThe RAK811 bootloader uses flash memory segments between 0x0808 0F00 and 0x0808 0FFF to store its parameters.\nIn the bootloader parameter storage area, 256bytes are reserved for bootloading process, but only two words are used to store the jump flag and upgrade the status flag.  \nFinally, the serial port to communicate with the RAK bootloader in these modules is the UART1 (pin PA9, pin PA10). The parameters of the UART communication are the 115200 / 8-N-1, which need to be configured properly in the RAK firmware upgrade tool."}
{"id": "b2eb75e648ff2a608bdd34f1aebe797e", "product_family": "wisduo", "product_id": "rak811-module", "category": "How-To", "title": "Low Level Development Reference > Low Level Development Reference > How to Implement Your Own Firmware on RAK811 Module > Application Requirements > Modify Application Code and Linker Script for RAK811 Bootloader Compatibility [CODE]", "content": "Since the RAK bootloader is stored between the 0x0800 0000 and 0x0800 2FFF segments of the flash memory, your application should be shifted accordingly. In the application code, you need to modify the interrupt vector table address as the following:  \nSCB->VTOR = FLASH_BASE | 0x3000;  \nIn the linker, the script must be updated accordingly. For example, in case you use GCC, modify your linker script like the following:  \nFLASH (rx): ORIGIN = 0x8003000, LENGTH = 116K", "keywords": ["bootloader", "application code", "linker script", "interrupt vector table", "AT command", "firmware upgrade"], "source_file": "low-level-development.md", "token_count": 150, "parent_content": "Since the RAK bootloader is stored between the 0x0800 0000 and 0x0800 2FFF segments of the flash memory, your application should be shifted accordingly. In the application code, you need to modify the interrupt vector table address as the following:  \nSCB->VTOR = FLASH_BASE | 0x3000;  \nIn the linker, the script must be updated accordingly. For example, in case you use GCC, modify your linker script like the following:  \nFLASH (rx): ORIGIN = 0x8003000, LENGTH = 116K  \nYour application firmware should implement as a minimum one AT command: **`at+boot\\r\\n`**. The function of this command is to jump from the application state into the bootloader state in preparation for the further application firmware upgrade. The logic of this command are the following:  \n1. For RAK811, write the value **0x00000000** into the address **0x0808 0F00**.  \n2. Reset MCU. You can call the **NVIC_SystemReset() interface** in the ST library to reset the MCU.  \n> **TIP:** NOTE  \nThe bootloader turned off the global interrupt when jumping from the application state. Therefore, when the application code is initialized, the global interrupt should be turned on again."}
{"id": "f18a35cc45ebc5203f7c87bdb0b18149", "product_family": "wisduo", "product_id": "rak811-module", "category": "How-To", "title": "Low Level Development Reference > Low Level Development Reference > How to Implement Your Own Firmware on RAK811 Module > Application Requirements > Modify Application Code and Linker Script for RAK811 Bootloader Compatibility [CODE]", "content": "FLASH (rx): ORIGIN = 0x8003000, LENGTH = 116K  \nYour application firmware should implement as a minimum one AT command: **`at+boot\\r\\n`**. The function of this command is to jump from the application state into the bootloader state in preparation for the further application firmware upgrade. The logic of this command are the following:  \n1. For RAK811, write the value **0x00000000** into the address **0x0808 0F00**.", "keywords": ["bootloader", "application code", "linker script", "interrupt vector table", "AT command", "firmware upgrade"], "source_file": "low-level-development.md", "token_count": 150, "parent_content": "Since the RAK bootloader is stored between the 0x0800 0000 and 0x0800 2FFF segments of the flash memory, your application should be shifted accordingly. In the application code, you need to modify the interrupt vector table address as the following:  \nSCB->VTOR = FLASH_BASE | 0x3000;  \nIn the linker, the script must be updated accordingly. For example, in case you use GCC, modify your linker script like the following:  \nFLASH (rx): ORIGIN = 0x8003000, LENGTH = 116K  \nYour application firmware should implement as a minimum one AT command: **`at+boot\\r\\n`**. The function of this command is to jump from the application state into the bootloader state in preparation for the further application firmware upgrade. The logic of this command are the following:  \n1. For RAK811, write the value **0x00000000** into the address **0x0808 0F00**.  \n2. Reset MCU. You can call the **NVIC_SystemReset() interface** in the ST library to reset the MCU.  \n> **TIP:** NOTE  \nThe bootloader turned off the global interrupt when jumping from the application state. Therefore, when the application code is initialized, the global interrupt should be turned on again."}
{"id": "df9dcb5f8bca1cfa4564bcacd4535709", "product_family": "wisduo", "product_id": "rak811-module", "category": "How-To", "title": "Low Level Development Reference > Low Level Development Reference > How to Implement Your Own Firmware on RAK811 Module > Application Requirements > Modify Application Code and Linker Script for RAK811 Bootloader Compatibility [CODE]", "content": "1. For RAK811, write the value **0x00000000** into the address **0x0808 0F00**.  \n2. Reset MCU. You can call the **NVIC_SystemReset() interface** in the ST library to reset the MCU.  \n> **TIP:** NOTE  \nThe bootloader turned off the global interrupt when jumping from the application state. Therefore, when the application code is initialized, the global interrupt should be turned on again.", "keywords": ["bootloader", "application code", "linker script", "interrupt vector table", "AT command", "firmware upgrade"], "source_file": "low-level-development.md", "token_count": 150, "parent_content": "Since the RAK bootloader is stored between the 0x0800 0000 and 0x0800 2FFF segments of the flash memory, your application should be shifted accordingly. In the application code, you need to modify the interrupt vector table address as the following:  \nSCB->VTOR = FLASH_BASE | 0x3000;  \nIn the linker, the script must be updated accordingly. For example, in case you use GCC, modify your linker script like the following:  \nFLASH (rx): ORIGIN = 0x8003000, LENGTH = 116K  \nYour application firmware should implement as a minimum one AT command: **`at+boot\\r\\n`**. The function of this command is to jump from the application state into the bootloader state in preparation for the further application firmware upgrade. The logic of this command are the following:  \n1. For RAK811, write the value **0x00000000** into the address **0x0808 0F00**.  \n2. Reset MCU. You can call the **NVIC_SystemReset() interface** in the ST library to reset the MCU.  \n> **TIP:** NOTE  \nThe bootloader turned off the global interrupt when jumping from the application state. Therefore, when the application code is initialized, the global interrupt should be turned on again."}
