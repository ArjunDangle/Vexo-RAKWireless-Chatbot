{"id": "31a5d7dffd4c30eb99ccf0cefaf8430c", "product_family": "wisduo", "product_id": "rak4270-module", "category": "Concept", "title": "RAK4270 Low Level Development Reference > RAK4270 Low Level Development Reference > Overview > RAK4270 Module Firmware Configuration and Customization", "content": "RAK4270 module comes with a standard version of firmware that allows you to configure its functionality via AT commands. This simplicity helps you develop LoRa(P2P) and LoRaWAN projects quickly.", "keywords": ["firmware", "AT commands", "RUI", "customization", "STM32"], "source_file": "low-level-development.md", "token_count": 150, "parent_content": "RAK4270 module comes with a standard version of firmware that allows you to configure its functionality via AT commands. This simplicity helps you develop LoRa(P2P) and LoRaWAN projects quickly.  \nFurther customization of the firmware can be done through the [RUI (RAKwireless Unified Interface) Online compiler](https://docs.rakwireless.com/product-categories/software-apis-and-libraries/rui/). RAK's LoRa modules support not only out-of-the-box integration via AT commands but also allow you to customize RAK4270 firmware and access other functionalities of the internal MCU using RUI API. More so, you can adapt and extend the logic in the firmware to meet your requirements.  \nAdditionally, RAK offers a third alternative for advanced customers who need to have deeper integration of their solutions with these modules. In this alternative, you could develop your own version of STM32 firmware that runs inside of the RAK4270 module."}
{"id": "98d05fa30b6e1363275f815f5a94dc1f", "product_family": "wisduo", "product_id": "rak4270-module", "category": "Concept", "title": "RAK4270 Low Level Development Reference > RAK4270 Low Level Development Reference > Overview > RAK4270 Module Firmware Configuration and Customization", "content": "Further customization of the firmware can be done through the [RUI (RAKwireless Unified Interface) Online compiler](https://docs.rakwireless.com/product-categories/software-apis-and-libraries/rui/). RAK's LoRa modules support not only out-of-the-box integration via AT commands but also allow you to customize RAK4270 firmware and access other functionalities of the internal MCU using RUI API. More so, you can adapt and extend the logic in the firmware to meet your requirements.", "keywords": ["firmware", "AT commands", "RUI", "customization", "STM32"], "source_file": "low-level-development.md", "token_count": 150, "parent_content": "RAK4270 module comes with a standard version of firmware that allows you to configure its functionality via AT commands. This simplicity helps you develop LoRa(P2P) and LoRaWAN projects quickly.  \nFurther customization of the firmware can be done through the [RUI (RAKwireless Unified Interface) Online compiler](https://docs.rakwireless.com/product-categories/software-apis-and-libraries/rui/). RAK's LoRa modules support not only out-of-the-box integration via AT commands but also allow you to customize RAK4270 firmware and access other functionalities of the internal MCU using RUI API. More so, you can adapt and extend the logic in the firmware to meet your requirements.  \nAdditionally, RAK offers a third alternative for advanced customers who need to have deeper integration of their solutions with these modules. In this alternative, you could develop your own version of STM32 firmware that runs inside of the RAK4270 module."}
{"id": "797e984754a9e3c38b0bc7a1cf7bbea7", "product_family": "wisduo", "product_id": "rak4270-module", "category": "Concept", "title": "RAK4270 Low Level Development Reference > RAK4270 Low Level Development Reference > Overview > RAK4270 Module Firmware Configuration and Customization", "content": "Additionally, RAK offers a third alternative for advanced customers who need to have deeper integration of their solutions with these modules. In this alternative, you could develop your own version of STM32 firmware that runs inside of the RAK4270 module.", "keywords": ["firmware", "AT commands", "RUI", "customization", "STM32"], "source_file": "low-level-development.md", "token_count": 150, "parent_content": "RAK4270 module comes with a standard version of firmware that allows you to configure its functionality via AT commands. This simplicity helps you develop LoRa(P2P) and LoRaWAN projects quickly.  \nFurther customization of the firmware can be done through the [RUI (RAKwireless Unified Interface) Online compiler](https://docs.rakwireless.com/product-categories/software-apis-and-libraries/rui/). RAK's LoRa modules support not only out-of-the-box integration via AT commands but also allow you to customize RAK4270 firmware and access other functionalities of the internal MCU using RUI API. More so, you can adapt and extend the logic in the firmware to meet your requirements.  \nAdditionally, RAK offers a third alternative for advanced customers who need to have deeper integration of their solutions with these modules. In this alternative, you could develop your own version of STM32 firmware that runs inside of the RAK4270 module."}
{"id": "673151d655ff97aa72142805d2b3d6a4", "product_family": "wisduo", "product_id": "rak4270-module", "category": "Reference", "title": "RAK4270 Low Level Development Reference > RAK4270 Low Level Development Reference > How to Implement Your Own Firmware > Schematic > RAK4270 Hardware Schematic and Datasheet Reference", "content": "One of the essential aspects that allows you to develop your own version of firmware is the [RAK4270 Hardware Schematic](https://downloads.rakwireless.com/#LoRa/RAK4270/Hardware-Specification/). This allows you to understand the module\u2019s pinout and the connections between the internal STM32 MCU and the LoRa transceiver. Other important details can be found on [RAK4270 Datasheet](https://docs.rakwireless.com/product-categories/wisduo/rak4270-module/datasheet/).  \n> **TIP:** NOTE", "keywords": ["RAK4270", "Hardware Schematic", "Datasheet", "Firmware Development", "Pinout", "STM32 MCU", "LoRa Transceiver", "RAK4270(H)", "RAK4270(L)"], "source_file": "low-level-development.md", "token_count": 100, "parent_content": "One of the essential aspects that allows you to develop your own version of firmware is the [RAK4270 Hardware Schematic](https://downloads.rakwireless.com/#LoRa/RAK4270/Hardware-Specification/). This allows you to understand the module\u2019s pinout and the connections between the internal STM32 MCU and the LoRa transceiver. Other important details can be found on [RAK4270 Datasheet](https://docs.rakwireless.com/product-categories/wisduo/rak4270-module/datasheet/).  \n> **TIP:** NOTE  \nThere are two versions of the RAK4270 module: the high-frequency band RAK4270(H) used on EU868, US915, AU915, KR920, AS923, and IN865, and the low-frequency band RAK4270(L) used on EU433 and CN470. These two modules share the same schematic diagram which will be helpful to you when you develop your own firmware."}
{"id": "e9b339727fd8a7ef45007a0645b2753f", "product_family": "wisduo", "product_id": "rak4270-module", "category": "Reference", "title": "RAK4270 Low Level Development Reference > RAK4270 Low Level Development Reference > How to Implement Your Own Firmware > Schematic > RAK4270 Hardware Schematic and Datasheet Reference", "content": "> **TIP:** NOTE  \nThere are two versions of the RAK4270 module: the high-frequency band RAK4270(H) used on EU868, US915, AU915, KR920, AS923, and IN865, and the low-frequency band RAK4270(L) used on EU433 and CN470. These two modules share the same schematic diagram which will be helpful to you when you develop your own firmware.", "keywords": ["RAK4270", "Hardware Schematic", "Datasheet", "Firmware Development", "Pinout", "STM32 MCU", "LoRa Transceiver", "RAK4270(H)", "RAK4270(L)"], "source_file": "low-level-development.md", "token_count": 100, "parent_content": "One of the essential aspects that allows you to develop your own version of firmware is the [RAK4270 Hardware Schematic](https://downloads.rakwireless.com/#LoRa/RAK4270/Hardware-Specification/). This allows you to understand the module\u2019s pinout and the connections between the internal STM32 MCU and the LoRa transceiver. Other important details can be found on [RAK4270 Datasheet](https://docs.rakwireless.com/product-categories/wisduo/rak4270-module/datasheet/).  \n> **TIP:** NOTE  \nThere are two versions of the RAK4270 module: the high-frequency band RAK4270(H) used on EU868, US915, AU915, KR920, AS923, and IN865, and the low-frequency band RAK4270(L) used on EU433 and CN470. These two modules share the same schematic diagram which will be helpful to you when you develop your own firmware."}
{"id": "1a3f075fbf5fd4d6cb05999c03d96db1", "product_family": "wisduo", "product_id": "rak4270-module", "category": "Concept", "title": "RAK4270 Low Level Development Reference > RAK4270 Low Level Development Reference > How to Implement Your Own Firmware > Porting Lora Protocol Stack > Key Considerations for Implementing LoRa Protocol Stack on RAK4270 Module", "content": "When implementing the LoRa protocol stack, special attention must be given to the SPI connections since the LoRa transceivers are controlled by the MCU through an SPI interface. Hence, the following are the important pins: **SPI1_MISO, SPI1_MOSI, SPI_NSS, SPI_CLK**.", "keywords": ["LoRa", "SPI", "MCU", "DIO pins", "RF signal paths", "RTC", "protocol stack"], "source_file": "low-level-development.md", "token_count": 150, "parent_content": "When implementing the LoRa protocol stack, special attention must be given to the SPI connections since the LoRa transceivers are controlled by the MCU through an SPI interface. Hence, the following are the important pins: **SPI1_MISO, SPI1_MOSI, SPI_NSS, SPI_CLK**.  \nAdditionally, the DIO pins and RF signal paths are significant as well to have functional LoRa communication. Another important thing to consider is the RF switch logic table. The complete details of pin connections can be found on the [RAK4270 Datasheet](https://docs.rakwireless.com/product-categories/wisduo/rak4270-module/datasheet/).  \nAfter that, the **Real-Time Clock (RTC)** must be properly configured in the MCU to ensure accurate timing of the protocol stack during the runtime. Finally, the protocol stack code can be added after configuring the other pins."}
{"id": "e26a0305c5f71a5fef513c3a648b20e0", "product_family": "wisduo", "product_id": "rak4270-module", "category": "Concept", "title": "RAK4270 Low Level Development Reference > RAK4270 Low Level Development Reference > How to Implement Your Own Firmware > Porting Lora Protocol Stack > Key Considerations for Implementing LoRa Protocol Stack on RAK4270 Module", "content": "Additionally, the DIO pins and RF signal paths are significant as well to have functional LoRa communication. Another important thing to consider is the RF switch logic table. The complete details of pin connections can be found on the [RAK4270 Datasheet](https://docs.rakwireless.com/product-categories/wisduo/rak4270-module/datasheet/).", "keywords": ["LoRa", "SPI", "MCU", "DIO pins", "RF signal paths", "RTC", "protocol stack"], "source_file": "low-level-development.md", "token_count": 150, "parent_content": "When implementing the LoRa protocol stack, special attention must be given to the SPI connections since the LoRa transceivers are controlled by the MCU through an SPI interface. Hence, the following are the important pins: **SPI1_MISO, SPI1_MOSI, SPI_NSS, SPI_CLK**.  \nAdditionally, the DIO pins and RF signal paths are significant as well to have functional LoRa communication. Another important thing to consider is the RF switch logic table. The complete details of pin connections can be found on the [RAK4270 Datasheet](https://docs.rakwireless.com/product-categories/wisduo/rak4270-module/datasheet/).  \nAfter that, the **Real-Time Clock (RTC)** must be properly configured in the MCU to ensure accurate timing of the protocol stack during the runtime. Finally, the protocol stack code can be added after configuring the other pins."}
{"id": "66c423f5c7f567460cb806eb05b5e40f", "product_family": "wisduo", "product_id": "rak4270-module", "category": "Concept", "title": "RAK4270 Low Level Development Reference > RAK4270 Low Level Development Reference > How to Implement Your Own Firmware > Porting Lora Protocol Stack > Key Considerations for Implementing LoRa Protocol Stack on RAK4270 Module", "content": "After that, the **Real-Time Clock (RTC)** must be properly configured in the MCU to ensure accurate timing of the protocol stack during the runtime. Finally, the protocol stack code can be added after configuring the other pins.", "keywords": ["LoRa", "SPI", "MCU", "DIO pins", "RF signal paths", "RTC", "protocol stack"], "source_file": "low-level-development.md", "token_count": 150, "parent_content": "When implementing the LoRa protocol stack, special attention must be given to the SPI connections since the LoRa transceivers are controlled by the MCU through an SPI interface. Hence, the following are the important pins: **SPI1_MISO, SPI1_MOSI, SPI_NSS, SPI_CLK**.  \nAdditionally, the DIO pins and RF signal paths are significant as well to have functional LoRa communication. Another important thing to consider is the RF switch logic table. The complete details of pin connections can be found on the [RAK4270 Datasheet](https://docs.rakwireless.com/product-categories/wisduo/rak4270-module/datasheet/).  \nAfter that, the **Real-Time Clock (RTC)** must be properly configured in the MCU to ensure accurate timing of the protocol stack during the runtime. Finally, the protocol stack code can be added after configuring the other pins."}
{"id": "859121b2bdcb48f775a0acaec67e2e81", "product_family": "wisduo", "product_id": "rak4270-module", "category": "How-To", "title": "RAK4270 Low Level Development Reference > RAK4270 Low Level Development Reference > How to Implement Your Own Firmware > Application > Firmware Development Options for RAK4270 Module", "content": "Once the porting protocol stack is ready, you can focus on the development of their applications. There are two options:  \n- Do not use the original bootloader that comes in RAK modules from the factory. In this case, the customer must provide his own version of the bootloader.\n- Use RAK's bootloader and upgrade the custom firmware by using RAK\u2019s Device Firmware Upgrade Tool. You can download it from here:", "keywords": ["firmware development", "bootloader", "RAK4270", "DFU tool"], "source_file": "low-level-development.md", "token_count": 150, "parent_content": "Once the porting protocol stack is ready, you can focus on the development of their applications. There are two options:  \n- Do not use the original bootloader that comes in RAK modules from the factory. In this case, the customer must provide his own version of the bootloader.\n- Use RAK's bootloader and upgrade the custom firmware by using RAK\u2019s Device Firmware Upgrade Tool. You can download it from here:\n- [RAK Device Firmware Upgrade (DFU) Tool](https://downloads.rakwireless.com/LoRa/Tools/RAK_Device_Firmware_Upgrade_tool/RAK_Device_Firmware_Upgrade_Tool_v1.4.zip)\n- [Device Firmware Upgrade Tool for MacOS](https://downloads.rakwireless.com/LoRa/Tools/RAK_Device_Firmware_Upgrade_tool/RAK_Device_Firmware_Upgrade_Tool_v1.4_MacOS.zip)\n- [Device Firmware Upgrade Tool for Ubuntu](https://downloads.rakwireless.com/LoRa/Tools/RAK_Device_Firmware_Upgrade_tool/RAK_Device_Firmware_Upgrade_Tool_v1.4_Ubuntu.zip)  \nIf you want to fully develop your own, you can refer to the schematic diagram and the datasheet of the MCU to implement the code. If you want to use RAK\u2019s bootloader, continue reading the next section."}
{"id": "1242d8e268a9ca899acfc38cd8bd148c", "product_family": "wisduo", "product_id": "rak4270-module", "category": "How-To", "title": "RAK4270 Low Level Development Reference > RAK4270 Low Level Development Reference > How to Implement Your Own Firmware > Application > Firmware Development Options for RAK4270 Module", "content": "- [RAK Device Firmware Upgrade (DFU) Tool](https://downloads.rakwireless.com/LoRa/Tools/RAK_Device_Firmware_Upgrade_tool/RAK_Device_Firmware_Upgrade_Tool_v1.4.zip)\n- [Device Firmware Upgrade Tool for MacOS](https://downloads.rakwireless.com/LoRa/Tools/RAK_Device_Firmware_Upgrade_tool/RAK_Device_Firmware_Upgrade_Tool_v1.4_MacOS.zip)", "keywords": ["firmware development", "bootloader", "RAK4270", "DFU tool"], "source_file": "low-level-development.md", "token_count": 150, "parent_content": "Once the porting protocol stack is ready, you can focus on the development of their applications. There are two options:  \n- Do not use the original bootloader that comes in RAK modules from the factory. In this case, the customer must provide his own version of the bootloader.\n- Use RAK's bootloader and upgrade the custom firmware by using RAK\u2019s Device Firmware Upgrade Tool. You can download it from here:\n- [RAK Device Firmware Upgrade (DFU) Tool](https://downloads.rakwireless.com/LoRa/Tools/RAK_Device_Firmware_Upgrade_tool/RAK_Device_Firmware_Upgrade_Tool_v1.4.zip)\n- [Device Firmware Upgrade Tool for MacOS](https://downloads.rakwireless.com/LoRa/Tools/RAK_Device_Firmware_Upgrade_tool/RAK_Device_Firmware_Upgrade_Tool_v1.4_MacOS.zip)\n- [Device Firmware Upgrade Tool for Ubuntu](https://downloads.rakwireless.com/LoRa/Tools/RAK_Device_Firmware_Upgrade_tool/RAK_Device_Firmware_Upgrade_Tool_v1.4_Ubuntu.zip)  \nIf you want to fully develop your own, you can refer to the schematic diagram and the datasheet of the MCU to implement the code. If you want to use RAK\u2019s bootloader, continue reading the next section."}
{"id": "7e2b620de8f491366c57e8e76c34bb40", "product_family": "wisduo", "product_id": "rak4270-module", "category": "How-To", "title": "RAK4270 Low Level Development Reference > RAK4270 Low Level Development Reference > How to Implement Your Own Firmware > Application > Firmware Development Options for RAK4270 Module", "content": "- [Device Firmware Upgrade Tool for Ubuntu](https://downloads.rakwireless.com/LoRa/Tools/RAK_Device_Firmware_Upgrade_tool/RAK_Device_Firmware_Upgrade_Tool_v1.4_Ubuntu.zip)  \nIf you want to fully develop your own, you can refer to the schematic diagram and the datasheet of the MCU to implement the code. If you want to use RAK\u2019s bootloader, continue reading the next section.", "keywords": ["firmware development", "bootloader", "RAK4270", "DFU tool"], "source_file": "low-level-development.md", "token_count": 150, "parent_content": "Once the porting protocol stack is ready, you can focus on the development of their applications. There are two options:  \n- Do not use the original bootloader that comes in RAK modules from the factory. In this case, the customer must provide his own version of the bootloader.\n- Use RAK's bootloader and upgrade the custom firmware by using RAK\u2019s Device Firmware Upgrade Tool. You can download it from here:\n- [RAK Device Firmware Upgrade (DFU) Tool](https://downloads.rakwireless.com/LoRa/Tools/RAK_Device_Firmware_Upgrade_tool/RAK_Device_Firmware_Upgrade_Tool_v1.4.zip)\n- [Device Firmware Upgrade Tool for MacOS](https://downloads.rakwireless.com/LoRa/Tools/RAK_Device_Firmware_Upgrade_tool/RAK_Device_Firmware_Upgrade_Tool_v1.4_MacOS.zip)\n- [Device Firmware Upgrade Tool for Ubuntu](https://downloads.rakwireless.com/LoRa/Tools/RAK_Device_Firmware_Upgrade_tool/RAK_Device_Firmware_Upgrade_Tool_v1.4_Ubuntu.zip)  \nIf you want to fully develop your own, you can refer to the schematic diagram and the datasheet of the MCU to implement the code. If you want to use RAK\u2019s bootloader, continue reading the next section."}
{"id": "55808ec2ee38a0d0ecacb8aeb49fb88a", "product_family": "wisduo", "product_id": "rak4270-module", "category": "Concept", "title": "RAK4270 Low Level Development Reference > RAK4270 Low Level Development Reference > How to Implement Your Own Firmware > Bootloader > Bootloader Introduction > RAK4270 Bootloader Memory Map and Functionality", "content": "In any MCU, after the power is connected, the system bootloader is in charge to bootstrap all the necessary to set up the Interrupt Vector table, initialize variables, and jump to the address of the main() symbol.  \nIn Figure 1, it shows a usual memory map for an ARM Cortex M0+ MCU, which is the architecture of the MCU of the RAK4270.  \n> **Image:** Memory map for an ARM Cortex M0+ MCU", "keywords": ["bootloader", "memory map", "ARM Cortex M0+", "firmware upgrade", "Ymodem protocol", "UART1"], "source_file": "low-level-development.md", "token_count": 0, "parent_content": "In any MCU, after the power is connected, the system bootloader is in charge to bootstrap all the necessary to set up the Interrupt Vector table, initialize variables, and jump to the address of the main() symbol.  \nIn Figure 1, it shows a usual memory map for an ARM Cortex M0+ MCU, which is the architecture of the MCU of the RAK4270.  \n> **Image:** Memory map for an ARM Cortex M0+ MCU  \nThe RAK\u2019s bootloader is stored in the internal flash section and has a size of 12K, located between 0x0800 0000 to 0x0800 2FFF. Its primary function is to write a new version of firmware received from the serial port into the flash memory section. The bootloader uses the Ymodem protocol and supervises all possible exceptions internally during the upgrade process. When the upgrade process is interrupted, the bootloader will detect abnormal events, and the FW upgrade will fail. You can perform the FW upgrade again using the bootloader after recycling the power.  \nRAK4270\u2019s bootloader uses the segment between 0x0808 1700 to 0x0808 17FF to store its parameters.  \nIn the bootloader parameter storage area, 256bytes are planned, but only two words are used to store the jump flag and upgrade status flag.  \nFinally, the serial port to communicate with the RAK\u2019s bootloader in these modules is the UART1 (pin PA9, pin PA10). The parameters of the UART1 communication are 115200 / 8-N-1, which need to be properly configured in the RAK firmware upgrade tool."}
{"id": "0f641fb10be70687f2a01bced07b0613", "product_family": "wisduo", "product_id": "rak4270-module", "category": "Concept", "title": "RAK4270 Low Level Development Reference > RAK4270 Low Level Development Reference > How to Implement Your Own Firmware > Bootloader > Bootloader Introduction > RAK4270 Bootloader Memory Map and Functionality", "content": "The RAK\u2019s bootloader is stored in the internal flash section and has a size of 12K, located between 0x0800 0000 to 0x0800 2FFF. Its primary function is to write a new version of firmware received from the serial port into the flash memory section. The bootloader uses the Ymodem protocol and supervises all possible exceptions internally during the upgrade process. When the upgrade process is interrupted, the bootloader will detect abnormal events, and the FW upgrade will fail. You can perform", "keywords": ["bootloader", "memory map", "ARM Cortex M0+", "firmware upgrade", "Ymodem protocol", "UART1"], "source_file": "low-level-development.md", "token_count": 0, "parent_content": "In any MCU, after the power is connected, the system bootloader is in charge to bootstrap all the necessary to set up the Interrupt Vector table, initialize variables, and jump to the address of the main() symbol.  \nIn Figure 1, it shows a usual memory map for an ARM Cortex M0+ MCU, which is the architecture of the MCU of the RAK4270.  \n> **Image:** Memory map for an ARM Cortex M0+ MCU  \nThe RAK\u2019s bootloader is stored in the internal flash section and has a size of 12K, located between 0x0800 0000 to 0x0800 2FFF. Its primary function is to write a new version of firmware received from the serial port into the flash memory section. The bootloader uses the Ymodem protocol and supervises all possible exceptions internally during the upgrade process. When the upgrade process is interrupted, the bootloader will detect abnormal events, and the FW upgrade will fail. You can perform the FW upgrade again using the bootloader after recycling the power.  \nRAK4270\u2019s bootloader uses the segment between 0x0808 1700 to 0x0808 17FF to store its parameters.  \nIn the bootloader parameter storage area, 256bytes are planned, but only two words are used to store the jump flag and upgrade status flag.  \nFinally, the serial port to communicate with the RAK\u2019s bootloader in these modules is the UART1 (pin PA9, pin PA10). The parameters of the UART1 communication are 115200 / 8-N-1, which need to be properly configured in the RAK firmware upgrade tool."}
{"id": "9f8b62a0640e8b2057c7d2befac8a9aa", "product_family": "wisduo", "product_id": "rak4270-module", "category": "Concept", "title": "RAK4270 Low Level Development Reference > RAK4270 Low Level Development Reference > How to Implement Your Own Firmware > Bootloader > Bootloader Introduction > RAK4270 Bootloader Memory Map and Functionality", "content": "the bootloader will detect abnormal events, and the FW upgrade will fail. You can perform the FW upgrade again using the bootloader after recycling the power.", "keywords": ["bootloader", "memory map", "ARM Cortex M0+", "firmware upgrade", "Ymodem protocol", "UART1"], "source_file": "low-level-development.md", "token_count": 0, "parent_content": "In any MCU, after the power is connected, the system bootloader is in charge to bootstrap all the necessary to set up the Interrupt Vector table, initialize variables, and jump to the address of the main() symbol.  \nIn Figure 1, it shows a usual memory map for an ARM Cortex M0+ MCU, which is the architecture of the MCU of the RAK4270.  \n> **Image:** Memory map for an ARM Cortex M0+ MCU  \nThe RAK\u2019s bootloader is stored in the internal flash section and has a size of 12K, located between 0x0800 0000 to 0x0800 2FFF. Its primary function is to write a new version of firmware received from the serial port into the flash memory section. The bootloader uses the Ymodem protocol and supervises all possible exceptions internally during the upgrade process. When the upgrade process is interrupted, the bootloader will detect abnormal events, and the FW upgrade will fail. You can perform the FW upgrade again using the bootloader after recycling the power.  \nRAK4270\u2019s bootloader uses the segment between 0x0808 1700 to 0x0808 17FF to store its parameters.  \nIn the bootloader parameter storage area, 256bytes are planned, but only two words are used to store the jump flag and upgrade status flag.  \nFinally, the serial port to communicate with the RAK\u2019s bootloader in these modules is the UART1 (pin PA9, pin PA10). The parameters of the UART1 communication are 115200 / 8-N-1, which need to be properly configured in the RAK firmware upgrade tool."}
{"id": "2949166dee087879fbadb32b5a371d3c", "product_family": "wisduo", "product_id": "rak4270-module", "category": "Concept", "title": "RAK4270 Low Level Development Reference > RAK4270 Low Level Development Reference > How to Implement Your Own Firmware > Bootloader > Bootloader Introduction > RAK4270 Bootloader Memory Map and Functionality", "content": "RAK4270\u2019s bootloader uses the segment between 0x0808 1700 to 0x0808 17FF to store its parameters.  \nIn the bootloader parameter storage area, 256bytes are planned, but only two words are used to store the jump flag and upgrade status flag.  \nFinally, the serial port to communicate with the RAK\u2019s bootloader in these modules is the UART1 (pin PA9, pin PA10). The parameters of the UART1 communication are 115200 / 8-N-1, which need to be properly configured in the RAK firmware upgrade tool.", "keywords": ["bootloader", "memory map", "ARM Cortex M0+", "firmware upgrade", "Ymodem protocol", "UART1"], "source_file": "low-level-development.md", "token_count": 0, "parent_content": "In any MCU, after the power is connected, the system bootloader is in charge to bootstrap all the necessary to set up the Interrupt Vector table, initialize variables, and jump to the address of the main() symbol.  \nIn Figure 1, it shows a usual memory map for an ARM Cortex M0+ MCU, which is the architecture of the MCU of the RAK4270.  \n> **Image:** Memory map for an ARM Cortex M0+ MCU  \nThe RAK\u2019s bootloader is stored in the internal flash section and has a size of 12K, located between 0x0800 0000 to 0x0800 2FFF. Its primary function is to write a new version of firmware received from the serial port into the flash memory section. The bootloader uses the Ymodem protocol and supervises all possible exceptions internally during the upgrade process. When the upgrade process is interrupted, the bootloader will detect abnormal events, and the FW upgrade will fail. You can perform the FW upgrade again using the bootloader after recycling the power.  \nRAK4270\u2019s bootloader uses the segment between 0x0808 1700 to 0x0808 17FF to store its parameters.  \nIn the bootloader parameter storage area, 256bytes are planned, but only two words are used to store the jump flag and upgrade status flag.  \nFinally, the serial port to communicate with the RAK\u2019s bootloader in these modules is the UART1 (pin PA9, pin PA10). The parameters of the UART1 communication are 115200 / 8-N-1, which need to be properly configured in the RAK firmware upgrade tool."}
{"id": "ca0678900e8ae3cb21832b3073283d5a", "product_family": "wisduo", "product_id": "rak4270-module", "category": "How-To", "title": "RAK4270 Low Level Development Reference > RAK4270 Low Level Development Reference > How to Implement Your Own Firmware > Bootloader > Application Requirements > Modify Application Code and Linker Script for RAK4270 Bootloader Compatibility [CODE]", "content": "Since the RAK\u2019s bootloader is stored between the 0x0800 0000 and 0x0800 2FFF segments of the flash memory, your application should be shifted accordingly. In the application code, you need to modify the interrupt vector table address as the following:  \n`SCB->VTOR = FLASH_BASE | 0x3000`  \nIn the linker, the script must be updated accordingly. For example, in case you use GCC, modify your linker script as follows:  \n`FLASH (rx) : ORIGIN = 0x8003000, LENGTH = 116K`", "keywords": ["bootloader", "application code", "linker script", "interrupt vector table", "AT command", "firmware upgrade"], "source_file": "low-level-development.md", "token_count": 150, "parent_content": "Since the RAK\u2019s bootloader is stored between the 0x0800 0000 and 0x0800 2FFF segments of the flash memory, your application should be shifted accordingly. In the application code, you need to modify the interrupt vector table address as the following:  \n`SCB->VTOR = FLASH_BASE | 0x3000`  \nIn the linker, the script must be updated accordingly. For example, in case you use GCC, modify your linker script as follows:  \n`FLASH (rx) : ORIGIN = 0x8003000, LENGTH = 116K`  \nYour application firmware should implement as minimum one AT command: `at +boot\\r\\n`. The function of this command is to jump from the application state into the bootloader state in preparation for the further application firmware upgrade. The logic of this command is the following:  \n- For RAK4270, write the value 0x00000000 in the address 0x0808 1700.\n- Reset MCU. You can call the **NVIC_SystemReset()** interface in the ST library to reset the MCU.  \n> **TIP:** NOTE\nThe bootloader turned off the global interrupt when jumping from the application state. Therefore, when the application code is initialized, the global interrupt should be turned on again."}
{"id": "acfa94e23f02a6af1ac340ec613abda2", "product_family": "wisduo", "product_id": "rak4270-module", "category": "How-To", "title": "RAK4270 Low Level Development Reference > RAK4270 Low Level Development Reference > How to Implement Your Own Firmware > Bootloader > Application Requirements > Modify Application Code and Linker Script for RAK4270 Bootloader Compatibility [CODE]", "content": "`FLASH (rx) : ORIGIN = 0x8003000, LENGTH = 116K`  \nYour application firmware should implement as minimum one AT command: `at +boot\\r\\n`. The function of this command is to jump from the application state into the bootloader state in preparation for the further application firmware upgrade. The logic of this command is the following:  \n- For RAK4270, write the value 0x00000000 in the address 0x0808 1700.", "keywords": ["bootloader", "application code", "linker script", "interrupt vector table", "AT command", "firmware upgrade"], "source_file": "low-level-development.md", "token_count": 150, "parent_content": "Since the RAK\u2019s bootloader is stored between the 0x0800 0000 and 0x0800 2FFF segments of the flash memory, your application should be shifted accordingly. In the application code, you need to modify the interrupt vector table address as the following:  \n`SCB->VTOR = FLASH_BASE | 0x3000`  \nIn the linker, the script must be updated accordingly. For example, in case you use GCC, modify your linker script as follows:  \n`FLASH (rx) : ORIGIN = 0x8003000, LENGTH = 116K`  \nYour application firmware should implement as minimum one AT command: `at +boot\\r\\n`. The function of this command is to jump from the application state into the bootloader state in preparation for the further application firmware upgrade. The logic of this command is the following:  \n- For RAK4270, write the value 0x00000000 in the address 0x0808 1700.\n- Reset MCU. You can call the **NVIC_SystemReset()** interface in the ST library to reset the MCU.  \n> **TIP:** NOTE\nThe bootloader turned off the global interrupt when jumping from the application state. Therefore, when the application code is initialized, the global interrupt should be turned on again."}
{"id": "c770bf9df2d6da9255456feefcd350b1", "product_family": "wisduo", "product_id": "rak4270-module", "category": "How-To", "title": "RAK4270 Low Level Development Reference > RAK4270 Low Level Development Reference > How to Implement Your Own Firmware > Bootloader > Application Requirements > Modify Application Code and Linker Script for RAK4270 Bootloader Compatibility [CODE]", "content": "- For RAK4270, write the value 0x00000000 in the address 0x0808 1700.\n- Reset MCU. You can call the **NVIC_SystemReset()** interface in the ST library to reset the MCU.  \n> **TIP:** NOTE\nThe bootloader turned off the global interrupt when jumping from the application state. Therefore, when the application code is initialized, the global interrupt should be turned on again.", "keywords": ["bootloader", "application code", "linker script", "interrupt vector table", "AT command", "firmware upgrade"], "source_file": "low-level-development.md", "token_count": 150, "parent_content": "Since the RAK\u2019s bootloader is stored between the 0x0800 0000 and 0x0800 2FFF segments of the flash memory, your application should be shifted accordingly. In the application code, you need to modify the interrupt vector table address as the following:  \n`SCB->VTOR = FLASH_BASE | 0x3000`  \nIn the linker, the script must be updated accordingly. For example, in case you use GCC, modify your linker script as follows:  \n`FLASH (rx) : ORIGIN = 0x8003000, LENGTH = 116K`  \nYour application firmware should implement as minimum one AT command: `at +boot\\r\\n`. The function of this command is to jump from the application state into the bootloader state in preparation for the further application firmware upgrade. The logic of this command is the following:  \n- For RAK4270, write the value 0x00000000 in the address 0x0808 1700.\n- Reset MCU. You can call the **NVIC_SystemReset()** interface in the ST library to reset the MCU.  \n> **TIP:** NOTE\nThe bootloader turned off the global interrupt when jumping from the application state. Therefore, when the application code is initialized, the global interrupt should be turned on again."}
